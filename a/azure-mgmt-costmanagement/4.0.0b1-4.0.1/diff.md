# Comparing `tmp/azure-mgmt-costmanagement-4.0.0b1.zip` & `tmp/azure-mgmt-costmanagement-4.0.1.zip`

## zipinfo {}

```diff
@@ -1,79 +1,79 @@
-Zip file size: 193656 bytes, number of entries: 77
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/
--rw-rw-r--  2.0 unx     7724 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/CHANGELOG.md
--rw-rw-r--  2.0 unx      220 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/MANIFEST.in
--rw-rw-r--  2.0 unx      638 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/_meta.json
--rw-rw-r--  2.0 unx       38 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/setup.cfg
--rw-rw-r--  2.0 unx     2774 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/setup.py
--rw-rw-r--  2.0 unx     1359 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/README.md
--rw-rw-r--  2.0 unx     1074 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/LICENSE
--rw-rw-r--  2.0 unx     9925 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/PKG-INFO
--rw-rw-r--  2.0 unx        1 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx        1 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx     3679 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx        6 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/top_level.txt
--rw-rw-r--  2.0 unx     9925 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx      116 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/requires.txt
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/
--rw-rw-r--  2.0 unx       65 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/
--rw-rw-r--  2.0 unx    77450 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_serialization.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_patch.py
--rw-rw-r--  2.0 unx      915 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/__init__.py
--rw-rw-r--  2.0 unx     3501 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_configuration.py
--rw-rw-r--  2.0 unx     1169 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_vendor.py
--rw-rw-r--  2.0 unx      488 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_version.py
--rw-rw-r--  2.0 unx       26 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/py.typed
--rw-rw-r--  2.0 unx     9282 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_cost_management_client.py
--rw-rw-r--  2.0 unx     6866 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_operations.py
--rw-rw-r--  2.0 unx     9481 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_benefit_recommendations_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_patch.py
--rw-rw-r--  2.0 unx     2489 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/__init__.py
--rw-rw-r--  2.0 unx    72393 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_scheduled_actions_operations.py
--rw-rw-r--  2.0 unx    28299 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_benefit_utilization_summaries_operations.py
--rw-rw-r--  2.0 unx    24603 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_cost_details_report_operations.py
--rw-rw-r--  2.0 unx    26316 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_alerts_operations.py
--rw-rw-r--  2.0 unx    18937 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_reservation_details_report_operations.py
--rw-rw-r--  2.0 unx    19334 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_price_sheet_operations.py
--rw-rw-r--  2.0 unx    46796 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_views_operations.py
--rw-rw-r--  2.0 unx    16328 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operations.py
--rw-rw-r--  2.0 unx     9489 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_results_operations.py
--rw-rw-r--  2.0 unx    18235 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_dimensions_operations.py
--rw-rw-r--  2.0 unx    37511 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_exports_operations.py
--rw-rw-r--  2.0 unx    21929 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_query_operations.py
--rw-rw-r--  2.0 unx     6352 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_status_operations.py
--rw-rw-r--  2.0 unx    24563 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_forecast_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/_patch.py
--rw-rw-r--  2.0 unx    13002 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/__init__.py
--rw-rw-r--  2.0 unx   246383 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/_models_py3.py
--rw-rw-r--  2.0 unx    15027 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/_cost_management_client_enums.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/_patch.py
--rw-rw-r--  2.0 unx      862 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/__init__.py
--rw-rw-r--  2.0 unx     3505 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/_configuration.py
--rw-rw-r--  2.0 unx     9415 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/_cost_management_client.py
--rw-rw-r--  2.0 unx     6143 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_operations.py
--rw-rw-r--  2.0 unx     8088 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_benefit_recommendations_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     2489 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    60473 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_scheduled_actions_operations.py
--rw-rw-r--  2.0 unx    22284 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_benefit_utilization_summaries_operations.py
--rw-rw-r--  2.0 unx    22553 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_cost_details_report_operations.py
--rw-rw-r--  2.0 unx    21754 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_alerts_operations.py
--rw-rw-r--  2.0 unx    16381 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_reservation_details_report_operations.py
--rw-rw-r--  2.0 unx    16331 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_price_sheet_operations.py
--rw-rw-r--  2.0 unx    39081 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_views_operations.py
--rw-rw-r--  2.0 unx    15290 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operations.py
--rw-rw-r--  2.0 unx     8537 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_results_operations.py
--rw-rw-r--  2.0 unx    14858 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_dimensions_operations.py
--rw-rw-r--  2.0 unx    30928 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_exports_operations.py
--rw-rw-r--  2.0 unx    19192 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_query_operations.py
--rw-rw-r--  2.0 unx     5311 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_status_operations.py
--rw-rw-r--  2.0 unx    21551 b- defN 22-Nov-08 08:16 azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_forecast_operations.py
-77 files, 1143170 bytes uncompressed, 174846 bytes compressed:  84.7%
+Zip file size: 194223 bytes, number of entries: 77
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure/
+-rw-rw-r--  2.0 unx      660 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/_meta.json
+-rw-rw-r--  2.0 unx    10387 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/CHANGELOG.md
+-rw-rw-r--  2.0 unx     1971 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/README.md
+-rw-rw-r--  2.0 unx       38 b- defN 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/setup.cfg
+-rw-rw-r--  2.0 unx      220 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/MANIFEST.in
+-rw-rw-r--  2.0 unx     1074 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/LICENSE
+-rw-rw-r--  2.0 unx    13262 b- defN 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/PKG-INFO
+-rw-rw-r--  2.0 unx     2857 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/setup.py
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx    13262 b- defN 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx     3679 b- defN 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx        6 b- defN 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx      124 b- defN 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/requires.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/not-zip-safe
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/
+-rw-rw-r--  2.0 unx     9260 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_cost_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_version.py
+-rw-rw-r--  2.0 unx    78836 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_serialization.py
+-rw-rw-r--  2.0 unx     3200 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_configuration.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_vendor.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_patch.py
+-rw-rw-r--  2.0 unx      900 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/__init__.py
+-rw-rw-r--  2.0 unx       26 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/py.typed
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-19 06:42 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/
+-rw-rw-r--  2.0 unx     9456 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/_cost_management_client.py
+-rw-rw-r--  2.0 unx     3248 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/_patch.py
+-rw-rw-r--  2.0 unx      847 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/__init__.py
+-rw-rw-r--  2.0 unx    62393 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_scheduled_actions_operations.py
+-rw-rw-r--  2.0 unx     8152 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_results_operations.py
+-rw-rw-r--  2.0 unx    31153 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_exports_operations.py
+-rw-rw-r--  2.0 unx    19450 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_query_operations.py
+-rw-rw-r--  2.0 unx    22998 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_cost_details_report_operations.py
+-rw-rw-r--  2.0 unx    21892 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_alerts_operations.py
+-rw-rw-r--  2.0 unx     5858 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx    15239 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operations.py
+-rw-rw-r--  2.0 unx    15847 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_price_sheet_operations.py
+-rw-rw-r--  2.0 unx    39579 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_views_operations.py
+-rw-rw-r--  2.0 unx     7896 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_benefit_recommendations_operations.py
+-rw-rw-r--  2.0 unx     5022 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_status_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    14718 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_dimensions_operations.py
+-rw-rw-r--  2.0 unx    22266 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_benefit_utilization_summaries_operations.py
+-rw-rw-r--  2.0 unx    16071 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_reservation_details_report_operations.py
+-rw-rw-r--  2.0 unx    21815 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_forecast_operations.py
+-rw-rw-r--  2.0 unx     2474 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    74471 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_scheduled_actions_operations.py
+-rw-rw-r--  2.0 unx     9099 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_results_operations.py
+-rw-rw-r--  2.0 unx    37698 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_exports_operations.py
+-rw-rw-r--  2.0 unx    22161 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_query_operations.py
+-rw-rw-r--  2.0 unx    25030 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_cost_details_report_operations.py
+-rw-rw-r--  2.0 unx    26426 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_alerts_operations.py
+-rw-rw-r--  2.0 unx     6555 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_operations.py
+-rw-rw-r--  2.0 unx    16264 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operations.py
+-rw-rw-r--  2.0 unx    18840 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_price_sheet_operations.py
+-rw-rw-r--  2.0 unx    47217 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_views_operations.py
+-rw-rw-r--  2.0 unx     9284 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_benefit_recommendations_operations.py
+-rw-rw-r--  2.0 unx     6058 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_status_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_patch.py
+-rw-rw-r--  2.0 unx    18085 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_dimensions_operations.py
+-rw-rw-r--  2.0 unx    28261 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_benefit_utilization_summaries_operations.py
+-rw-rw-r--  2.0 unx    18617 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_reservation_details_report_operations.py
+-rw-rw-r--  2.0 unx    24801 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_forecast_operations.py
+-rw-rw-r--  2.0 unx     2474 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/__init__.py
+-rw-rw-r--  2.0 unx    15097 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/_cost_management_client_enums.py
+-rw-rw-r--  2.0 unx   251444 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/_patch.py
+-rw-rw-r--  2.0 unx    13077 b- defN 23-Jul-19 06:41 azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/__init__.py
+77 files, 1162385 bytes uncompressed, 175721 bytes compressed:  84.9%
```

## zipnote {}

```diff
@@ -1,232 +1,232 @@
-Filename: azure-mgmt-costmanagement-4.0.0b1/
+Filename: azure-mgmt-costmanagement-4.0.1/
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/
+Filename: azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/
+Filename: azure-mgmt-costmanagement-4.0.1/azure/
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/CHANGELOG.md
+Filename: azure-mgmt-costmanagement-4.0.1/_meta.json
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/MANIFEST.in
+Filename: azure-mgmt-costmanagement-4.0.1/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/_meta.json
+Filename: azure-mgmt-costmanagement-4.0.1/README.md
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/setup.cfg
+Filename: azure-mgmt-costmanagement-4.0.1/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/setup.py
+Filename: azure-mgmt-costmanagement-4.0.1/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/README.md
+Filename: azure-mgmt-costmanagement-4.0.1/LICENSE
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/LICENSE
+Filename: azure-mgmt-costmanagement-4.0.1/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/PKG-INFO
+Filename: azure-mgmt-costmanagement-4.0.1/setup.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/dependency_links.txt
+Filename: azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/not-zip-safe
+Filename: azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/SOURCES.txt
+Filename: azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/top_level.txt
+Filename: azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/PKG-INFO
+Filename: azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/requires.txt
+Filename: azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/__init__.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/__init__.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_serialization.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_cost_management_client.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_patch.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_version.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/__init__.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_configuration.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_vendor.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_version.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_patch.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/py.typed
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/__init__.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_cost_management_client.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/py.typed
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_benefit_recommendations_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/_cost_management_client.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_patch.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/__init__.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_scheduled_actions_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_benefit_utilization_summaries_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_scheduled_actions_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_cost_details_report_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_results_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_alerts_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_exports_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_reservation_details_report_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_query_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_price_sheet_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_cost_details_report_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_views_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_alerts_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_results_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_dimensions_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_price_sheet_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_exports_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_views_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_query_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_benefit_recommendations_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_status_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_status_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_forecast_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/_patch.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_dimensions_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/__init__.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_benefit_utilization_summaries_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/_models_py3.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_reservation_details_report_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/_cost_management_client_enums.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_forecast_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/_patch.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_scheduled_actions_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/__init__.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_results_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/_configuration.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_exports_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/_cost_management_client.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_query_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_cost_details_report_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_benefit_recommendations_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_alerts_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_patch.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/__init__.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_scheduled_actions_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_price_sheet_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_benefit_utilization_summaries_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_views_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_cost_details_report_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_benefit_recommendations_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_alerts_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_status_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_reservation_details_report_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_price_sheet_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_dimensions_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_views_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_benefit_utilization_summaries_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_reservation_details_report_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_results_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_forecast_operations.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_dimensions_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_exports_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/_cost_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_query_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_status_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_forecast_operations.py
+Filename: azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/__init__.py
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/CHANGELOG.md` & `azure-mgmt-costmanagement-4.0.1/CHANGELOG.md`

 * *Files 25% similar despite different names*

```diff
@@ -1,9 +1,64 @@
 # Release History
 
+## 4.0.1 (2023-07-19)
+
+### Bugs Fixed
+
+  - Fix deserialization error for some operation when error happens
+
+## 4.0.0 (2023-05-22)
+
+### Features Added
+
+  - Added operation group BenefitRecommendationsOperations
+  - Added operation group BenefitUtilizationSummariesOperations
+  - Added operation group GenerateCostDetailsReportOperations
+  - Added operation group GenerateDetailedCostReportOperationResultsOperations
+  - Added operation group GenerateDetailedCostReportOperationStatusOperations
+  - Added operation group GenerateDetailedCostReportOperations
+  - Added operation group PriceSheetOperations
+  - Added operation group ScheduledActionsOperations
+  - Model Alert has a new parameter e_tag
+  - Model AlertPropertiesDetails has a new parameter company_name
+  - Model AlertPropertiesDetails has a new parameter department_name
+  - Model AlertPropertiesDetails has a new parameter enrollment_end_date
+  - Model AlertPropertiesDetails has a new parameter enrollment_number
+  - Model AlertPropertiesDetails has a new parameter enrollment_start_date
+  - Model AlertPropertiesDetails has a new parameter invoicing_threshold
+  - Model CommonExportProperties has a new parameter next_run_time_estimate
+  - Model CommonExportProperties has a new parameter partition_data
+  - Model CommonExportProperties has a new parameter run_history
+  - Model Dimension has a new parameter e_tag
+  - Model Dimension has a new parameter location
+  - Model Dimension has a new parameter sku
+  - Model Export has a new parameter next_run_time_estimate
+  - Model Export has a new parameter partition_data
+  - Model Export has a new parameter run_history
+  - Model ExportDeliveryDestination has a new parameter sas_token
+  - Model ExportDeliveryDestination has a new parameter storage_account
+  - Model ExportProperties has a new parameter next_run_time_estimate
+  - Model ExportProperties has a new parameter partition_data
+  - Model ExportProperties has a new parameter run_history
+  - Model Operation has a new parameter action_type
+  - Model Operation has a new parameter is_data_action
+  - Model Operation has a new parameter origin
+  - Model OperationDisplay has a new parameter description
+  - Operation ExportsOperations.get has a new optional parameter expand
+  - Operation ExportsOperations.list has a new optional parameter expand
+
+### Breaking Changes
+
+  - Model Alert no longer has parameter tags
+  - Model ProxyResource no longer has parameter e_tag
+  - Model ReportConfigFilter no longer has parameter tag_key
+  - Model ReportConfigFilter no longer has parameter tag_value
+  - Model Resource no longer has parameter tags
+  - Removed operation group SettingsOperations
+
 ## 4.0.0b1 (2022-11-07)
 
 ### Features Added
 
   - Added operation group BenefitRecommendationsOperations
   - Added operation group BenefitUtilizationSummariesOperations
   - Added operation group GenerateCostDetailsReportOperations
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/_meta.json` & `azure-mgmt-costmanagement-4.0.1/_meta.json`

 * *Files 14% similar despite different names*

### Pretty-printed

 * *Similarity: 0.7777777777777777%*

 * *Differences: {"'autorest_command'": "'autorest specification/cost-management/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--tag=package-2022-10 --use=@autorest/python@6.6.0 '*

 * *                       '--use=@autorest/modelerfour@4.24.3 --version=3.9.2 '*

 * *                       "--version-tolerant=False'",*

 * * "'commit'": "'493aa72 […]*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
-    "autorest_command": "autorest specification/cost-management/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.2.1 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "e77f2f011a17a05457e14a0e78b10c100337a557",
+    "autorest_command": "autorest specification/cost-management/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --tag=package-2022-10 --use=@autorest/python@6.6.0 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
+    "commit": "493aa7224fd65fe1e5b4cff59bcae5c6cdf4525e",
     "readme": "specification/cost-management/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.2.1",
+        "@autorest/python@6.6.0",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/setup.py` & `azure-mgmt-costmanagement-4.0.1/setup.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,78 +1,83 @@
 #!/usr/bin/env python
 
-#-------------------------------------------------------------------------
+# -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
-#--------------------------------------------------------------------------
+# --------------------------------------------------------------------------
 
 import re
 import os.path
 from io import open
 from setuptools import find_packages, setup
 
 # Change the PACKAGE_NAME only to change folder and different name
 PACKAGE_NAME = "azure-mgmt-costmanagement"
 PACKAGE_PPRINT_NAME = "Cost Management"
 
 # a-b-c => a/b/c
-package_folder_path = PACKAGE_NAME.replace('-', '/')
+package_folder_path = PACKAGE_NAME.replace("-", "/")
 # a-b-c => a.b.c
-namespace_name = PACKAGE_NAME.replace('-', '.')
+namespace_name = PACKAGE_NAME.replace("-", ".")
 
 # Version extraction inspired from 'requests'
-with open(os.path.join(package_folder_path, 'version.py')
-          if os.path.exists(os.path.join(package_folder_path, 'version.py'))
-          else os.path.join(package_folder_path, '_version.py'), 'r') as fd:
-    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]',
-                        fd.read(), re.MULTILINE).group(1)
+with open(
+    os.path.join(package_folder_path, "version.py")
+    if os.path.exists(os.path.join(package_folder_path, "version.py"))
+    else os.path.join(package_folder_path, "_version.py"),
+    "r",
+) as fd:
+    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]', fd.read(), re.MULTILINE).group(1)
 
 if not version:
-    raise RuntimeError('Cannot find version information')
+    raise RuntimeError("Cannot find version information")
 
-with open('README.md', encoding='utf-8') as f:
+with open("README.md", encoding="utf-8") as f:
     readme = f.read()
-with open('CHANGELOG.md', encoding='utf-8') as f:
+with open("CHANGELOG.md", encoding="utf-8") as f:
     changelog = f.read()
 
 setup(
     name=PACKAGE_NAME,
     version=version,
-    description='Microsoft Azure {} Client Library for Python'.format(PACKAGE_PPRINT_NAME),
-    long_description=readme + '\n\n' + changelog,
-    long_description_content_type='text/markdown',
-    license='MIT License',
-    author='Microsoft Corporation',
-    author_email='azpysdkhelp@microsoft.com',
-    url='https://github.com/Azure/azure-sdk-for-python',
+    description="Microsoft Azure {} Client Library for Python".format(PACKAGE_PPRINT_NAME),
+    long_description=readme + "\n\n" + changelog,
+    long_description_content_type="text/markdown",
+    license="MIT License",
+    author="Microsoft Corporation",
+    author_email="azpysdkhelp@microsoft.com",
+    url="https://github.com/Azure/azure-sdk-for-python",
     keywords="azure, azure sdk",  # update with search keywords relevant to the azure service / product
     classifiers=[
-        'Development Status :: 4 - Beta',
-        'Programming Language :: Python',
-        'Programming Language :: Python :: 3 :: Only',
-        'Programming Language :: Python :: 3',
-        'Programming Language :: Python :: 3.7',
-        'Programming Language :: Python :: 3.8',
-        'Programming Language :: Python :: 3.9',
-        'Programming Language :: Python :: 3.10',
-        'License :: OSI Approved :: MIT License',
+        "Development Status :: 5 - Production/Stable",
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 3 :: Only",
+        "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
+        "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
+        "License :: OSI Approved :: MIT License",
     ],
     zip_safe=False,
-    packages=find_packages(exclude=[
-        'tests',
-        # Exclude packages that will be covered by PEP420 or nspkg
-        'azure',
-        'azure.mgmt',
-    ]),
+    packages=find_packages(
+        exclude=[
+            "tests",
+            # Exclude packages that will be covered by PEP420 or nspkg
+            "azure",
+            "azure.mgmt",
+        ]
+    ),
     include_package_data=True,
     package_data={
-        'pytyped': ['py.typed'],
+        "pytyped": ["py.typed"],
     },
     install_requires=[
-        "msrest>=0.7.1",
+        "isodate<1.0.0,>=0.6.1",
         "azure-common~=1.1",
         "azure-mgmt-core>=1.3.2,<2.0.0",
         "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
-    python_requires=">=3.7"
+    python_requires=">=3.7",
 )
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/LICENSE` & `azure-mgmt-costmanagement-4.0.1/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-costmanagement-4.0.0b1/PKG-INFO` & `azure-mgmt-costmanagement-4.0.1/PKG-INFO`

 * *Files 17% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-costmanagement
-Version: 4.0.0b1
+Version: 4.0.1
 Summary: Microsoft Azure Cost Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
-Classifier: Development Status :: 4 - Beta
+Classifier: Development Status :: 5 - Production/Stable
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: License :: OSI Approved :: MIT License
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 # Microsoft Azure SDK for Python
 
@@ -26,36 +27,123 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-# Usage
+## Getting started
 
+### Prerequisites
 
-To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
- 
-For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
-Code samples for this package can be found at [Cost Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
-Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+- Python 3.7+ is required to use this package.
+- [Azure subscription](https://azure.microsoft.com/free/)
 
+### Install the package
 
-# Provide Feedback
+```bash
+pip install azure-mgmt-costmanagement
+pip install azure-identity
+```
+
+### Authentication
+
+By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
+
+- `AZURE_CLIENT_ID` for Azure client ID.
+- `AZURE_TENANT_ID` for Azure tenant ID.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
+
+With above configuration, client can be authenticated by following code:
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.mgmt.costmanagement import CostManagementClient
+
+client = CostManagementClient(credential=DefaultAzureCredential())
+```
+
+## Examples
+
+Code samples for this package can be found at:
+- [Search Cost Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+
+
+## Troubleshooting
+
+## Next steps
+
+## Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-costmanagement%2FREADME.png)
 
 
 # Release History
 
+## 4.0.1 (2023-07-19)
+
+### Bugs Fixed
+
+  - Fix deserialization error for some operation when error happens
+
+## 4.0.0 (2023-05-22)
+
+### Features Added
+
+  - Added operation group BenefitRecommendationsOperations
+  - Added operation group BenefitUtilizationSummariesOperations
+  - Added operation group GenerateCostDetailsReportOperations
+  - Added operation group GenerateDetailedCostReportOperationResultsOperations
+  - Added operation group GenerateDetailedCostReportOperationStatusOperations
+  - Added operation group GenerateDetailedCostReportOperations
+  - Added operation group PriceSheetOperations
+  - Added operation group ScheduledActionsOperations
+  - Model Alert has a new parameter e_tag
+  - Model AlertPropertiesDetails has a new parameter company_name
+  - Model AlertPropertiesDetails has a new parameter department_name
+  - Model AlertPropertiesDetails has a new parameter enrollment_end_date
+  - Model AlertPropertiesDetails has a new parameter enrollment_number
+  - Model AlertPropertiesDetails has a new parameter enrollment_start_date
+  - Model AlertPropertiesDetails has a new parameter invoicing_threshold
+  - Model CommonExportProperties has a new parameter next_run_time_estimate
+  - Model CommonExportProperties has a new parameter partition_data
+  - Model CommonExportProperties has a new parameter run_history
+  - Model Dimension has a new parameter e_tag
+  - Model Dimension has a new parameter location
+  - Model Dimension has a new parameter sku
+  - Model Export has a new parameter next_run_time_estimate
+  - Model Export has a new parameter partition_data
+  - Model Export has a new parameter run_history
+  - Model ExportDeliveryDestination has a new parameter sas_token
+  - Model ExportDeliveryDestination has a new parameter storage_account
+  - Model ExportProperties has a new parameter next_run_time_estimate
+  - Model ExportProperties has a new parameter partition_data
+  - Model ExportProperties has a new parameter run_history
+  - Model Operation has a new parameter action_type
+  - Model Operation has a new parameter is_data_action
+  - Model Operation has a new parameter origin
+  - Model OperationDisplay has a new parameter description
+  - Operation ExportsOperations.get has a new optional parameter expand
+  - Operation ExportsOperations.list has a new optional parameter expand
+
+### Breaking Changes
+
+  - Model Alert no longer has parameter tags
+  - Model ProxyResource no longer has parameter e_tag
+  - Model ReportConfigFilter no longer has parameter tag_key
+  - Model ReportConfigFilter no longer has parameter tag_value
+  - Model Resource no longer has parameter tags
+  - Removed operation group SettingsOperations
+
 ## 4.0.0b1 (2022-11-07)
 
 ### Features Added
 
   - Added operation group BenefitRecommendationsOperations
   - Added operation group BenefitUtilizationSummariesOperations
   - Added operation group GenerateCostDetailsReportOperations
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/SOURCES.txt` & `azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/SOURCES.txt`

 * *Files identical despite different names*

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure_mgmt_costmanagement.egg-info/PKG-INFO` & `azure-mgmt-costmanagement-4.0.1/azure_mgmt_costmanagement.egg-info/PKG-INFO`

 * *Files 17% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-costmanagement
-Version: 4.0.0b1
+Version: 4.0.1
 Summary: Microsoft Azure Cost Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
-Classifier: Development Status :: 4 - Beta
+Classifier: Development Status :: 5 - Production/Stable
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: License :: OSI Approved :: MIT License
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 # Microsoft Azure SDK for Python
 
@@ -26,36 +27,123 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-# Usage
+## Getting started
 
+### Prerequisites
 
-To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
- 
-For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
-Code samples for this package can be found at [Cost Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
-Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+- Python 3.7+ is required to use this package.
+- [Azure subscription](https://azure.microsoft.com/free/)
 
+### Install the package
 
-# Provide Feedback
+```bash
+pip install azure-mgmt-costmanagement
+pip install azure-identity
+```
+
+### Authentication
+
+By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
+
+- `AZURE_CLIENT_ID` for Azure client ID.
+- `AZURE_TENANT_ID` for Azure tenant ID.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
+
+With above configuration, client can be authenticated by following code:
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.mgmt.costmanagement import CostManagementClient
+
+client = CostManagementClient(credential=DefaultAzureCredential())
+```
+
+## Examples
+
+Code samples for this package can be found at:
+- [Search Cost Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+
+
+## Troubleshooting
+
+## Next steps
+
+## Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-costmanagement%2FREADME.png)
 
 
 # Release History
 
+## 4.0.1 (2023-07-19)
+
+### Bugs Fixed
+
+  - Fix deserialization error for some operation when error happens
+
+## 4.0.0 (2023-05-22)
+
+### Features Added
+
+  - Added operation group BenefitRecommendationsOperations
+  - Added operation group BenefitUtilizationSummariesOperations
+  - Added operation group GenerateCostDetailsReportOperations
+  - Added operation group GenerateDetailedCostReportOperationResultsOperations
+  - Added operation group GenerateDetailedCostReportOperationStatusOperations
+  - Added operation group GenerateDetailedCostReportOperations
+  - Added operation group PriceSheetOperations
+  - Added operation group ScheduledActionsOperations
+  - Model Alert has a new parameter e_tag
+  - Model AlertPropertiesDetails has a new parameter company_name
+  - Model AlertPropertiesDetails has a new parameter department_name
+  - Model AlertPropertiesDetails has a new parameter enrollment_end_date
+  - Model AlertPropertiesDetails has a new parameter enrollment_number
+  - Model AlertPropertiesDetails has a new parameter enrollment_start_date
+  - Model AlertPropertiesDetails has a new parameter invoicing_threshold
+  - Model CommonExportProperties has a new parameter next_run_time_estimate
+  - Model CommonExportProperties has a new parameter partition_data
+  - Model CommonExportProperties has a new parameter run_history
+  - Model Dimension has a new parameter e_tag
+  - Model Dimension has a new parameter location
+  - Model Dimension has a new parameter sku
+  - Model Export has a new parameter next_run_time_estimate
+  - Model Export has a new parameter partition_data
+  - Model Export has a new parameter run_history
+  - Model ExportDeliveryDestination has a new parameter sas_token
+  - Model ExportDeliveryDestination has a new parameter storage_account
+  - Model ExportProperties has a new parameter next_run_time_estimate
+  - Model ExportProperties has a new parameter partition_data
+  - Model ExportProperties has a new parameter run_history
+  - Model Operation has a new parameter action_type
+  - Model Operation has a new parameter is_data_action
+  - Model Operation has a new parameter origin
+  - Model OperationDisplay has a new parameter description
+  - Operation ExportsOperations.get has a new optional parameter expand
+  - Operation ExportsOperations.list has a new optional parameter expand
+
+### Breaking Changes
+
+  - Model Alert no longer has parameter tags
+  - Model ProxyResource no longer has parameter e_tag
+  - Model ReportConfigFilter no longer has parameter tag_key
+  - Model ReportConfigFilter no longer has parameter tag_value
+  - Model Resource no longer has parameter tags
+  - Removed operation group SettingsOperations
+
 ## 4.0.0b1 (2022-11-07)
 
 ### Features Added
 
   - Added operation group BenefitRecommendationsOperations
   - Added operation group BenefitUtilizationSummariesOperations
   - Added operation group GenerateCostDetailsReportOperations
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_serialization.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_serialization.py`

 * *Files 3% similar despite different names*

```diff
@@ -21,56 +21,71 @@
 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 # IN THE SOFTWARE.
 #
 # --------------------------------------------------------------------------
 
 # pylint: skip-file
+# pyright: reportUnnecessaryTypeIgnoreComment=false
 
 from base64 import b64decode, b64encode
 import calendar
 import datetime
 import decimal
 import email
 from enum import Enum
 import json
 import logging
 import re
 import sys
 import codecs
+from typing import (
+    Dict,
+    Any,
+    cast,
+    Optional,
+    Union,
+    AnyStr,
+    IO,
+    Mapping,
+    Callable,
+    TypeVar,
+    MutableMapping,
+    Type,
+    List,
+    Mapping,
+)
 
 try:
     from urllib import quote  # type: ignore
 except ImportError:
-    from urllib.parse import quote  # type: ignore
+    from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
-import isodate
-
-from typing import Dict, Any, cast, TYPE_CHECKING
+import isodate  # type: ignore
 
 from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
+from azure.core.serialization import NULL as AzureCoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
-if TYPE_CHECKING:
-    from typing import Optional, Union, AnyStr, IO, Mapping
+ModelType = TypeVar("ModelType", bound="Model")
+JSON = MutableMapping[str, Any]
 
 
 class RawDeserializer:
 
     # Accept "text" because we're open minded people...
     JSON_REGEXP = re.compile(r"^(application|text)/([a-z+.]+\+)?json$")
 
     # Name used in context
     CONTEXT_NAME = "deserialized_data"
 
     @classmethod
-    def deserialize_from_text(cls, data, content_type=None):
-        # type: (Optional[Union[AnyStr, IO]], Optional[str]) -> Any
+    def deserialize_from_text(cls, data: Optional[Union[AnyStr, IO]], content_type: Optional[str] = None) -> Any:
         """Decode data according to content-type.
 
         Accept a stream of data as well, but will be load at once in memory for now.
 
         If no content-type, will return the string version (not bytes, not stream)
 
         :param data: Input, could be bytes or stream (will be decoded with UTF8) or text
@@ -128,16 +143,15 @@
                 # The function hack is because Py2.7 messes up with exception
                 # context otherwise.
                 _LOGGER.critical("Wasn't XML not JSON, failing")
                 raise_with_traceback(DeserializationError, "XML is invalid")
         raise DeserializationError("Cannot deserialize content-type: {}".format(content_type))
 
     @classmethod
-    def deserialize_from_http_generics(cls, body_bytes, headers):
-        # type: (Optional[Union[AnyStr, IO]], Mapping) -> Any
+    def deserialize_from_http_generics(cls, body_bytes: Optional[Union[AnyStr, IO]], headers: Mapping) -> Any:
         """Deserialize from HTTP response.
 
         Use bytes and headers to NOT use any requests/aiohttp or whatever
         specific implementation.
         Headers will tested for "content-type"
         """
         # Try to use content-type from headers if available
@@ -156,16 +170,16 @@
         return None
 
 
 try:
     basestring  # type: ignore
     unicode_str = unicode  # type: ignore
 except NameError:
-    basestring = str  # type: ignore
-    unicode_str = str  # type: ignore
+    basestring = str
+    unicode_str = str
 
 _LOGGER = logging.getLogger(__name__)
 
 try:
     _long_type = long  # type: ignore
 except NameError:
     _long_type = int
@@ -184,15 +198,15 @@
 
     def dst(self, dt):
         """No daylight saving for UTC."""
         return datetime.timedelta(hours=1)
 
 
 try:
-    from datetime import timezone as _FixedOffset
+    from datetime import timezone as _FixedOffset  # type: ignore
 except ImportError:  # Python 2.7
 
     class _FixedOffset(datetime.tzinfo):  # type: ignore
         """Fixed offset in minutes east from UTC.
         Copy/pasted from Python doc
         :param datetime.timedelta offset: offset in timedelta format
         """
@@ -215,15 +229,15 @@
         def __getinitargs__(self):
             return (self.__offset,)
 
 
 try:
     from datetime import timezone
 
-    TZ_UTC = timezone.utc  # type: ignore
+    TZ_UTC = timezone.utc
 except ImportError:
     TZ_UTC = UTC()  # type: ignore
 
 _FLATTEN = re.compile(r"(?<!\\)\.")
 
 
 def attribute_transformer(key, attr_desc, value):
@@ -272,79 +286,84 @@
 
 
 class Model(object):
     """Mixin for all client request body/response body models to support
     serialization and deserialization.
     """
 
-    _subtype_map = {}  # type: Dict[str, Dict[str, Any]]
-    _attribute_map = {}  # type: Dict[str, Dict[str, Any]]
-    _validation = {}  # type: Dict[str, Dict[str, Any]]
+    _subtype_map: Dict[str, Dict[str, Any]] = {}
+    _attribute_map: Dict[str, Dict[str, Any]] = {}
+    _validation: Dict[str, Dict[str, Any]] = {}
 
-    def __init__(self, **kwargs):
-        self.additional_properties = {}
+    def __init__(self, **kwargs: Any) -> None:
+        self.additional_properties: Dict[str, Any] = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
 
-    def __eq__(self, other):
+    def __eq__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         if isinstance(other, self.__class__):
             return self.__dict__ == other.__dict__
         return False
 
-    def __ne__(self, other):
+    def __ne__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         return not self.__eq__(other)
 
-    def __str__(self):
+    def __str__(self) -> str:
         return str(self.__dict__)
 
     @classmethod
-    def enable_additional_properties_sending(cls):
+    def enable_additional_properties_sending(cls) -> None:
         cls._attribute_map["additional_properties"] = {"key": "", "type": "{object}"}
 
     @classmethod
-    def is_xml_model(cls):
+    def is_xml_model(cls) -> bool:
         try:
-            cls._xml_map
+            cls._xml_map  # type: ignore
         except AttributeError:
             return False
         return True
 
     @classmethod
     def _create_xml_node(cls):
         """Create XML node."""
         try:
-            xml_map = cls._xml_map
+            xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
-    def serialize(self, keep_readonly=False, **kwargs):
+    def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
         """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
-    def as_dict(self, keep_readonly=True, key_transformer=attribute_transformer, **kwargs):
-        """Return a dict that can be JSONify using json.dump.
+    def as_dict(
+        self,
+        keep_readonly: bool = True,
+        key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
+        **kwargs: Any
+    ) -> JSON:
+        """Return a dict that can be serialized using json.dump.
 
         Advanced usage might optionally use a callback as parameter:
 
         .. code::python
 
             def my_key_transformer(key, attr_desc, value):
                 return key
@@ -383,41 +402,46 @@
                 raise ValueError("Not Autorest generated code")
         except Exception:
             # Assume it's not Autorest generated (tests?). Add ourselves as dependencies.
             client_models = {cls.__name__: cls}
         return client_models
 
     @classmethod
-    def deserialize(cls, data, content_type=None):
+    def deserialize(cls: Type[ModelType], data: Any, content_type: Optional[str] = None) -> ModelType:
         """Parse a str using the RestAPI syntax and return a model.
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
-    def from_dict(cls, data, key_extractors=None, content_type=None):
+    def from_dict(
+        cls: Type[ModelType],
+        data: Any,
+        key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
+        content_type: Optional[str] = None,
+    ) -> ModelType:
         """Parse a dict using given key extractor return a model.
 
         By default consider key
         extractors (rest_key_case_insensitive_extractor, attribute_key_case_insensitive_extractor
         and last_rest_key_case_insensitive_extractor)
 
         :param dict data: A dict using RestAPI structure
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        deserializer.key_extractors = (
-            [
+        deserializer.key_extractors = (  # type: ignore
+            [  # type: ignore
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
@@ -449,15 +473,15 @@
             if subtype_value:
                 # Try to match base class. Can be class name only
                 # (bug to fix in Autorest to support x-ms-discriminator-name)
                 if cls.__name__ == subtype_value:
                     return cls
                 flatten_mapping_type = cls._flatten_subtype(subtype_key, objects)
                 try:
-                    return objects[flatten_mapping_type[subtype_value]]
+                    return objects[flatten_mapping_type[subtype_value]]  # type: ignore
                 except KeyError:
                     _LOGGER.warning(
                         "Subtype value %s has no mapping, use base class %s.",
                         subtype_value,
                         cls.__name__,
                     )
                     break
@@ -517,15 +541,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -533,15 +557,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -601,47 +625,46 @@
                         xml_desc = attr_desc.get("xml", {})
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
-                                xml_name = "{}{}".format(xml_ns, xml_name)
-                            serialized.set(xml_name, new_attr)
+                                xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+                            serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
-                            serialized.text = new_attr
+                            serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
-                            serialized.extend(new_attr)
+                            serialized.extend(new_attr)  # type: ignore
                         elif isinstance(new_attr, ET.Element):
                             # If the down XML has no XML/Name, we MUST replace the tag with the local tag. But keeping the namespaces.
                             if "name" not in getattr(orig_attr, "_xml_map", {}):
                                 splitted_tag = new_attr.tag.split("}")
                                 if len(splitted_tag) == 2:  # Namespace
                                     new_attr.tag = "}".join([splitted_tag[0], xml_name])
                                 else:
                                     new_attr.tag = xml_name
-                            serialized.append(new_attr)
+                            serialized.append(new_attr)  # type: ignore
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
                             local_node.text = unicode_str(new_attr)
-                            serialized.append(local_node)
+                            serialized.append(local_node)  # type: ignore
                     else:  # JSON
-                        for k in reversed(keys):
-                            unflattened = {k: new_attr}
-                            new_attr = unflattened
+                        for k in reversed(keys):  # type: ignore
+                            new_attr = {k: new_attr}
 
                         _new_attr = new_attr
                         _serialized = serialized
-                        for k in keys:
+                        for k in keys:  # type: ignore
                             if k not in _serialized:
-                                _serialized.update(_new_attr)
-                            _new_attr = _new_attr[k]
+                                _serialized.update(_new_attr)  # type: ignore
+                            _new_attr = _new_attr[k]  # type: ignore
                             _serialized = _serialized[k]
                 except ValueError:
                     continue
 
         except (AttributeError, KeyError, TypeError) as err:
             msg = "Attribute {} in object {} cannot be serialized.\n{}".format(attr_name, class_name, str(target_obj))
             raise_with_traceback(SerializationError, msg, err)
@@ -655,31 +678,31 @@
         :param str data_type: The type to be serialized from.
         :rtype: dict
         :raises: SerializationError if serialization fails.
         :raises: ValueError if data is None
         """
 
         # Just in case this is a dict
-        internal_data_type = data_type.strip("[]{}")
-        internal_data_type = self.dependencies.get(internal_data_type, None)
+        internal_data_type_str = data_type.strip("[]{}")
+        internal_data_type = self.dependencies.get(internal_data_type_str, None)
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             if internal_data_type and issubclass(internal_data_type, Model):
                 is_xml_model_serialization = kwargs.setdefault("is_xml", internal_data_type.is_xml_model())
             else:
                 is_xml_model_serialization = False
         if internal_data_type and not isinstance(internal_data_type, Enum):
             try:
                 deserializer = Deserializer(self.dependencies)
                 # Since it's on serialization, it's almost sure that format is not JSON REST
                 # We're not able to deal with additional properties for now.
                 deserializer.additional_properties_detection = False
                 if is_xml_model_serialization:
-                    deserializer.key_extractors = [
+                    deserializer.key_extractors = [  # type: ignore
                         attribute_key_case_insensitive_extractor,
                     ]
                 else:
                     deserializer.key_extractors = [
                         rest_key_case_insensitive_extractor,
                         attribute_key_case_insensitive_extractor,
                         last_rest_key_case_insensitive_extractor,
@@ -776,14 +799,16 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
+            if data is AzureCoreNull:
+                return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
             # If dependencies is empty, try with current data class
@@ -839,15 +864,15 @@
         """
         try:  # If I received an enum, return its value
             return data.value
         except AttributeError:
             pass
 
         try:
-            if isinstance(data, unicode):
+            if isinstance(data, unicode):  # type: ignore
                 # Don't change it, JSON and XML ElementTree are totally able
                 # to serialize correctly u'' strings
                 return data
         except NameError:
             return str(data)
         else:
             return str(data)
@@ -997,18 +1022,18 @@
     @staticmethod
     def serialize_enum(attr, enum_obj=None):
         try:
             result = attr.value
         except AttributeError:
             result = attr
         try:
-            enum_obj(result)
+            enum_obj(result)  # type: ignore
             return result
         except ValueError:
-            for enum_value in enum_obj:
+            for enum_value in enum_obj:  # type: ignore
                 if enum_value.value.lower() == str(attr).lower():
                     return enum_value.value
             error = "{!r} is not valid value for enum {!r}"
             raise SerializationError(error.format(attr, enum_obj))
 
     @staticmethod
     def serialize_bytearray(attr, **kwargs):
@@ -1160,15 +1185,16 @@
 
 
 def rest_key_extractor(attr, attr_desc, data):
     key = attr_desc["key"]
     working_data = data
 
     while "." in key:
-        dict_keys = _FLATTEN.split(key)
+        # Need the cast, as for some reasons "split" is typed as list[str | Any]
+        dict_keys = cast(List[str], _FLATTEN.split(key))
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
@@ -1241,15 +1267,15 @@
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
     xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
@@ -1265,15 +1291,15 @@
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
     xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
     # If it's x-ms-text, that's simple too
     if xml_desc.get("text", False):
@@ -1331,15 +1357,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1351,15 +1377,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1412,15 +1438,15 @@
             return self.deserialize_data(data, response)
         elif isinstance(response, type) and issubclass(response, Enum):
             return self.deserialize_enum(data, response)
 
         if data is None:
             return data
         try:
-            attributes = response._attribute_map
+            attributes = response._attribute_map  # type: ignore
             d_attrs = {}
             for attr, attr_desc in attributes.items():
                 # Check empty string. If it's not empty, someone has a real "additionalProperties"...
                 if attr == "additional_properties" and attr_desc["key"] == "":
                     continue
                 raw_value = None
                 # Enhance attr_desc with some dynamic data
@@ -1440,15 +1466,15 @@
                             _LOGGER.warning(msg, found_value, key_extractor, attr)
                             continue
                         raw_value = found_value
 
                 value = self.deserialize_data(raw_value, attr_desc["type"])
                 d_attrs[attr] = value
         except (AttributeError, TypeError, KeyError) as err:
-            msg = "Unable to deserialize to object: " + class_name
+            msg = "Unable to deserialize to object: " + class_name  # type: ignore
             raise_with_traceback(DeserializationError, msg, err)
         else:
             additional_properties = self._build_additional_properties(attributes, data)
             return self._instantiate_model(response, d_attrs, additional_properties)
 
     def _build_additional_properties(self, attribute_map, data):
         if not self.additional_properties_detection:
@@ -1470,40 +1496,40 @@
 
     def _classify_target(self, target, data):
         """Check to see whether the deserialization target object can
         be classified into a subclass.
         Once classification has been determined, initialize object.
 
         :param str target: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         """
         if target is None:
             return None, None
 
         if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
             target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
-        return target, target.__class__.__name__
+        return target, target.__class__.__name__  # type: ignore
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
         for use in error deserialization, as we want to return the
         HttpResponseError to users, and not have them deal with
         a deserialization error.
 
         :param str target_obj: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
             _LOGGER.debug(
                 "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
@@ -1539,15 +1565,15 @@
             return RawDeserializer.deserialize_from_http_generics(raw_data.text(), raw_data.headers)
 
         # Assume this enough to recognize requests.Response without importing it.
         if hasattr(raw_data, "_content_consumed"):
             return RawDeserializer.deserialize_from_http_generics(raw_data.text, raw_data.headers)
 
         if isinstance(raw_data, (basestring, bytes)) or hasattr(raw_data, "read"):
-            return RawDeserializer.deserialize_from_text(raw_data, content_type)
+            return RawDeserializer.deserialize_from_text(raw_data, content_type)  # type: ignore
         return raw_data
 
     def _instantiate_model(self, response, attrs, additional_properties=None):
         """Instantiate a response model passing in deserialized args.
 
         :param response: The response model class.
         :param d_attrs: The deserialized response attributes.
@@ -1561,15 +1587,15 @@
                 response_obj = response(**kwargs)
                 for attr in readonly:
                     setattr(response_obj, attr, attrs.get(attr))
                 if additional_properties:
                     response_obj.additional_properties = additional_properties
                 return response_obj
             except TypeError as err:
-                msg = "Unable to deserialize {} into model {}. ".format(kwargs, response)
+                msg = "Unable to deserialize {} into model {}. ".format(kwargs, response)  # type: ignore
                 raise DeserializationError(msg + str(err))
         else:
             try:
                 for attr, value in attrs.items():
                     setattr(response, attr, value)
                 return response
             except Exception as exp:
@@ -1743,15 +1769,15 @@
         # We might be here because we have an enum modeled as string,
         # and we try to deserialize a partial dict with enum inside
         if isinstance(data, Enum):
             return data
 
         # Consider this is real string
         try:
-            if isinstance(data, unicode):
+            if isinstance(data, unicode):  # type: ignore
                 return data
         except NameError:
             return str(data)
         else:
             return str(data)
 
     @staticmethod
@@ -1794,58 +1820,58 @@
 
         :param str attr: response string to be deserialized.
         :rtype: bytearray
         :raises: TypeError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        return bytearray(b64decode(attr))
+        return bytearray(b64decode(attr))  # type: ignore
 
     @staticmethod
     def deserialize_base64(attr):
         """Deserialize base64 encoded string into string.
 
         :param str attr: response string to be deserialized.
         :rtype: bytearray
         :raises: TypeError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        padding = "=" * (3 - (len(attr) + 3) % 4)
-        attr = attr + padding
+        padding = "=" * (3 - (len(attr) + 3) % 4)  # type: ignore
+        attr = attr + padding  # type: ignore
         encoded = attr.replace("-", "+").replace("_", "/")
         return b64decode(encoded)
 
     @staticmethod
     def deserialize_decimal(attr):
         """Deserialize string into Decimal object.
 
         :param str attr: response string to be deserialized.
         :rtype: Decimal
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            return decimal.Decimal(attr)
+            return decimal.Decimal(attr)  # type: ignore
         except decimal.DecimalException as err:
             msg = "Invalid decimal {}".format(attr)
             raise_with_traceback(DeserializationError, msg, err)
 
     @staticmethod
     def deserialize_long(attr):
         """Deserialize string into long (Py2) or int (Py3).
 
         :param str attr: response string to be deserialized.
         :rtype: long or int
         :raises: ValueError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        return _long_type(attr)
+        return _long_type(attr)  # type: ignore
 
     @staticmethod
     def deserialize_duration(attr):
         """Deserialize ISO-8601 formatted string into TimeDelta object.
 
         :param str attr: response string to be deserialized.
         :rtype: TimeDelta
@@ -1867,45 +1893,45 @@
 
         :param str attr: response string to be deserialized.
         :rtype: Date
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        if re.search(r"[^\W\d_]", attr, re.I + re.U):
+        if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         # This must NOT use defaultmonth/defaultday. Using None ensure this raises an exception.
         return isodate.parse_date(attr, defaultmonth=None, defaultday=None)
 
     @staticmethod
     def deserialize_time(attr):
         """Deserialize ISO-8601 formatted string into time object.
 
         :param str attr: response string to be deserialized.
         :rtype: datetime.time
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        if re.search(r"[^\W\d_]", attr, re.I + re.U):
+        if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         return isodate.parse_time(attr)
 
     @staticmethod
     def deserialize_rfc(attr):
         """Deserialize RFC-1123 formatted string into Datetime object.
 
         :param str attr: response string to be deserialized.
         :rtype: Datetime
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            parsed_date = email.utils.parsedate_tz(attr)
+            parsed_date = email.utils.parsedate_tz(attr)  # type: ignore
             date_obj = datetime.datetime(
                 *parsed_date[:6], tzinfo=_FixedOffset(datetime.timedelta(minutes=(parsed_date[9] or 0) / 60))
             )
             if not date_obj.tzinfo:
                 date_obj = date_obj.astimezone(tz=TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to rfc datetime object."
@@ -1920,15 +1946,15 @@
         :param str attr: response string to be deserialized.
         :rtype: Datetime
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            attr = attr.upper()
+            attr = attr.upper()  # type: ignore
             match = Deserializer.valid_date.match(attr)
             if not match:
                 raise ValueError("Invalid datetime string: " + attr)
 
             check_decimal = attr.split(".")
             if len(check_decimal) > 1:
                 decimal_str = ""
@@ -1956,15 +1982,15 @@
         This is represented as seconds.
 
         :param int attr: Object to be serialized.
         :rtype: Datetime
         :raises: DeserializationError if format invalid
         """
         if isinstance(attr, ET.Element):
-            attr = int(attr.text)
+            attr = int(attr.text)  # type: ignore
         try:
             date_obj = datetime.datetime.fromtimestamp(attr, TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to unix datetime object."
             raise_with_traceback(DeserializationError, msg, err)
         else:
             return date_obj
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_patch.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/__init__.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 from ._cost_management_client import CostManagementClient
 from ._version import VERSION
 
 __version__ = VERSION
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "CostManagementClient",
 ]
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_configuration.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/_configuration.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,69 +2,60 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class CostManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for CostManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :keyword api_version: Api Version. Default value is "2022-10-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", **kwargs: Any) -> None:
         super(CostManagementClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "2022-10-01")  # type: Literal["2022-10-01"]
+        api_version: str = kwargs.pop("api_version", "2022-10-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
 
         self.credential = credential
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "mgmt-costmanagement/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_vendor.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_vendor.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+from typing import List, cast
+
 from azure.core.pipeline.transport import HttpRequest
 
 
 def _convert_request(request, files=None):
     data = request.content if not files else None
     request = HttpRequest(method=request.method, url=request.url, headers=request.headers, data=data)
     if files:
@@ -18,10 +20,11 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/_cost_management_client.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_cost_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any, TYPE_CHECKING
 
 from azure.core.rest import HttpRequest, HttpResponse
 from azure.mgmt.core import ARMPipelineClient
 
-from . import models
+from . import models as _models
 from ._configuration import CostManagementClientConfiguration
 from ._serialization import Deserializer, Serializer
 from .operations import (
     AlertsOperations,
     BenefitRecommendationsOperations,
     BenefitUtilizationSummariesOperations,
     DimensionsOperations,
@@ -96,17 +96,17 @@
      Retry-After header is present.
     """
 
     def __init__(
         self, credential: "TokenCredential", base_url: str = "https://management.azure.com", **kwargs: Any
     ) -> None:
         self._config = CostManagementClientConfiguration(credential=credential, **kwargs)
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.views = ViewsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.alerts = AlertsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.forecast = ForecastOperations(self._client, self._config, self._serialize, self._deserialize)
@@ -157,19 +157,16 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self):
-        # type: () -> None
+    def close(self) -> None:
         self._client.close()
 
-    def __enter__(self):
-        # type: () -> CostManagementClient
+    def __enter__(self) -> "CostManagementClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details):
-        # type: (Any) -> None
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.CostManagement/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -88,18 +83,16 @@
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.CostManagementOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.OperationListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -111,15 +104,15 @@
                 request = build_list_request(
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -127,36 +120,37 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.CostManagement/operations"}  # type: ignore
+    list.metadata = {"url": "/providers/Microsoft.CostManagement/operations"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_benefit_recommendations_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_benefit_recommendations_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -48,24 +43,24 @@
     orderby: Optional[str] = None,
     expand: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{billingScope}/providers/Microsoft.CostManagement/benefitRecommendations")
     path_format_arguments = {
         "billingScope": _SERIALIZER.url("billing_scope", billing_scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     if orderby is not None:
         _params["$orderby"] = _SERIALIZER.query("orderby", orderby, "str")
     if expand is not None:
@@ -104,14 +99,17 @@
         filter: Optional[str] = None,
         orderby: Optional[str] = None,
         expand: Optional[str] = None,
         **kwargs: Any
     ) -> Iterable["_models.BenefitRecommendationModel"]:
         """List of recommendations for purchasing savings plan.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/CostManagement/
+
         :param billing_scope: The scope associated with benefit recommendation operations. This
          includes '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resource group scope,
          /providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for enterprise agreement
          scope, and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
          for billing profile scope. Required.
@@ -135,18 +133,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.BenefitRecommendationModel]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BenefitRecommendationsListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.BenefitRecommendationsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -162,15 +158,15 @@
                     expand=expand,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -178,36 +174,37 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("BenefitRecommendationsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/{billingScope}/providers/Microsoft.CostManagement/benefitRecommendations"}  # type: ignore
+    list.metadata = {"url": "/{billingScope}/providers/Microsoft.CostManagement/benefitRecommendations"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_patch.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/__init__.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -24,15 +24,15 @@
 )
 from ._price_sheet_operations import PriceSheetOperations
 from ._scheduled_actions_operations import ScheduledActionsOperations
 from ._benefit_recommendations_operations import BenefitRecommendationsOperations
 from ._benefit_utilization_summaries_operations import BenefitUtilizationSummariesOperations
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Operations",
     "ViewsOperations",
     "AlertsOperations",
     "ForecastOperations",
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_scheduled_actions_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_scheduled_actions_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(*, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.CostManagement/scheduledActions")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -62,244 +58,250 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/scheduledActions")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_create_or_update_request(name: str, **kwargs: Any) -> HttpRequest:
+def build_create_or_update_request(name: str, *, if_match: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.CostManagement/scheduledActions/{name}")
     path_format_arguments = {
         "name": _SERIALIZER.url("name", name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if if_match is not None:
+        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.CostManagement/scheduledActions/{name}")
     path_format_arguments = {
         "name": _SERIALIZER.url("name", name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.CostManagement/scheduledActions/{name}")
     path_format_arguments = {
         "name": _SERIALIZER.url("name", name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_create_or_update_by_scope_request(scope: str, name: str, **kwargs: Any) -> HttpRequest:
+def build_create_or_update_by_scope_request(
+    scope: str, name: str, *, if_match: Optional[str] = None, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
         "name": _SERIALIZER.url("name", name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if if_match is not None:
+        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_scope_request(scope: str, name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
         "name": _SERIALIZER.url("name", name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_scope_request(scope: str, name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
         "name": _SERIALIZER.url("name", name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_run_request(name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.CostManagement/scheduledActions/{name}/execute")
     path_format_arguments = {
         "name": _SERIALIZER.url("name", name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_run_by_scope_request(scope: str, name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}/execute")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
         "name": _SERIALIZER.url("name", name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_check_name_availability_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.CostManagement/checkNameAvailability")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -312,25 +314,25 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_check_name_availability_by_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/checkNameAvailability")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -358,29 +360,30 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(self, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.ScheduledAction"]:
         """List all private scheduled actions.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param filter: May be used to filter scheduled actions by properties/viewId. Supported operator
          is 'eq'. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ScheduledAction or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.ScheduledAction]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledActionListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ScheduledActionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -393,15 +396,15 @@
                     filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -409,50 +412,56 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("ScheduledActionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                error = self._deserialize.failsafe_deserialize(
+                    _models.ErrorResponseWithNestedDetails, pipeline_response
+                )
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions"}  # type: ignore
+    list.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions"}
 
     @distributed_trace
     def list_by_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.ScheduledAction"]:
         """List all shared scheduled actions within the given scope.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param scope: The scope associated with scheduled action operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -474,18 +483,16 @@
         :return: An iterator like instance of either ScheduledAction or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.ScheduledAction]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledActionListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ScheduledActionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -499,15 +506,15 @@
                     filter=filter,
                     api_version=api_version,
                     template_url=self.list_by_scope.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -515,98 +522,124 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("ScheduledActionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                error = self._deserialize.failsafe_deserialize(
+                    _models.ErrorResponseWithNestedDetails, pipeline_response
+                )
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions"}  # type: ignore
+    list_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions"}
 
     @overload
     def create_or_update(
         self,
         name: str,
         scheduled_action: _models.ScheduledAction,
+        if_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a private scheduled action.
 
         :param name: Scheduled action name. Required.
         :type name: str
         :param scheduled_action: Scheduled action to be created or updated. Required.
         :type scheduled_action: ~azure.mgmt.costmanagement.models.ScheduledAction
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_or_update(
-        self, name: str, scheduled_action: IO, *, content_type: str = "application/json", **kwargs: Any
+        self,
+        name: str,
+        scheduled_action: IO,
+        if_match: Optional[str] = None,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a private scheduled action.
 
         :param name: Scheduled action name. Required.
         :type name: str
         :param scheduled_action: Scheduled action to be created or updated. Required.
         :type scheduled_action: IO
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_or_update(
-        self, name: str, scheduled_action: Union[_models.ScheduledAction, IO], **kwargs: Any
+        self,
+        name: str,
+        scheduled_action: Union[_models.ScheduledAction, IO],
+        if_match: Optional[str] = None,
+        **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a private scheduled action.
 
         :param name: Scheduled action name. Required.
         :type name: str
-        :param scheduled_action: Scheduled action to be created or updated. Is either a model type or a
-         IO type. Required.
+        :param scheduled_action: Scheduled action to be created or updated. Is either a ScheduledAction
+         type or a IO type. Required.
         :type scheduled_action: ~azure.mgmt.costmanagement.models.ScheduledAction or IO
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -618,69 +651,72 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledAction]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.ScheduledAction] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(scheduled_action, (IO, bytes)):
+        if isinstance(scheduled_action, (IOBase, bytes)):
             _content = scheduled_action
         else:
             _json = self._serialize.body(scheduled_action, "ScheduledAction")
 
         request = build_create_or_update_request(
             name=name,
+            if_match=if_match,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    create_or_update.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    create_or_update.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @distributed_trace
     def get(self, name: str, **kwargs: Any) -> _models.ScheduledAction:
         """Get the private scheduled action by name.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param name: Scheduled action name. Required.
         :type name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -691,53 +727,55 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledAction]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ScheduledAction] = kwargs.pop("cls", None)
 
         request = build_get_request(
             name=name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    get.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @distributed_trace
     def delete(self, name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
         """Delete a private scheduled action.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param name: Scheduled action name. Required.
         :type name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -748,51 +786,51 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             name=name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    delete.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @overload
     def create_or_update_by_scope(
         self,
         scope: str,
         name: str,
         scheduled_action: _models.ScheduledAction,
+        if_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a shared scheduled action within the given scope.
 
         :param scope: The scope associated with scheduled action operations. This includes
@@ -813,26 +851,37 @@
          External Subscription scope. Note: Insight Alerts are only available on subscription scope.
          Required.
         :type scope: str
         :param name: Scheduled action name. Required.
         :type name: str
         :param scheduled_action: Scheduled action to be created or updated. Required.
         :type scheduled_action: ~azure.mgmt.costmanagement.models.ScheduledAction
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_or_update_by_scope(
-        self, scope: str, name: str, scheduled_action: IO, *, content_type: str = "application/json", **kwargs: Any
+        self,
+        scope: str,
+        name: str,
+        scheduled_action: IO,
+        if_match: Optional[str] = None,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a shared scheduled action within the given scope.
 
         :param scope: The scope associated with scheduled action operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
@@ -850,26 +899,35 @@
          External Subscription scope. Note: Insight Alerts are only available on subscription scope.
          Required.
         :type scope: str
         :param name: Scheduled action name. Required.
         :type name: str
         :param scheduled_action: Scheduled action to be created or updated. Required.
         :type scheduled_action: IO
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_or_update_by_scope(
-        self, scope: str, name: str, scheduled_action: Union[_models.ScheduledAction, IO], **kwargs: Any
+        self,
+        scope: str,
+        name: str,
+        scheduled_action: Union[_models.ScheduledAction, IO],
+        if_match: Optional[str] = None,
+        **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a shared scheduled action within the given scope.
 
         :param scope: The scope associated with scheduled action operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
@@ -885,17 +943,21 @@
          External Billing Account scope and
          'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
          External Subscription scope. Note: Insight Alerts are only available on subscription scope.
          Required.
         :type scope: str
         :param name: Scheduled action name. Required.
         :type name: str
-        :param scheduled_action: Scheduled action to be created or updated. Is either a model type or a
-         IO type. Required.
+        :param scheduled_action: Scheduled action to be created or updated. Is either a ScheduledAction
+         type or a IO type. Required.
         :type scheduled_action: ~azure.mgmt.costmanagement.models.ScheduledAction or IO
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -907,70 +969,73 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledAction]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.ScheduledAction] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(scheduled_action, (IO, bytes)):
+        if isinstance(scheduled_action, (IOBase, bytes)):
             _content = scheduled_action
         else:
             _json = self._serialize.body(scheduled_action, "ScheduledAction")
 
         request = build_create_or_update_by_scope_request(
             scope=scope,
             name=name,
+            if_match=if_match,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self.create_or_update_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    create_or_update_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    create_or_update_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @distributed_trace
     def get_by_scope(self, scope: str, name: str, **kwargs: Any) -> _models.ScheduledAction:
         """Get the shared scheduled action from the given scope by name.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param scope: The scope associated with scheduled action operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -999,56 +1064,58 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledAction]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ScheduledAction] = kwargs.pop("cls", None)
 
         request = build_get_by_scope_request(
             scope=scope,
             name=name,
             api_version=api_version,
             template_url=self.get_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    get_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @distributed_trace
     def delete_by_scope(  # pylint: disable=inconsistent-return-statements
         self, scope: str, name: str, **kwargs: Any
     ) -> None:
         """Delete a scheduled action within the given scope.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param scope: The scope associated with scheduled action operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -1077,45 +1144,44 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_scope_request(
             scope=scope,
             name=name,
             api_version=api_version,
             template_url=self.delete_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    delete_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @distributed_trace
     def run(self, name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
         """Processes a private scheduled action.
 
         :param name: Scheduled action name. Required.
         :type name: str
@@ -1131,44 +1197,43 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_run_request(
             name=name,
             api_version=api_version,
             template_url=self.run.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    run.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}/execute"}  # type: ignore
+    run.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}/execute"}
 
     @distributed_trace
     def run_by_scope(  # pylint: disable=inconsistent-return-statements
         self, scope: str, name: str, **kwargs: Any
     ) -> None:
         """Runs a shared scheduled action within the given scope.
 
@@ -1204,45 +1269,44 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_run_by_scope_request(
             scope=scope,
             name=name,
             api_version=api_version,
             template_url=self.run_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    run_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}/execute"}  # type: ignore
+    run_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}/execute"}
 
     @overload
     def check_name_availability(
         self,
         check_name_availability_request: _models.CheckNameAvailabilityRequest,
         *,
         content_type: str = "application/json",
@@ -1282,15 +1346,15 @@
     @distributed_trace
     def check_name_availability(
         self, check_name_availability_request: Union[_models.CheckNameAvailabilityRequest, IO], **kwargs: Any
     ) -> _models.CheckNameAvailabilityResponse:
         """Checks availability and correctness of the name for a scheduled action.
 
         :param check_name_availability_request: Scheduled action to be created or updated. Is either a
-         model type or a IO type. Required.
+         CheckNameAvailabilityRequest type or a IO type. Required.
         :type check_name_availability_request:
          ~azure.mgmt.costmanagement.models.CheckNameAvailabilityRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityResponse or the result of cls(response)
@@ -1304,59 +1368,58 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CheckNameAvailabilityResponse]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CheckNameAvailabilityResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(check_name_availability_request, (IO, bytes)):
+        if isinstance(check_name_availability_request, (IOBase, bytes)):
             _content = check_name_availability_request
         else:
             _json = self._serialize.body(check_name_availability_request, "CheckNameAvailabilityRequest")
 
         request = build_check_name_availability_request(
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameAvailabilityResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    check_name_availability.metadata = {"url": "/providers/Microsoft.CostManagement/checkNameAvailability"}  # type: ignore
+    check_name_availability.metadata = {"url": "/providers/Microsoft.CostManagement/checkNameAvailability"}
 
     @overload
     def check_name_availability_by_scope(
         self,
         scope: str,
         check_name_availability_request: _models.CheckNameAvailabilityRequest,
         *,
@@ -1454,15 +1517,15 @@
          'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
          External Billing Account scope and
          'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
          External Subscription scope. Note: Insight Alerts are only available on subscription scope.
          Required.
         :type scope: str
         :param check_name_availability_request: Scheduled action to be created or updated. Is either a
-         model type or a IO type. Required.
+         CheckNameAvailabilityRequest type or a IO type. Required.
         :type check_name_availability_request:
          ~azure.mgmt.costmanagement.models.CheckNameAvailabilityRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityResponse or the result of cls(response)
@@ -1476,24 +1539,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CheckNameAvailabilityResponse]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CheckNameAvailabilityResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(check_name_availability_request, (IO, bytes)):
+        if isinstance(check_name_availability_request, (IOBase, bytes)):
             _content = check_name_availability_request
         else:
             _json = self._serialize.body(check_name_availability_request, "CheckNameAvailabilityRequest")
 
         request = build_check_name_availability_by_scope_request(
             scope=scope,
             api_version=api_version,
@@ -1501,28 +1562,31 @@
             json=_json,
             content=_content,
             template_url=self.check_name_availability_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameAvailabilityResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    check_name_availability_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/checkNameAvailability"}  # type: ignore
+    check_name_availability_by_scope.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/checkNameAvailability"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_benefit_utilization_summaries_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_benefit_utilization_summaries_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar, Union
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -47,27 +42,27 @@
     grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "billingAccountId": _SERIALIZER.url("billing_account_id", billing_account_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if grain_parameter is not None:
         _params["grainParameter"] = _SERIALIZER.query("grain_parameter", grain_parameter, "str")
     if filter is not None:
         _params["filter"] = _SERIALIZER.query("filter", filter, "str")
@@ -85,28 +80,28 @@
     grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "billingAccountId": _SERIALIZER.url("billing_account_id", billing_account_id, "str"),
         "billingProfileId": _SERIALIZER.url("billing_profile_id", billing_profile_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if grain_parameter is not None:
         _params["grainParameter"] = _SERIALIZER.query("grain_parameter", grain_parameter, "str")
     if filter is not None:
         _params["filter"] = _SERIALIZER.query("filter", filter, "str")
@@ -123,27 +118,27 @@
     filter: Optional[str] = None,
     grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "savingsPlanOrderId": _SERIALIZER.url("savings_plan_order_id", savings_plan_order_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     if grain_parameter is not None:
         _params["grainParameter"] = _SERIALIZER.query("grain_parameter", grain_parameter, "str")
@@ -161,28 +156,28 @@
     filter: Optional[str] = None,
     grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/savingsPlans/{savingsPlanId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "savingsPlanOrderId": _SERIALIZER.url("savings_plan_order_id", savings_plan_order_id, "str"),
         "savingsPlanId": _SERIALIZER.url("savings_plan_id", savings_plan_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     if grain_parameter is not None:
         _params["grainParameter"] = _SERIALIZER.query("grain_parameter", grain_parameter, "str")
@@ -219,14 +214,17 @@
         grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
         filter: Optional[str] = None,
         **kwargs: Any
     ) -> Iterable["_models.BenefitUtilizationSummary"]:
         """Lists savings plan utilization summaries for the enterprise agreement scope. Supported at grain
         values: 'Daily' and 'Monthly'.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/cost-management/
+
         :param billing_account_id: Billing account ID. Required.
         :type billing_account_id: str
         :param grain_parameter: Grain. Known values are: "Hourly", "Daily", and "Monthly". Default
          value is None.
         :type grain_parameter: str or ~azure.mgmt.costmanagement.models.GrainParameter
         :param filter: Supports filtering by properties/benefitId, properties/benefitOrderId and
          properties/usageDate. Default value is None.
@@ -237,18 +235,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.BenefitUtilizationSummary]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BenefitUtilizationSummariesListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.BenefitUtilizationSummariesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -263,15 +259,15 @@
                     filter=filter,
                     api_version=api_version,
                     template_url=self.list_by_billing_account_id.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -279,56 +275,62 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("BenefitUtilizationSummariesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_by_billing_account_id.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"}  # type: ignore
+    list_by_billing_account_id.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"
+    }
 
     @distributed_trace
     def list_by_billing_profile_id(
         self,
         billing_account_id: str,
         billing_profile_id: str,
         grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
         filter: Optional[str] = None,
         **kwargs: Any
     ) -> Iterable["_models.BenefitUtilizationSummary"]:
         """Lists savings plan utilization summaries for billing profile. Supported at grain values:
         'Daily' and 'Monthly'.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/cost-management/
+
         :param billing_account_id: Billing account ID. Required.
         :type billing_account_id: str
         :param billing_profile_id: Billing profile ID. Required.
         :type billing_profile_id: str
         :param grain_parameter: Grain. Known values are: "Hourly", "Daily", and "Monthly". Default
          value is None.
         :type grain_parameter: str or ~azure.mgmt.costmanagement.models.GrainParameter
@@ -341,18 +343,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.BenefitUtilizationSummary]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BenefitUtilizationSummariesListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.BenefitUtilizationSummariesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -368,15 +368,15 @@
                     filter=filter,
                     api_version=api_version,
                     template_url=self.list_by_billing_profile_id.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -384,54 +384,60 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("BenefitUtilizationSummariesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_by_billing_profile_id.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"}  # type: ignore
+    list_by_billing_profile_id.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"
+    }
 
     @distributed_trace
     def list_by_savings_plan_order(
         self,
         savings_plan_order_id: str,
         filter: Optional[str] = None,
         grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
         **kwargs: Any
     ) -> Iterable["_models.BenefitUtilizationSummary"]:
         """Lists the savings plan utilization summaries for daily or monthly grain.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/cost-management/
+
         :param savings_plan_order_id: Savings plan order ID. Required.
         :type savings_plan_order_id: str
         :param filter: Supports filtering by properties/usageDate. Default value is None.
         :type filter: str
         :param grain_parameter: Grain. Known values are: "Hourly", "Daily", and "Monthly". Default
          value is None.
         :type grain_parameter: str or ~azure.mgmt.costmanagement.models.GrainParameter
@@ -441,18 +447,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.BenefitUtilizationSummary]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BenefitUtilizationSummariesListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.BenefitUtilizationSummariesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -467,15 +471,15 @@
                     grain_parameter=grain_parameter,
                     api_version=api_version,
                     template_url=self.list_by_savings_plan_order.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -483,55 +487,61 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("BenefitUtilizationSummariesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_by_savings_plan_order.metadata = {"url": "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"}  # type: ignore
+    list_by_savings_plan_order.metadata = {
+        "url": "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"
+    }
 
     @distributed_trace
     def list_by_savings_plan_id(
         self,
         savings_plan_order_id: str,
         savings_plan_id: str,
         filter: Optional[str] = None,
         grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
         **kwargs: Any
     ) -> Iterable["_models.BenefitUtilizationSummary"]:
         """Lists the savings plan utilization summaries for daily or monthly grain.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/cost-management/
+
         :param savings_plan_order_id: Savings plan order ID. Required.
         :type savings_plan_order_id: str
         :param savings_plan_id: Savings plan ID. Required.
         :type savings_plan_id: str
         :param filter: Supports filtering by properties/usageDate. Default value is None.
         :type filter: str
         :param grain_parameter: Grain. Known values are: "Hourly", "Daily", and "Monthly". Default
@@ -543,18 +553,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.BenefitUtilizationSummary]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BenefitUtilizationSummariesListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.BenefitUtilizationSummariesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -570,15 +578,15 @@
                     grain_parameter=grain_parameter,
                     api_version=api_version,
                     template_url=self.list_by_savings_plan_id.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -586,36 +594,39 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("BenefitUtilizationSummariesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_by_savings_plan_id.metadata = {"url": "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/savingsPlans/{savingsPlanId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"}  # type: ignore
+    list_by_savings_plan_id.metadata = {
+        "url": "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/savingsPlans/{savingsPlanId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_cost_details_report_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_cost_details_report_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,40 +26,36 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_operation_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/generateCostDetailsReport")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -68,27 +64,27 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_operation_results_request(scope: str, operation_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.CostManagement/costDetailsOperationResults/{operationId}"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -124,24 +120,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.CostDetailsOperationResults]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[Optional[_models.CostDetailsOperationResults]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "GenerateCostDetailsReportRequestDefinition")
 
         request = build_create_operation_request(
             scope=scope,
             api_version=api_version,
@@ -149,23 +143,24 @@
             json=_json,
             content=_content,
             template_url=self._create_operation_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(
                 _models.GenerateCostDetailsReportErrorResponse, pipeline_response
             )
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
@@ -178,15 +173,17 @@
             response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _create_operation_initial.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateCostDetailsReport"}  # type: ignore
+    _create_operation_initial.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/generateCostDetailsReport"
+    }
 
     @overload
     def begin_create_operation(
         self,
         scope: str,
         parameters: _models.GenerateCostDetailsReportRequestDefinition,
         *,
@@ -198,15 +195,20 @@
         or Invoice Id asynchronously at a certain scope. The initial call to request a report will
         return a 202 with a 'Location' and 'Retry-After' header. The 'Location' header will provide the
         endpoint to poll to get the result of the report generation. The 'Retry-After' provides the
         duration to wait before polling for the generated report. A call to poll the report operation
         will provide a 202 response with a 'Location' header if the operation is still in progress.
         Once the report generation operation completes, the polling endpoint will provide a 200
         response along with details on the report blob(s) that are available for download. The details
-        on the file(s) available for download will be available in the polling response body.
+        on the file(s) available for download will be available in the polling response body. To
+        Understand cost details (formerly known as usage details) fields found in files ,see
+        https://learn.microsoft.com/azure/cost-management-billing/automate/understand-usage-details-fields.
+
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
 
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
         :param parameters: Parameters supplied to the Create cost details operation. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.GenerateCostDetailsReportRequestDefinition
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -236,15 +238,20 @@
         or Invoice Id asynchronously at a certain scope. The initial call to request a report will
         return a 202 with a 'Location' and 'Retry-After' header. The 'Location' header will provide the
         endpoint to poll to get the result of the report generation. The 'Retry-After' provides the
         duration to wait before polling for the generated report. A call to poll the report operation
         will provide a 202 response with a 'Location' header if the operation is still in progress.
         Once the report generation operation completes, the polling endpoint will provide a 200
         response along with details on the report blob(s) that are available for download. The details
-        on the file(s) available for download will be available in the polling response body.
+        on the file(s) available for download will be available in the polling response body. To
+        Understand cost details (formerly known as usage details) fields found in files ,see
+        https://learn.microsoft.com/azure/cost-management-billing/automate/understand-usage-details-fields.
+
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
 
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
         :param parameters: Parameters supplied to the Create cost details operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -274,21 +281,26 @@
         or Invoice Id asynchronously at a certain scope. The initial call to request a report will
         return a 202 with a 'Location' and 'Retry-After' header. The 'Location' header will provide the
         endpoint to poll to get the result of the report generation. The 'Retry-After' provides the
         duration to wait before polling for the generated report. A call to poll the report operation
         will provide a 202 response with a 'Location' header if the operation is still in progress.
         Once the report generation operation completes, the polling endpoint will provide a 200
         response along with details on the report blob(s) that are available for download. The details
-        on the file(s) available for download will be available in the polling response body.
+        on the file(s) available for download will be available in the polling response body. To
+        Understand cost details (formerly known as usage details) fields found in files ,see
+        https://learn.microsoft.com/azure/cost-management-billing/automate/understand-usage-details-fields.
+
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
 
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
-        :param parameters: Parameters supplied to the Create cost details operation. Is either a model
-         type or a IO type. Required.
+        :param parameters: Parameters supplied to the Create cost details operation. Is either a
+         GenerateCostDetailsReportRequestDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.GenerateCostDetailsReportRequestDefinition
          or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -303,24 +315,22 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.CostDetailsOperationResults]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CostDetailsOperationResults]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CostDetailsOperationResults] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._create_operation_initial(  # type: ignore
+            raw_result = self._create_operation_initial(
                 scope=scope,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -331,31 +341,31 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("CostDetailsOperationResults", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_create_operation.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateCostDetailsReport"}  # type: ignore
+    begin_create_operation.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateCostDetailsReport"}
 
     def _get_operation_results_initial(
         self, scope: str, operation_id: str, **kwargs: Any
     ) -> Optional[_models.CostDetailsOperationResults]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -363,32 +373,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.CostDetailsOperationResults]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.CostDetailsOperationResults]] = kwargs.pop("cls", None)
 
         request = build_get_operation_results_request(
             scope=scope,
             operation_id=operation_id,
             api_version=api_version,
             template_url=self._get_operation_results_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -399,15 +408,17 @@
             deserialized = self._deserialize("CostDetailsOperationResults", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _get_operation_results_initial.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/costDetailsOperationResults/{operationId}"}  # type: ignore
+    _get_operation_results_initial.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/costDetailsOperationResults/{operationId}"
+    }
 
     @distributed_trace
     def begin_get_operation_results(
         self, scope: str, operation_id: str, **kwargs: Any
     ) -> LROPoller[_models.CostDetailsOperationResults]:
         """Get the result of the specified operation. This link is provided in the CostDetails creation
         request response Location header.
@@ -430,23 +441,21 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.CostDetailsOperationResults]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CostDetailsOperationResults]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.CostDetailsOperationResults] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._get_operation_results_initial(  # type: ignore
+            raw_result = self._get_operation_results_initial(
                 scope=scope,
                 operation_id=operation_id,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
@@ -456,24 +465,26 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("CostDetailsOperationResults", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_get_operation_results.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/costDetailsOperationResults/{operationId}"}  # type: ignore
+    begin_get_operation_results.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/costDetailsOperationResults/{operationId}"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_alerts_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_alerts_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,90 +24,86 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/alerts")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "alertId": _SERIALIZER.url("alert_id", alert_id, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_dismiss_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "alertId": _SERIALIZER.url("alert_id", alert_id, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -120,30 +116,30 @@
     external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
     external_cloud_provider_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/alerts",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "externalCloudProviderType": _SERIALIZER.url(
             "external_cloud_provider_type", external_cloud_provider_type, "str"
         ),
         "externalCloudProviderId": _SERIALIZER.url("external_cloud_provider_id", external_cloud_provider_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -169,14 +165,17 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(self, scope: str, **kwargs: Any) -> _models.AlertsResult:
         """Lists the alerts for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with alerts operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -202,31 +201,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.AlertsResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.AlertsResult] = kwargs.pop("cls", None)
 
         request = build_list_request(
             scope=scope,
             api_version=api_version,
             template_url=self.list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -235,20 +233,23 @@
         deserialized = self._deserialize("AlertsResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts"}
 
     @distributed_trace
     def get(self, scope: str, alert_id: str, **kwargs: Any) -> _models.Alert:
         """Gets the alert for the scope by alert ID.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with alerts operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -276,32 +277,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Alert]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.Alert] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             alert_id=alert_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -310,28 +310,31 @@
         deserialized = self._deserialize("Alert", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}"}
 
     @overload
     def dismiss(
         self,
         scope: str,
         alert_id: str,
         parameters: _models.DismissAlertPayload,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.Alert:
         """Dismisses the specified alert.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with alerts operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -360,14 +363,17 @@
 
     @overload
     def dismiss(
         self, scope: str, alert_id: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.Alert:
         """Dismisses the specified alert.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with alerts operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -396,14 +402,17 @@
 
     @distributed_trace
     def dismiss(
         self, scope: str, alert_id: str, parameters: Union[_models.DismissAlertPayload, IO], **kwargs: Any
     ) -> _models.Alert:
         """Dismisses the specified alert.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with alerts operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -415,16 +424,16 @@
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
          for invoiceSection scope, and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
          specific for partners. Required.
         :type scope: str
         :param alert_id: Alert ID. Required.
         :type alert_id: str
-        :param parameters: Parameters supplied to the Dismiss Alert operation. Is either a model type
-         or a IO type. Required.
+        :param parameters: Parameters supplied to the Dismiss Alert operation. Is either a
+         DismissAlertPayload type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.DismissAlertPayload or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Alert or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.Alert
@@ -437,24 +446,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Alert]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.Alert] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "DismissAlertPayload")
 
         request = build_dismiss_request(
             scope=scope,
             alert_id=alert_id,
@@ -463,18 +470,19 @@
             json=_json,
             content=_content,
             template_url=self.dismiss.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -483,25 +491,28 @@
         deserialized = self._deserialize("Alert", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    dismiss.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}"}  # type: ignore
+    dismiss.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}"}
 
     @distributed_trace
     def list_external(
         self,
         external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
         external_cloud_provider_id: str,
         **kwargs: Any
     ) -> _models.AlertsResult:
         """Lists the Alerts for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -520,32 +531,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.AlertsResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.AlertsResult] = kwargs.pop("cls", None)
 
         request = build_list_external_request(
             external_cloud_provider_type=external_cloud_provider_type,
             external_cloud_provider_id=external_cloud_provider_id,
             api_version=api_version,
             template_url=self.list_external.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -554,8 +564,10 @@
         deserialized = self._deserialize("AlertsResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    list_external.metadata = {"url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/alerts"}  # type: ignore
+    list_external.metadata = {
+        "url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/alerts"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_reservation_details_report_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_reservation_details_report_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar, Union, cast
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,44 +25,40 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_by_billing_account_id_request(
     billing_account_id: str, *, start_date: str, end_date: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/generateReservationDetailsReport",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "billingAccountId": _SERIALIZER.url("billing_account_id", billing_account_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["startDate"] = _SERIALIZER.query("start_date", start_date, "str")
     _params["endDate"] = _SERIALIZER.query("end_date", end_date, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -74,28 +69,28 @@
 
 def build_by_billing_profile_id_request(
     billing_account_id: str, billing_profile_id: str, *, start_date: str, end_date: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/generateReservationDetailsReport",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "billingAccountId": _SERIALIZER.url("billing_account_id", billing_account_id, "str"),
         "billingProfileId": _SERIALIZER.url("billing_profile_id", billing_profile_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["startDate"] = _SERIALIZER.query("start_date", start_date, "str")
     _params["endDate"] = _SERIALIZER.query("end_date", end_date, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -133,33 +128,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.OperationStatus]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.OperationStatus]] = kwargs.pop("cls", None)
 
         request = build_by_billing_account_id_request(
             billing_account_id=billing_account_id,
             start_date=start_date,
             end_date=end_date,
             api_version=api_version,
             template_url=self._by_billing_account_id_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -175,24 +169,29 @@
             response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _by_billing_account_id_initial.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"}  # type: ignore
+    _by_billing_account_id_initial.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"
+    }
 
     @distributed_trace
     def begin_by_billing_account_id(
         self, billing_account_id: str, start_date: str, end_date: str, **kwargs: Any
     ) -> LROPoller[_models.OperationStatus]:
         """Generates the reservations details report for provided date range asynchronously based on
         enrollment id. The Reservation usage details can be viewed only by certain enterprise roles.
         For more details on the roles see,
-        https://docs.microsoft.com/en-us/azure/cost-management-billing/manage/understand-ea-roles#usage-and-costs-access-by-role.
+        https://docs.microsoft.com/azure/cost-management-billing/manage/understand-ea-roles#usage-and-costs-access-by-role.
+
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
 
         :param billing_account_id: Enrollment ID (Legacy BillingAccount ID). Required.
         :type billing_account_id: str
         :param start_date: Start Date. Required.
         :type start_date: str
         :param end_date: End Date. Required.
         :type end_date: str
@@ -208,23 +207,21 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.OperationStatus]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.OperationStatus]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._by_billing_account_id_initial(  # type: ignore
+            raw_result = self._by_billing_account_id_initial(
                 billing_account_id=billing_account_id,
                 start_date=start_date,
                 end_date=end_date,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -235,31 +232,33 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("OperationStatus", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_by_billing_account_id.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"}  # type: ignore
+    begin_by_billing_account_id.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"
+    }
 
     def _by_billing_profile_id_initial(
         self, billing_account_id: str, billing_profile_id: str, start_date: str, end_date: str, **kwargs: Any
     ) -> Optional[_models.OperationStatus]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -267,34 +266,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.OperationStatus]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.OperationStatus]] = kwargs.pop("cls", None)
 
         request = build_by_billing_profile_id_request(
             billing_account_id=billing_account_id,
             billing_profile_id=billing_profile_id,
             start_date=start_date,
             end_date=end_date,
             api_version=api_version,
             template_url=self._by_billing_profile_id_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -310,24 +308,29 @@
             response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _by_billing_profile_id_initial.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"}  # type: ignore
+    _by_billing_profile_id_initial.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"
+    }
 
     @distributed_trace
     def begin_by_billing_profile_id(
         self, billing_account_id: str, billing_profile_id: str, start_date: str, end_date: str, **kwargs: Any
     ) -> LROPoller[_models.OperationStatus]:
         """Generates the reservations details report for provided date range asynchronously by billing
         profile. The Reservation usage details can be viewed by only certain enterprise roles by
         default. For more details on the roles see,
-        https://docs.microsoft.com/en-us/azure/cost-management-billing/reservations/reservation-utilization#view-utilization-in-the-azure-portal-with-azure-rbac-access.
+        https://docs.microsoft.com/azure/cost-management-billing/reservations/reservation-utilization#view-utilization-in-the-azure-portal-with-azure-rbac-access.
+
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
 
         :param billing_account_id: Billing account ID. Required.
         :type billing_account_id: str
         :param billing_profile_id: Billing profile ID. Required.
         :type billing_profile_id: str
         :param start_date: Start Date. Required.
         :type start_date: str
@@ -345,23 +348,21 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.OperationStatus]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.OperationStatus]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._by_billing_profile_id_initial(  # type: ignore
+            raw_result = self._by_billing_profile_id_initial(
                 billing_account_id=billing_account_id,
                 billing_profile_id=billing_profile_id,
                 start_date=start_date,
                 end_date=end_date,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -373,24 +374,26 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("OperationStatus", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_by_billing_profile_id.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"}  # type: ignore
+    begin_by_billing_profile_id.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_price_sheet_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_price_sheet_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar, Union, cast
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,32 +25,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_download_request(
     billing_account_name: str, billing_profile_name: str, invoice_name: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoices/{invoiceName}/providers/Microsoft.CostManagement/pricesheets/default/download",
     )  # pylint: disable=line-too-long
@@ -64,15 +59,15 @@
         ),
         "billingProfileName": _SERIALIZER.url(
             "billing_profile_name", billing_profile_name, "str", pattern=r"([A-Za-z0-9]+(-[A-Za-z0-9]+)+)"
         ),
         "invoiceName": _SERIALIZER.url("invoice_name", invoice_name, "str", pattern=r"[A-Za-z0-9]+"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -81,15 +76,15 @@
 
 def build_download_by_billing_profile_request(
     billing_account_name: str, billing_profile_name: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.CostManagement/pricesheets/default/download",
     )  # pylint: disable=line-too-long
@@ -101,15 +96,15 @@
             pattern=r"([A-Za-z0-9]+(-[A-Za-z0-9]+)+):([A-Za-z0-9]+(-[A-Za-z0-9]+)+)_[0-9]{4}-[0-9]{2}-[0-9]{2}",
         ),
         "billingProfileName": _SERIALIZER.url(
             "billing_profile_name", billing_profile_name, "str", pattern=r"([A-Za-z0-9]+(-[A-Za-z0-9]+)+)"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -145,33 +140,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.DownloadURL]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.DownloadURL]] = kwargs.pop("cls", None)
 
         request = build_download_request(
             billing_account_name=billing_account_name,
             billing_profile_name=billing_profile_name,
             invoice_name=invoice_name,
             api_version=api_version,
             template_url=self._download_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -188,15 +182,17 @@
             response_headers["OData-EntityId"] = self._deserialize("str", response.headers.get("OData-EntityId"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _download_initial.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoices/{invoiceName}/providers/Microsoft.CostManagement/pricesheets/default/download"}  # type: ignore
+    _download_initial.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoices/{invoiceName}/providers/Microsoft.CostManagement/pricesheets/default/download"
+    }
 
     @distributed_trace
     def begin_download(
         self, billing_account_name: str, billing_profile_name: str, invoice_name: str, **kwargs: Any
     ) -> LROPoller[_models.DownloadURL]:
         """Gets a URL to download the pricesheet for an invoice. The operation is supported for billing
         accounts with agreement type Microsoft Partner Agreement or Microsoft Customer Agreement.
@@ -219,23 +215,21 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.DownloadURL]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DownloadURL]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.DownloadURL] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._download_initial(  # type: ignore
+            raw_result = self._download_initial(
                 billing_account_name=billing_account_name,
                 billing_profile_name=billing_profile_name,
                 invoice_name=invoice_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -246,31 +240,33 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DownloadURL", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_download.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoices/{invoiceName}/providers/Microsoft.CostManagement/pricesheets/default/download"}  # type: ignore
+    begin_download.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoices/{invoiceName}/providers/Microsoft.CostManagement/pricesheets/default/download"
+    }
 
     def _download_by_billing_profile_initial(
         self, billing_account_name: str, billing_profile_name: str, **kwargs: Any
     ) -> Optional[_models.DownloadURL]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -278,32 +274,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.DownloadURL]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.DownloadURL]] = kwargs.pop("cls", None)
 
         request = build_download_by_billing_profile_request(
             billing_account_name=billing_account_name,
             billing_profile_name=billing_profile_name,
             api_version=api_version,
             template_url=self._download_by_billing_profile_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -320,15 +315,17 @@
             response_headers["OData-EntityId"] = self._deserialize("str", response.headers.get("OData-EntityId"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _download_by_billing_profile_initial.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.CostManagement/pricesheets/default/download"}  # type: ignore
+    _download_by_billing_profile_initial.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.CostManagement/pricesheets/default/download"
+    }
 
     @distributed_trace
     def begin_download_by_billing_profile(
         self, billing_account_name: str, billing_profile_name: str, **kwargs: Any
     ) -> LROPoller[_models.DownloadURL]:
         """Gets a URL to download the current month's pricesheet for a billing profile. The operation is
         supported for billing accounts with agreement type Microsoft Partner Agreement or Microsoft
@@ -352,23 +349,21 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.DownloadURL]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DownloadURL]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.DownloadURL] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._download_by_billing_profile_initial(  # type: ignore
+            raw_result = self._download_by_billing_profile_initial(
                 billing_account_name=billing_account_name,
                 billing_profile_name=billing_profile_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
@@ -378,24 +373,26 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DownloadURL", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_download_by_billing_profile.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.CostManagement/pricesheets/default/download"}  # type: ignore
+    begin_download_by_billing_profile.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.CostManagement/pricesheets/default/download"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_views_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_views_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.CostManagement/views")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -60,73 +56,73 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/views")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(view_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.CostManagement/views/{viewName}")
     path_format_arguments = {
         "viewName": _SERIALIZER.url("view_name", view_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(view_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.CostManagement/views/{viewName}")
     path_format_arguments = {
         "viewName": _SERIALIZER.url("view_name", view_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -135,75 +131,75 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(view_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.CostManagement/views/{viewName}")
     path_format_arguments = {
         "viewName": _SERIALIZER.url("view_name", view_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_scope_request(scope: str, view_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/views/{viewName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
         "viewName": _SERIALIZER.url("view_name", view_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_by_scope_request(scope: str, view_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/views/{viewName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
         "viewName": _SERIALIZER.url("view_name", view_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -212,25 +208,25 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_scope_request(scope: str, view_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/views/{viewName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
         "viewName": _SERIALIZER.url("view_name", view_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -256,26 +252,27 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.View"]:
         """Lists all views by tenant and object.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either View or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.View]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ViewListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ViewListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -287,15 +284,15 @@
                 request = build_list_request(
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -303,48 +300,52 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("ViewListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.CostManagement/views"}  # type: ignore
+    list.metadata = {"url": "/providers/Microsoft.CostManagement/views"}
 
     @distributed_trace
     def list_by_scope(self, scope: str, **kwargs: Any) -> Iterable["_models.View"]:
         """Lists all views at the given scope.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -363,18 +364,16 @@
         :return: An iterator like instance of either View or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.View]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ViewListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ViewListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -387,15 +386,15 @@
                     scope=scope,
                     api_version=api_version,
                     template_url=self.list_by_scope.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -403,48 +402,52 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("ViewListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views"}  # type: ignore
+    list_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views"}
 
     @distributed_trace
     def get(self, view_name: str, **kwargs: Any) -> _models.View:
         """Gets the view by view name.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param view_name: View name. Required.
         :type view_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: View or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.View
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -455,31 +458,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.View]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.View] = kwargs.pop("cls", None)
 
         request = build_get_request(
             view_name=view_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -488,24 +490,27 @@
         deserialized = self._deserialize("View", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    get.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}
 
     @overload
     def create_or_update(
         self, view_name: str, parameters: _models.View, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param view_name: View name. Required.
         :type view_name: str
         :param parameters: Parameters supplied to the CreateOrUpdate View operation. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.View
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -519,14 +524,17 @@
     def create_or_update(
         self, view_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param view_name: View name. Required.
         :type view_name: str
         :param parameters: Parameters supplied to the CreateOrUpdate View operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -538,17 +546,20 @@
 
     @distributed_trace
     def create_or_update(self, view_name: str, parameters: Union[_models.View, IO], **kwargs: Any) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param view_name: View name. Required.
         :type view_name: str
-        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Is either a model
+        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Is either a View
          type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.View or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: View or the result of cls(response)
@@ -562,24 +573,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.View]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.View] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "View")
 
         request = build_create_or_update_request(
             view_name=view_name,
             api_version=api_version,
@@ -587,18 +596,19 @@
             json=_json,
             content=_content,
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -607,24 +617,27 @@
         if response.status_code == 200:
             deserialized = self._deserialize("View", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("View", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    create_or_update.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    create_or_update.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}
 
     @distributed_trace
     def delete(self, view_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
         """The operation to delete a view.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param view_name: View name. Required.
         :type view_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -635,49 +648,51 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             view_name=view_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    delete.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}
 
     @distributed_trace
     def get_by_scope(self, scope: str, view_name: str, **kwargs: Any) -> _models.View:
         """Gets the view for the defined scope by view name.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -706,32 +721,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.View]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.View] = kwargs.pop("cls", None)
 
         request = build_get_by_scope_request(
             scope=scope,
             view_name=view_name,
             api_version=api_version,
             template_url=self.get_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -740,15 +754,15 @@
         deserialized = self._deserialize("View", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    get_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}
 
     @overload
     def create_or_update_by_scope(
         self,
         scope: str,
         view_name: str,
         parameters: _models.View,
@@ -756,14 +770,17 @@
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -795,14 +812,17 @@
     def create_or_update_by_scope(
         self, scope: str, view_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -834,14 +854,17 @@
     def create_or_update_by_scope(
         self, scope: str, view_name: str, parameters: Union[_models.View, IO], **kwargs: Any
     ) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -854,15 +877,15 @@
          'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
          External Billing Account scope and
          'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
          External Subscription scope. Required.
         :type scope: str
         :param view_name: View name. Required.
         :type view_name: str
-        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Is either a model
+        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Is either a View
          type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.View or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: View or the result of cls(response)
@@ -876,24 +899,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.View]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.View] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "View")
 
         request = build_create_or_update_by_scope_request(
             scope=scope,
             view_name=view_name,
@@ -902,18 +923,19 @@
             json=_json,
             content=_content,
             template_url=self.create_or_update_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -922,26 +944,29 @@
         if response.status_code == 200:
             deserialized = self._deserialize("View", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("View", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    create_or_update_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    create_or_update_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}
 
     @distributed_trace
     def delete_by_scope(  # pylint: disable=inconsistent-return-statements
         self, scope: str, view_name: str, **kwargs: Any
     ) -> None:
         """The operation to delete a view.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -970,38 +995,37 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_scope_request(
             scope=scope,
             view_name=view_name,
             api_version=api_version,
             template_url=self.delete_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    delete_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,40 +26,36 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_operation_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/generateDetailedCostReport")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -97,24 +93,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.GenerateDetailedCostReportOperationResult]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[Optional[_models.GenerateDetailedCostReportOperationResult]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "GenerateDetailedCostReportDefinition")
 
         request = build_create_operation_request(
             scope=scope,
             api_version=api_version,
@@ -122,18 +116,19 @@
             json=_json,
             content=_content,
             template_url=self._create_operation_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(
@@ -157,15 +152,17 @@
             response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _create_operation_initial.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateDetailedCostReport"}  # type: ignore
+    _create_operation_initial.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/generateDetailedCostReport"
+    }
 
     @overload
     def begin_create_operation(
         self,
         scope: str,
         parameters: _models.GenerateDetailedCostReportDefinition,
         *,
@@ -174,14 +171,17 @@
     ) -> LROPoller[_models.GenerateDetailedCostReportOperationResult]:
         """Generates the detailed cost report for provided date range, billing period(only enterprise
         customers) or Invoice ID asynchronously at a certain scope. Call returns a 202 with header
         Azure-Consumption-AsyncOperation providing a link to the operation created. A call on the
         operation will provide the status and if the operation is completed the blob file where
         generated detailed cost report is being stored.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
         :param parameters: Parameters supplied to the Create detailed cost report operation. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.GenerateDetailedCostReportDefinition
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
@@ -207,14 +207,17 @@
     ) -> LROPoller[_models.GenerateDetailedCostReportOperationResult]:
         """Generates the detailed cost report for provided date range, billing period(only enterprise
         customers) or Invoice ID asynchronously at a certain scope. Call returns a 202 with header
         Azure-Consumption-AsyncOperation providing a link to the operation created. A call on the
         operation will provide the status and if the operation is completed the blob file where
         generated detailed cost report is being stored.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
         :param parameters: Parameters supplied to the Create detailed cost report operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
@@ -240,19 +243,22 @@
     ) -> LROPoller[_models.GenerateDetailedCostReportOperationResult]:
         """Generates the detailed cost report for provided date range, billing period(only enterprise
         customers) or Invoice ID asynchronously at a certain scope. Call returns a 202 with header
         Azure-Consumption-AsyncOperation providing a link to the operation created. A call on the
         operation will provide the status and if the operation is completed the blob file where
         generated detailed cost report is being stored.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
         :param parameters: Parameters supplied to the Create detailed cost report operation. Is either
-         a model type or a IO type. Required.
+         a GenerateDetailedCostReportDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.GenerateDetailedCostReportDefinition or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -266,24 +272,22 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.GenerateDetailedCostReportOperationResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.GenerateDetailedCostReportOperationResult]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.GenerateDetailedCostReportOperationResult] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._create_operation_initial(  # type: ignore
+            raw_result = self._create_operation_initial(
                 scope=scope,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -294,24 +298,24 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("GenerateDetailedCostReportOperationResult", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_create_operation.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateDetailedCostReport"}  # type: ignore
+    begin_create_operation.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateDetailedCostReport"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_results_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_results_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar, Union, cast
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,40 +25,36 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(operation_id: str, scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/operationResults/{operationId}")
     path_format_arguments = {
         "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -95,32 +90,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.GenerateDetailedCostReportOperationResult]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.GenerateDetailedCostReportOperationResult]] = kwargs.pop("cls", None)
 
         request = build_get_request(
             operation_id=operation_id,
             scope=scope,
             api_version=api_version,
             template_url=self._get_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -131,15 +125,15 @@
             deserialized = self._deserialize("GenerateDetailedCostReportOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _get_initial.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationResults/{operationId}"}  # type: ignore
+    _get_initial.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationResults/{operationId}"}
 
     @distributed_trace
     def begin_get(
         self, operation_id: str, scope: str, **kwargs: Any
     ) -> LROPoller[_models.GenerateDetailedCostReportOperationResult]:
         """Gets the result of the specified operation. The link with this operationId is provided as a
         response header of the initial request.
@@ -162,23 +156,21 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.costmanagement.models.GenerateDetailedCostReportOperationResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.GenerateDetailedCostReportOperationResult]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.GenerateDetailedCostReportOperationResult] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._get_initial(  # type: ignore
+            raw_result = self._get_initial(
                 operation_id=operation_id,
                 scope=scope,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
@@ -188,22 +180,22 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("GenerateDetailedCostReportOperationResult", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))  # type: PollingMethod
+            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationResults/{operationId}"}  # type: ignore
+    begin_get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationResults/{operationId}"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_dimensions_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_dimensions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar, Union
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -49,24 +44,24 @@
     skiptoken: Optional[str] = None,
     top: Optional[int] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/dimensions")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     if expand is not None:
         _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
@@ -90,30 +85,30 @@
     skiptoken: Optional[str] = None,
     top: Optional[int] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/dimensions",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "externalCloudProviderType": _SERIALIZER.url(
             "external_cloud_provider_type", external_cloud_provider_type, "str"
         ),
         "externalCloudProviderId": _SERIALIZER.url("external_cloud_provider_id", external_cloud_provider_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     if expand is not None:
         _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
@@ -155,14 +150,17 @@
         expand: Optional[str] = None,
         skiptoken: Optional[str] = None,
         top: Optional[int] = None,
         **kwargs: Any
     ) -> Iterable["_models.Dimension"]:
         """Lists the dimensions by the defined scope.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with dimension operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -195,18 +193,16 @@
         :return: An iterator like instance of either Dimension or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.Dimension]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DimensionsListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.DimensionsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -223,15 +219,15 @@
                     top=top,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -239,57 +235,61 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DimensionsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200, 204]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/dimensions"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/dimensions"}
 
     @distributed_trace
     def by_external_cloud_provider_type(
         self,
         external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
         external_cloud_provider_id: str,
         filter: Optional[str] = None,
         expand: Optional[str] = None,
         skiptoken: Optional[str] = None,
         top: Optional[int] = None,
         **kwargs: Any
     ) -> Iterable["_models.Dimension"]:
         """Lists the dimensions by the external cloud provider type.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -315,18 +315,16 @@
         :return: An iterator like instance of either Dimension or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.costmanagement.models.Dimension]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DimensionsListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.DimensionsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -344,15 +342,15 @@
                     top=top,
                     api_version=api_version,
                     template_url=self.by_external_cloud_provider_type.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -360,36 +358,39 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DimensionsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    by_external_cloud_provider_type.metadata = {"url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/dimensions"}  # type: ignore
+    by_external_cloud_provider_type.metadata = {
+        "url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/dimensions"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_exports_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_exports_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,39 +24,35 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(scope: str, *, expand: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/exports")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if expand is not None:
         _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
 
     # Construct headers
@@ -65,25 +61,25 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, export_name: str, *, expand: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "exportName": _SERIALIZER.url("export_name", export_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if expand is not None:
         _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
 
     # Construct headers
@@ -92,26 +88,26 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(scope: str, export_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "exportName": _SERIALIZER.url("export_name", export_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -120,75 +116,75 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(scope: str, export_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "exportName": _SERIALIZER.url("export_name", export_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_execute_request(scope: str, export_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/run")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "exportName": _SERIALIZER.url("export_name", export_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_execution_history_request(scope: str, export_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/runHistory")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "exportName": _SERIALIZER.url("export_name", export_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -214,14 +210,17 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(self, scope: str, expand: Optional[str] = None, **kwargs: Any) -> _models.ExportListResult:
         """The operation to list all exports at the given scope.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -251,32 +250,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ExportListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ExportListResult] = kwargs.pop("cls", None)
 
         request = build_list_request(
             scope=scope,
             expand=expand,
             api_version=api_version,
             template_url=self.list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -285,20 +283,23 @@
         deserialized = self._deserialize("ExportListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports"}
 
     @distributed_trace
     def get(self, scope: str, export_name: str, expand: Optional[str] = None, **kwargs: Any) -> _models.Export:
         """The operation to get the export for the defined scope by export name.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -330,33 +331,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Export]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.Export] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             export_name=export_name,
             expand=expand,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -365,15 +365,15 @@
         deserialized = self._deserialize("Export", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}
 
     @overload
     def create_or_update(
         self,
         scope: str,
         export_name: str,
         parameters: _models.Export,
@@ -381,14 +381,17 @@
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.Export:
         """The operation to create or update a export. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -419,14 +422,17 @@
     def create_or_update(
         self, scope: str, export_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.Export:
         """The operation to create or update a export. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -457,14 +463,17 @@
     def create_or_update(
         self, scope: str, export_name: str, parameters: Union[_models.Export, IO], **kwargs: Any
     ) -> _models.Export:
         """The operation to create or update a export. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -477,15 +486,15 @@
          for invoiceSection scope, and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
          specific for partners. Required.
         :type scope: str
         :param export_name: Export Name. Required.
         :type export_name: str
         :param parameters: Parameters supplied to the CreateOrUpdate Export operation. Is either a
-         model type or a IO type. Required.
+         Export type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.Export or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Export or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.Export
@@ -498,24 +507,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Export]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.Export] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Export")
 
         request = build_create_or_update_request(
             scope=scope,
             export_name=export_name,
@@ -524,18 +531,19 @@
             json=_json,
             content=_content,
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -544,26 +552,29 @@
         if response.status_code == 200:
             deserialized = self._deserialize("Export", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Export", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    create_or_update.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}  # type: ignore
+    create_or_update.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}
 
     @distributed_trace
     def delete(  # pylint: disable=inconsistent-return-statements
         self, scope: str, export_name: str, **kwargs: Any
     ) -> None:
         """The operation to delete a export.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -591,52 +602,54 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             export_name=export_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}
 
     @distributed_trace
     def execute(  # pylint: disable=inconsistent-return-statements
         self, scope: str, export_name: str, **kwargs: Any
     ) -> None:
         """The operation to run an export.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -664,50 +677,52 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_execute_request(
             scope=scope,
             export_name=export_name,
             api_version=api_version,
             template_url=self.execute.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    execute.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/run"}  # type: ignore
+    execute.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/run"}
 
     @distributed_trace
     def get_execution_history(self, scope: str, export_name: str, **kwargs: Any) -> _models.ExportExecutionListResult:
         """The operation to get the run history of an export for the defined scope and export name.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -735,32 +750,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ExportExecutionListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ExportExecutionListResult] = kwargs.pop("cls", None)
 
         request = build_get_execution_history_request(
             scope=scope,
             export_name=export_name,
             api_version=api_version,
             template_url=self.get_execution_history.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -769,8 +783,10 @@
         deserialized = self._deserialize("ExportExecutionListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_execution_history.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/runHistory"}  # type: ignore
+    get_execution_history.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/runHistory"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_query_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_query_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,40 +24,36 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_usage_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/query")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -70,31 +66,31 @@
     external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
     external_cloud_provider_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/query",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "externalCloudProviderType": _SERIALIZER.url(
             "external_cloud_provider_type", external_cloud_provider_type, "str"
         ),
         "externalCloudProviderId": _SERIALIZER.url("external_cloud_provider_id", external_cloud_provider_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -124,14 +120,17 @@
 
     @overload
     def usage(
         self, scope: str, parameters: _models.QueryDefinition, *, content_type: str = "application/json", **kwargs: Any
     ) -> Optional[_models.QueryResult]:
         """Query the usage data for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with query and export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -158,14 +157,17 @@
 
     @overload
     def usage(
         self, scope: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> Optional[_models.QueryResult]:
         """Query the usage data for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with query and export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -192,14 +194,17 @@
 
     @distributed_trace
     def usage(
         self, scope: str, parameters: Union[_models.QueryDefinition, IO], **kwargs: Any
     ) -> Optional[_models.QueryResult]:
         """Query the usage data for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with query and export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -210,15 +215,15 @@
          for billingProfile scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
          for invoiceSection scope, and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
          specific for partners. Required.
         :type scope: str
         :param parameters: Parameters supplied to the CreateOrUpdate Query Config operation. Is either
-         a model type or a IO type. Required.
+         a QueryDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.QueryDefinition or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: QueryResult or None or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.QueryResult or None
@@ -231,24 +236,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.QueryResult]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[Optional[_models.QueryResult]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "QueryDefinition")
 
         request = build_usage_request(
             scope=scope,
             api_version=api_version,
@@ -256,18 +259,19 @@
             json=_json,
             content=_content,
             template_url=self.usage.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -278,28 +282,31 @@
             deserialized = self._deserialize("QueryResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    usage.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/query"}  # type: ignore
+    usage.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/query"}
 
     @overload
     def usage_by_external_cloud_provider_type(
         self,
         external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
         external_cloud_provider_id: str,
         parameters: _models.QueryDefinition,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.QueryResult:
         """Query the usage data for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -325,14 +332,17 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.QueryResult:
         """Query the usage data for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -356,26 +366,29 @@
         external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
         external_cloud_provider_id: str,
         parameters: Union[_models.QueryDefinition, IO],
         **kwargs: Any
     ) -> _models.QueryResult:
         """Query the usage data for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
          '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
          Required.
         :type external_cloud_provider_id: str
         :param parameters: Parameters supplied to the CreateOrUpdate Query Config operation. Is either
-         a model type or a IO type. Required.
+         a QueryDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.QueryDefinition or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: QueryResult or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.QueryResult
@@ -388,24 +401,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.QueryResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.QueryResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "QueryDefinition")
 
         request = build_usage_by_external_cloud_provider_type_request(
             external_cloud_provider_type=external_cloud_provider_type,
             external_cloud_provider_id=external_cloud_provider_id,
@@ -414,18 +425,19 @@
             json=_json,
             content=_content,
             template_url=self.usage_by_external_cloud_provider_type.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -434,8 +446,10 @@
         deserialized = self._deserialize("QueryResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    usage_by_external_cloud_provider_type.metadata = {"url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/query"}  # type: ignore
+    usage_by_external_cloud_provider_type.metadata = {
+        "url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/query"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_status_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_generate_detailed_cost_report_operation_status_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,40 +23,36 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(operation_id: str, scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/operationStatus/{operationId}")
     path_format_arguments = {
         "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -105,32 +100,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.GenerateDetailedCostReportOperationStatuses]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.GenerateDetailedCostReportOperationStatuses] = kwargs.pop("cls", None)
 
         request = build_get_request(
             operation_id=operation_id,
             scope=scope,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -139,8 +133,8 @@
         deserialized = self._deserialize("GenerateDetailedCostReportOperationStatuses", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationStatus/{operationId}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationStatus/{operationId}"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/operations/_forecast_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_forecast_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,40 +24,36 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_usage_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.CostManagement/forecast")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -74,31 +70,31 @@
     *,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))  # type: Literal["2022-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/forecast",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "externalCloudProviderType": _SERIALIZER.url(
             "external_cloud_provider_type", external_cloud_provider_type, "str"
         ),
         "externalCloudProviderId": _SERIALIZER.url("external_cloud_provider_id", external_cloud_provider_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -136,14 +132,17 @@
         filter: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Optional[_models.ForecastResult]:
         """Lists the forecast charges for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with forecast operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -181,14 +180,17 @@
         filter: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Optional[_models.ForecastResult]:
         """Lists the forecast charges for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with forecast operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -220,14 +222,17 @@
 
     @distributed_trace
     def usage(
         self, scope: str, parameters: Union[_models.ForecastDefinition, IO], filter: Optional[str] = None, **kwargs: Any
     ) -> Optional[_models.ForecastResult]:
         """Lists the forecast charges for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with forecast operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -238,15 +243,15 @@
          for billingProfile scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
          for invoiceSection scope, and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
          specific for partners. Required.
         :type scope: str
         :param parameters: Parameters supplied to the CreateOrUpdate Forecast Config operation. Is
-         either a model type or a IO type. Required.
+         either a ForecastDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.ForecastDefinition or IO
         :param filter: May be used to filter forecasts by properties/usageDate (Utc time),
          properties/chargeType or properties/grain. The filter supports 'eq', 'lt', 'gt', 'le', 'ge',
          and 'and'. It does not currently support 'ne', 'or', or 'not'. Default value is None.
         :type filter: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -263,24 +268,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.ForecastResult]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[Optional[_models.ForecastResult]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ForecastDefinition")
 
         request = build_usage_request(
             scope=scope,
             filter=filter,
@@ -289,18 +292,19 @@
             json=_json,
             content=_content,
             template_url=self.usage.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -311,29 +315,32 @@
             deserialized = self._deserialize("ForecastResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    usage.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/forecast"}  # type: ignore
+    usage.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/forecast"}
 
     @overload
     def external_cloud_provider_usage(
         self,
         external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
         external_cloud_provider_id: str,
         parameters: _models.ForecastDefinition,
         filter: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ForecastResult:
         """Lists the forecast charges for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -365,14 +372,17 @@
         filter: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ForecastResult:
         """Lists the forecast charges for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -402,26 +412,29 @@
         external_cloud_provider_id: str,
         parameters: Union[_models.ForecastDefinition, IO],
         filter: Optional[str] = None,
         **kwargs: Any
     ) -> _models.ForecastResult:
         """Lists the forecast charges for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
          '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
          Required.
         :type external_cloud_provider_id: str
         :param parameters: Parameters supplied to the CreateOrUpdate Forecast Config operation. Is
-         either a model type or a IO type. Required.
+         either a ForecastDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.ForecastDefinition or IO
         :param filter: May be used to filter forecasts by properties/usageDate (Utc time),
          properties/chargeType or properties/grain. The filter supports 'eq', 'lt', 'gt', 'le', 'ge',
          and 'and'. It does not currently support 'ne', 'or', or 'not'. Default value is None.
         :type filter: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -438,24 +451,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ForecastResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.ForecastResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ForecastDefinition")
 
         request = build_external_cloud_provider_usage_request(
             external_cloud_provider_type=external_cloud_provider_type,
             external_cloud_provider_id=external_cloud_provider_id,
@@ -465,18 +476,19 @@
             json=_json,
             content=_content,
             template_url=self.external_cloud_provider_usage.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -485,8 +497,10 @@
         deserialized = self._deserialize("ForecastResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    external_cloud_provider_usage.metadata = {"url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/forecast"}  # type: ignore
+    external_cloud_provider_usage.metadata = {
+        "url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/forecast"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/_patch.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/__init__.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,15 +29,17 @@
 from ._models_py3 import CostManagementProxyResource
 from ._models_py3 import CostManagementResource
 from ._models_py3 import Dimension
 from ._models_py3 import DimensionsListResult
 from ._models_py3 import DismissAlertPayload
 from ._models_py3 import DownloadURL
 from ._models_py3 import ErrorDetails
+from ._models_py3 import ErrorDetailsWithNestedDetails
 from ._models_py3 import ErrorResponse
+from ._models_py3 import ErrorResponseWithNestedDetails
 from ._models_py3 import Export
 from ._models_py3 import ExportDataset
 from ._models_py3 import ExportDatasetConfiguration
 from ._models_py3 import ExportDefinition
 from ._models_py3 import ExportDeliveryDestination
 from ._models_py3 import ExportDeliveryInfo
 from ._models_py3 import ExportExecutionListResult
@@ -145,15 +147,14 @@
 from ._cost_management_client_enums import OperationStatusType
 from ._cost_management_client_enums import OperatorType
 from ._cost_management_client_enums import Origin
 from ._cost_management_client_enums import PivotType
 from ._cost_management_client_enums import QueryColumnType
 from ._cost_management_client_enums import QueryOperatorType
 from ._cost_management_client_enums import RecurrenceType
-from ._cost_management_client_enums import ReportConfigColumnType
 from ._cost_management_client_enums import ReportConfigSortingType
 from ._cost_management_client_enums import ReportGranularityType
 from ._cost_management_client_enums import ReportOperationStatusType
 from ._cost_management_client_enums import ReportTimeframeType
 from ._cost_management_client_enums import ReportType
 from ._cost_management_client_enums import ReservationReportSchema
 from ._cost_management_client_enums import ScheduleFrequency
@@ -161,15 +162,15 @@
 from ._cost_management_client_enums import ScheduledActionStatus
 from ._cost_management_client_enums import Scope
 from ._cost_management_client_enums import StatusType
 from ._cost_management_client_enums import Term
 from ._cost_management_client_enums import TimeframeType
 from ._cost_management_client_enums import WeeksOfMonth
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Alert",
     "AlertPropertiesDefinition",
     "AlertPropertiesDetails",
     "AlertsResult",
@@ -192,15 +193,17 @@
     "CostManagementProxyResource",
     "CostManagementResource",
     "Dimension",
     "DimensionsListResult",
     "DismissAlertPayload",
     "DownloadURL",
     "ErrorDetails",
+    "ErrorDetailsWithNestedDetails",
     "ErrorResponse",
+    "ErrorResponseWithNestedDetails",
     "Export",
     "ExportDataset",
     "ExportDatasetConfiguration",
     "ExportDefinition",
     "ExportDeliveryDestination",
     "ExportDeliveryInfo",
     "ExportExecutionListResult",
@@ -307,15 +310,14 @@
     "OperationStatusType",
     "OperatorType",
     "Origin",
     "PivotType",
     "QueryColumnType",
     "QueryOperatorType",
     "RecurrenceType",
-    "ReportConfigColumnType",
     "ReportConfigSortingType",
     "ReportGranularityType",
     "ReportOperationStatusType",
     "ReportTimeframeType",
     "ReportType",
     "ReservationReportSchema",
     "ScheduleFrequency",
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/_models_py3.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/_models_py3.py`

 * *Files 2% similar despite different names*

```diff
@@ -49,15 +49,15 @@
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "e_tag": {"key": "eTag", "type": "str"},
     }
 
-    def __init__(self, *, e_tag: Optional[str] = None, **kwargs):
+    def __init__(self, *, e_tag: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
          used to determine whether the user is updating the latest version or not.
         :paramtype e_tag: str
         """
         super().__init__(**kwargs)
         self.id = None
@@ -140,16 +140,16 @@
         cost_entity_id: Optional[str] = None,
         status: Optional[Union[str, "_models.AlertStatus"]] = None,
         creation_time: Optional[str] = None,
         close_time: Optional[str] = None,
         modification_time: Optional[str] = None,
         status_modification_user_name: Optional[str] = None,
         status_modification_time: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
          used to determine whether the user is updating the latest version or not.
         :paramtype e_tag: str
         :keyword definition: defines the type of alert.
         :paramtype definition: ~azure.mgmt.costmanagement.models.AlertPropertiesDefinition
         :keyword description: Alert description.
@@ -213,16 +213,16 @@
 
     def __init__(
         self,
         *,
         type: Optional[Union[str, "_models.AlertType"]] = None,
         category: Optional[Union[str, "_models.AlertCategory"]] = None,
         criteria: Optional[Union[str, "_models.AlertCriteria"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword type: type of alert. Known values are: "Budget", "Invoice", "Credit", "Quota",
          "General", "xCloud", and "BudgetForecast".
         :paramtype type: str or ~azure.mgmt.costmanagement.models.AlertType
         :keyword category: Alert category. Known values are: "Cost", "Usage", "Billing", and "System".
         :paramtype category: str or ~azure.mgmt.costmanagement.models.AlertCategory
         :keyword criteria: Criteria that triggered alert. Known values are: "CostThresholdExceeded",
@@ -336,16 +336,16 @@
         overriding_alert: Optional[str] = None,
         department_name: Optional[str] = None,
         company_name: Optional[str] = None,
         enrollment_number: Optional[str] = None,
         enrollment_start_date: Optional[str] = None,
         enrollment_end_date: Optional[str] = None,
         invoicing_threshold: Optional[float] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword time_grain_type: Type of timegrain cadence. Known values are: "None", "Monthly",
          "Quarterly", "Annually", "BillingMonth", "BillingQuarter", and "BillingAnnual".
         :paramtype time_grain_type: str or ~azure.mgmt.costmanagement.models.AlertTimeGrainType
         :keyword period_start_date: datetime of periodStartDate.
         :paramtype period_start_date: str
         :keyword triggered_by: notificationId that triggered this alert.
@@ -432,15 +432,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Alert]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class AllSavingsBenefitDetails(_serialization.Model):
@@ -494,15 +494,15 @@
         "savings_percentage": {"key": "savingsPercentage", "type": "float"},
         "coverage_percentage": {"key": "coveragePercentage", "type": "float"},
         "commitment_amount": {"key": "commitmentAmount", "type": "float"},
         "average_utilization_percentage": {"key": "averageUtilizationPercentage", "type": "float"},
         "wastage_cost": {"key": "wastageCost", "type": "float"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.overage_cost = None
         self.benefit_cost = None
         self.total_cost = None
         self.savings_amount = None
         self.savings_percentage = None
@@ -529,15 +529,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[AllSavingsBenefitDetails]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class Resource(_serialization.Model):
@@ -563,15 +563,15 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
 
 
@@ -602,15 +602,15 @@
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "kind": {"key": "kind", "type": "str"},
     }
 
-    def __init__(self, *, kind: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs):
+    def __init__(self, *, kind: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs: Any) -> None:
         """
         :keyword kind: Reservation or SavingsPlan. Known values are: "IncludedQuantity", "Reservation",
          and "SavingsPlan".
         :paramtype kind: str or ~azure.mgmt.costmanagement.models.BenefitKind
         """
         super().__init__(**kwargs)
         self.kind = kind
@@ -651,16 +651,16 @@
     }
 
     def __init__(
         self,
         *,
         kind: Optional[Union[str, "_models.BenefitKind"]] = None,
         properties: Optional["_models.BenefitRecommendationProperties"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kind: Reservation or SavingsPlan. Known values are: "IncludedQuantity", "Reservation",
          and "SavingsPlan".
         :paramtype kind: str or ~azure.mgmt.costmanagement.models.BenefitKind
         :keyword properties: The properties of the benefit recommendations.
         :paramtype properties: ~azure.mgmt.costmanagement.models.BenefitRecommendationProperties
         """
@@ -754,16 +754,16 @@
         self,
         *,
         look_back_period: Optional[Union[str, "_models.LookBackPeriod"]] = None,
         usage: Optional["_models.RecommendationUsageDetails"] = None,
         term: Optional[Union[str, "_models.Term"]] = None,
         commitment_granularity: Optional[Union[str, "_models.Grain"]] = None,
         recommendation_details: Optional["_models.AllSavingsBenefitDetails"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword look_back_period: The number of days of usage evaluated for computing the
          recommendations. Known values are: "Last7Days", "Last30Days", and "Last60Days".
         :paramtype look_back_period: str or ~azure.mgmt.costmanagement.models.LookBackPeriod
         :keyword usage: On-demand charges between firstConsumptionDate and lastConsumptionDate that
          were used for computing benefit recommendations.
         :paramtype usage: ~azure.mgmt.costmanagement.models.RecommendationUsageDetails
@@ -785,15 +785,15 @@
         self.arm_sku_name = None
         self.term = term
         self.commitment_granularity = commitment_granularity
         self.currency_code = None
         self.cost_without_benefit = None
         self.recommendation_details = recommendation_details
         self.all_recommendation_details = None
-        self.scope = None  # type: Optional[str]
+        self.scope: Optional[str] = None
 
 
 class BenefitRecommendationsListResult(_serialization.Model):
     """Result of listing benefit recommendations.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
@@ -809,15 +809,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[BenefitRecommendationModel]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class BenefitUtilizationSummariesListResult(_serialization.Model):
@@ -837,15 +837,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[BenefitUtilizationSummary]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class BenefitUtilizationSummary(Resource):
@@ -888,18 +888,18 @@
     _subtype_map = {
         "kind": {
             "IncludedQuantity": "IncludedQuantityUtilizationSummary",
             "SavingsPlan": "SavingsPlanUtilizationSummary",
         }
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
-        self.kind = None  # type: Optional[str]
+        self.kind: Optional[str] = None
 
 
 class BenefitUtilizationSummaryProperties(_serialization.Model):
     """The properties of a benefit utilization summary.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
@@ -928,15 +928,15 @@
         "arm_sku_name": {"key": "armSkuName", "type": "str"},
         "benefit_id": {"key": "benefitId", "type": "str"},
         "benefit_order_id": {"key": "benefitOrderId", "type": "str"},
         "benefit_type": {"key": "benefitType", "type": "str"},
         "usage_date": {"key": "usageDate", "type": "iso-8601"},
     }
 
-    def __init__(self, *, benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs):
+    def __init__(self, *, benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs: Any) -> None:
         """
         :keyword benefit_type: The benefit type. Supported values: 'SavingsPlan'. Known values are:
          "IncludedQuantity", "Reservation", and "SavingsPlan".
         :paramtype benefit_type: str or ~azure.mgmt.costmanagement.models.BenefitKind
         """
         super().__init__(**kwargs)
         self.arm_sku_name = None
@@ -956,15 +956,15 @@
     """
 
     _attribute_map = {
         "blob_link": {"key": "blobLink", "type": "str"},
         "byte_count": {"key": "byteCount", "type": "int"},
     }
 
-    def __init__(self, *, blob_link: Optional[str] = None, byte_count: Optional[int] = None, **kwargs):
+    def __init__(self, *, blob_link: Optional[str] = None, byte_count: Optional[int] = None, **kwargs: Any) -> None:
         """
         :keyword blob_link: Link to the blob to download file.
         :paramtype blob_link: str
         :keyword byte_count: Bytes in the blob.
         :paramtype byte_count: int
         """
         super().__init__(**kwargs)
@@ -982,15 +982,15 @@
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, *, name: Optional[str] = None, type: Optional[str] = None, **kwargs):
+    def __init__(self, *, name: Optional[str] = None, type: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword name: The name of the resource for which availability needs to be checked.
         :paramtype name: str
         :keyword type: The resource type.
         :paramtype type: str
         """
         super().__init__(**kwargs)
@@ -1018,16 +1018,16 @@
 
     def __init__(
         self,
         *,
         name_available: Optional[bool] = None,
         reason: Optional[Union[str, "_models.CheckNameAvailabilityReason"]] = None,
         message: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name_available: Indicates if the resource name is available.
         :paramtype name_available: bool
         :keyword reason: The reason why the given name is not available. Known values are: "Invalid"
          and "AlreadyExists".
         :paramtype reason: str or ~azure.mgmt.costmanagement.models.CheckNameAvailabilityReason
         :keyword message: Detailed reason why the given name is available.
@@ -1083,16 +1083,16 @@
         self,
         *,
         delivery_info: "_models.ExportDeliveryInfo",
         definition: "_models.ExportDefinition",
         format: Optional[Union[str, "_models.FormatType"]] = None,
         run_history: Optional["_models.ExportExecutionListResult"] = None,
         partition_data: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword format: The format of the export being delivered. Currently only 'Csv' is supported.
          "Csv"
         :paramtype format: str or ~azure.mgmt.costmanagement.models.FormatType
         :keyword delivery_info: Has delivery information for the export. Required.
         :paramtype delivery_info: ~azure.mgmt.costmanagement.models.ExportDeliveryInfo
         :keyword definition: Has the definition for the export. Required.
@@ -1182,16 +1182,16 @@
         data_format: Optional[Union[str, "_models.CostDetailsDataFormat"]] = None,
         byte_count: Optional[int] = None,
         blob_count: Optional[int] = None,
         compress_data: Optional[bool] = None,
         blobs: Optional[List["_models.BlobInfo"]] = None,
         request_scope: Optional[str] = None,
         request_body: Optional["_models.GenerateCostDetailsReportRequestDefinition"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: The id of the long running operation.
         :paramtype id: str
         :keyword name: The name of the long running operation.
         :paramtype name: str
         :keyword type: The type of the long running operation.
         :paramtype type: str
@@ -1235,15 +1235,16 @@
         self.compress_data = compress_data
         self.blobs = blobs
         self.request_scope = request_scope
         self.request_body = request_body
 
 
 class CostDetailsTimePeriod(_serialization.Model):
-    """The start and end date for pulling data for the cost detailed report. API only allows data to be pulled for 1 month or less and no older than 13 months.
+    """The start and end date for pulling data for the cost detailed report. API only allows data to
+    be pulled for 1 month or less and no older than 13 months.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar start: The start date to pull data from. example format 2020-03-15. Required.
     :vartype start: str
     :ivar end: The end date to pull data to. example format 2020-03-15. Required.
     :vartype end: str
@@ -1255,15 +1256,15 @@
     }
 
     _attribute_map = {
         "start": {"key": "start", "type": "str"},
         "end": {"key": "end", "type": "str"},
     }
 
-    def __init__(self, *, start: str, end: str, **kwargs):
+    def __init__(self, *, start: str, end: str, **kwargs: Any) -> None:
         """
         :keyword start: The start date to pull data from. example format 2020-03-15. Required.
         :paramtype start: str
         :keyword end: The end date to pull data to. example format 2020-03-15. Required.
         :paramtype end: str
         """
         super().__init__(**kwargs)
@@ -1304,15 +1305,15 @@
         "name": {"key": "name", "type": "str"},
         "is_data_action": {"key": "isDataAction", "type": "bool"},
         "display": {"key": "display", "type": "OperationDisplay"},
         "origin": {"key": "origin", "type": "str"},
         "action_type": {"key": "actionType", "type": "str"},
     }
 
-    def __init__(self, *, display: Optional["_models.OperationDisplay"] = None, **kwargs):
+    def __init__(self, *, display: Optional["_models.OperationDisplay"] = None, **kwargs: Any) -> None:
         """
         :keyword display: Localized display information for this particular operation.
         :paramtype display: ~azure.mgmt.costmanagement.models.OperationDisplay
         """
         super().__init__(**kwargs)
         self.name = None
         self.is_data_action = None
@@ -1358,15 +1359,15 @@
         "is_data_action": {"key": "isDataAction", "type": "bool"},
         "display": {"key": "display", "type": "OperationDisplay"},
         "origin": {"key": "origin", "type": "str"},
         "action_type": {"key": "actionType", "type": "str"},
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, *, display: Optional["_models.OperationDisplay"] = None, **kwargs):
+    def __init__(self, *, display: Optional["_models.OperationDisplay"] = None, **kwargs: Any) -> None:
         """
         :keyword display: Localized display information for this particular operation.
         :paramtype display: ~azure.mgmt.costmanagement.models.OperationDisplay
         """
         super().__init__(display=display, **kwargs)
         self.id = None
 
@@ -1408,15 +1409,15 @@
         "type": {"key": "type", "type": "str"},
         "location": {"key": "location", "type": "str"},
         "sku": {"key": "sku", "type": "str"},
         "e_tag": {"key": "eTag", "type": "str"},
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
         self.location = None
         self.sku = None
@@ -1496,15 +1497,15 @@
         "total": {"key": "properties.total", "type": "int"},
         "category": {"key": "properties.category", "type": "str"},
         "usage_start": {"key": "properties.usageStart", "type": "iso-8601"},
         "usage_end": {"key": "properties.usageEnd", "type": "iso-8601"},
         "next_link": {"key": "properties.nextLink", "type": "str"},
     }
 
-    def __init__(self, *, data: Optional[List[str]] = None, **kwargs):
+    def __init__(self, *, data: Optional[List[str]] = None, **kwargs: Any) -> None:
         """
         :keyword data: Dimension data.
         :paramtype data: list[str]
         """
         super().__init__(**kwargs)
         self.description = None
         self.filter_enabled = None
@@ -1530,15 +1531,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Dimension]"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class DismissAlertPayload(_serialization.Model):  # pylint: disable=too-many-instance-attributes
     """The request payload to update an alert.
@@ -1592,16 +1593,16 @@
         cost_entity_id: Optional[str] = None,
         status: Optional[Union[str, "_models.AlertStatus"]] = None,
         creation_time: Optional[str] = None,
         close_time: Optional[str] = None,
         modification_time: Optional[str] = None,
         status_modification_user_name: Optional[str] = None,
         status_modification_time: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword definition: defines the type of alert.
         :paramtype definition: ~azure.mgmt.costmanagement.models.AlertPropertiesDefinition
         :keyword description: Alert description.
         :paramtype description: str
         :keyword source: Source of alert. Known values are: "Preset" and "User".
         :paramtype source: str or ~azure.mgmt.costmanagement.models.AlertSource
@@ -1658,15 +1659,17 @@
 
     _attribute_map = {
         "expiry_time": {"key": "expiryTime", "type": "iso-8601"},
         "valid_till": {"key": "validTill", "type": "iso-8601"},
         "download_url": {"key": "downloadUrl", "type": "str"},
     }
 
-    def __init__(self, *, valid_till: Optional[datetime.datetime] = None, download_url: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, valid_till: Optional[datetime.datetime] = None, download_url: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword valid_till: The time at which report URL becomes invalid/expires in UTC e.g.
          2020-12-08T05:55:59.4394737Z.
         :paramtype valid_till: ~datetime.datetime
         :keyword download_url: The URL to download the generated report.
         :paramtype download_url: str
         """
@@ -1693,50 +1696,116 @@
     }
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
 
 
+class ErrorDetailsWithNestedDetails(ErrorDetails):
+    """The details of the error.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar code: Error code.
+    :vartype code: str
+    :ivar message: Error message indicating why the operation failed.
+    :vartype message: str
+    :ivar details: The additional details of the error.
+    :vartype details: list[~azure.mgmt.costmanagement.models.ErrorDetailsWithNestedDetails]
+    """
+
+    _validation = {
+        "code": {"readonly": True},
+        "message": {"readonly": True},
+        "details": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "code": {"key": "code", "type": "str"},
+        "message": {"key": "message", "type": "str"},
+        "details": {"key": "details", "type": "[ErrorDetailsWithNestedDetails]"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.details = None
+
+
 class ErrorResponse(_serialization.Model):
-    """Error response indicates that the service is not able to process the incoming request. The reason is provided in the error message.
+    """Error response indicates that the service is not able to process the incoming request. The
+    reason is provided in the error message.
 
     Some Error responses:
 
 
     *
-      429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the "x-ms-ratelimit-microsoft.consumption-retry-after" header.
+      429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the
+    "x-ms-ratelimit-microsoft.consumption-retry-after" header.
 
     *
-      503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time specified in the "Retry-After" header.
+      503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time
+    specified in the "Retry-After" header.
 
-        :ivar error: The details of the error.
-        :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
+    :ivar error: The details of the error.
+    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
     """
 
     _attribute_map = {
         "error": {"key": "error", "type": "ErrorDetails"},
     }
 
-    def __init__(self, *, error: Optional["_models.ErrorDetails"] = None, **kwargs):
+    def __init__(self, *, error: Optional["_models.ErrorDetails"] = None, **kwargs: Any) -> None:
         """
         :keyword error: The details of the error.
         :paramtype error: ~azure.mgmt.costmanagement.models.ErrorDetails
         """
         super().__init__(**kwargs)
         self.error = error
 
 
+class ErrorResponseWithNestedDetails(_serialization.Model):
+    """Error response indicates that the service is not able to process the incoming request. The
+    reason is provided in the error message.
+
+    Some Error responses:
+
+
+    *
+      429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the
+    "x-ms-ratelimit-microsoft.consumption-retry-after" header.
+
+    *
+      503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time
+    specified in the "Retry-After" header.
+
+    :ivar error: The details of the error.
+    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetailsWithNestedDetails
+    """
+
+    _attribute_map = {
+        "error": {"key": "error", "type": "ErrorDetailsWithNestedDetails"},
+    }
+
+    def __init__(self, *, error: Optional["_models.ErrorDetailsWithNestedDetails"] = None, **kwargs: Any) -> None:
+        """
+        :keyword error: The details of the error.
+        :paramtype error: ~azure.mgmt.costmanagement.models.ErrorDetailsWithNestedDetails
+        """
+        super().__init__(**kwargs)
+        self.error = error
+
+
 class Export(CostManagementProxyResource):  # pylint: disable=too-many-instance-attributes
     """An export resource.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Resource Id.
     :vartype id: str
@@ -1794,16 +1863,16 @@
         e_tag: Optional[str] = None,
         format: Optional[Union[str, "_models.FormatType"]] = None,
         delivery_info: Optional["_models.ExportDeliveryInfo"] = None,
         definition: Optional["_models.ExportDefinition"] = None,
         run_history: Optional["_models.ExportExecutionListResult"] = None,
         partition_data: Optional[bool] = None,
         schedule: Optional["_models.ExportSchedule"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
          used to determine whether the user is updating the latest version or not.
         :paramtype e_tag: str
         :keyword format: The format of the export being delivered. Currently only 'Csv' is supported.
          "Csv"
         :paramtype format: str or ~azure.mgmt.costmanagement.models.FormatType
@@ -1846,42 +1915,43 @@
     }
 
     def __init__(
         self,
         *,
         granularity: Optional[Union[str, "_models.GranularityType"]] = None,
         configuration: Optional["_models.ExportDatasetConfiguration"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword granularity: The granularity of rows in the export. Currently only 'Daily' is
          supported. "Daily"
         :paramtype granularity: str or ~azure.mgmt.costmanagement.models.GranularityType
         :keyword configuration: The export dataset configuration.
         :paramtype configuration: ~azure.mgmt.costmanagement.models.ExportDatasetConfiguration
         """
         super().__init__(**kwargs)
         self.granularity = granularity
         self.configuration = configuration
 
 
 class ExportDatasetConfiguration(_serialization.Model):
-    """The export dataset configuration. Allows columns to be selected for the export. If not provided then the export will include all available columns.
+    """The export dataset configuration. Allows columns to be selected for the export. If not provided
+    then the export will include all available columns.
 
     :ivar columns: Array of column names to be included in the export. If not provided then the
      export will include all available columns. The available columns can vary by customer channel
      (see examples).
     :vartype columns: list[str]
     """
 
     _attribute_map = {
         "columns": {"key": "columns", "type": "[str]"},
     }
 
-    def __init__(self, *, columns: Optional[List[str]] = None, **kwargs):
+    def __init__(self, *, columns: Optional[List[str]] = None, **kwargs: Any) -> None:
         """
         :keyword columns: Array of column names to be included in the export. If not provided then the
          export will include all available columns. The available columns can vary by customer channel
          (see examples).
         :paramtype columns: list[str]
         """
         super().__init__(**kwargs)
@@ -1922,16 +1992,16 @@
     def __init__(
         self,
         *,
         type: Union[str, "_models.ExportType"],
         timeframe: Union[str, "_models.TimeframeType"],
         time_period: Optional["_models.ExportTimePeriod"] = None,
         data_set: Optional["_models.ExportDataset"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword type: The type of the export. Note that 'Usage' is equivalent to 'ActualCost' and is
          applicable to exports that do not yet provide data for charges or amortization for service
          reservations. Required. Known values are: "Usage", "ActualCost", and "AmortizedCost".
         :paramtype type: str or ~azure.mgmt.costmanagement.models.ExportType
         :keyword timeframe: The time frame for pulling data for the export. If custom, then a specific
          time period must be provided. Required. Known values are: "MonthToDate", "BillingMonthToDate",
@@ -1946,15 +2016,30 @@
         self.type = type
         self.timeframe = timeframe
         self.time_period = time_period
         self.data_set = data_set
 
 
 class ExportDeliveryDestination(_serialization.Model):
-    """This represents the blob storage account location where exports of costs will be delivered. There are two ways to configure the destination. The approach recommended for most customers is to specify the resourceId of the storage account. This requires a one-time registration of the account's subscription with the Microsoft.CostManagementExports resource provider in order to give Cost Management services access to the storage. When creating an export in the Azure portal this registration is performed automatically but API users may need to register the subscription explicitly (for more information see https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-supported-services ). Another way to configure the destination is available ONLY to Partners with a Microsoft Partner Agreement plan who are global admins of their billing account. These Partners, instead of specifying the resourceId of a storage account, can specify the storage account name along with a SAS token for the account. This allows exports of costs to a storage account in any tenant. The SAS token should be created for the blob service with Service/Container/Object resource types and with Read/Write/Delete/List/Add/Create permissions (for more information see https://docs.microsoft.com/en-us/azure/cost-management-billing/costs/export-cost-data-storage-account-sas-key ).
+    """This represents the blob storage account location where exports of costs will be delivered.
+    There are two ways to configure the destination. The approach recommended for most customers is
+    to specify the resourceId of the storage account. This requires a one-time registration of the
+    account's subscription with the Microsoft.CostManagementExports resource provider in order to
+    give Cost Management services access to the storage. When creating an export in the Azure
+    portal this registration is performed automatically but API users may need to register the
+    subscription explicitly (for more information see
+    https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-supported-services
+    ). Another way to configure the destination is available ONLY to Partners with a Microsoft
+    Partner Agreement plan who are global admins of their billing account. These Partners, instead
+    of specifying the resourceId of a storage account, can specify the storage account name along
+    with a SAS token for the account. This allows exports of costs to a storage account in any
+    tenant. The SAS token should be created for the blob service with Service/Container/Object
+    resource types and with Read/Write/Delete/List/Add/Create permissions (for more information see
+    https://docs.microsoft.com/en-us/azure/cost-management-billing/costs/export-cost-data-storage-account-sas-key
+    ).
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar resource_id: The resource id of the storage account where exports will be delivered. This
      is not required if a sasToken and storageAccount are specified.
     :vartype resource_id: str
     :ivar container: The name of the container where exports will be uploaded. If the container
@@ -1989,16 +2074,16 @@
         self,
         *,
         container: str,
         resource_id: Optional[str] = None,
         root_folder_path: Optional[str] = None,
         sas_token: Optional[str] = None,
         storage_account: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword resource_id: The resource id of the storage account where exports will be delivered.
          This is not required if a sasToken and storageAccount are specified.
         :paramtype resource_id: str
         :keyword container: The name of the container where exports will be uploaded. If the container
          does not exist it will be created. Required.
         :paramtype container: str
@@ -2035,15 +2120,15 @@
         "destination": {"required": True},
     }
 
     _attribute_map = {
         "destination": {"key": "destination", "type": "ExportDeliveryDestination"},
     }
 
-    def __init__(self, *, destination: "_models.ExportDeliveryDestination", **kwargs):
+    def __init__(self, *, destination: "_models.ExportDeliveryDestination", **kwargs: Any) -> None:
         """
         :keyword destination: Has destination for the export being delivered. Required.
         :paramtype destination: ~azure.mgmt.costmanagement.models.ExportDeliveryDestination
         """
         super().__init__(**kwargs)
         self.destination = destination
 
@@ -2061,15 +2146,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[ExportRun]"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class ExportListResult(_serialization.Model):
     """Result of listing exports. It contains a list of available exports in the scope provided.
@@ -2084,15 +2169,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Export]"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class ExportProperties(CommonExportProperties):
     """The properties of the export.
@@ -2142,16 +2227,16 @@
         *,
         delivery_info: "_models.ExportDeliveryInfo",
         definition: "_models.ExportDefinition",
         format: Optional[Union[str, "_models.FormatType"]] = None,
         run_history: Optional["_models.ExportExecutionListResult"] = None,
         partition_data: Optional[bool] = None,
         schedule: Optional["_models.ExportSchedule"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword format: The format of the export being delivered. Currently only 'Csv' is supported.
          "Csv"
         :paramtype format: str or ~azure.mgmt.costmanagement.models.FormatType
         :keyword delivery_info: Has delivery information for the export. Required.
         :paramtype delivery_info: ~azure.mgmt.costmanagement.models.ExportDeliveryInfo
         :keyword definition: Has the definition for the export. Required.
@@ -2192,15 +2277,17 @@
     }
 
     _attribute_map = {
         "from_property": {"key": "from", "type": "iso-8601"},
         "to": {"key": "to", "type": "iso-8601"},
     }
 
-    def __init__(self, *, from_property: datetime.datetime, to: Optional[datetime.datetime] = None, **kwargs):
+    def __init__(
+        self, *, from_property: datetime.datetime, to: Optional[datetime.datetime] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword from_property: The start date of recurrence. Required.
         :paramtype from_property: ~datetime.datetime
         :keyword to: The end date of recurrence.
         :paramtype to: ~datetime.datetime
         """
         super().__init__(**kwargs)
@@ -2275,16 +2362,16 @@
         submitted_by: Optional[str] = None,
         submitted_time: Optional[datetime.datetime] = None,
         processing_start_time: Optional[datetime.datetime] = None,
         processing_end_time: Optional[datetime.datetime] = None,
         file_name: Optional[str] = None,
         run_settings: Optional["_models.CommonExportProperties"] = None,
         error: Optional["_models.ErrorDetails"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
          used to determine whether the user is updating the latest version or not.
         :paramtype e_tag: str
         :keyword execution_type: The type of the export run. Known values are: "OnDemand" and
          "Scheduled".
         :paramtype execution_type: str or ~azure.mgmt.costmanagement.models.ExecutionType
@@ -2341,16 +2428,16 @@
 
     def __init__(
         self,
         *,
         status: Optional[Union[str, "_models.StatusType"]] = None,
         recurrence: Optional[Union[str, "_models.RecurrenceType"]] = None,
         recurrence_period: Optional["_models.ExportRecurrencePeriod"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: The status of the export's schedule. If 'Inactive', the export's schedule is
          paused. Known values are: "Active" and "Inactive".
         :paramtype status: str or ~azure.mgmt.costmanagement.models.StatusType
         :keyword recurrence: The schedule recurrence. Known values are: "Daily", "Weekly", "Monthly",
          and "Annually".
         :paramtype recurrence: str or ~azure.mgmt.costmanagement.models.RecurrenceType
@@ -2361,15 +2448,16 @@
         super().__init__(**kwargs)
         self.status = status
         self.recurrence = recurrence
         self.recurrence_period = recurrence_period
 
 
 class ExportTimePeriod(_serialization.Model):
-    """The date range for data in the export. This should only be specified with timeFrame set to 'Custom'. The maximum date range is 3 months.
+    """The date range for data in the export. This should only be specified with timeFrame set to
+    'Custom'. The maximum date range is 3 months.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar from_property: The start date for export data. Required.
     :vartype from_property: ~datetime.datetime
     :ivar to: The end date for export data. Required.
     :vartype to: ~datetime.datetime
@@ -2381,15 +2469,15 @@
     }
 
     _attribute_map = {
         "from_property": {"key": "from", "type": "iso-8601"},
         "to": {"key": "to", "type": "iso-8601"},
     }
 
-    def __init__(self, *, from_property: datetime.datetime, to: datetime.datetime, **kwargs):
+    def __init__(self, *, from_property: datetime.datetime, to: datetime.datetime, **kwargs: Any) -> None:
         """
         :keyword from_property: The start date for export data. Required.
         :paramtype from_property: ~datetime.datetime
         :keyword to: The end date for export data. Required.
         :paramtype to: ~datetime.datetime
         """
         super().__init__(**kwargs)
@@ -2404,15 +2492,15 @@
     :vartype file_formats: list[str or ~azure.mgmt.costmanagement.models.FileFormat]
     """
 
     _attribute_map = {
         "file_formats": {"key": "fileFormats", "type": "[str]"},
     }
 
-    def __init__(self, *, file_formats: Optional[List[Union[str, "_models.FileFormat"]]] = None, **kwargs):
+    def __init__(self, *, file_formats: Optional[List[Union[str, "_models.FileFormat"]]] = None, **kwargs: Any) -> None:
         """
         :keyword file_formats: Destination of the view data. Currently only CSV format is supported.
         :paramtype file_formats: list[str or ~azure.mgmt.costmanagement.models.FileFormat]
         """
         super().__init__(**kwargs)
         self.file_formats = file_formats
 
@@ -2436,16 +2524,16 @@
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "function": {"key": "function", "type": "str"},
     }
 
     def __init__(
-        self, *, name: Union[str, "_models.FunctionName"], function: Union[str, "_models.FunctionType"], **kwargs
-    ):
+        self, *, name: Union[str, "_models.FunctionName"], function: Union[str, "_models.FunctionType"], **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of the column to aggregate. Required. Known values are:
          "PreTaxCostUSD", "Cost", "CostUSD", and "PreTaxCost".
         :paramtype name: str or ~azure.mgmt.costmanagement.models.FunctionName
         :keyword function: The name of the aggregation function to use. Required. "Sum"
         :paramtype function: str or ~azure.mgmt.costmanagement.models.FunctionType
         """
@@ -2464,15 +2552,15 @@
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, *, name: Optional[str] = None, type: Optional[str] = None, **kwargs):
+    def __init__(self, *, name: Optional[str] = None, type: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword name: The name of column.
         :paramtype name: str
         :keyword type: The type of column.
         :paramtype type: str
         """
         super().__init__(**kwargs)
@@ -2483,15 +2571,15 @@
 class ForecastComparisonExpression(_serialization.Model):
     """The comparison expression to be used in the forecast.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar name: The name of the column to use in comparison. Required.
     :vartype name: str
-    :ivar operator: The operator to use for comparison. Required. "In"
+    :ivar operator: The operator to use for comparison. Required. Known values are: "In" and "In".
     :vartype operator: str or ~azure.mgmt.costmanagement.models.ForecastOperatorType
     :ivar values: Array of values to use for comparison. Required.
     :vartype values: list[str]
     """
 
     _validation = {
         "name": {"required": True},
@@ -2501,19 +2589,22 @@
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "operator": {"key": "operator", "type": "str"},
         "values": {"key": "values", "type": "[str]"},
     }
 
-    def __init__(self, *, name: str, operator: Union[str, "_models.ForecastOperatorType"], values: List[str], **kwargs):
+    def __init__(
+        self, *, name: str, operator: Union[str, "_models.ForecastOperatorType"], values: List[str], **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of the column to use in comparison. Required.
         :paramtype name: str
-        :keyword operator: The operator to use for comparison. Required. "In"
+        :keyword operator: The operator to use for comparison. Required. Known values are: "In" and
+         "In".
         :paramtype operator: str or ~azure.mgmt.costmanagement.models.ForecastOperatorType
         :keyword values: Array of values to use for comparison. Required.
         :paramtype values: list[str]
         """
         super().__init__(**kwargs)
         self.name = name
         self.operator = operator
@@ -2552,16 +2643,16 @@
     def __init__(
         self,
         *,
         aggregation: Dict[str, "_models.ForecastAggregation"],
         granularity: Optional[Union[str, "_models.GranularityType"]] = None,
         configuration: Optional["_models.ForecastDatasetConfiguration"] = None,
         filter: Optional["_models.ForecastFilter"] = None,  # pylint: disable=redefined-builtin
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword granularity: The granularity of rows in the forecast. "Daily"
         :paramtype granularity: str or ~azure.mgmt.costmanagement.models.GranularityType
         :keyword configuration: Has configuration information for the data in the export. The
          configuration will be ignored if aggregation and grouping are provided.
         :paramtype configuration: ~azure.mgmt.costmanagement.models.ForecastDatasetConfiguration
         :keyword aggregation: Dictionary of aggregation expression to use in the forecast. The key of
@@ -2586,15 +2677,15 @@
     :vartype columns: list[str]
     """
 
     _attribute_map = {
         "columns": {"key": "columns", "type": "[str]"},
     }
 
-    def __init__(self, *, columns: Optional[List[str]] = None, **kwargs):
+    def __init__(self, *, columns: Optional[List[str]] = None, **kwargs: Any) -> None:
         """
         :keyword columns: Array of column names to be included in the forecast. Any valid forecast
          column name is allowed. If not provided, then forecast includes all columns.
         :paramtype columns: list[str]
         """
         super().__init__(**kwargs)
         self.columns = columns
@@ -2641,16 +2732,16 @@
         *,
         type: Union[str, "_models.ForecastType"],
         timeframe: Union[str, "_models.ForecastTimeframe"],
         dataset: "_models.ForecastDataset",
         time_period: Optional["_models.ForecastTimePeriod"] = None,
         include_actual_cost: Optional[bool] = None,
         include_fresh_partial_cost: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword type: The type of the forecast. Required. Known values are: "Usage", "ActualCost", and
          "AmortizedCost".
         :paramtype type: str or ~azure.mgmt.costmanagement.models.ForecastType
         :keyword timeframe: The time frame for pulling data for the forecast. If custom, then a
          specific time period must be provided. Required. "Custom"
         :paramtype timeframe: str or ~azure.mgmt.costmanagement.models.ForecastTimeframe
@@ -2701,16 +2792,16 @@
     def __init__(
         self,
         *,
         and_property: Optional[List["_models.ForecastFilter"]] = None,
         or_property: Optional[List["_models.ForecastFilter"]] = None,
         dimensions: Optional["_models.ForecastComparisonExpression"] = None,
         tags: Optional["_models.ForecastComparisonExpression"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword and_property: The logical "AND" expression. Must have at least 2 items.
         :paramtype and_property: list[~azure.mgmt.costmanagement.models.ForecastFilter]
         :keyword or_property: The logical "OR" expression. Must have at least 2 items.
         :paramtype or_property: list[~azure.mgmt.costmanagement.models.ForecastFilter]
         :keyword dimensions: Has comparison expression for a dimension.
         :paramtype dimensions: ~azure.mgmt.costmanagement.models.ForecastComparisonExpression
@@ -2776,16 +2867,16 @@
 
     def __init__(
         self,
         *,
         next_link: Optional[str] = None,
         columns: Optional[List["_models.ForecastColumn"]] = None,
         rows: Optional[List[List[Any]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword next_link: The link (url) to the next page of results.
         :paramtype next_link: str
         :keyword columns: Array of columns.
         :paramtype columns: list[~azure.mgmt.costmanagement.models.ForecastColumn]
         :keyword rows: Array of rows.
         :paramtype rows: list[list[any]]
@@ -2813,59 +2904,67 @@
     }
 
     _attribute_map = {
         "from_property": {"key": "from", "type": "iso-8601"},
         "to": {"key": "to", "type": "iso-8601"},
     }
 
-    def __init__(self, *, from_property: datetime.datetime, to: datetime.datetime, **kwargs):
+    def __init__(self, *, from_property: datetime.datetime, to: datetime.datetime, **kwargs: Any) -> None:
         """
         :keyword from_property: The start date to pull data from. Required.
         :paramtype from_property: ~datetime.datetime
         :keyword to: The end date to pull data to. Required.
         :paramtype to: ~datetime.datetime
         """
         super().__init__(**kwargs)
         self.from_property = from_property
         self.to = to
 
 
 class GenerateCostDetailsReportErrorResponse(_serialization.Model):
-    """Error response indicates that the service is not able to process the incoming request. The reason is provided in the error message.
+    """Error response indicates that the service is not able to process the incoming request. The
+    reason is provided in the error message.
 
     Some Error responses:
 
 
     *
-      400 Bad Request - Invalid Request Payload. Request payload provided is not in a json format or had an invalid member not accepted in the request payload.
+      400 Bad Request - Invalid Request Payload. Request payload provided is not in a json format
+    or had an invalid member not accepted in the request payload.
 
     *
-      400 Bad Request - Invalid request payload:  can only have either timePeriod or invoiceId or billingPeriod. API only allows data to be pulled for either timePeriod or invoiceId or billingPeriod. Customer should provide only one of these parameters.
+      400 Bad Request - Invalid request payload:  can only have either timePeriod or invoiceId or
+    billingPeriod. API only allows data to be pulled for either timePeriod or invoiceId or
+    billingPeriod. Customer should provide only one of these parameters.
 
     *
-      400 Bad Request - Start date must be after . API only allows data to be pulled no older than 13 months from now.
+      400 Bad Request - Start date must be after . API only allows data to be pulled no older than
+    13 months from now.
 
     *
-      400 Bad Request - The maximum allowed date range is 1 months. API only allows data to be pulled for 1 month or less.
+      400 Bad Request - The maximum allowed date range is 1 months. API only allows data to be
+    pulled for 1 month or less.
 
     *
-      429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the "retry-after" header.
+      429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the
+    "retry-after" header.
 
     *
-      503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time specified in the "Retry-After" header.
+      503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time
+    specified in the "Retry-After" header.
 
-        :ivar error: The details of the error.
-        :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
+    :ivar error: The details of the error.
+    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
     """
 
     _attribute_map = {
         "error": {"key": "error", "type": "ErrorDetails"},
     }
 
-    def __init__(self, *, error: Optional["_models.ErrorDetails"] = None, **kwargs):
+    def __init__(self, *, error: Optional["_models.ErrorDetails"] = None, **kwargs: Any) -> None:
         """
         :keyword error: The details of the error.
         :paramtype error: ~azure.mgmt.costmanagement.models.ErrorDetails
         """
         super().__init__(**kwargs)
         self.error = error
 
@@ -2906,16 +3005,16 @@
     def __init__(
         self,
         *,
         metric: Optional[Union[str, "_models.CostDetailsMetricType"]] = None,
         time_period: Optional["_models.CostDetailsTimePeriod"] = None,
         billing_period: Optional[str] = None,
         invoice_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword metric: The type of the detailed report. By default ActualCost is provided. Known
          values are: "ActualCost" and "AmortizedCost".
         :paramtype metric: str or ~azure.mgmt.costmanagement.models.CostDetailsMetricType
         :keyword time_period: The specific date range of cost details requested for the report. This
          parameter cannot be used alongside either the invoiceId or billingPeriod parameters. If a
          timePeriod, invoiceId or billingPeriod parameter is not provided in the request body the API
@@ -2977,16 +3076,16 @@
         self,
         *,
         metric: Optional[Union[str, "_models.GenerateDetailedCostReportMetricType"]] = None,
         time_period: Optional["_models.GenerateDetailedCostReportTimePeriod"] = None,
         billing_period: Optional[str] = None,
         invoice_id: Optional[str] = None,
         customer_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword metric: The type of the detailed report. By default ActualCost is provided. Known
          values are: "ActualCost" and "AmortizedCost".
         :paramtype metric: str or
          ~azure.mgmt.costmanagement.models.GenerateDetailedCostReportMetricType
         :keyword time_period: Has time period for pulling data for the cost detailed report. Can only
          have one of either timePeriod or invoiceId or billingPeriod parameters. If none provided
@@ -3009,37 +3108,42 @@
         self.time_period = time_period
         self.billing_period = billing_period
         self.invoice_id = invoice_id
         self.customer_id = customer_id
 
 
 class GenerateDetailedCostReportErrorResponse(_serialization.Model):
-    """Error response indicates that the service is not able to process the incoming request. The reason is provided in the error message.
+    """Error response indicates that the service is not able to process the incoming request. The
+    reason is provided in the error message.
 
     Some Error responses:
 
 
     *
-      413 Request Entity Too Large - Request is throttled. The amount of data required to fulfill the request exceeds the maximum size permitted of 2Gb. Please utilize our Exports feature instead.
+      413 Request Entity Too Large - Request is throttled. The amount of data required to fulfill
+    the request exceeds the maximum size permitted of 2Gb. Please utilize our Exports feature
+    instead.
 
     *
-      429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the "x-ms-ratelimit-microsoft.consumption-retry-after" header.
+      429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the
+    "x-ms-ratelimit-microsoft.consumption-retry-after" header.
 
     *
-      503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time specified in the "Retry-After" header.
+      503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time
+    specified in the "Retry-After" header.
 
-        :ivar error: The details of the error.
-        :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
+    :ivar error: The details of the error.
+    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
     """
 
     _attribute_map = {
         "error": {"key": "error", "type": "ErrorDetails"},
     }
 
-    def __init__(self, *, error: Optional["_models.ErrorDetails"] = None, **kwargs):
+    def __init__(self, *, error: Optional["_models.ErrorDetails"] = None, **kwargs: Any) -> None:
         """
         :keyword error: The details of the error.
         :paramtype error: ~azure.mgmt.costmanagement.models.ErrorDetails
         """
         super().__init__(**kwargs)
         self.error = error
 
@@ -3082,16 +3186,16 @@
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         type: Optional[str] = None,
         valid_till: Optional[datetime.datetime] = None,
         download_url: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: The ARM resource id of the long running operation.
         :paramtype id: str
         :keyword name: The name of the long running operation.
         :paramtype name: str
         :keyword type: The type of the long running operation.
         :paramtype type: str
@@ -3117,14 +3221,18 @@
 
     :ivar id: The ID of the long running operation.
     :vartype id: str
     :ivar name: The name of the long running operation.
     :vartype name: str
     :ivar status: The status of the long running operation.
     :vartype status: ~azure.mgmt.costmanagement.models.Status
+    :ivar start_time: The startTime of the operation.
+    :vartype start_time: str
+    :ivar end_time: The endTime of the operation.
+    :vartype end_time: str
     :ivar type: The type of the long running operation.
     :vartype type: str
     :ivar error: The details of the error.
     :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
     :ivar expiry_time: The time at which report URL becomes invalid/expires in UTC e.g.
      2020-12-08T05:55:59.4394737Z.
     :vartype expiry_time: ~datetime.datetime
@@ -3139,54 +3247,64 @@
         "expiry_time": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "status": {"key": "status", "type": "Status"},
+        "start_time": {"key": "startTime", "type": "str"},
+        "end_time": {"key": "endTime", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "error": {"key": "error", "type": "ErrorDetails"},
         "expiry_time": {"key": "properties.expiryTime", "type": "iso-8601"},
         "valid_till": {"key": "properties.validTill", "type": "iso-8601"},
         "download_url": {"key": "properties.downloadUrl", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         status: Optional["_models.Status"] = None,
+        start_time: Optional[str] = None,
+        end_time: Optional[str] = None,
         type: Optional[str] = None,
         error: Optional["_models.ErrorDetails"] = None,
         valid_till: Optional[datetime.datetime] = None,
         download_url: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: The ID of the long running operation.
         :paramtype id: str
         :keyword name: The name of the long running operation.
         :paramtype name: str
         :keyword status: The status of the long running operation.
         :paramtype status: ~azure.mgmt.costmanagement.models.Status
+        :keyword start_time: The startTime of the operation.
+        :paramtype start_time: str
+        :keyword end_time: The endTime of the operation.
+        :paramtype end_time: str
         :keyword type: The type of the long running operation.
         :paramtype type: str
         :keyword error: The details of the error.
         :paramtype error: ~azure.mgmt.costmanagement.models.ErrorDetails
         :keyword valid_till: The time at which report URL becomes invalid/expires in UTC e.g.
          2020-12-08T05:55:59.4394737Z.
         :paramtype valid_till: ~datetime.datetime
         :keyword download_url: The URL to download the generated report.
         :paramtype download_url: str
         """
         super().__init__(**kwargs)
         self.id = id
         self.name = name
         self.status = status
+        self.start_time = start_time
+        self.end_time = end_time
         self.type = type
         self.error = error
         self.expiry_time = None
         self.valid_till = valid_till
         self.download_url = download_url
 
 
@@ -3207,15 +3325,15 @@
     }
 
     _attribute_map = {
         "start": {"key": "start", "type": "str"},
         "end": {"key": "end", "type": "str"},
     }
 
-    def __init__(self, *, start: str, end: str, **kwargs):
+    def __init__(self, *, start: str, end: str, **kwargs: Any) -> None:
         """
         :keyword start: The start date to pull data from. example format 2020-03-15. Required.
         :paramtype start: str
         :keyword end: The end date to pull data to. example format 2020-03-15. Required.
         :paramtype end: str
         """
         super().__init__(**kwargs)
@@ -3278,22 +3396,22 @@
         "benefit_id": {"key": "properties.benefitId", "type": "str"},
         "benefit_order_id": {"key": "properties.benefitOrderId", "type": "str"},
         "benefit_type": {"key": "properties.benefitType", "type": "str"},
         "usage_date": {"key": "properties.usageDate", "type": "iso-8601"},
         "utilization_percentage": {"key": "properties.utilizationPercentage", "type": "float"},
     }
 
-    def __init__(self, *, benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs):
+    def __init__(self, *, benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs: Any) -> None:
         """
         :keyword benefit_type: The benefit type. Supported values: 'SavingsPlan'. Known values are:
          "IncludedQuantity", "Reservation", and "SavingsPlan".
         :paramtype benefit_type: str or ~azure.mgmt.costmanagement.models.BenefitKind
         """
         super().__init__(**kwargs)
-        self.kind = "IncludedQuantity"  # type: str
+        self.kind: str = "IncludedQuantity"
         self.arm_sku_name = None
         self.benefit_id = None
         self.benefit_order_id = None
         self.benefit_type = benefit_type
         self.usage_date = None
         self.utilization_percentage = None
 
@@ -3332,15 +3450,15 @@
         "benefit_id": {"key": "benefitId", "type": "str"},
         "benefit_order_id": {"key": "benefitOrderId", "type": "str"},
         "benefit_type": {"key": "benefitType", "type": "str"},
         "usage_date": {"key": "usageDate", "type": "iso-8601"},
         "utilization_percentage": {"key": "utilizationPercentage", "type": "float"},
     }
 
-    def __init__(self, *, benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs):
+    def __init__(self, *, benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs: Any) -> None:
         """
         :keyword benefit_type: The benefit type. Supported values: 'SavingsPlan'. Known values are:
          "IncludedQuantity", "Reservation", and "SavingsPlan".
         :paramtype benefit_type: str or ~azure.mgmt.costmanagement.models.BenefitKind
         """
         super().__init__(benefit_type=benefit_type, **kwargs)
         self.utilization_percentage = None
@@ -3365,16 +3483,16 @@
 
     def __init__(
         self,
         *,
         type: Optional[Union[str, "_models.KpiType"]] = None,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         enabled: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword type: KPI type (Forecast, Budget). Known values are: "Forecast" and "Budget".
         :paramtype type: str or ~azure.mgmt.costmanagement.models.KpiType
         :keyword id: ID of resource related to metric (budget).
         :paramtype id: str
         :keyword enabled: show the KPI in the UI?.
         :paramtype enabled: bool
@@ -3420,16 +3538,16 @@
         self,
         *,
         to: List[str],
         subject: str,
         language: Optional[str] = None,
         message: Optional[str] = None,
         regional_format: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword to: Array of email addresses. Required.
         :paramtype to: list[str]
         :keyword language: Locale of the email.
         :paramtype language: str
         :keyword message: Optional message to be added in the email. Length is limited to 250
          characters.
@@ -3477,25 +3595,26 @@
     _attribute_map = {
         "provider": {"key": "provider", "type": "str"},
         "resource": {"key": "resource", "type": "str"},
         "operation": {"key": "operation", "type": "str"},
         "description": {"key": "description", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.provider = None
         self.resource = None
         self.operation = None
         self.description = None
 
 
 class OperationListResult(_serialization.Model):
-    """Result of listing cost management operations. It contains a list of operations and a URL link to get the next set of results.
+    """Result of listing cost management operations. It contains a list of operations and a URL link
+    to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of cost management operations supported by the Microsoft.CostManagement
      resource provider.
     :vartype value: list[~azure.mgmt.costmanagement.models.CostManagementOperation]
     :ivar next_link: URL to get the next set of operation list results if there are any.
@@ -3508,15 +3627,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[CostManagementOperation]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class OperationStatus(_serialization.Model):
@@ -3542,16 +3661,16 @@
 
     def __init__(
         self,
         *,
         status: Optional[Union[str, "_models.OperationStatusType"]] = None,
         report_url: Optional[Union[str, "_models.ReservationReportSchema"]] = None,
         valid_until: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: The status of the long running operation. Known values are: "Running",
          "Completed", and "Failed".
         :paramtype status: str or ~azure.mgmt.costmanagement.models.OperationStatusType
         :keyword report_url: The CSV file from the reportUrl blob link consists of reservation usage
          data with the following schema at daily granularity. Known values are:
          "InstanceFlexibilityGroup", "InstanceFlexibilityRatio", "InstanceId", "Kind", "ReservationId",
@@ -3577,28 +3696,31 @@
     """
 
     _attribute_map = {
         "type": {"key": "type", "type": "str"},
         "name": {"key": "name", "type": "str"},
     }
 
-    def __init__(self, *, type: Optional[Union[str, "_models.PivotType"]] = None, name: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, type: Optional[Union[str, "_models.PivotType"]] = None, name: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword type: Data type to show in view. Known values are: "Dimension" and "TagKey".
         :paramtype type: str or ~azure.mgmt.costmanagement.models.PivotType
         :keyword name: Data field to show in view.
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.type = type
         self.name = name
 
 
 class ProxyResource(Resource):
-    """The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a location.
+    """The resource model definition for a Azure Resource Manager proxy resource. It will not have
+    tags and a location.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Fully qualified resource ID for the resource. Ex -
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
@@ -3616,15 +3738,15 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
 
 
 class QueryAggregation(_serialization.Model):
     """The aggregation expression to be used in the query.
 
@@ -3642,15 +3764,15 @@
     }
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "function": {"key": "function", "type": "str"},
     }
 
-    def __init__(self, *, name: str, function: Union[str, "_models.FunctionType"], **kwargs):
+    def __init__(self, *, name: str, function: Union[str, "_models.FunctionType"], **kwargs: Any) -> None:
         """
         :keyword name: The name of the column to aggregate. Required.
         :paramtype name: str
         :keyword function: The name of the aggregation function to use. Required. "Sum"
         :paramtype function: str or ~azure.mgmt.costmanagement.models.FunctionType
         """
         super().__init__(**kwargs)
@@ -3668,15 +3790,15 @@
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, *, name: Optional[str] = None, type: Optional[str] = None, **kwargs):
+    def __init__(self, *, name: Optional[str] = None, type: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword name: The name of column.
         :paramtype name: str
         :keyword type: The type of column.
         :paramtype type: str
         """
         super().__init__(**kwargs)
@@ -3687,15 +3809,15 @@
 class QueryComparisonExpression(_serialization.Model):
     """The comparison expression to be used in the query.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar name: The name of the column to use in comparison. Required.
     :vartype name: str
-    :ivar operator: The operator to use for comparison. Required. "In"
+    :ivar operator: The operator to use for comparison. Required. Known values are: "In" and "In".
     :vartype operator: str or ~azure.mgmt.costmanagement.models.QueryOperatorType
     :ivar values: Array of values to use for comparison. Required.
     :vartype values: list[str]
     """
 
     _validation = {
         "name": {"required": True},
@@ -3705,19 +3827,22 @@
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "operator": {"key": "operator", "type": "str"},
         "values": {"key": "values", "type": "[str]"},
     }
 
-    def __init__(self, *, name: str, operator: Union[str, "_models.QueryOperatorType"], values: List[str], **kwargs):
+    def __init__(
+        self, *, name: str, operator: Union[str, "_models.QueryOperatorType"], values: List[str], **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of the column to use in comparison. Required.
         :paramtype name: str
-        :keyword operator: The operator to use for comparison. Required. "In"
+        :keyword operator: The operator to use for comparison. Required. Known values are: "In" and
+         "In".
         :paramtype operator: str or ~azure.mgmt.costmanagement.models.QueryOperatorType
         :keyword values: Array of values to use for comparison. Required.
         :paramtype values: list[str]
         """
         super().__init__(**kwargs)
         self.name = name
         self.operator = operator
@@ -3760,16 +3885,16 @@
         self,
         *,
         granularity: Optional[Union[str, "_models.GranularityType"]] = None,
         configuration: Optional["_models.QueryDatasetConfiguration"] = None,
         aggregation: Optional[Dict[str, "_models.QueryAggregation"]] = None,
         grouping: Optional[List["_models.QueryGrouping"]] = None,
         filter: Optional["_models.QueryFilter"] = None,  # pylint: disable=redefined-builtin
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword granularity: The granularity of rows in the query. "Daily"
         :paramtype granularity: str or ~azure.mgmt.costmanagement.models.GranularityType
         :keyword configuration: Has configuration information for the data in the export. The
          configuration will be ignored if aggregation and grouping are provided.
         :paramtype configuration: ~azure.mgmt.costmanagement.models.QueryDatasetConfiguration
         :keyword aggregation: Dictionary of aggregation expression to use in the query. The key of each
@@ -3799,15 +3924,15 @@
     :vartype columns: list[str]
     """
 
     _attribute_map = {
         "columns": {"key": "columns", "type": "[str]"},
     }
 
-    def __init__(self, *, columns: Optional[List[str]] = None, **kwargs):
+    def __init__(self, *, columns: Optional[List[str]] = None, **kwargs: Any) -> None:
         """
         :keyword columns: Array of column names to be included in the query. Any valid query column
          name is allowed. If not provided, then query includes all columns.
         :paramtype columns: list[str]
         """
         super().__init__(**kwargs)
         self.columns = columns
@@ -3847,16 +3972,16 @@
     def __init__(
         self,
         *,
         type: Union[str, "_models.ExportType"],
         timeframe: Union[str, "_models.TimeframeType"],
         dataset: "_models.QueryDataset",
         time_period: Optional["_models.QueryTimePeriod"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword type: The type of the query. Required. Known values are: "Usage", "ActualCost", and
          "AmortizedCost".
         :paramtype type: str or ~azure.mgmt.costmanagement.models.ExportType
         :keyword timeframe: The time frame for pulling data for the query. If custom, then a specific
          time period must be provided. Required. Known values are: "MonthToDate", "BillingMonthToDate",
          "TheLastMonth", "TheLastBillingMonth", "WeekToDate", and "Custom".
@@ -3901,16 +4026,16 @@
     def __init__(
         self,
         *,
         and_property: Optional[List["_models.QueryFilter"]] = None,
         or_property: Optional[List["_models.QueryFilter"]] = None,
         dimensions: Optional["_models.QueryComparisonExpression"] = None,
         tags: Optional["_models.QueryComparisonExpression"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword and_property: The logical "AND" expression. Must have at least 2 items.
         :paramtype and_property: list[~azure.mgmt.costmanagement.models.QueryFilter]
         :keyword or_property: The logical "OR" expression. Must have at least 2 items.
         :paramtype or_property: list[~azure.mgmt.costmanagement.models.QueryFilter]
         :keyword dimensions: Has comparison expression for a dimension.
         :paramtype dimensions: ~azure.mgmt.costmanagement.models.QueryComparisonExpression
@@ -3925,15 +4050,16 @@
 
 
 class QueryGrouping(_serialization.Model):
     """The group by expression to be used in the query.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar type: Has type of the column to group. Required. Known values are: "Tag" and "Dimension".
+    :ivar type: Has type of the column to group. Required. Known values are: "TagKey" and
+     "Dimension".
     :vartype type: str or ~azure.mgmt.costmanagement.models.QueryColumnType
     :ivar name: The name of the column to group. Required.
     :vartype name: str
     """
 
     _validation = {
         "type": {"required": True},
@@ -3941,17 +4067,17 @@
     }
 
     _attribute_map = {
         "type": {"key": "type", "type": "str"},
         "name": {"key": "name", "type": "str"},
     }
 
-    def __init__(self, *, type: Union[str, "_models.QueryColumnType"], name: str, **kwargs):
+    def __init__(self, *, type: Union[str, "_models.QueryColumnType"], name: str, **kwargs: Any) -> None:
         """
-        :keyword type: Has type of the column to group. Required. Known values are: "Tag" and
+        :keyword type: Has type of the column to group. Required. Known values are: "TagKey" and
          "Dimension".
         :paramtype type: str or ~azure.mgmt.costmanagement.models.QueryColumnType
         :keyword name: The name of the column to group. Required.
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.type = type
@@ -4010,16 +4136,16 @@
 
     def __init__(
         self,
         *,
         next_link: Optional[str] = None,
         columns: Optional[List["_models.QueryColumn"]] = None,
         rows: Optional[List[List[Any]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword next_link: The link (url) to the next page of results.
         :paramtype next_link: str
         :keyword columns: Array of columns.
         :paramtype columns: list[~azure.mgmt.costmanagement.models.QueryColumn]
         :keyword rows: Array of rows.
         :paramtype rows: list[list[any]]
@@ -4047,28 +4173,29 @@
     }
 
     _attribute_map = {
         "from_property": {"key": "from", "type": "iso-8601"},
         "to": {"key": "to", "type": "iso-8601"},
     }
 
-    def __init__(self, *, from_property: datetime.datetime, to: datetime.datetime, **kwargs):
+    def __init__(self, *, from_property: datetime.datetime, to: datetime.datetime, **kwargs: Any) -> None:
         """
         :keyword from_property: The start date to pull data from. Required.
         :paramtype from_property: ~datetime.datetime
         :keyword to: The end date to pull data to. Required.
         :paramtype to: ~datetime.datetime
         """
         super().__init__(**kwargs)
         self.from_property = from_property
         self.to = to
 
 
 class RecommendationUsageDetails(_serialization.Model):
-    """On-demand charges between firstConsumptionDate and lastConsumptionDate that were used for computing benefit recommendations.
+    """On-demand charges between firstConsumptionDate and lastConsumptionDate that were used for
+    computing benefit recommendations.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar usage_grain: The grain of the usage. Supported values: 'Hourly'. Known values are:
      "Hourly", "Daily", and "Monthly".
     :vartype usage_grain: str or ~azure.mgmt.costmanagement.models.Grain
     :ivar charges: On-demand charges for each hour between firstConsumptionDate and
@@ -4081,15 +4208,15 @@
     }
 
     _attribute_map = {
         "usage_grain": {"key": "usageGrain", "type": "str"},
         "charges": {"key": "charges", "type": "[float]"},
     }
 
-    def __init__(self, *, usage_grain: Optional[Union[str, "_models.Grain"]] = None, **kwargs):
+    def __init__(self, *, usage_grain: Optional[Union[str, "_models.Grain"]] = None, **kwargs: Any) -> None:
         """
         :keyword usage_grain: The grain of the usage. Supported values: 'Hourly'. Known values are:
          "Hourly", "Daily", and "Monthly".
         :paramtype usage_grain: str or ~azure.mgmt.costmanagement.models.Grain
         """
         super().__init__(**kwargs)
         self.usage_grain = usage_grain
@@ -4113,15 +4240,15 @@
     }
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "function": {"key": "function", "type": "str"},
     }
 
-    def __init__(self, *, name: str, function: Union[str, "_models.FunctionType"], **kwargs):
+    def __init__(self, *, name: str, function: Union[str, "_models.FunctionType"], **kwargs: Any) -> None:
         """
         :keyword name: The name of the column to aggregate. Required.
         :paramtype name: str
         :keyword function: The name of the aggregation function to use. Required. "Sum"
         :paramtype function: str or ~azure.mgmt.costmanagement.models.FunctionType
         """
         super().__init__(**kwargs)
@@ -4132,16 +4259,16 @@
 class ReportConfigComparisonExpression(_serialization.Model):
     """The comparison expression to be used in the report.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar name: The name of the column to use in comparison. Required.
     :vartype name: str
-    :ivar operator: The operator to use for comparison. Required. Known values are: "In" and
-     "Contains".
+    :ivar operator: The operator to use for comparison. Required. Known values are: "In",
+     "Contains", and "In".
     :vartype operator: str or ~azure.mgmt.costmanagement.models.OperatorType
     :ivar values: Array of values to use for comparison. Required.
     :vartype values: list[str]
     """
 
     _validation = {
         "name": {"required": True},
@@ -4151,20 +4278,22 @@
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "operator": {"key": "operator", "type": "str"},
         "values": {"key": "values", "type": "[str]"},
     }
 
-    def __init__(self, *, name: str, operator: Union[str, "_models.OperatorType"], values: List[str], **kwargs):
+    def __init__(
+        self, *, name: str, operator: Union[str, "_models.OperatorType"], values: List[str], **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of the column to use in comparison. Required.
         :paramtype name: str
-        :keyword operator: The operator to use for comparison. Required. Known values are: "In" and
-         "Contains".
+        :keyword operator: The operator to use for comparison. Required. Known values are: "In",
+         "Contains", and "In".
         :paramtype operator: str or ~azure.mgmt.costmanagement.models.OperatorType
         :keyword values: Array of values to use for comparison. Required.
         :paramtype values: list[str]
         """
         super().__init__(**kwargs)
         self.name = name
         self.operator = operator
@@ -4211,16 +4340,16 @@
         *,
         granularity: Optional[Union[str, "_models.ReportGranularityType"]] = None,
         configuration: Optional["_models.ReportConfigDatasetConfiguration"] = None,
         aggregation: Optional[Dict[str, "_models.ReportConfigAggregation"]] = None,
         grouping: Optional[List["_models.ReportConfigGrouping"]] = None,
         sorting: Optional[List["_models.ReportConfigSorting"]] = None,
         filter: Optional["_models.ReportConfigFilter"] = None,  # pylint: disable=redefined-builtin
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword granularity: The granularity of rows in the report. Known values are: "Daily" and
          "Monthly".
         :paramtype granularity: str or ~azure.mgmt.costmanagement.models.ReportGranularityType
         :keyword configuration: Has configuration information for the data in the report. The
          configuration will be ignored if aggregation and grouping are provided.
         :paramtype configuration: ~azure.mgmt.costmanagement.models.ReportConfigDatasetConfiguration
@@ -4253,15 +4382,15 @@
     :vartype columns: list[str]
     """
 
     _attribute_map = {
         "columns": {"key": "columns", "type": "[str]"},
     }
 
-    def __init__(self, *, columns: Optional[List[str]] = None, **kwargs):
+    def __init__(self, *, columns: Optional[List[str]] = None, **kwargs: Any) -> None:
         """
         :keyword columns: Array of column names to be included in the report. Any valid report column
          name is allowed. If not provided, then report includes all columns.
         :paramtype columns: list[str]
         """
         super().__init__(**kwargs)
         self.columns = columns
@@ -4295,16 +4424,16 @@
     def __init__(
         self,
         *,
         and_property: Optional[List["_models.ReportConfigFilter"]] = None,
         or_property: Optional[List["_models.ReportConfigFilter"]] = None,
         dimensions: Optional["_models.ReportConfigComparisonExpression"] = None,
         tags: Optional["_models.ReportConfigComparisonExpression"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword and_property: The logical "AND" expression. Must have at least 2 items.
         :paramtype and_property: list[~azure.mgmt.costmanagement.models.ReportConfigFilter]
         :keyword or_property: The logical "OR" expression. Must have at least 2 items.
         :paramtype or_property: list[~azure.mgmt.costmanagement.models.ReportConfigFilter]
         :keyword dimensions: Has comparison expression for a dimension.
         :paramtype dimensions: ~azure.mgmt.costmanagement.models.ReportConfigComparisonExpression
@@ -4319,16 +4448,17 @@
 
 
 class ReportConfigGrouping(_serialization.Model):
     """The group by expression to be used in the report.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar type: Has type of the column to group. Required. Known values are: "Tag" and "Dimension".
-    :vartype type: str or ~azure.mgmt.costmanagement.models.ReportConfigColumnType
+    :ivar type: Has type of the column to group. Required. Known values are: "TagKey" and
+     "Dimension".
+    :vartype type: str or ~azure.mgmt.costmanagement.models.QueryColumnType
     :ivar name: The name of the column to group. This version supports subscription lowest possible
      grain. Required.
     :vartype name: str
     """
 
     _validation = {
         "type": {"required": True},
@@ -4336,19 +4466,19 @@
     }
 
     _attribute_map = {
         "type": {"key": "type", "type": "str"},
         "name": {"key": "name", "type": "str"},
     }
 
-    def __init__(self, *, type: Union[str, "_models.ReportConfigColumnType"], name: str, **kwargs):
+    def __init__(self, *, type: Union[str, "_models.QueryColumnType"], name: str, **kwargs: Any) -> None:
         """
-        :keyword type: Has type of the column to group. Required. Known values are: "Tag" and
+        :keyword type: Has type of the column to group. Required. Known values are: "TagKey" and
          "Dimension".
-        :paramtype type: str or ~azure.mgmt.costmanagement.models.ReportConfigColumnType
+        :paramtype type: str or ~azure.mgmt.costmanagement.models.QueryColumnType
         :keyword name: The name of the column to group. This version supports subscription lowest
          possible grain. Required.
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.type = type
         self.name = name
@@ -4371,16 +4501,16 @@
 
     _attribute_map = {
         "direction": {"key": "direction", "type": "str"},
         "name": {"key": "name", "type": "str"},
     }
 
     def __init__(
-        self, *, name: str, direction: Optional[Union[str, "_models.ReportConfigSortingType"]] = None, **kwargs
-    ):
+        self, *, name: str, direction: Optional[Union[str, "_models.ReportConfigSortingType"]] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword direction: Direction of sort. Known values are: "Ascending" and "Descending".
         :paramtype direction: str or ~azure.mgmt.costmanagement.models.ReportConfigSortingType
         :keyword name: The name of the column to sort. Required.
         :paramtype name: str
         """
         super().__init__(**kwargs)
@@ -4405,15 +4535,15 @@
     }
 
     _attribute_map = {
         "from_property": {"key": "from", "type": "iso-8601"},
         "to": {"key": "to", "type": "iso-8601"},
     }
 
-    def __init__(self, *, from_property: datetime.datetime, to: datetime.datetime, **kwargs):
+    def __init__(self, *, from_property: datetime.datetime, to: datetime.datetime, **kwargs: Any) -> None:
         """
         :keyword from_property: The start date to pull data from. Required.
         :paramtype from_property: ~datetime.datetime
         :keyword to: The end date to pull data to. Required.
         :paramtype to: ~datetime.datetime
         """
         super().__init__(**kwargs)
@@ -4501,22 +4631,22 @@
         "benefit_type": {"key": "properties.benefitType", "type": "str"},
         "usage_date": {"key": "properties.usageDate", "type": "iso-8601"},
         "avg_utilization_percentage": {"key": "properties.avgUtilizationPercentage", "type": "float"},
         "min_utilization_percentage": {"key": "properties.minUtilizationPercentage", "type": "float"},
         "max_utilization_percentage": {"key": "properties.maxUtilizationPercentage", "type": "float"},
     }
 
-    def __init__(self, *, benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs):
+    def __init__(self, *, benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs: Any) -> None:
         """
         :keyword benefit_type: The benefit type. Supported values: 'SavingsPlan'. Known values are:
          "IncludedQuantity", "Reservation", and "SavingsPlan".
         :paramtype benefit_type: str or ~azure.mgmt.costmanagement.models.BenefitKind
         """
         super().__init__(**kwargs)
-        self.kind = "SavingsPlan"  # type: str
+        self.kind: str = "SavingsPlan"
         self.arm_sku_name = None
         self.benefit_id = None
         self.benefit_order_id = None
         self.benefit_type = benefit_type
         self.usage_date = None
         self.avg_utilization_percentage = None
         self.min_utilization_percentage = None
@@ -4582,15 +4712,15 @@
         "benefit_type": {"key": "benefitType", "type": "str"},
         "usage_date": {"key": "usageDate", "type": "iso-8601"},
         "avg_utilization_percentage": {"key": "avgUtilizationPercentage", "type": "float"},
         "min_utilization_percentage": {"key": "minUtilizationPercentage", "type": "float"},
         "max_utilization_percentage": {"key": "maxUtilizationPercentage", "type": "float"},
     }
 
-    def __init__(self, *, benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs):
+    def __init__(self, *, benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None, **kwargs: Any) -> None:
         """
         :keyword benefit_type: The benefit type. Supported values: 'SavingsPlan'. Known values are:
          "IncludedQuantity", "Reservation", and "SavingsPlan".
         :paramtype benefit_type: str or ~azure.mgmt.costmanagement.models.BenefitKind
         """
         super().__init__(benefit_type=benefit_type, **kwargs)
         self.avg_utilization_percentage = None
@@ -4607,15 +4737,18 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
-    :ivar e_tag: Resource Etag.
+    :ivar e_tag: Resource Etag. For update calls, eTag is optional and can be specified to achieve
+     optimistic concurrency. Fetch the resource's eTag by doing a 'GET' call first and then
+     including the latest eTag as part of the request body or 'If-Match' header while performing the
+     update. For create calls, eTag is not required.
     :vartype e_tag: str
     :ivar kind: Kind of the scheduled action. Known values are: "Email" and "InsightAlert".
     :vartype kind: str or ~azure.mgmt.costmanagement.models.ScheduledActionKind
     :ivar system_data: Kind of the scheduled action.
     :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
     """
 
@@ -4632,15 +4765,15 @@
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "e_tag": {"key": "eTag", "type": "str"},
         "kind": {"key": "kind", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
     }
 
-    def __init__(self, *, kind: Optional[Union[str, "_models.ScheduledActionKind"]] = None, **kwargs):
+    def __init__(self, *, kind: Optional[Union[str, "_models.ScheduledActionKind"]] = None, **kwargs: Any) -> None:
         """
         :keyword kind: Kind of the scheduled action. Known values are: "Email" and "InsightAlert".
         :paramtype kind: str or ~azure.mgmt.costmanagement.models.ScheduledActionKind
         """
         super().__init__(**kwargs)
         self.e_tag = None
         self.kind = kind
@@ -4656,15 +4789,18 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
-    :ivar e_tag: Resource Etag.
+    :ivar e_tag: Resource Etag. For update calls, eTag is optional and can be specified to achieve
+     optimistic concurrency. Fetch the resource's eTag by doing a 'GET' call first and then
+     including the latest eTag as part of the request body or 'If-Match' header while performing the
+     update. For create calls, eTag is not required.
     :vartype e_tag: str
     :ivar kind: Kind of the scheduled action. Known values are: "Email" and "InsightAlert".
     :vartype kind: str or ~azure.mgmt.costmanagement.models.ScheduledActionKind
     :ivar system_data: Kind of the scheduled action.
     :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
     :ivar display_name: Scheduled action name.
     :vartype display_name: str
@@ -4735,16 +4871,16 @@
         file_destination: Optional["_models.FileDestination"] = None,
         notification: Optional["_models.NotificationProperties"] = None,
         notification_email: Optional[str] = None,
         schedule: Optional["_models.ScheduleProperties"] = None,
         scope: Optional[str] = None,
         status: Optional[Union[str, "_models.ScheduledActionStatus"]] = None,
         view_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kind: Kind of the scheduled action. Known values are: "Email" and "InsightAlert".
         :paramtype kind: str or ~azure.mgmt.costmanagement.models.ScheduledActionKind
         :keyword display_name: Scheduled action name.
         :paramtype display_name: str
         :keyword file_destination: Destination format of the view data. This is optional.
         :paramtype file_destination: ~azure.mgmt.costmanagement.models.FileDestination
@@ -4807,15 +4943,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[ScheduledAction]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class ScheduleProperties(_serialization.Model):
@@ -4866,16 +5002,16 @@
         frequency: Union[str, "_models.ScheduleFrequency"],
         start_date: datetime.datetime,
         end_date: datetime.datetime,
         hour_of_day: Optional[int] = None,
         days_of_week: Optional[List[Union[str, "_models.DaysOfWeek"]]] = None,
         weeks_of_month: Optional[List[Union[str, "_models.WeeksOfMonth"]]] = None,
         day_of_month: Optional[int] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword frequency: Frequency of the schedule. Required. Known values are: "Daily", "Weekly",
          and "Monthly".
         :paramtype frequency: str or ~azure.mgmt.costmanagement.models.ScheduleFrequency
         :keyword hour_of_day: UTC time at which cost analysis data will be emailed.
         :paramtype hour_of_day: int
         :keyword days_of_week: Day names in english on which cost analysis data will be emailed. This
@@ -4981,16 +5117,16 @@
         self,
         *,
         look_back_period: Optional[Union[str, "_models.LookBackPeriod"]] = None,
         usage: Optional["_models.RecommendationUsageDetails"] = None,
         term: Optional[Union[str, "_models.Term"]] = None,
         commitment_granularity: Optional[Union[str, "_models.Grain"]] = None,
         recommendation_details: Optional["_models.AllSavingsBenefitDetails"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword look_back_period: The number of days of usage evaluated for computing the
          recommendations. Known values are: "Last7Days", "Last30Days", and "Last60Days".
         :paramtype look_back_period: str or ~azure.mgmt.costmanagement.models.LookBackPeriod
         :keyword usage: On-demand charges between firstConsumptionDate and lastConsumptionDate that
          were used for computing benefit recommendations.
         :paramtype usage: ~azure.mgmt.costmanagement.models.RecommendationUsageDetails
@@ -5007,15 +5143,15 @@
             look_back_period=look_back_period,
             usage=usage,
             term=term,
             commitment_granularity=commitment_granularity,
             recommendation_details=recommendation_details,
             **kwargs
         )
-        self.scope = "Shared"  # type: str
+        self.scope: str = "Shared"
 
 
 class SingleScopeBenefitRecommendationProperties(
     BenefitRecommendationProperties
 ):  # pylint: disable=too-many-instance-attributes
     """The properties of the benefit recommendations when scope is 'Single'.
 
@@ -5102,16 +5238,16 @@
         self,
         *,
         look_back_period: Optional[Union[str, "_models.LookBackPeriod"]] = None,
         usage: Optional["_models.RecommendationUsageDetails"] = None,
         term: Optional[Union[str, "_models.Term"]] = None,
         commitment_granularity: Optional[Union[str, "_models.Grain"]] = None,
         recommendation_details: Optional["_models.AllSavingsBenefitDetails"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword look_back_period: The number of days of usage evaluated for computing the
          recommendations. Known values are: "Last7Days", "Last30Days", and "Last60Days".
         :paramtype look_back_period: str or ~azure.mgmt.costmanagement.models.LookBackPeriod
         :keyword usage: On-demand charges between firstConsumptionDate and lastConsumptionDate that
          were used for computing benefit recommendations.
         :paramtype usage: ~azure.mgmt.costmanagement.models.RecommendationUsageDetails
@@ -5128,15 +5264,15 @@
             look_back_period=look_back_period,
             usage=usage,
             term=term,
             commitment_granularity=commitment_granularity,
             recommendation_details=recommendation_details,
             **kwargs
         )
-        self.scope = "Single"  # type: str
+        self.scope: str = "Single"
         self.subscription_id = None
         self.resource_group = None
 
 
 class Status(_serialization.Model):
     """The status of the long running operation.
 
@@ -5145,15 +5281,17 @@
     :vartype status: str or ~azure.mgmt.costmanagement.models.ReportOperationStatusType
     """
 
     _attribute_map = {
         "status": {"key": "status", "type": "str"},
     }
 
-    def __init__(self, *, status: Optional[Union[str, "_models.ReportOperationStatusType"]] = None, **kwargs):
+    def __init__(
+        self, *, status: Optional[Union[str, "_models.ReportOperationStatusType"]] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword status: The status of the long running operation. Known values are: "InProgress",
          "Completed", "Failed", "Queued", "NoDataFound", "ReadyToDownload", and "TimedOut".
         :paramtype status: str or ~azure.mgmt.costmanagement.models.ReportOperationStatusType
         """
         super().__init__(**kwargs)
         self.status = status
@@ -5192,16 +5330,16 @@
         *,
         created_by: Optional[str] = None,
         created_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
         created_at: Optional[datetime.datetime] = None,
         last_modified_by: Optional[str] = None,
         last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
         last_modified_at: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword created_by: The identity that created the resource.
         :paramtype created_by: str
         :keyword created_by_type: The type of identity that created the resource. Known values are:
          "User", "Application", "ManagedIdentity", and "Key".
         :paramtype created_by_type: str or ~azure.mgmt.costmanagement.models.CreatedByType
         :keyword created_at: The timestamp of resource creation (UTC).
@@ -5295,15 +5433,14 @@
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "created_on": {"readonly": True},
         "modified_on": {"readonly": True},
-        "date_range": {"readonly": True},
         "currency": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
@@ -5328,26 +5465,27 @@
 
     def __init__(
         self,
         *,
         e_tag: Optional[str] = None,
         display_name: Optional[str] = None,
         scope: Optional[str] = None,
+        date_range: Optional[str] = None,
         chart: Optional[Union[str, "_models.ChartType"]] = None,
         accumulated: Optional[Union[str, "_models.AccumulatedType"]] = None,
         metric: Optional[Union[str, "_models.MetricType"]] = None,
         kpis: Optional[List["_models.KpiProperties"]] = None,
         pivots: Optional[List["_models.PivotProperties"]] = None,
         type_properties_query_type: Optional[Union[str, "_models.ReportType"]] = None,
         timeframe: Optional[Union[str, "_models.ReportTimeframeType"]] = None,
         time_period: Optional["_models.ReportConfigTimePeriod"] = None,
         data_set: Optional["_models.ReportConfigDataset"] = None,
         include_monetary_commitment: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
          used to determine whether the user is updating the latest version or not.
         :paramtype e_tag: str
         :keyword display_name: User input name of the view. Required.
         :paramtype display_name: str
         :keyword scope: Cost Management scope to save the view on. This includes
@@ -5364,14 +5502,16 @@
          for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
          for Management Group scope,
          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
          ExternalBillingAccount scope, and
          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
          ExternalSubscription scope.
         :paramtype scope: str
+        :keyword date_range: Date range of the current view.
+        :paramtype date_range: str
         :keyword chart: Chart type of the main view in Cost Analysis. Required. Known values are:
          "Area", "Line", "StackedColumn", "GroupedColumn", and "Table".
         :paramtype chart: str or ~azure.mgmt.costmanagement.models.ChartType
         :keyword accumulated: Show costs accumulated over time. Known values are: "true" and "false".
         :paramtype accumulated: str or ~azure.mgmt.costmanagement.models.AccumulatedType
         :keyword metric: Metric to use when displaying costs. Known values are: "ActualCost",
          "AmortizedCost", and "AHUB".
@@ -5396,15 +5536,15 @@
         :paramtype include_monetary_commitment: bool
         """
         super().__init__(e_tag=e_tag, **kwargs)
         self.display_name = display_name
         self.scope = scope
         self.created_on = None
         self.modified_on = None
-        self.date_range = None
+        self.date_range = date_range
         self.currency = None
         self.chart = chart
         self.accumulated = accumulated
         self.metric = metric
         self.kpis = kpis
         self.pivots = pivots
         self.type_properties_query_type = type_properties_query_type
@@ -5431,12 +5571,12 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[View]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/models/_cost_management_client_enums.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/_cost_management_client_enums.py`

 * *Files 5% similar despite different names*

```diff
@@ -102,20 +102,20 @@
     X_CLOUD = "xCloud"
     BUDGET_FORECAST = "BudgetForecast"
 
 
 class BenefitKind(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Kind/type of the benefit."""
 
-    #: Benefit is IncludedQuantity.
     INCLUDED_QUANTITY = "IncludedQuantity"
-    #: Benefit is Reservation.
+    """Benefit is IncludedQuantity."""
     RESERVATION = "Reservation"
-    #: Benefit is SavingsPlan.
+    """Benefit is Reservation."""
     SAVINGS_PLAN = "SavingsPlan"
+    """Benefit is SavingsPlan."""
 
 
 class ChartType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Chart type of the main view in Cost Analysis. Required."""
 
     AREA = "Area"
     LINE = "Line"
@@ -130,36 +130,36 @@
     INVALID = "Invalid"
     ALREADY_EXISTS = "AlreadyExists"
 
 
 class CostDetailsDataFormat(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The data format of the report."""
 
-    #: Csv data format.
     CSV_COST_DETAILS_DATA_FORMAT = "Csv"
+    """Csv data format."""
 
 
 class CostDetailsMetricType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The type of the detailed report. By default ActualCost is provided."""
 
-    #: Actual cost data.
     ACTUAL_COST_COST_DETAILS_METRIC_TYPE = "ActualCost"
-    #: Amortized cost data.
+    """Actual cost data."""
     AMORTIZED_COST_COST_DETAILS_METRIC_TYPE = "AmortizedCost"
+    """Amortized cost data."""
 
 
 class CostDetailsStatusType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The status of the cost details operation."""
 
-    #: Operation is Completed.
     COMPLETED_COST_DETAILS_STATUS_TYPE = "Completed"
-    #: Operation is Completed and no cost data found.
+    """Operation is Completed."""
     NO_DATA_FOUND_COST_DETAILS_STATUS_TYPE = "NoDataFound"
-    #: Operation Failed.
+    """Operation is Completed and no cost data found."""
     FAILED_COST_DETAILS_STATUS_TYPE = "Failed"
+    """Operation Failed."""
 
 
 class CreatedByType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The type of identity that created the resource."""
 
     USER = "User"
     APPLICATION = "Application"
@@ -219,14 +219,15 @@
     CSV = "Csv"
 
 
 class ForecastOperatorType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The operator to use for comparison."""
 
     IN = "In"
+    IN_ENUM = "In"
 
 
 class ForecastTimeframe(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The time frame for pulling data for the forecast."""
 
     CUSTOM = "Custom"
 
@@ -266,31 +267,31 @@
     ACTUAL_COST = "ActualCost"
     AMORTIZED_COST = "AmortizedCost"
 
 
 class Grain(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Grain which corresponds to value."""
 
-    #: Hourly grain corresponds to value per hour.
     HOURLY = "Hourly"
-    #: Hourly grain corresponds to value per day.
+    """Hourly grain corresponds to value per hour."""
     DAILY = "Daily"
-    #: Hourly grain corresponds to value per month.
+    """Hourly grain corresponds to value per day."""
     MONTHLY = "Monthly"
+    """Hourly grain corresponds to value per month."""
 
 
 class GrainParameter(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """GrainParameter."""
 
-    #: Hourly grain corresponds to value per hour.
     HOURLY = "Hourly"
-    #: Hourly grain corresponds to value per day.
+    """Hourly grain corresponds to value per hour."""
     DAILY = "Daily"
-    #: Hourly grain corresponds to value per month.
+    """Hourly grain corresponds to value per day."""
     MONTHLY = "Monthly"
+    """Hourly grain corresponds to value per month."""
 
 
 class GranularityType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The granularity of rows in the forecast."""
 
     DAILY = "Daily"
 
@@ -301,20 +302,20 @@
     FORECAST = "Forecast"
     BUDGET = "Budget"
 
 
 class LookBackPeriod(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The number of days used to look back."""
 
-    #: 7 days used to look back.
     LAST7_DAYS = "Last7Days"
-    #: 30 days used to look back.
+    """7 days used to look back."""
     LAST30_DAYS = "Last30Days"
-    #: 60 days used to look back.
+    """30 days used to look back."""
     LAST60_DAYS = "Last60Days"
+    """60 days used to look back."""
 
 
 class MetricType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Metric to use when displaying costs."""
 
     ACTUAL_COST = "ActualCost"
     AMORTIZED_COST = "AmortizedCost"
@@ -330,14 +331,15 @@
 
 
 class OperatorType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The operator to use for comparison."""
 
     IN = "In"
     CONTAINS = "Contains"
+    IN_ENUM = "In"
 
 
 class Origin(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The intended executor of the operation; as in Resource Based Access Control (RBAC) and audit
     logs UX. Default value is "user,system".
     """
 
@@ -350,42 +352,38 @@
     """Data type to show in view."""
 
     DIMENSION = "Dimension"
     TAG_KEY = "TagKey"
 
 
 class QueryColumnType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """The type of the column in the export."""
+    """The type of the column in the report."""
 
-    TAG = "Tag"
+    TAG_KEY = "TagKey"
+    """The tag associated with the cost data."""
     DIMENSION = "Dimension"
+    """The dimension of cost data."""
 
 
 class QueryOperatorType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The operator to use for comparison."""
 
     IN = "In"
+    IN_ENUM = "In"
 
 
 class RecurrenceType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The schedule recurrence."""
 
     DAILY = "Daily"
     WEEKLY = "Weekly"
     MONTHLY = "Monthly"
     ANNUALLY = "Annually"
 
 
-class ReportConfigColumnType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """The type of the column in the report."""
-
-    TAG = "Tag"
-    DIMENSION = "Dimension"
-
-
 class ReportConfigSortingType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Direction of sort."""
 
     ASCENDING = "Ascending"
     DESCENDING = "Descending"
 
 
@@ -445,66 +443,66 @@
     USAGE_DATE = "UsageDate"
     USED_HOURS = "UsedHours"
 
 
 class ScheduledActionKind(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Kind of the scheduled action."""
 
-    #: Cost analysis data will be emailed.
     EMAIL = "Email"
-    #: Cost anomaly information will be emailed. Available only on subscription scope at daily
-    #: frequency. If no anomaly is detected on the resource, an email won't be sent.
+    """Cost analysis data will be emailed."""
     INSIGHT_ALERT = "InsightAlert"
+    """Cost anomaly information will be emailed. Available only on subscription scope at daily
+    #: frequency. If no anomaly is detected on the resource, an email won't be sent."""
 
 
 class ScheduledActionStatus(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Status of the scheduled action."""
 
-    #: Scheduled action is saved but will not be run.
     DISABLED = "Disabled"
-    #: Scheduled action is saved and will be run.
+    """Scheduled action is saved but will not be run."""
     ENABLED = "Enabled"
-    #: Scheduled action is expired.
+    """Scheduled action is saved and will be run."""
     EXPIRED = "Expired"
+    """Scheduled action is expired."""
 
 
 class ScheduleFrequency(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Frequency of the schedule."""
 
-    #: Cost analysis data will be emailed every day.
     DAILY = "Daily"
-    #: Cost analysis data will be emailed every week.
+    """Cost analysis data will be emailed every day."""
     WEEKLY = "Weekly"
-    #: Cost analysis data will be emailed every month.
+    """Cost analysis data will be emailed every week."""
     MONTHLY = "Monthly"
+    """Cost analysis data will be emailed every month."""
 
 
 class Scope(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Kind of the recommendation scope."""
 
-    #: Single scope recommendation.
     SINGLE = "Single"
-    #: Shared scope recommendation.
+    """Single scope recommendation."""
     SHARED = "Shared"
+    """Shared scope recommendation."""
 
 
 class StatusType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The status of the export's schedule. If 'Inactive', the export's schedule is paused."""
 
     ACTIVE = "Active"
     INACTIVE = "Inactive"
 
 
 class Term(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Grain which corresponds to value."""
 
-    #: Benefit term is 1 year.
     P1_Y = "P1Y"
-    #: Benefit term is 3 years.
+    """Benefit term is 1 year."""
     P3_Y = "P3Y"
+    """Benefit term is 3 years."""
 
 
 class TimeframeType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The time frame for pulling data for the query. If custom, then a specific time period must be
     provided.
     """
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/_patch.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/__init__.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._cost_management_client import CostManagementClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "CostManagementClient",
 ]
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/_configuration.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/_configuration.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,49 +2,43 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class CostManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for CostManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :keyword api_version: Api Version. Default value is "2022-10-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", **kwargs: Any) -> None:
         super(CostManagementClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "2022-10-01")  # type: Literal["2022-10-01"]
+        api_version: str = kwargs.pop("api_version", "2022-10-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
 
         self.credential = credential
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
@@ -53,15 +47,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/_cost_management_client.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/_cost_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any, Awaitable, TYPE_CHECKING
 
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 from azure.mgmt.core import AsyncARMPipelineClient
 
-from .. import models
+from .. import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import CostManagementClientConfiguration
 from .operations import (
     AlertsOperations,
     BenefitRecommendationsOperations,
     BenefitUtilizationSummariesOperations,
     DimensionsOperations,
@@ -96,17 +96,17 @@
      Retry-After header is present.
     """
 
     def __init__(
         self, credential: "AsyncTokenCredential", base_url: str = "https://management.azure.com", **kwargs: Any
     ) -> None:
         self._config = CostManagementClientConfiguration(credential=credential, **kwargs)
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.views = ViewsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.alerts = AlertsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.forecast = ForecastOperations(self._client, self._config, self._serialize, self._deserialize)
@@ -164,9 +164,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "CostManagementClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
@@ -67,18 +62,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.CostManagementOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.OperationListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -90,15 +83,15 @@
                 request = build_list_request(
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -106,36 +99,37 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.CostManagement/operations"}  # type: ignore
+    list.metadata = {"url": "/providers/Microsoft.CostManagement/operations"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_benefit_recommendations_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_benefit_recommendations_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._benefit_recommendations_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class BenefitRecommendationsOperations:
     """
     .. warning::
@@ -64,14 +59,17 @@
         filter: Optional[str] = None,
         orderby: Optional[str] = None,
         expand: Optional[str] = None,
         **kwargs: Any
     ) -> AsyncIterable["_models.BenefitRecommendationModel"]:
         """List of recommendations for purchasing savings plan.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/CostManagement/
+
         :param billing_scope: The scope associated with benefit recommendation operations. This
          includes '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resource group scope,
          /providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for enterprise agreement
          scope, and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
          for billing profile scope. Required.
@@ -95,18 +93,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.BenefitRecommendationModel]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BenefitRecommendationsListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.BenefitRecommendationsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -122,15 +118,15 @@
                     expand=expand,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -138,36 +134,37 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("BenefitRecommendationsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/{billingScope}/providers/Microsoft.CostManagement/benefitRecommendations"}  # type: ignore
+    list.metadata = {"url": "/{billingScope}/providers/Microsoft.CostManagement/benefitRecommendations"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_patch.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/__init__.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/operations/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -24,15 +24,15 @@
 )
 from ._price_sheet_operations import PriceSheetOperations
 from ._scheduled_actions_operations import ScheduledActionsOperations
 from ._benefit_recommendations_operations import BenefitRecommendationsOperations
 from ._benefit_utilization_summaries_operations import BenefitUtilizationSummariesOperations
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Operations",
     "ViewsOperations",
     "AlertsOperations",
     "ForecastOperations",
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_scheduled_actions_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_scheduled_actions_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -40,18 +40,14 @@
     build_get_request,
     build_list_by_scope_request,
     build_list_request,
     build_run_by_scope_request,
     build_run_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScheduledActionsOperations:
     """
     .. warning::
@@ -71,30 +67,31 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(self, filter: Optional[str] = None, **kwargs: Any) -> AsyncIterable["_models.ScheduledAction"]:
         """List all private scheduled actions.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param filter: May be used to filter scheduled actions by properties/viewId. Supported operator
          is 'eq'. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ScheduledAction or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.ScheduledAction]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledActionListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ScheduledActionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -107,15 +104,15 @@
                     filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -123,50 +120,56 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ScheduledActionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                error = self._deserialize.failsafe_deserialize(
+                    _models.ErrorResponseWithNestedDetails, pipeline_response
+                )
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions"}  # type: ignore
+    list.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions"}
 
     @distributed_trace
     def list_by_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.ScheduledAction"]:
         """List all shared scheduled actions within the given scope.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param scope: The scope associated with scheduled action operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -189,18 +192,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.ScheduledAction]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledActionListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ScheduledActionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -214,15 +215,15 @@
                     filter=filter,
                     api_version=api_version,
                     template_url=self.list_by_scope.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -230,98 +231,124 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ScheduledActionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                error = self._deserialize.failsafe_deserialize(
+                    _models.ErrorResponseWithNestedDetails, pipeline_response
+                )
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions"}  # type: ignore
+    list_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions"}
 
     @overload
     async def create_or_update(
         self,
         name: str,
         scheduled_action: _models.ScheduledAction,
+        if_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a private scheduled action.
 
         :param name: Scheduled action name. Required.
         :type name: str
         :param scheduled_action: Scheduled action to be created or updated. Required.
         :type scheduled_action: ~azure.mgmt.costmanagement.models.ScheduledAction
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_or_update(
-        self, name: str, scheduled_action: IO, *, content_type: str = "application/json", **kwargs: Any
+        self,
+        name: str,
+        scheduled_action: IO,
+        if_match: Optional[str] = None,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a private scheduled action.
 
         :param name: Scheduled action name. Required.
         :type name: str
         :param scheduled_action: Scheduled action to be created or updated. Required.
         :type scheduled_action: IO
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_or_update(
-        self, name: str, scheduled_action: Union[_models.ScheduledAction, IO], **kwargs: Any
+        self,
+        name: str,
+        scheduled_action: Union[_models.ScheduledAction, IO],
+        if_match: Optional[str] = None,
+        **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a private scheduled action.
 
         :param name: Scheduled action name. Required.
         :type name: str
-        :param scheduled_action: Scheduled action to be created or updated. Is either a model type or a
-         IO type. Required.
+        :param scheduled_action: Scheduled action to be created or updated. Is either a ScheduledAction
+         type or a IO type. Required.
         :type scheduled_action: ~azure.mgmt.costmanagement.models.ScheduledAction or IO
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -333,69 +360,72 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledAction]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.ScheduledAction] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(scheduled_action, (IO, bytes)):
+        if isinstance(scheduled_action, (IOBase, bytes)):
             _content = scheduled_action
         else:
             _json = self._serialize.body(scheduled_action, "ScheduledAction")
 
         request = build_create_or_update_request(
             name=name,
+            if_match=if_match,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    create_or_update.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    create_or_update.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @distributed_trace_async
     async def get(self, name: str, **kwargs: Any) -> _models.ScheduledAction:
         """Get the private scheduled action by name.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param name: Scheduled action name. Required.
         :type name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -406,53 +436,55 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledAction]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ScheduledAction] = kwargs.pop("cls", None)
 
         request = build_get_request(
             name=name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    get.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @distributed_trace_async
     async def delete(self, name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
         """Delete a private scheduled action.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param name: Scheduled action name. Required.
         :type name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -463,51 +495,51 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             name=name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    delete.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @overload
     async def create_or_update_by_scope(
         self,
         scope: str,
         name: str,
         scheduled_action: _models.ScheduledAction,
+        if_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a shared scheduled action within the given scope.
 
         :param scope: The scope associated with scheduled action operations. This includes
@@ -528,26 +560,37 @@
          External Subscription scope. Note: Insight Alerts are only available on subscription scope.
          Required.
         :type scope: str
         :param name: Scheduled action name. Required.
         :type name: str
         :param scheduled_action: Scheduled action to be created or updated. Required.
         :type scheduled_action: ~azure.mgmt.costmanagement.models.ScheduledAction
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_or_update_by_scope(
-        self, scope: str, name: str, scheduled_action: IO, *, content_type: str = "application/json", **kwargs: Any
+        self,
+        scope: str,
+        name: str,
+        scheduled_action: IO,
+        if_match: Optional[str] = None,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a shared scheduled action within the given scope.
 
         :param scope: The scope associated with scheduled action operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
@@ -565,26 +608,35 @@
          External Subscription scope. Note: Insight Alerts are only available on subscription scope.
          Required.
         :type scope: str
         :param name: Scheduled action name. Required.
         :type name: str
         :param scheduled_action: Scheduled action to be created or updated. Required.
         :type scheduled_action: IO
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_or_update_by_scope(
-        self, scope: str, name: str, scheduled_action: Union[_models.ScheduledAction, IO], **kwargs: Any
+        self,
+        scope: str,
+        name: str,
+        scheduled_action: Union[_models.ScheduledAction, IO],
+        if_match: Optional[str] = None,
+        **kwargs: Any
     ) -> _models.ScheduledAction:
         """Create or update a shared scheduled action within the given scope.
 
         :param scope: The scope associated with scheduled action operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
@@ -600,17 +652,21 @@
          External Billing Account scope and
          'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
          External Subscription scope. Note: Insight Alerts are only available on subscription scope.
          Required.
         :type scope: str
         :param name: Scheduled action name. Required.
         :type name: str
-        :param scheduled_action: Scheduled action to be created or updated. Is either a model type or a
-         IO type. Required.
+        :param scheduled_action: Scheduled action to be created or updated. Is either a ScheduledAction
+         type or a IO type. Required.
         :type scheduled_action: ~azure.mgmt.costmanagement.models.ScheduledAction or IO
+        :param if_match: ETag of the Entity. Not required when creating an entity. Optional when
+         updating an entity and can be specified to achieve optimistic concurrency. Default value is
+         None.
+        :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ScheduledAction or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.ScheduledAction
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -622,70 +678,73 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledAction]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.ScheduledAction] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(scheduled_action, (IO, bytes)):
+        if isinstance(scheduled_action, (IOBase, bytes)):
             _content = scheduled_action
         else:
             _json = self._serialize.body(scheduled_action, "ScheduledAction")
 
         request = build_create_or_update_by_scope_request(
             scope=scope,
             name=name,
+            if_match=if_match,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self.create_or_update_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    create_or_update_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    create_or_update_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @distributed_trace_async
     async def get_by_scope(self, scope: str, name: str, **kwargs: Any) -> _models.ScheduledAction:
         """Get the shared scheduled action from the given scope by name.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param scope: The scope associated with scheduled action operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -714,56 +773,58 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledAction]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ScheduledAction] = kwargs.pop("cls", None)
 
         request = build_get_by_scope_request(
             scope=scope,
             name=name,
             api_version=api_version,
             template_url=self.get_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ScheduledAction", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    get_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @distributed_trace_async
     async def delete_by_scope(  # pylint: disable=inconsistent-return-statements
         self, scope: str, name: str, **kwargs: Any
     ) -> None:
         """Delete a scheduled action within the given scope.
 
+        .. seealso::
+           - https://docs.microsoft.com/rest/api/cost-management/
+
         :param scope: The scope associated with scheduled action operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -792,45 +853,44 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_scope_request(
             scope=scope,
             name=name,
             api_version=api_version,
             template_url=self.delete_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}  # type: ignore
+    delete_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}"}
 
     @distributed_trace_async
     async def run(self, name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
         """Processes a private scheduled action.
 
         :param name: Scheduled action name. Required.
         :type name: str
@@ -846,44 +906,43 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_run_request(
             name=name,
             api_version=api_version,
             template_url=self.run.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    run.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}/execute"}  # type: ignore
+    run.metadata = {"url": "/providers/Microsoft.CostManagement/scheduledActions/{name}/execute"}
 
     @distributed_trace_async
     async def run_by_scope(  # pylint: disable=inconsistent-return-statements
         self, scope: str, name: str, **kwargs: Any
     ) -> None:
         """Runs a shared scheduled action within the given scope.
 
@@ -919,45 +978,44 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_run_by_scope_request(
             scope=scope,
             name=name,
             api_version=api_version,
             template_url=self.run_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    run_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}/execute"}  # type: ignore
+    run_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}/execute"}
 
     @overload
     async def check_name_availability(
         self,
         check_name_availability_request: _models.CheckNameAvailabilityRequest,
         *,
         content_type: str = "application/json",
@@ -997,15 +1055,15 @@
     @distributed_trace_async
     async def check_name_availability(
         self, check_name_availability_request: Union[_models.CheckNameAvailabilityRequest, IO], **kwargs: Any
     ) -> _models.CheckNameAvailabilityResponse:
         """Checks availability and correctness of the name for a scheduled action.
 
         :param check_name_availability_request: Scheduled action to be created or updated. Is either a
-         model type or a IO type. Required.
+         CheckNameAvailabilityRequest type or a IO type. Required.
         :type check_name_availability_request:
          ~azure.mgmt.costmanagement.models.CheckNameAvailabilityRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityResponse or the result of cls(response)
@@ -1019,59 +1077,58 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CheckNameAvailabilityResponse]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CheckNameAvailabilityResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(check_name_availability_request, (IO, bytes)):
+        if isinstance(check_name_availability_request, (IOBase, bytes)):
             _content = check_name_availability_request
         else:
             _json = self._serialize.body(check_name_availability_request, "CheckNameAvailabilityRequest")
 
         request = build_check_name_availability_request(
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameAvailabilityResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    check_name_availability.metadata = {"url": "/providers/Microsoft.CostManagement/checkNameAvailability"}  # type: ignore
+    check_name_availability.metadata = {"url": "/providers/Microsoft.CostManagement/checkNameAvailability"}
 
     @overload
     async def check_name_availability_by_scope(
         self,
         scope: str,
         check_name_availability_request: _models.CheckNameAvailabilityRequest,
         *,
@@ -1169,15 +1226,15 @@
          'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
          External Billing Account scope and
          'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
          External Subscription scope. Note: Insight Alerts are only available on subscription scope.
          Required.
         :type scope: str
         :param check_name_availability_request: Scheduled action to be created or updated. Is either a
-         model type or a IO type. Required.
+         CheckNameAvailabilityRequest type or a IO type. Required.
         :type check_name_availability_request:
          ~azure.mgmt.costmanagement.models.CheckNameAvailabilityRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityResponse or the result of cls(response)
@@ -1191,24 +1248,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CheckNameAvailabilityResponse]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CheckNameAvailabilityResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(check_name_availability_request, (IO, bytes)):
+        if isinstance(check_name_availability_request, (IOBase, bytes)):
             _content = check_name_availability_request
         else:
             _json = self._serialize.body(check_name_availability_request, "CheckNameAvailabilityRequest")
 
         request = build_check_name_availability_by_scope_request(
             scope=scope,
             api_version=api_version,
@@ -1216,28 +1271,31 @@
             json=_json,
             content=_content,
             template_url=self.check_name_availability_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponseWithNestedDetails, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameAvailabilityResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    check_name_availability_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/checkNameAvailability"}  # type: ignore
+    check_name_availability_by_scope.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/checkNameAvailability"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_benefit_utilization_summaries_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_benefit_utilization_summaries_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar, Union
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -31,18 +30,14 @@
 from ...operations._benefit_utilization_summaries_operations import (
     build_list_by_billing_account_id_request,
     build_list_by_billing_profile_id_request,
     build_list_by_savings_plan_id_request,
     build_list_by_savings_plan_order_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class BenefitUtilizationSummariesOperations:
     """
     .. warning::
@@ -69,14 +64,17 @@
         grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
         filter: Optional[str] = None,
         **kwargs: Any
     ) -> AsyncIterable["_models.BenefitUtilizationSummary"]:
         """Lists savings plan utilization summaries for the enterprise agreement scope. Supported at grain
         values: 'Daily' and 'Monthly'.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/cost-management/
+
         :param billing_account_id: Billing account ID. Required.
         :type billing_account_id: str
         :param grain_parameter: Grain. Known values are: "Hourly", "Daily", and "Monthly". Default
          value is None.
         :type grain_parameter: str or ~azure.mgmt.costmanagement.models.GrainParameter
         :param filter: Supports filtering by properties/benefitId, properties/benefitOrderId and
          properties/usageDate. Default value is None.
@@ -87,18 +85,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.BenefitUtilizationSummary]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BenefitUtilizationSummariesListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.BenefitUtilizationSummariesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -113,15 +109,15 @@
                     filter=filter,
                     api_version=api_version,
                     template_url=self.list_by_billing_account_id.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -129,56 +125,62 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("BenefitUtilizationSummariesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_by_billing_account_id.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"}  # type: ignore
+    list_by_billing_account_id.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"
+    }
 
     @distributed_trace
     def list_by_billing_profile_id(
         self,
         billing_account_id: str,
         billing_profile_id: str,
         grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
         filter: Optional[str] = None,
         **kwargs: Any
     ) -> AsyncIterable["_models.BenefitUtilizationSummary"]:
         """Lists savings plan utilization summaries for billing profile. Supported at grain values:
         'Daily' and 'Monthly'.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/cost-management/
+
         :param billing_account_id: Billing account ID. Required.
         :type billing_account_id: str
         :param billing_profile_id: Billing profile ID. Required.
         :type billing_profile_id: str
         :param grain_parameter: Grain. Known values are: "Hourly", "Daily", and "Monthly". Default
          value is None.
         :type grain_parameter: str or ~azure.mgmt.costmanagement.models.GrainParameter
@@ -191,18 +193,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.BenefitUtilizationSummary]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BenefitUtilizationSummariesListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.BenefitUtilizationSummariesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -218,15 +218,15 @@
                     filter=filter,
                     api_version=api_version,
                     template_url=self.list_by_billing_profile_id.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -234,54 +234,60 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("BenefitUtilizationSummariesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_by_billing_profile_id.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"}  # type: ignore
+    list_by_billing_profile_id.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"
+    }
 
     @distributed_trace
     def list_by_savings_plan_order(
         self,
         savings_plan_order_id: str,
         filter: Optional[str] = None,
         grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
         **kwargs: Any
     ) -> AsyncIterable["_models.BenefitUtilizationSummary"]:
         """Lists the savings plan utilization summaries for daily or monthly grain.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/cost-management/
+
         :param savings_plan_order_id: Savings plan order ID. Required.
         :type savings_plan_order_id: str
         :param filter: Supports filtering by properties/usageDate. Default value is None.
         :type filter: str
         :param grain_parameter: Grain. Known values are: "Hourly", "Daily", and "Monthly". Default
          value is None.
         :type grain_parameter: str or ~azure.mgmt.costmanagement.models.GrainParameter
@@ -291,18 +297,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.BenefitUtilizationSummary]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BenefitUtilizationSummariesListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.BenefitUtilizationSummariesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -317,15 +321,15 @@
                     grain_parameter=grain_parameter,
                     api_version=api_version,
                     template_url=self.list_by_savings_plan_order.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -333,55 +337,61 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("BenefitUtilizationSummariesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_by_savings_plan_order.metadata = {"url": "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"}  # type: ignore
+    list_by_savings_plan_order.metadata = {
+        "url": "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"
+    }
 
     @distributed_trace
     def list_by_savings_plan_id(
         self,
         savings_plan_order_id: str,
         savings_plan_id: str,
         filter: Optional[str] = None,
         grain_parameter: Optional[Union[str, _models.GrainParameter]] = None,
         **kwargs: Any
     ) -> AsyncIterable["_models.BenefitUtilizationSummary"]:
         """Lists the savings plan utilization summaries for daily or monthly grain.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/cost-management/
+
         :param savings_plan_order_id: Savings plan order ID. Required.
         :type savings_plan_order_id: str
         :param savings_plan_id: Savings plan ID. Required.
         :type savings_plan_id: str
         :param filter: Supports filtering by properties/usageDate. Default value is None.
         :type filter: str
         :param grain_parameter: Grain. Known values are: "Hourly", "Daily", and "Monthly". Default
@@ -393,18 +403,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.BenefitUtilizationSummary]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BenefitUtilizationSummariesListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.BenefitUtilizationSummariesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -420,15 +428,15 @@
                     grain_parameter=grain_parameter,
                     api_version=api_version,
                     template_url=self.list_by_savings_plan_id.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -436,36 +444,39 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("BenefitUtilizationSummariesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_by_savings_plan_id.metadata = {"url": "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/savingsPlans/{savingsPlanId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"}  # type: ignore
+    list_by_savings_plan_id.metadata = {
+        "url": "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/savingsPlans/{savingsPlanId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_cost_details_report_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_cost_details_report_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -29,18 +29,14 @@
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._generate_cost_details_report_operations import (
     build_create_operation_request,
     build_get_operation_results_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class GenerateCostDetailsReportOperations:
     """
     .. warning::
@@ -70,24 +66,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.CostDetailsOperationResults]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[Optional[_models.CostDetailsOperationResults]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "GenerateCostDetailsReportRequestDefinition")
 
         request = build_create_operation_request(
             scope=scope,
             api_version=api_version,
@@ -95,23 +89,24 @@
             json=_json,
             content=_content,
             template_url=self._create_operation_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(
                 _models.GenerateCostDetailsReportErrorResponse, pipeline_response
             )
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
@@ -124,15 +119,17 @@
             response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _create_operation_initial.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateCostDetailsReport"}  # type: ignore
+    _create_operation_initial.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/generateCostDetailsReport"
+    }
 
     @overload
     async def begin_create_operation(
         self,
         scope: str,
         parameters: _models.GenerateCostDetailsReportRequestDefinition,
         *,
@@ -144,15 +141,20 @@
         or Invoice Id asynchronously at a certain scope. The initial call to request a report will
         return a 202 with a 'Location' and 'Retry-After' header. The 'Location' header will provide the
         endpoint to poll to get the result of the report generation. The 'Retry-After' provides the
         duration to wait before polling for the generated report. A call to poll the report operation
         will provide a 202 response with a 'Location' header if the operation is still in progress.
         Once the report generation operation completes, the polling endpoint will provide a 200
         response along with details on the report blob(s) that are available for download. The details
-        on the file(s) available for download will be available in the polling response body.
+        on the file(s) available for download will be available in the polling response body. To
+        Understand cost details (formerly known as usage details) fields found in files ,see
+        https://learn.microsoft.com/azure/cost-management-billing/automate/understand-usage-details-fields.
+
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
 
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
         :param parameters: Parameters supplied to the Create cost details operation. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.GenerateCostDetailsReportRequestDefinition
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -182,15 +184,20 @@
         or Invoice Id asynchronously at a certain scope. The initial call to request a report will
         return a 202 with a 'Location' and 'Retry-After' header. The 'Location' header will provide the
         endpoint to poll to get the result of the report generation. The 'Retry-After' provides the
         duration to wait before polling for the generated report. A call to poll the report operation
         will provide a 202 response with a 'Location' header if the operation is still in progress.
         Once the report generation operation completes, the polling endpoint will provide a 200
         response along with details on the report blob(s) that are available for download. The details
-        on the file(s) available for download will be available in the polling response body.
+        on the file(s) available for download will be available in the polling response body. To
+        Understand cost details (formerly known as usage details) fields found in files ,see
+        https://learn.microsoft.com/azure/cost-management-billing/automate/understand-usage-details-fields.
+
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
 
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
         :param parameters: Parameters supplied to the Create cost details operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -220,21 +227,26 @@
         or Invoice Id asynchronously at a certain scope. The initial call to request a report will
         return a 202 with a 'Location' and 'Retry-After' header. The 'Location' header will provide the
         endpoint to poll to get the result of the report generation. The 'Retry-After' provides the
         duration to wait before polling for the generated report. A call to poll the report operation
         will provide a 202 response with a 'Location' header if the operation is still in progress.
         Once the report generation operation completes, the polling endpoint will provide a 200
         response along with details on the report blob(s) that are available for download. The details
-        on the file(s) available for download will be available in the polling response body.
+        on the file(s) available for download will be available in the polling response body. To
+        Understand cost details (formerly known as usage details) fields found in files ,see
+        https://learn.microsoft.com/azure/cost-management-billing/automate/understand-usage-details-fields.
+
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
 
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
-        :param parameters: Parameters supplied to the Create cost details operation. Is either a model
-         type or a IO type. Required.
+        :param parameters: Parameters supplied to the Create cost details operation. Is either a
+         GenerateCostDetailsReportRequestDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.GenerateCostDetailsReportRequestDefinition
          or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -249,24 +261,22 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.CostDetailsOperationResults]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CostDetailsOperationResults]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CostDetailsOperationResults] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._create_operation_initial(  # type: ignore
+            raw_result = await self._create_operation_initial(
                 scope=scope,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -277,31 +287,31 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("CostDetailsOperationResults", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_create_operation.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateCostDetailsReport"}  # type: ignore
+    begin_create_operation.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateCostDetailsReport"}
 
     async def _get_operation_results_initial(
         self, scope: str, operation_id: str, **kwargs: Any
     ) -> Optional[_models.CostDetailsOperationResults]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -309,32 +319,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.CostDetailsOperationResults]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.CostDetailsOperationResults]] = kwargs.pop("cls", None)
 
         request = build_get_operation_results_request(
             scope=scope,
             operation_id=operation_id,
             api_version=api_version,
             template_url=self._get_operation_results_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -345,15 +354,17 @@
             deserialized = self._deserialize("CostDetailsOperationResults", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _get_operation_results_initial.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/costDetailsOperationResults/{operationId}"}  # type: ignore
+    _get_operation_results_initial.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/costDetailsOperationResults/{operationId}"
+    }
 
     @distributed_trace_async
     async def begin_get_operation_results(
         self, scope: str, operation_id: str, **kwargs: Any
     ) -> AsyncLROPoller[_models.CostDetailsOperationResults]:
         """Get the result of the specified operation. This link is provided in the CostDetails creation
         request response Location header.
@@ -376,23 +387,21 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.CostDetailsOperationResults]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CostDetailsOperationResults]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.CostDetailsOperationResults] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._get_operation_results_initial(  # type: ignore
+            raw_result = await self._get_operation_results_initial(
                 scope=scope,
                 operation_id=operation_id,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
@@ -402,24 +411,26 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("CostDetailsOperationResults", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_get_operation_results.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/costDetailsOperationResults/{operationId}"}  # type: ignore
+    begin_get_operation_results.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/costDetailsOperationResults/{operationId}"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_alerts_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_alerts_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -29,18 +29,14 @@
 from ...operations._alerts_operations import (
     build_dismiss_request,
     build_get_request,
     build_list_external_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AlertsOperations:
     """
     .. warning::
@@ -60,14 +56,17 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace_async
     async def list(self, scope: str, **kwargs: Any) -> _models.AlertsResult:
         """Lists the alerts for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with alerts operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -93,31 +92,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.AlertsResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.AlertsResult] = kwargs.pop("cls", None)
 
         request = build_list_request(
             scope=scope,
             api_version=api_version,
             template_url=self.list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -126,20 +124,23 @@
         deserialized = self._deserialize("AlertsResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts"}
 
     @distributed_trace_async
     async def get(self, scope: str, alert_id: str, **kwargs: Any) -> _models.Alert:
         """Gets the alert for the scope by alert ID.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with alerts operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -167,32 +168,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Alert]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.Alert] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             alert_id=alert_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -201,28 +201,31 @@
         deserialized = self._deserialize("Alert", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}"}
 
     @overload
     async def dismiss(
         self,
         scope: str,
         alert_id: str,
         parameters: _models.DismissAlertPayload,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.Alert:
         """Dismisses the specified alert.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with alerts operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -251,14 +254,17 @@
 
     @overload
     async def dismiss(
         self, scope: str, alert_id: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.Alert:
         """Dismisses the specified alert.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with alerts operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -287,14 +293,17 @@
 
     @distributed_trace_async
     async def dismiss(
         self, scope: str, alert_id: str, parameters: Union[_models.DismissAlertPayload, IO], **kwargs: Any
     ) -> _models.Alert:
         """Dismisses the specified alert.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with alerts operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -306,16 +315,16 @@
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
          for invoiceSection scope, and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
          specific for partners. Required.
         :type scope: str
         :param alert_id: Alert ID. Required.
         :type alert_id: str
-        :param parameters: Parameters supplied to the Dismiss Alert operation. Is either a model type
-         or a IO type. Required.
+        :param parameters: Parameters supplied to the Dismiss Alert operation. Is either a
+         DismissAlertPayload type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.DismissAlertPayload or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Alert or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.Alert
@@ -328,24 +337,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Alert]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.Alert] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "DismissAlertPayload")
 
         request = build_dismiss_request(
             scope=scope,
             alert_id=alert_id,
@@ -354,18 +361,19 @@
             json=_json,
             content=_content,
             template_url=self.dismiss.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -374,25 +382,28 @@
         deserialized = self._deserialize("Alert", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    dismiss.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}"}  # type: ignore
+    dismiss.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}"}
 
     @distributed_trace_async
     async def list_external(
         self,
         external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
         external_cloud_provider_id: str,
         **kwargs: Any
     ) -> _models.AlertsResult:
         """Lists the Alerts for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -411,32 +422,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.AlertsResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.AlertsResult] = kwargs.pop("cls", None)
 
         request = build_list_external_request(
             external_cloud_provider_type=external_cloud_provider_type,
             external_cloud_provider_id=external_cloud_provider_id,
             api_version=api_version,
             template_url=self.list_external.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -445,8 +455,10 @@
         deserialized = self._deserialize("AlertsResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    list_external.metadata = {"url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/alerts"}  # type: ignore
+    list_external.metadata = {
+        "url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/alerts"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_reservation_details_report_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_price_sheet_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar, Union, cast
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,310 +23,298 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._generate_reservation_details_report_operations import (
-    build_by_billing_account_id_request,
-    build_by_billing_profile_id_request,
-)
+from ...operations._price_sheet_operations import build_download_by_billing_profile_request, build_download_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class GenerateReservationDetailsReportOperations:
+class PriceSheetOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.costmanagement.aio.CostManagementClient`'s
-        :attr:`generate_reservation_details_report` attribute.
+        :attr:`price_sheet` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    async def _by_billing_account_id_initial(
-        self, billing_account_id: str, start_date: str, end_date: str, **kwargs: Any
-    ) -> Optional[_models.OperationStatus]:
+    async def _download_initial(
+        self, billing_account_name: str, billing_profile_name: str, invoice_name: str, **kwargs: Any
+    ) -> Optional[_models.DownloadURL]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.OperationStatus]]
-
-        request = build_by_billing_account_id_request(
-            billing_account_id=billing_account_id,
-            start_date=start_date,
-            end_date=end_date,
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.DownloadURL]] = kwargs.pop("cls", None)
+
+        request = build_download_request(
+            billing_account_name=billing_account_name,
+            billing_profile_name=billing_profile_name,
+            invoice_name=invoice_name,
             api_version=api_version,
-            template_url=self._by_billing_account_id_initial.metadata["url"],
+            template_url=self._download_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("OperationStatus", pipeline_response)
+            deserialized = self._deserialize("DownloadURL", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
+            response_headers["Retry-After"] = self._deserialize("str", response.headers.get("Retry-After"))
+            response_headers["OData-EntityId"] = self._deserialize("str", response.headers.get("OData-EntityId"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _by_billing_account_id_initial.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"}  # type: ignore
+    _download_initial.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoices/{invoiceName}/providers/Microsoft.CostManagement/pricesheets/default/download"
+    }
 
     @distributed_trace_async
-    async def begin_by_billing_account_id(
-        self, billing_account_id: str, start_date: str, end_date: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.OperationStatus]:
-        """Generates the reservations details report for provided date range asynchronously based on
-        enrollment id. The Reservation usage details can be viewed only by certain enterprise roles.
-        For more details on the roles see,
-        https://docs.microsoft.com/en-us/azure/cost-management-billing/manage/understand-ea-roles#usage-and-costs-access-by-role.
-
-        :param billing_account_id: Enrollment ID (Legacy BillingAccount ID). Required.
-        :type billing_account_id: str
-        :param start_date: Start Date. Required.
-        :type start_date: str
-        :param end_date: End Date. Required.
-        :type end_date: str
+    async def begin_download(
+        self, billing_account_name: str, billing_profile_name: str, invoice_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[_models.DownloadURL]:
+        """Gets a URL to download the pricesheet for an invoice. The operation is supported for billing
+        accounts with agreement type Microsoft Partner Agreement or Microsoft Customer Agreement.
+
+        :param billing_account_name: The ID that uniquely identifies a billing account. Required.
+        :type billing_account_name: str
+        :param billing_profile_name: The ID that uniquely identifies a billing profile. Required.
+        :type billing_profile_name: str
+        :param invoice_name: The ID that uniquely identifies an invoice. Required.
+        :type invoice_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either OperationStatus or the result of
+        :return: An instance of AsyncLROPoller that returns either DownloadURL or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.OperationStatus]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.DownloadURL]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.OperationStatus]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.DownloadURL] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._by_billing_account_id_initial(  # type: ignore
-                billing_account_id=billing_account_id,
-                start_date=start_date,
-                end_date=end_date,
+            raw_result = await self._download_initial(
+                billing_account_name=billing_account_name,
+                billing_profile_name=billing_profile_name,
+                invoice_name=invoice_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("OperationStatus", pipeline_response)
+            deserialized = self._deserialize("DownloadURL", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_by_billing_account_id.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"}  # type: ignore
-
-    async def _by_billing_profile_id_initial(
-        self, billing_account_id: str, billing_profile_id: str, start_date: str, end_date: str, **kwargs: Any
-    ) -> Optional[_models.OperationStatus]:
+    begin_download.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoices/{invoiceName}/providers/Microsoft.CostManagement/pricesheets/default/download"
+    }
+
+    async def _download_by_billing_profile_initial(
+        self, billing_account_name: str, billing_profile_name: str, **kwargs: Any
+    ) -> Optional[_models.DownloadURL]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.OperationStatus]]
-
-        request = build_by_billing_profile_id_request(
-            billing_account_id=billing_account_id,
-            billing_profile_id=billing_profile_id,
-            start_date=start_date,
-            end_date=end_date,
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.DownloadURL]] = kwargs.pop("cls", None)
+
+        request = build_download_by_billing_profile_request(
+            billing_account_name=billing_account_name,
+            billing_profile_name=billing_profile_name,
             api_version=api_version,
-            template_url=self._by_billing_profile_id_initial.metadata["url"],
+            template_url=self._download_by_billing_profile_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("OperationStatus", pipeline_response)
+            deserialized = self._deserialize("DownloadURL", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
+            response_headers["Retry-After"] = self._deserialize("str", response.headers.get("Retry-After"))
+            response_headers["OData-EntityId"] = self._deserialize("str", response.headers.get("OData-EntityId"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _by_billing_profile_id_initial.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"}  # type: ignore
+    _download_by_billing_profile_initial.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.CostManagement/pricesheets/default/download"
+    }
 
     @distributed_trace_async
-    async def begin_by_billing_profile_id(
-        self, billing_account_id: str, billing_profile_id: str, start_date: str, end_date: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.OperationStatus]:
-        """Generates the reservations details report for provided date range asynchronously by billing
-        profile. The Reservation usage details can be viewed by only certain enterprise roles by
-        default. For more details on the roles see,
-        https://docs.microsoft.com/en-us/azure/cost-management-billing/reservations/reservation-utilization#view-utilization-in-the-azure-portal-with-azure-rbac-access.
-
-        :param billing_account_id: Billing account ID. Required.
-        :type billing_account_id: str
-        :param billing_profile_id: Billing profile ID. Required.
-        :type billing_profile_id: str
-        :param start_date: Start Date. Required.
-        :type start_date: str
-        :param end_date: End Date. Required.
-        :type end_date: str
+    async def begin_download_by_billing_profile(
+        self, billing_account_name: str, billing_profile_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[_models.DownloadURL]:
+        """Gets a URL to download the current month's pricesheet for a billing profile. The operation is
+        supported for billing accounts with agreement type Microsoft Partner Agreement or Microsoft
+        Customer Agreement.Due to Azure product growth, the Azure price sheet download experience in
+        this preview version will be updated from a single csv file to a Zip file containing multiple
+        csv files, each with max 200k records.
+
+        :param billing_account_name: The ID that uniquely identifies a billing account. Required.
+        :type billing_account_name: str
+        :param billing_profile_name: The ID that uniquely identifies a billing profile. Required.
+        :type billing_profile_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either OperationStatus or the result of
+        :return: An instance of AsyncLROPoller that returns either DownloadURL or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.OperationStatus]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.DownloadURL]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.OperationStatus]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.DownloadURL] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._by_billing_profile_id_initial(  # type: ignore
-                billing_account_id=billing_account_id,
-                billing_profile_id=billing_profile_id,
-                start_date=start_date,
-                end_date=end_date,
+            raw_result = await self._download_by_billing_profile_initial(
+                billing_account_name=billing_account_name,
+                billing_profile_name=billing_profile_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("OperationStatus", pipeline_response)
+            deserialized = self._deserialize("DownloadURL", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_by_billing_profile_id.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"}  # type: ignore
+    begin_download_by_billing_profile.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.CostManagement/pricesheets/default/download"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_price_sheet_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_reservation_details_report_operations.py`

 * *Files 25% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar, Union, cast
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,300 +23,314 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._price_sheet_operations import build_download_by_billing_profile_request, build_download_request
+from ...operations._generate_reservation_details_report_operations import (
+    build_by_billing_account_id_request,
+    build_by_billing_profile_id_request,
+)
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class PriceSheetOperations:
+class GenerateReservationDetailsReportOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.costmanagement.aio.CostManagementClient`'s
-        :attr:`price_sheet` attribute.
+        :attr:`generate_reservation_details_report` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    async def _download_initial(
-        self, billing_account_name: str, billing_profile_name: str, invoice_name: str, **kwargs: Any
-    ) -> Optional[_models.DownloadURL]:
+    async def _by_billing_account_id_initial(
+        self, billing_account_id: str, start_date: str, end_date: str, **kwargs: Any
+    ) -> Optional[_models.OperationStatus]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.DownloadURL]]
-
-        request = build_download_request(
-            billing_account_name=billing_account_name,
-            billing_profile_name=billing_profile_name,
-            invoice_name=invoice_name,
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.OperationStatus]] = kwargs.pop("cls", None)
+
+        request = build_by_billing_account_id_request(
+            billing_account_id=billing_account_id,
+            start_date=start_date,
+            end_date=end_date,
             api_version=api_version,
-            template_url=self._download_initial.metadata["url"],
+            template_url=self._by_billing_account_id_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("DownloadURL", pipeline_response)
+            deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-            response_headers["Retry-After"] = self._deserialize("str", response.headers.get("Retry-After"))
-            response_headers["OData-EntityId"] = self._deserialize("str", response.headers.get("OData-EntityId"))
+            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _download_initial.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoices/{invoiceName}/providers/Microsoft.CostManagement/pricesheets/default/download"}  # type: ignore
+    _by_billing_account_id_initial.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"
+    }
 
     @distributed_trace_async
-    async def begin_download(
-        self, billing_account_name: str, billing_profile_name: str, invoice_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.DownloadURL]:
-        """Gets a URL to download the pricesheet for an invoice. The operation is supported for billing
-        accounts with agreement type Microsoft Partner Agreement or Microsoft Customer Agreement.
-
-        :param billing_account_name: The ID that uniquely identifies a billing account. Required.
-        :type billing_account_name: str
-        :param billing_profile_name: The ID that uniquely identifies a billing profile. Required.
-        :type billing_profile_name: str
-        :param invoice_name: The ID that uniquely identifies an invoice. Required.
-        :type invoice_name: str
+    async def begin_by_billing_account_id(
+        self, billing_account_id: str, start_date: str, end_date: str, **kwargs: Any
+    ) -> AsyncLROPoller[_models.OperationStatus]:
+        """Generates the reservations details report for provided date range asynchronously based on
+        enrollment id. The Reservation usage details can be viewed only by certain enterprise roles.
+        For more details on the roles see,
+        https://docs.microsoft.com/azure/cost-management-billing/manage/understand-ea-roles#usage-and-costs-access-by-role.
+
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
+        :param billing_account_id: Enrollment ID (Legacy BillingAccount ID). Required.
+        :type billing_account_id: str
+        :param start_date: Start Date. Required.
+        :type start_date: str
+        :param end_date: End Date. Required.
+        :type end_date: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either DownloadURL or the result of
+        :return: An instance of AsyncLROPoller that returns either OperationStatus or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.DownloadURL]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.OperationStatus]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DownloadURL]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._download_initial(  # type: ignore
-                billing_account_name=billing_account_name,
-                billing_profile_name=billing_profile_name,
-                invoice_name=invoice_name,
+            raw_result = await self._by_billing_account_id_initial(
+                billing_account_id=billing_account_id,
+                start_date=start_date,
+                end_date=end_date,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("DownloadURL", pipeline_response)
+            deserialized = self._deserialize("OperationStatus", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_download.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoices/{invoiceName}/providers/Microsoft.CostManagement/pricesheets/default/download"}  # type: ignore
-
-    async def _download_by_billing_profile_initial(
-        self, billing_account_name: str, billing_profile_name: str, **kwargs: Any
-    ) -> Optional[_models.DownloadURL]:
+    begin_by_billing_account_id.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"
+    }
+
+    async def _by_billing_profile_id_initial(
+        self, billing_account_id: str, billing_profile_id: str, start_date: str, end_date: str, **kwargs: Any
+    ) -> Optional[_models.OperationStatus]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.DownloadURL]]
-
-        request = build_download_by_billing_profile_request(
-            billing_account_name=billing_account_name,
-            billing_profile_name=billing_profile_name,
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.OperationStatus]] = kwargs.pop("cls", None)
+
+        request = build_by_billing_profile_id_request(
+            billing_account_id=billing_account_id,
+            billing_profile_id=billing_profile_id,
+            start_date=start_date,
+            end_date=end_date,
             api_version=api_version,
-            template_url=self._download_by_billing_profile_initial.metadata["url"],
+            template_url=self._by_billing_profile_id_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("DownloadURL", pipeline_response)
+            deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-            response_headers["Retry-After"] = self._deserialize("str", response.headers.get("Retry-After"))
-            response_headers["OData-EntityId"] = self._deserialize("str", response.headers.get("OData-EntityId"))
+            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _download_by_billing_profile_initial.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.CostManagement/pricesheets/default/download"}  # type: ignore
+    _by_billing_profile_id_initial.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"
+    }
 
     @distributed_trace_async
-    async def begin_download_by_billing_profile(
-        self, billing_account_name: str, billing_profile_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.DownloadURL]:
-        """Gets a URL to download the current month's pricesheet for a billing profile. The operation is
-        supported for billing accounts with agreement type Microsoft Partner Agreement or Microsoft
-        Customer Agreement.Due to Azure product growth, the Azure price sheet download experience in
-        this preview version will be updated from a single csv file to a Zip file containing multiple
-        csv files, each with max 200k records.
-
-        :param billing_account_name: The ID that uniquely identifies a billing account. Required.
-        :type billing_account_name: str
-        :param billing_profile_name: The ID that uniquely identifies a billing profile. Required.
-        :type billing_profile_name: str
+    async def begin_by_billing_profile_id(
+        self, billing_account_id: str, billing_profile_id: str, start_date: str, end_date: str, **kwargs: Any
+    ) -> AsyncLROPoller[_models.OperationStatus]:
+        """Generates the reservations details report for provided date range asynchronously by billing
+        profile. The Reservation usage details can be viewed by only certain enterprise roles by
+        default. For more details on the roles see,
+        https://docs.microsoft.com/azure/cost-management-billing/reservations/reservation-utilization#view-utilization-in-the-azure-portal-with-azure-rbac-access.
+
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
+        :param billing_account_id: Billing account ID. Required.
+        :type billing_account_id: str
+        :param billing_profile_id: Billing profile ID. Required.
+        :type billing_profile_id: str
+        :param start_date: Start Date. Required.
+        :type start_date: str
+        :param end_date: End Date. Required.
+        :type end_date: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either DownloadURL or the result of
+        :return: An instance of AsyncLROPoller that returns either OperationStatus or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.DownloadURL]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.OperationStatus]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DownloadURL]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._download_by_billing_profile_initial(  # type: ignore
-                billing_account_name=billing_account_name,
-                billing_profile_name=billing_profile_name,
+            raw_result = await self._by_billing_profile_id_initial(
+                billing_account_id=billing_account_id,
+                billing_profile_id=billing_profile_id,
+                start_date=start_date,
+                end_date=end_date,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("DownloadURL", pipeline_response)
+            deserialized = self._deserialize("OperationStatus", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_download_by_billing_profile.metadata = {"url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.CostManagement/pricesheets/default/download"}  # type: ignore
+    begin_by_billing_profile_id.metadata = {
+        "url": "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_views_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_views_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -36,18 +36,14 @@
     build_delete_request,
     build_get_by_scope_request,
     build_get_request,
     build_list_by_scope_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ViewsOperations:
     """
     .. warning::
@@ -67,26 +63,27 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.View"]:
         """Lists all views by tenant and object.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either View or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.View]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ViewListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ViewListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -98,15 +95,15 @@
                 request = build_list_request(
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -114,48 +111,52 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ViewListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.CostManagement/views"}  # type: ignore
+    list.metadata = {"url": "/providers/Microsoft.CostManagement/views"}
 
     @distributed_trace
     def list_by_scope(self, scope: str, **kwargs: Any) -> AsyncIterable["_models.View"]:
         """Lists all views at the given scope.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -174,18 +175,16 @@
         :return: An iterator like instance of either View or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.View]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ViewListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ViewListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -198,15 +197,15 @@
                     scope=scope,
                     api_version=api_version,
                     template_url=self.list_by_scope.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -214,48 +213,52 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ViewListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views"}  # type: ignore
+    list_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views"}
 
     @distributed_trace_async
     async def get(self, view_name: str, **kwargs: Any) -> _models.View:
         """Gets the view by view name.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param view_name: View name. Required.
         :type view_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: View or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.View
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -266,31 +269,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.View]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.View] = kwargs.pop("cls", None)
 
         request = build_get_request(
             view_name=view_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -299,24 +301,27 @@
         deserialized = self._deserialize("View", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    get.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}
 
     @overload
     async def create_or_update(
         self, view_name: str, parameters: _models.View, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param view_name: View name. Required.
         :type view_name: str
         :param parameters: Parameters supplied to the CreateOrUpdate View operation. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.View
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -330,14 +335,17 @@
     async def create_or_update(
         self, view_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param view_name: View name. Required.
         :type view_name: str
         :param parameters: Parameters supplied to the CreateOrUpdate View operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -351,17 +359,20 @@
     async def create_or_update(
         self, view_name: str, parameters: Union[_models.View, IO], **kwargs: Any
     ) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param view_name: View name. Required.
         :type view_name: str
-        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Is either a model
+        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Is either a View
          type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.View or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: View or the result of cls(response)
@@ -375,24 +386,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.View]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.View] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "View")
 
         request = build_create_or_update_request(
             view_name=view_name,
             api_version=api_version,
@@ -400,18 +409,19 @@
             json=_json,
             content=_content,
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -420,24 +430,27 @@
         if response.status_code == 200:
             deserialized = self._deserialize("View", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("View", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    create_or_update.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    create_or_update.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}
 
     @distributed_trace_async
     async def delete(self, view_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
         """The operation to delete a view.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param view_name: View name. Required.
         :type view_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -448,49 +461,51 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             view_name=view_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    delete.metadata = {"url": "/providers/Microsoft.CostManagement/views/{viewName}"}
 
     @distributed_trace_async
     async def get_by_scope(self, scope: str, view_name: str, **kwargs: Any) -> _models.View:
         """Gets the view for the defined scope by view name.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -519,32 +534,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.View]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.View] = kwargs.pop("cls", None)
 
         request = build_get_by_scope_request(
             scope=scope,
             view_name=view_name,
             api_version=api_version,
             template_url=self.get_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -553,15 +567,15 @@
         deserialized = self._deserialize("View", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    get_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}
 
     @overload
     async def create_or_update_by_scope(
         self,
         scope: str,
         view_name: str,
         parameters: _models.View,
@@ -569,14 +583,17 @@
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -608,14 +625,17 @@
     async def create_or_update_by_scope(
         self, scope: str, view_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -647,14 +667,17 @@
     async def create_or_update_by_scope(
         self, scope: str, view_name: str, parameters: Union[_models.View, IO], **kwargs: Any
     ) -> _models.View:
         """The operation to create or update a view. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -667,15 +690,15 @@
          'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
          External Billing Account scope and
          'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
          External Subscription scope. Required.
         :type scope: str
         :param view_name: View name. Required.
         :type view_name: str
-        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Is either a model
+        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Is either a View
          type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.View or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: View or the result of cls(response)
@@ -689,24 +712,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.View]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.View] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "View")
 
         request = build_create_or_update_by_scope_request(
             scope=scope,
             view_name=view_name,
@@ -715,18 +736,19 @@
             json=_json,
             content=_content,
             template_url=self.create_or_update_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -735,26 +757,29 @@
         if response.status_code == 200:
             deserialized = self._deserialize("View", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("View", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    create_or_update_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    create_or_update_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}
 
     @distributed_trace_async
     async def delete_by_scope(  # pylint: disable=inconsistent-return-statements
         self, scope: str, view_name: str, **kwargs: Any
     ) -> None:
         """The operation to delete a view.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with view operations. This includes
          'subscriptions/{subscriptionId}' for subscription scope,
          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
          Department scope,
          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -783,38 +808,37 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_scope_request(
             scope=scope,
             view_name=view_name,
             api_version=api_version,
             template_url=self.delete_by_scope.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}  # type: ignore
+    delete_by_scope.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,18 +26,14 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._generate_detailed_cost_report_operations import build_create_operation_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class GenerateDetailedCostReportOperations:
     """
     .. warning::
@@ -67,24 +63,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.GenerateDetailedCostReportOperationResult]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[Optional[_models.GenerateDetailedCostReportOperationResult]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "GenerateDetailedCostReportDefinition")
 
         request = build_create_operation_request(
             scope=scope,
             api_version=api_version,
@@ -92,18 +86,19 @@
             json=_json,
             content=_content,
             template_url=self._create_operation_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(
@@ -127,15 +122,17 @@
             response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _create_operation_initial.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateDetailedCostReport"}  # type: ignore
+    _create_operation_initial.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/generateDetailedCostReport"
+    }
 
     @overload
     async def begin_create_operation(
         self,
         scope: str,
         parameters: _models.GenerateDetailedCostReportDefinition,
         *,
@@ -144,14 +141,17 @@
     ) -> AsyncLROPoller[_models.GenerateDetailedCostReportOperationResult]:
         """Generates the detailed cost report for provided date range, billing period(only enterprise
         customers) or Invoice ID asynchronously at a certain scope. Call returns a 202 with header
         Azure-Consumption-AsyncOperation providing a link to the operation created. A call on the
         operation will provide the status and if the operation is completed the blob file where
         generated detailed cost report is being stored.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
         :param parameters: Parameters supplied to the Create detailed cost report operation. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.GenerateDetailedCostReportDefinition
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
@@ -177,14 +177,17 @@
     ) -> AsyncLROPoller[_models.GenerateDetailedCostReportOperationResult]:
         """Generates the detailed cost report for provided date range, billing period(only enterprise
         customers) or Invoice ID asynchronously at a certain scope. Call returns a 202 with header
         Azure-Consumption-AsyncOperation providing a link to the operation created. A call on the
         operation will provide the status and if the operation is completed the blob file where
         generated detailed cost report is being stored.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
         :param parameters: Parameters supplied to the Create detailed cost report operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
@@ -210,19 +213,22 @@
     ) -> AsyncLROPoller[_models.GenerateDetailedCostReportOperationResult]:
         """Generates the detailed cost report for provided date range, billing period(only enterprise
         customers) or Invoice ID asynchronously at a certain scope. Call returns a 202 with header
         Azure-Consumption-AsyncOperation providing a link to the operation created. A call on the
         operation will provide the status and if the operation is completed the blob file where
         generated detailed cost report is being stored.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The ARM Resource ID for subscription, resource group, billing account, or other
          billing scopes. For details, see https://aka.ms/costmgmt/scopes. Required.
         :type scope: str
         :param parameters: Parameters supplied to the Create detailed cost report operation. Is either
-         a model type or a IO type. Required.
+         a GenerateDetailedCostReportDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.GenerateDetailedCostReportDefinition or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -236,24 +242,22 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.GenerateDetailedCostReportOperationResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.GenerateDetailedCostReportOperationResult]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.GenerateDetailedCostReportOperationResult] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._create_operation_initial(  # type: ignore
+            raw_result = await self._create_operation_initial(
                 scope=scope,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -264,24 +268,24 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("GenerateDetailedCostReportOperationResult", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_create_operation.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateDetailedCostReport"}  # type: ignore
+    begin_create_operation.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/generateDetailedCostReport"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_results_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_results_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar, Union, cast
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,18 +25,14 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._generate_detailed_cost_report_operation_results_operations import build_get_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class GenerateDetailedCostReportOperationResultsOperations:
     """
     .. warning::
@@ -67,32 +62,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.GenerateDetailedCostReportOperationResult]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[Optional[_models.GenerateDetailedCostReportOperationResult]] = kwargs.pop("cls", None)
 
         request = build_get_request(
             operation_id=operation_id,
             scope=scope,
             api_version=api_version,
             template_url=self._get_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -103,15 +97,15 @@
             deserialized = self._deserialize("GenerateDetailedCostReportOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _get_initial.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationResults/{operationId}"}  # type: ignore
+    _get_initial.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationResults/{operationId}"}
 
     @distributed_trace_async
     async def begin_get(
         self, operation_id: str, scope: str, **kwargs: Any
     ) -> AsyncLROPoller[_models.GenerateDetailedCostReportOperationResult]:
         """Gets the result of the specified operation. The link with this operationId is provided as a
         response header of the initial request.
@@ -134,23 +128,21 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.costmanagement.models.GenerateDetailedCostReportOperationResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.GenerateDetailedCostReportOperationResult]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.GenerateDetailedCostReportOperationResult] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._get_initial(  # type: ignore
+            raw_result = await self._get_initial(
                 operation_id=operation_id,
                 scope=scope,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
@@ -160,22 +152,22 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("GenerateDetailedCostReportOperationResult", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
+            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationResults/{operationId}"}  # type: ignore
+    begin_get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationResults/{operationId}"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_dimensions_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_dimensions_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar, Union
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._dimensions_operations import build_by_external_cloud_provider_type_request, build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DimensionsOperations:
     """
     .. warning::
@@ -65,14 +60,17 @@
         expand: Optional[str] = None,
         skiptoken: Optional[str] = None,
         top: Optional[int] = None,
         **kwargs: Any
     ) -> AsyncIterable["_models.Dimension"]:
         """Lists the dimensions by the defined scope.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with dimension operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -105,18 +103,16 @@
         :return: An iterator like instance of either Dimension or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.Dimension]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DimensionsListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.DimensionsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -133,15 +129,15 @@
                     top=top,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -149,57 +145,61 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DimensionsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200, 204]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/dimensions"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/dimensions"}
 
     @distributed_trace
     def by_external_cloud_provider_type(
         self,
         external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
         external_cloud_provider_id: str,
         filter: Optional[str] = None,
         expand: Optional[str] = None,
         skiptoken: Optional[str] = None,
         top: Optional[int] = None,
         **kwargs: Any
     ) -> AsyncIterable["_models.Dimension"]:
         """Lists the dimensions by the external cloud provider type.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -225,18 +225,16 @@
         :return: An iterator like instance of either Dimension or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.costmanagement.models.Dimension]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DimensionsListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.DimensionsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -254,15 +252,15 @@
                     top=top,
                     api_version=api_version,
                     template_url=self.by_external_cloud_provider_type.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -270,36 +268,39 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)  # type: ignore
+                request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DimensionsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    by_external_cloud_provider_type.metadata = {"url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/dimensions"}  # type: ignore
+    by_external_cloud_provider_type.metadata = {
+        "url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/dimensions"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_exports_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_exports_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -31,18 +31,14 @@
     build_delete_request,
     build_execute_request,
     build_get_execution_history_request,
     build_get_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ExportsOperations:
     """
     .. warning::
@@ -62,14 +58,17 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace_async
     async def list(self, scope: str, expand: Optional[str] = None, **kwargs: Any) -> _models.ExportListResult:
         """The operation to list all exports at the given scope.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -99,32 +98,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ExportListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ExportListResult] = kwargs.pop("cls", None)
 
         request = build_list_request(
             scope=scope,
             expand=expand,
             api_version=api_version,
             template_url=self.list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -133,20 +131,23 @@
         deserialized = self._deserialize("ExportListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports"}
 
     @distributed_trace_async
     async def get(self, scope: str, export_name: str, expand: Optional[str] = None, **kwargs: Any) -> _models.Export:
         """The operation to get the export for the defined scope by export name.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -178,33 +179,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Export]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.Export] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             export_name=export_name,
             expand=expand,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -213,15 +213,15 @@
         deserialized = self._deserialize("Export", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}
 
     @overload
     async def create_or_update(
         self,
         scope: str,
         export_name: str,
         parameters: _models.Export,
@@ -229,14 +229,17 @@
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.Export:
         """The operation to create or update a export. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -267,14 +270,17 @@
     async def create_or_update(
         self, scope: str, export_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.Export:
         """The operation to create or update a export. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -305,14 +311,17 @@
     async def create_or_update(
         self, scope: str, export_name: str, parameters: Union[_models.Export, IO], **kwargs: Any
     ) -> _models.Export:
         """The operation to create or update a export. Update operation requires latest eTag to be set in
         the request. You may obtain the latest eTag by performing a get operation. Create operation
         does not require eTag.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -325,15 +334,15 @@
          for invoiceSection scope, and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
          specific for partners. Required.
         :type scope: str
         :param export_name: Export Name. Required.
         :type export_name: str
         :param parameters: Parameters supplied to the CreateOrUpdate Export operation. Is either a
-         model type or a IO type. Required.
+         Export type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.Export or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Export or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.Export
@@ -346,24 +355,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Export]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.Export] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Export")
 
         request = build_create_or_update_request(
             scope=scope,
             export_name=export_name,
@@ -372,18 +379,19 @@
             json=_json,
             content=_content,
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -392,26 +400,29 @@
         if response.status_code == 200:
             deserialized = self._deserialize("Export", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Export", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
-    create_or_update.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}  # type: ignore
+    create_or_update.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}
 
     @distributed_trace_async
     async def delete(  # pylint: disable=inconsistent-return-statements
         self, scope: str, export_name: str, **kwargs: Any
     ) -> None:
         """The operation to delete a export.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -439,52 +450,54 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             export_name=export_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"}
 
     @distributed_trace_async
     async def execute(  # pylint: disable=inconsistent-return-statements
         self, scope: str, export_name: str, **kwargs: Any
     ) -> None:
         """The operation to run an export.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -512,52 +525,54 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_execute_request(
             scope=scope,
             export_name=export_name,
             api_version=api_version,
             template_url=self.execute.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    execute.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/run"}  # type: ignore
+    execute.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/run"}
 
     @distributed_trace_async
     async def get_execution_history(
         self, scope: str, export_name: str, **kwargs: Any
     ) -> _models.ExportExecutionListResult:
         """The operation to get the run history of an export for the defined scope and export name.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -585,32 +600,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ExportExecutionListResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ExportExecutionListResult] = kwargs.pop("cls", None)
 
         request = build_get_execution_history_request(
             scope=scope,
             export_name=export_name,
             api_version=api_version,
             template_url=self.get_execution_history.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -619,8 +633,10 @@
         deserialized = self._deserialize("ExportExecutionListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_execution_history.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/runHistory"}  # type: ignore
+    get_execution_history.metadata = {
+        "url": "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/runHistory"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_query_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_query_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,18 +24,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._query_operations import build_usage_by_external_cloud_provider_type_request, build_usage_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class QueryOperations:
     """
     .. warning::
@@ -57,14 +53,17 @@
 
     @overload
     async def usage(
         self, scope: str, parameters: _models.QueryDefinition, *, content_type: str = "application/json", **kwargs: Any
     ) -> Optional[_models.QueryResult]:
         """Query the usage data for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with query and export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -91,14 +90,17 @@
 
     @overload
     async def usage(
         self, scope: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> Optional[_models.QueryResult]:
         """Query the usage data for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with query and export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -125,14 +127,17 @@
 
     @distributed_trace_async
     async def usage(
         self, scope: str, parameters: Union[_models.QueryDefinition, IO], **kwargs: Any
     ) -> Optional[_models.QueryResult]:
         """Query the usage data for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with query and export operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -143,15 +148,15 @@
          for billingProfile scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
          for invoiceSection scope, and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
          specific for partners. Required.
         :type scope: str
         :param parameters: Parameters supplied to the CreateOrUpdate Query Config operation. Is either
-         a model type or a IO type. Required.
+         a QueryDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.QueryDefinition or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: QueryResult or None or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.QueryResult or None
@@ -164,24 +169,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.QueryResult]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[Optional[_models.QueryResult]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "QueryDefinition")
 
         request = build_usage_request(
             scope=scope,
             api_version=api_version,
@@ -189,18 +192,19 @@
             json=_json,
             content=_content,
             template_url=self.usage.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -211,28 +215,31 @@
             deserialized = self._deserialize("QueryResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    usage.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/query"}  # type: ignore
+    usage.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/query"}
 
     @overload
     async def usage_by_external_cloud_provider_type(
         self,
         external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
         external_cloud_provider_id: str,
         parameters: _models.QueryDefinition,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.QueryResult:
         """Query the usage data for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -258,14 +265,17 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.QueryResult:
         """Query the usage data for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -289,26 +299,29 @@
         external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
         external_cloud_provider_id: str,
         parameters: Union[_models.QueryDefinition, IO],
         **kwargs: Any
     ) -> _models.QueryResult:
         """Query the usage data for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
          '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
          Required.
         :type external_cloud_provider_id: str
         :param parameters: Parameters supplied to the CreateOrUpdate Query Config operation. Is either
-         a model type or a IO type. Required.
+         a QueryDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.QueryDefinition or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: QueryResult or the result of cls(response)
         :rtype: ~azure.mgmt.costmanagement.models.QueryResult
@@ -321,24 +334,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.QueryResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.QueryResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "QueryDefinition")
 
         request = build_usage_by_external_cloud_provider_type_request(
             external_cloud_provider_type=external_cloud_provider_type,
             external_cloud_provider_id=external_cloud_provider_id,
@@ -347,18 +358,19 @@
             json=_json,
             content=_content,
             template_url=self.usage_by_external_cloud_provider_type.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -367,8 +379,10 @@
         deserialized = self._deserialize("QueryResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    usage_by_external_cloud_provider_type.metadata = {"url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/query"}  # type: ignore
+    usage_by_external_cloud_provider_type.metadata = {
+        "url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/query"
+    }
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_status_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_generate_detailed_cost_report_operation_status_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,18 +23,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._generate_detailed_cost_report_operation_status_operations import build_get_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class GenerateDetailedCostReportOperationStatusOperations:
     """
     .. warning::
@@ -79,32 +74,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.GenerateDetailedCostReportOperationStatuses]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.GenerateDetailedCostReportOperationStatuses] = kwargs.pop("cls", None)
 
         request = build_get_request(
             operation_id=operation_id,
             scope=scope,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -113,8 +107,8 @@
         deserialized = self._deserialize("GenerateDetailedCostReportOperationStatuses", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationStatus/{operationId}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/operationStatus/{operationId}"}
```

## Comparing `azure-mgmt-costmanagement-4.0.0b1/azure/mgmt/costmanagement/aio/operations/_forecast_operations.py` & `azure-mgmt-costmanagement-4.0.1/azure/mgmt/costmanagement/aio/operations/_forecast_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,18 +24,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._forecast_operations import build_external_cloud_provider_usage_request, build_usage_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ForecastOperations:
     """
     .. warning::
@@ -63,14 +59,17 @@
         filter: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Optional[_models.ForecastResult]:
         """Lists the forecast charges for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with forecast operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -108,14 +107,17 @@
         filter: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> Optional[_models.ForecastResult]:
         """Lists the forecast charges for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with forecast operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -147,14 +149,17 @@
 
     @distributed_trace_async
     async def usage(
         self, scope: str, parameters: Union[_models.ForecastDefinition, IO], filter: Optional[str] = None, **kwargs: Any
     ) -> Optional[_models.ForecastResult]:
         """Lists the forecast charges for scope defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param scope: The scope associated with forecast operations. This includes
          '/subscriptions/{subscriptionId}/' for subscription scope,
          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
          for Department scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
@@ -165,15 +170,15 @@
          for billingProfile scope,
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
          for invoiceSection scope, and
          '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
          specific for partners. Required.
         :type scope: str
         :param parameters: Parameters supplied to the CreateOrUpdate Forecast Config operation. Is
-         either a model type or a IO type. Required.
+         either a ForecastDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.ForecastDefinition or IO
         :param filter: May be used to filter forecasts by properties/usageDate (Utc time),
          properties/chargeType or properties/grain. The filter supports 'eq', 'lt', 'gt', 'le', 'ge',
          and 'and'. It does not currently support 'ne', 'or', or 'not'. Default value is None.
         :type filter: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -190,24 +195,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.ForecastResult]]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[Optional[_models.ForecastResult]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ForecastDefinition")
 
         request = build_usage_request(
             scope=scope,
             filter=filter,
@@ -216,18 +219,19 @@
             json=_json,
             content=_content,
             template_url=self.usage.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -238,29 +242,32 @@
             deserialized = self._deserialize("ForecastResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    usage.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/forecast"}  # type: ignore
+    usage.metadata = {"url": "/{scope}/providers/Microsoft.CostManagement/forecast"}
 
     @overload
     async def external_cloud_provider_usage(
         self,
         external_cloud_provider_type: Union[str, _models.ExternalCloudProviderType],
         external_cloud_provider_id: str,
         parameters: _models.ForecastDefinition,
         filter: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ForecastResult:
         """Lists the forecast charges for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -292,14 +299,17 @@
         filter: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ForecastResult:
         """Lists the forecast charges for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
@@ -329,26 +339,29 @@
         external_cloud_provider_id: str,
         parameters: Union[_models.ForecastDefinition, IO],
         filter: Optional[str] = None,
         **kwargs: Any
     ) -> _models.ForecastResult:
         """Lists the forecast charges for external cloud provider type defined.
 
+        .. seealso::
+           - https://docs.microsoft.com/en-us/rest/api/costmanagement/
+
         :param external_cloud_provider_type: The external cloud provider type associated with
          dimension/query operations. This includes 'externalSubscriptions' for linked account and
          'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
          and "externalBillingAccounts". Required.
         :type external_cloud_provider_type: str or
          ~azure.mgmt.costmanagement.models.ExternalCloudProviderType
         :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
          '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
          Required.
         :type external_cloud_provider_id: str
         :param parameters: Parameters supplied to the CreateOrUpdate Forecast Config operation. Is
-         either a model type or a IO type. Required.
+         either a ForecastDefinition type or a IO type. Required.
         :type parameters: ~azure.mgmt.costmanagement.models.ForecastDefinition or IO
         :param filter: May be used to filter forecasts by properties/usageDate (Utc time),
          properties/chargeType or properties/grain. The filter supports 'eq', 'lt', 'gt', 'le', 'ge',
          and 'and'. It does not currently support 'ne', 'or', or 'not'. Default value is None.
         :type filter: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -365,24 +378,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )  # type: Literal["2022-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ForecastResult]
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.ForecastResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ForecastDefinition")
 
         request = build_external_cloud_provider_usage_request(
             external_cloud_provider_type=external_cloud_provider_type,
             external_cloud_provider_id=external_cloud_provider_id,
@@ -392,18 +403,19 @@
             json=_json,
             content=_content,
             template_url=self.external_cloud_provider_usage.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)  # type: ignore
+        request.url = self._client.format_url(request.url)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -412,8 +424,10 @@
         deserialized = self._deserialize("ForecastResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    external_cloud_provider_usage.metadata = {"url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/forecast"}  # type: ignore
+    external_cloud_provider_usage.metadata = {
+        "url": "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/forecast"
+    }
```

