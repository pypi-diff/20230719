# Comparing `tmp/gmsaas-1.7.1-py3-none-win_amd64.whl.zip` & `tmp/gmsaas-1.8.0-py3-none-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,51 +1,57 @@
-Zip file size: 6231289 bytes, number of entries: 49
--rw-rw-rw-  2.0 fat     1237 b- defN 22-Aug-25 19:24 gmsaas/__init__.py
+Zip file size: 6243709 bytes, number of entries: 55
+-rw-rw-rw-  2.0 fat     1237 b- defN 23-Jul-18 12:45 gmsaas/__init__.py
 -rw-rw-rw-  2.0 fat     1618 b- defN 22-Feb-01 09:20 gmsaas/adbtunnel/__init__.py
 -rw-rw-rw-  2.0 fat     1975 b- defN 22-Feb-01 09:20 gmsaas/adbtunnel/adbclient.py
--rw-rw-rw-  2.0 fat     7604 b- defN 22-Feb-02 21:00 gmsaas/adbtunnel/adbtunnelclient.py
--rw-rw-rw-  2.0 fat  6631064 b- defN 22-Aug-29 18:50 gmsaas/adbtunnel/gmadbtunneld/Qt5Core.dll
+-rw-rw-rw-  2.0 fat     7604 b- defN 22-Dec-16 02:53 gmsaas/adbtunnel/adbtunnelclient.py
+-rw-rw-rw-  2.0 fat  6631064 b- defN 23-Jul-18 15:38 gmsaas/adbtunnel/gmadbtunneld/Qt5Core.dll
 -rw-rw-rw-  2.0 fat  1891992 b- defN 20-Mar-31 15:23 gmsaas/adbtunnel/gmadbtunneld/Qt5Network.dll
 -rw-rw-rw-  2.0 fat   184984 b- defN 20-Mar-31 16:47 gmsaas/adbtunnel/gmadbtunneld/Qt5WebSockets.dll
--rw-rw-rw-  2.0 fat  1424912 b- defN 22-Aug-29 18:50 gmsaas/adbtunnel/gmadbtunneld/gmadbtunneld.exe
--rw-rw-rw-  2.0 fat  2892302 b- defN 22-Aug-29 18:50 gmsaas/adbtunnel/gmadbtunneld/libcrypto-1_1.dll
+-rw-rw-rw-  2.0 fat  1424912 b- defN 23-Jul-18 15:38 gmsaas/adbtunnel/gmadbtunneld/gmadbtunneld.exe
+-rw-rw-rw-  2.0 fat  2892302 b- defN 23-Jul-18 15:38 gmsaas/adbtunnel/gmadbtunneld/libcrypto-1_1.dll
 -rw-rw-rw-  2.0 fat   113678 b- defN 18-Mar-19 13:12 gmsaas/adbtunnel/gmadbtunneld/libgcc_s_dw2-1.dll
--rw-rw-rw-  2.0 fat   582670 b- defN 22-Aug-29 18:50 gmsaas/adbtunnel/gmadbtunneld/libssl-1_1.dll
+-rw-rw-rw-  2.0 fat   582670 b- defN 23-Jul-18 15:38 gmsaas/adbtunnel/gmadbtunneld/libssl-1_1.dll
 -rw-rw-rw-  2.0 fat  1542158 b- defN 18-Mar-19 13:12 gmsaas/adbtunnel/gmadbtunneld/libstdc++-6.dll
 -rw-rw-rw-  2.0 fat    47104 b- defN 18-Mar-19 13:12 gmsaas/adbtunnel/gmadbtunneld/libwinpthread-1.dll
 -rw-rw-rw-  2.0 fat      630 b- defN 21-Apr-27 12:22 gmsaas/cli/__init__.py
--rw-rw-rw-  2.0 fat     2267 b- defN 21-Apr-27 12:22 gmsaas/cli/auth.py
+-rw-rw-rw-  2.0 fat     2259 b- defN 23-Jul-18 12:45 gmsaas/cli/auth.py
 -rw-rw-rw-  2.0 fat     2493 b- defN 22-Feb-01 09:20 gmsaas/cli/checks.py
--rw-rw-rw-  2.0 fat     3894 b- defN 21-Apr-27 12:22 gmsaas/cli/cli.py
--rw-rw-rw-  2.0 fat    12060 b- defN 21-Apr-27 12:22 gmsaas/cli/clioutput.py
--rw-rw-rw-  2.0 fat     4129 b- defN 22-Feb-01 09:20 gmsaas/cli/config.py
--rw-rw-rw-  2.0 fat     7468 b- defN 21-Apr-27 12:22 gmsaas/cli/instances.py
--rw-rw-rw-  2.0 fat     1095 b- defN 22-Feb-02 21:00 gmsaas/cli/logzip.py
--rw-rw-rw-  2.0 fat     1495 b- defN 21-Apr-27 12:22 gmsaas/cli/recipes.py
+-rw-rw-rw-  2.0 fat     4136 b- defN 23-Jul-18 12:45 gmsaas/cli/cli.py
+-rw-rw-rw-  2.0 fat    18043 b- defN 23-Jul-18 12:45 gmsaas/cli/clioutput.py
+-rw-rw-rw-  2.0 fat     4096 b- defN 23-Jul-18 12:45 gmsaas/cli/config.py
+-rw-rw-rw-  2.0 fat     4054 b- defN 23-Jul-18 12:45 gmsaas/cli/hwprofiles.py
+-rw-rw-rw-  2.0 fat    11981 b- defN 23-Jul-18 12:45 gmsaas/cli/instances.py
+-rw-rw-rw-  2.0 fat     2510 b- defN 23-Jul-18 12:45 gmsaas/cli/logzip.py
+-rw-rw-rw-  2.0 fat     2787 b- defN 23-Jul-18 12:45 gmsaas/cli/osimages.py
+-rw-rw-rw-  2.0 fat     3723 b- defN 23-Jul-18 12:45 gmsaas/cli/recipes.py
 -rw-rw-rw-  2.0 fat      618 b- defN 21-Apr-27 12:22 gmsaas/gmsaas/__init__.py
--rw-rw-rw-  2.0 fat    12160 b- defN 22-Feb-02 15:45 gmsaas/gmsaas/errors.py
--rw-rw-rw-  2.0 fat     2266 b- defN 22-Feb-02 21:00 gmsaas/gmsaas/logger.py
+-rw-rw-rw-  2.0 fat    12392 b- defN 23-Jul-18 12:45 gmsaas/gmsaas/errors.py
+-rw-rw-rw-  2.0 fat     2266 b- defN 22-Dec-16 02:53 gmsaas/gmsaas/logger.py
 -rw-rw-rw-  2.0 fat     3039 b- defN 21-Apr-27 12:22 gmsaas/gmsaas/proxy.py
--rw-rw-rw-  2.0 fat     1614 b- defN 21-Apr-27 12:22 gmsaas/gmsaas/timeout.py
+-rw-rw-rw-  2.0 fat     1757 b- defN 23-Jul-18 12:45 gmsaas/gmsaas/timeout.py
 -rw-rw-rw-  2.0 fat     1858 b- defN 21-Apr-27 12:22 gmsaas/gmsaas/triggererrors.py
 -rw-rw-rw-  2.0 fat      587 b- defN 21-Apr-27 12:22 gmsaas/model/__init__.py
 -rw-rw-rw-  2.0 fat      758 b- defN 21-Apr-27 12:22 gmsaas/model/daemoninfo.py
--rw-rw-rw-  2.0 fat     9212 b- defN 21-Sep-29 11:35 gmsaas/model/instanceinfo.py
--rw-rw-rw-  2.0 fat     5394 b- defN 21-Apr-27 12:22 gmsaas/model/recipeinfo.py
+-rw-rw-rw-  2.0 fat     6968 b- defN 23-Jul-18 12:45 gmsaas/model/hwprofileinfo.py
+-rw-rw-rw-  2.0 fat    10129 b- defN 23-Jul-18 12:45 gmsaas/model/instanceinfo.py
+-rw-rw-rw-  2.0 fat     4799 b- defN 23-Jul-18 12:45 gmsaas/model/osimageinfo.py
+-rw-rw-rw-  2.0 fat     6377 b- defN 23-Jul-18 12:45 gmsaas/model/recipeinfo.py
 -rw-rw-rw-  2.0 fat      811 b- defN 21-Apr-27 12:22 gmsaas/saas/__init__.py
--rw-rw-rw-  2.0 fat     1792 b- defN 21-Apr-27 12:22 gmsaas/saas/api.py
--rw-rw-rw-  2.0 fat    14695 b- defN 22-Feb-02 21:00 gmsaas/saas/client.py
--rw-rw-rw-  2.0 fat     5715 b- defN 22-Feb-02 21:00 gmsaas/saas/logcollector.py
--rw-rw-rw-  2.0 fat     7436 b- defN 21-Apr-27 12:22 gmsaas/saas/sioclient.py
--rw-rw-rw-  2.0 fat     1178 b- defN 21-Apr-27 12:22 gmsaas/storage/__init__.py
--rw-rw-rw-  2.0 fat     3009 b- defN 21-Sep-30 02:53 gmsaas/storage/authcache.py
--rw-rw-rw-  2.0 fat     1919 b- defN 21-Apr-27 12:22 gmsaas/storage/configcache.py
+-rw-rw-rw-  2.0 fat     3695 b- defN 23-Jul-18 12:45 gmsaas/saas/api.py
+-rw-rw-rw-  2.0 fat    26519 b- defN 23-Jul-18 12:45 gmsaas/saas/client.py
+-rw-rw-rw-  2.0 fat     5915 b- defN 23-Jul-18 12:45 gmsaas/saas/logcollector.py
+-rw-rw-rw-  2.0 fat     7909 b- defN 23-Jul-18 12:45 gmsaas/saas/sioclient.py
+-rw-rw-rw-  2.0 fat     1178 b- defN 22-Dec-16 02:53 gmsaas/storage/__init__.py
+-rw-rw-rw-  2.0 fat     3009 b- defN 22-Dec-16 02:53 gmsaas/storage/authcache.py
+-rw-rw-rw-  2.0 fat     1919 b- defN 22-Dec-16 02:53 gmsaas/storage/configcache.py
 -rw-rw-rw-  2.0 fat     1931 b- defN 21-Apr-27 12:22 gmsaas/storage/crypto.py
--rw-rw-rw-  2.0 fat     2467 b- defN 22-Jul-27 02:53 gmsaas/storage/json_file_storage.py
+-rw-rw-rw-  2.0 fat     2467 b- defN 22-Dec-16 02:53 gmsaas/storage/json_file_storage.py
 -rw-rw-rw-  2.0 fat     2863 b- defN 22-Jul-27 02:53 gmsaas/storage/settings.py
--rw-rw-rw-  2.0 fat     1990 b- defN 21-Apr-27 12:22 gmsaas/storage/storage.py
--rw-rw-rw-  2.0 fat     4724 b- defN 22-Aug-29 18:52 gmsaas-1.7.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      103 b- defN 22-Aug-29 18:52 gmsaas-1.7.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       48 b- defN 22-Aug-29 18:52 gmsaas-1.7.1.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat        7 b- defN 22-Aug-29 18:52 gmsaas-1.7.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     4177 b- defN 22-Aug-29 18:52 gmsaas-1.7.1.dist-info/RECORD
-49 files, 15451200 bytes uncompressed, 6224695 bytes compressed:  59.7%
+-rw-rw-rw-  2.0 fat     1990 b- defN 22-Dec-16 02:53 gmsaas/storage/storage.py
+-rw-rw-rw-  2.0 fat      587 b- defN 23-Jul-18 12:45 gmsaas/utils/__init__.py
+-rw-rw-rw-  2.0 fat     1772 b- defN 23-Jul-18 12:45 gmsaas/utils/dictionnary.py
+-rw-rw-rw-  2.0 fat     5439 b- defN 23-Jul-18 15:39 gmsaas-1.8.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      103 b- defN 23-Jul-18 15:39 gmsaas-1.8.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       48 b- defN 23-Jul-18 15:39 gmsaas-1.8.0.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat        7 b- defN 23-Jul-18 15:39 gmsaas-1.8.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     4673 b- defN 23-Jul-18 15:39 gmsaas-1.8.0.dist-info/RECORD
+55 files, 15504393 bytes uncompressed, 6236353 bytes compressed:  59.8%
```

## zipnote {}

```diff
@@ -51,20 +51,26 @@
 
 Filename: gmsaas/cli/clioutput.py
 Comment: 
 
 Filename: gmsaas/cli/config.py
 Comment: 
 
+Filename: gmsaas/cli/hwprofiles.py
+Comment: 
+
 Filename: gmsaas/cli/instances.py
 Comment: 
 
 Filename: gmsaas/cli/logzip.py
 Comment: 
 
+Filename: gmsaas/cli/osimages.py
+Comment: 
+
 Filename: gmsaas/cli/recipes.py
 Comment: 
 
 Filename: gmsaas/gmsaas/__init__.py
 Comment: 
 
 Filename: gmsaas/gmsaas/errors.py
@@ -84,17 +90,23 @@
 
 Filename: gmsaas/model/__init__.py
 Comment: 
 
 Filename: gmsaas/model/daemoninfo.py
 Comment: 
 
+Filename: gmsaas/model/hwprofileinfo.py
+Comment: 
+
 Filename: gmsaas/model/instanceinfo.py
 Comment: 
 
+Filename: gmsaas/model/osimageinfo.py
+Comment: 
+
 Filename: gmsaas/model/recipeinfo.py
 Comment: 
 
 Filename: gmsaas/saas/__init__.py
 Comment: 
 
 Filename: gmsaas/saas/api.py
@@ -126,23 +138,29 @@
 
 Filename: gmsaas/storage/settings.py
 Comment: 
 
 Filename: gmsaas/storage/storage.py
 Comment: 
 
-Filename: gmsaas-1.7.1.dist-info/METADATA
+Filename: gmsaas/utils/__init__.py
+Comment: 
+
+Filename: gmsaas/utils/dictionnary.py
+Comment: 
+
+Filename: gmsaas-1.8.0.dist-info/METADATA
 Comment: 
 
-Filename: gmsaas-1.7.1.dist-info/WHEEL
+Filename: gmsaas-1.8.0.dist-info/WHEEL
 Comment: 
 
-Filename: gmsaas-1.7.1.dist-info/entry_points.txt
+Filename: gmsaas-1.8.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: gmsaas-1.7.1.dist-info/top_level.txt
+Filename: gmsaas-1.8.0.dist-info/top_level.txt
 Comment: 
 
-Filename: gmsaas-1.7.1.dist-info/RECORD
+Filename: gmsaas-1.8.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## gmsaas/__init__.py

```diff
@@ -11,15 +11,15 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """ gmsaas package """
 import os
 
 __application__ = "gmsaas"
-__version__ = os.environ.get("GMSAAS_VERSION", "1.7.1")
+__version__ = os.environ.get("GMSAAS_VERSION", "1.8.0")
 
 
 def get_name():
     """ Return gmsaas application name """
     return __application__
```

## gmsaas/adbtunnel/gmadbtunneld/gmadbtunneld.exe

```diff
@@ -2,20 +2,20 @@
 00000010: b800 0000 0000 0000 4000 0000 0000 0000  ........@.......
 00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 00000030: 0000 0000 0000 0000 0000 0000 8000 0000  ................
 00000040: 0e1f ba0e 00b4 09cd 21b8 014c cd21 5468  ........!..L.!Th
 00000050: 6973 2070 726f 6772 616d 2063 616e 6e6f  is program canno
 00000060: 7420 6265 2072 756e 2069 6e20 444f 5320  t be run in DOS 
 00000070: 6d6f 6465 2e0d 0d0a 2400 0000 0000 0000  mode....$.......
-00000080: 5045 0000 4c01 0e00 850a 0d63 003c 0800  PE..L......c.<..
+00000080: 5045 0000 4c01 0e00 f1b1 b664 003c 0800  PE..L......d.<..
 00000090: 3b50 0000 e000 0701 0b01 021e 00d4 0400  ;P..............
 000000a0: 000e 0800 0006 0000 a014 0000 0010 0000  ................
 000000b0: 00f0 0400 0000 4000 0010 0000 0002 0000  ......@.........
 000000c0: 0400 0000 0000 0000 0400 0000 0000 0000  ................
-000000d0: 00e0 0800 0004 0000 00f5 1500 0300 0000  ................
+000000d0: 00e0 0800 0004 0000 159e 1600 0300 0000  ................
 000000e0: 0000 2000 0010 0000 0000 1000 0010 0000  .. .............
 000000f0: 0000 0000 1000 0000 0000 0000 0000 0000  ................
 00000100: 00c0 0700 c885 0000 0000 0000 0000 0000  ................
 00000110: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 00000120: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 00000130: 0000 0000 0000 0000 0000 0000 0000 0000  ................
 00000140: ac75 0500 1800 0000 0000 0000 0000 0000  .u..............
@@ -19920,15 +19920,15 @@
 0004dcf0: 6469 7363 6f6e 6e65 6374 0000 6765 7469  disconnect..geti
 0004dd00: 6e73 7461 6e63 6573 0000 0000 6164 622d  nstances....adb-
 0004dd10: 7365 7269 616c 2d70 6f72 7400 0200 0000  serial-port.....
 0004dd20: 636f 6e66 6972 6d69 6e67 7373 6c65 7272  confirmingsslerr
 0004dd30: 6f72 7300 4765 6e79 6d6f 6269 6c65 0000  ors.Genymobile..
 0004dd40: 6765 6e79 6d6f 6269 6c65 2e63 6f6d 0000  genymobile.com..
 0004dd50: 676d 6164 6274 756e 6e65 6c64 0000 0000  gmadbtunneld....
-0004dd60: 0000 0000 0100 0000 312e 372e 3100 474d  ........1.7.1.GM
+0004dd60: 0000 0000 0100 0000 312e 382e 3000 474d  ........1.8.0.GM
 0004dd70: 4144 4254 554e 4e45 4c44 5f56 4552 5349  ADBTUNNELD_VERSI
 0004dd80: 4f4e 0047 4d53 4141 535f 434f 4e46 4947  ON.GMSAAS_CONFIG
 0004dd90: 5f48 4f4d 4500 7e2f 0000 0000 474d 5341  _HOME.~/....GMSA
 0004dda0: 4153 5f43 4f4e 4649 475f 484f 4d45 2069  AS_CONFIG_HOME i
 0004ddb0: 7320 7365 7420 746f 2027 2573 2720 6275  s set to '%s' bu
 0004ddc0: 7420 6d75 7374 2062 6520 616e 2061 6273  t must be an abs
 0004ddd0: 6f6c 7574 6520 7061 7468 2e00 2e00 0000  olute path......
```

## gmsaas/cli/auth.py

```diff
@@ -23,33 +23,34 @@
 from gmsaas.cli.clioutput import ui
 
 
 def _logout():
     adbtunnel = get_adbtunnel()
     if adbtunnel.is_ready():
         adbtunnel.stop()
+    saas = get_client(authcache.get_email(), authcache.get_password())
+    saas.logout()
     authcache.clear()
 
 
 @click.group()
 def auth():
     """
-    Manage your Genymotion Cloud SaaS credentials
+    Authentication commands
     """
 
 
 @click.command(
-    "login",
-    short_help="Allows you to input your Genymotion Cloud SaaS credentials, ensure their validity, and store them",
+    "login", help="Authenticate with your credentials.",
 )
 @click.argument("email")
 @click.argument("password", required=False)
 def auth_login(email, password):
     """
-    Allows you to input your Genymotion Cloud SaaS credentials, ensure their validity, and store them
+    Authenticate with you credentials
     """
     # Note: `short_help` makes help text not being truncated to 45 char, don't remove it.
     if not password:
         password = click.prompt("Password", type=click.STRING, hide_input=True)
 
     _logout()
 
@@ -59,26 +60,26 @@
     authcache.set_email(email)
     authcache.set_password(password)
     authcache.set_jwt(jwt)
 
     ui().auth_login(email, authcache.get_path())
 
 
-@click.command("whoami")
+@click.command("whoami", help="Display current authenticated user.")
 def auth_whoami():
     """
-    Display credentials currently in use
+    Display current authenticated user
     """
     ui().auth_whoami(authcache.get_email(), authcache.get_path())
 
 
-@click.command("logout")
+@click.command("logout", help="Disconnect current user.")
 def auth_logout():
     """
-    Remove stored credentials and clean up
+    Disconnect current user
     """
     _logout()
     ui().auth_logout()
 
 
 auth.add_command(auth_login)
 auth.add_command(auth_whoami)
```

## gmsaas/cli/cli.py

```diff
@@ -19,16 +19,18 @@
 
 import click
 
 import gmsaas
 from gmsaas.cli.clioutput import ui
 from gmsaas.cli.auth import auth
 from gmsaas.cli.config import config
+from gmsaas.cli.hwprofiles import hwprofiles_cmd_group
 from gmsaas.storage.configcache import PROXY_KEY
 from gmsaas.cli.recipes import recipes_cmd_group
+from gmsaas.cli.osimages import osimages_cmd_group
 from gmsaas.cli.instances import instances_cmd_group
 from gmsaas.cli.logzip import logzip
 from gmsaas.gmsaas.logger import set_verbosity, LOGGER
 from gmsaas.gmsaas.proxy import setup_proxy
 from gmsaas.cli.clioutput import OutputFormat, OUTPUT_FORMATS
 
 
@@ -75,15 +77,15 @@
     """
     if not value or ctx.resilient_parsing:
         return
     ui().show_version(gmsaas.get_name(), gmsaas.get_version(), gmsaas.get_doc_url(), gmsaas.get_pypi_url())
     ctx.exit()
 
 
-@click.group()
+@click.group(context_settings=dict(help_option_names=["-h", "--help"]))
 @click.option(
     "--verbose",
     "-v",
     count=True,
     is_eager=True,
     callback=show_verbose,
     expose_value=False,
@@ -104,23 +106,25 @@
     expose_value=False,
     callback=show_version,
     help="Show the version and exit.",
 )
 @click.pass_context
 def main(ctx):
     """
-    Command line utility for Genymotion SaaS
+    Command line client for Genymotion SaaS
     """
     LOGGER.info("==== START args: %s ====", get_loggable_args(sys.argv[1:]))
     setup_proxy()
     ctx.ensure_object(dict)
 
 
 main.add_command(auth)
 main.add_command(config)
 main.add_command(instances_cmd_group)
 main.add_command(recipes_cmd_group)
+main.add_command(osimages_cmd_group)
+main.add_command(hwprofiles_cmd_group)
 main.add_command(logzip)
 
 
 if __name__ == "__main__":
     main()  # pylint: disable=no-value-for-parameter
```

## gmsaas/cli/clioutput.py

```diff
@@ -20,14 +20,17 @@
 
 import click
 
 from gmsaas.gmsaas.logger import LOGGER
 from gmsaas.gmsaas.errors import ExitCode
 from gmsaas.storage.configcache import get_output_format
 from gmsaas.model.instanceinfo import Instances
+from gmsaas.model.recipeinfo import Recipes
+from gmsaas.model.osimageinfo import OsImages
+from gmsaas.model.hwprofileinfo import HwProfiles
 
 TEXT_OUTPUT = "text"
 JSON_OUTPUT = "json"
 COMPACT_JSON_OUTPUT = "compactjson"
 OUTPUT_FORMATS = [TEXT_OUTPUT, JSON_OUTPUT, COMPACT_JSON_OUTPUT]
 
 
@@ -137,25 +140,77 @@
         """ Output for `gmsaas instances list` """
 
     @abstractmethod
     def instances_start(self, instance):
         """ Output for `gmsaas instances start` """
 
     @abstractmethod
+    def instances_save(self, instance):
+        """ Output for `gmsaas instances save` """
+
+    @abstractmethod
+    def instances_saveas(self, instance, recipe_name, osimage_name):
+        """ Output for `gmsaas instances saveas` """
+
+    @abstractmethod
     def instances_stop(self, instance):
         """ Output for `gmsaas instances stop` """
 
     @abstractmethod
     def logzip(self, archive_path):
         """ Output for `gmsaas logzip` """
 
     @abstractmethod
+    def recipes_create(self, recipe):
+        """ Output for `gmsaas recipes create` """
+
+    @abstractmethod
+    def recipes_get(self, recipe):
+        """ Output for `gmsaas recipes get` """
+
+    @abstractmethod
     def recipes_list(self, recipes):
         """ Output for `gmsaas recipes list` """
 
+    @abstractmethod
+    def recipes_delete(self, recipe_uuid):
+        """ Output for `gmsaas recipes delete` """
+
+    @abstractmethod
+    def osimages_create(self, osimage):
+        """ Output for `gmsaas osimages create` """
+
+    @abstractmethod
+    def osimages_get(self, osimage):
+        """ Output for `gmsaas osimages get` """
+
+    @abstractmethod
+    def osimages_list(self, osimages):
+        """ Output for `gmsaas osimages list` """
+
+    @abstractmethod
+    def osimages_delete(self, osimage_uuid):
+        """ Output for `gmsaas osimages delete` """
+
+    @abstractmethod
+    def hwprofiles_create(self, hwprofile):
+        """ Output for `gmsaas hwprofiles create` """
+
+    @abstractmethod
+    def hwprofiles_get(self, hwprofile):
+        """ Output for `gmsaas hwprofile get` """
+
+    @abstractmethod
+    def hwprofiles_list(self, hwprofiles):
+        """ Output for `gmsaas hwprofiles list` """
+
+    @abstractmethod
+    def hwprofiles_delete(self, hwprofile_uuid):
+        """ Output for `gmsaas hwprofiles delete` """
+
 
 class PlainTextOut(Out):
     """ Subclass for text format output implementation
     """
 
     def error(self, exit_code, message, hint, details):
         """ Output for any error raised by gmsaas
@@ -222,43 +277,101 @@
         if output:
             self.write_stdout(output)
 
     def instances_start(self, instance):
         """ Output for `gmsaas instances start` """
         self.write_stdout(instance.uuid)
 
+    def instances_save(self, instance):
+        """ Output for `gmsaas instances save` """
+        self.write_stdout(f"Instance '{instance.name}' has been saved successfully.")
+
+    def instances_saveas(self, instance, recipe_name, osimage_name):
+        """ Output for `gmsaas instances saveas` """
+        self.write_stdout(
+            f"Instance '{instance.name}' has been saved successfully. Recipe '{recipe_name}' and Image '{osimage_name}' have been created."
+        )
+
     def instances_stop(self, instance):
         """ Output for `gmsaas instances stop` """
 
     def logzip(self, archive_path):
         """ Output for `gmsaas logzip` """
         self.write_stdout("'{}' generated.".format(archive_path))
 
+    def recipes_create(self, recipe):
+        """ Output for `gmsaas recipes create` """
+        self.write_stdout(recipe.uuid)
+
+    def recipes_get(self, recipe):
+        """ Output for `gmsaas recipes get` """
+        recipes = Recipes()
+        recipes.recipes = [recipe]
+        self.recipes_list(recipes)
+
     def recipes_list(self, recipes):
         """ Output for `gmsaas recipes list` """
         self.write_stdout(recipes.tabulate())
 
+    def recipes_delete(self, recipe_uuid):
+        """ Output for `gmsaas recipes delete` """
+        self.write_stdout(f"Recipe '{recipe_uuid}' deleted successfully.")
+
+    def osimages_create(self, osimage):
+        """ Output for `gmsaas osimages create` """
+        self.write_stdout(osimage.uuid)
+
+    def osimages_get(self, osimage):
+        """ Output for `gmsaas osimages get` """
+        osimages = OsImages()
+        osimages.osimages = [osimage]
+        self.osimages_list(osimages)
+
+    def osimages_list(self, osimages):
+        """ Output for `gmsaas osimages list` """
+        self.write_stdout(osimages.tabulate())
+
+    def osimages_delete(self, osimage_uuid):
+        """ Output for `gmsaas osimages delete` """
+        self.write_stdout(f"Image '{osimage_uuid}' deleted successfully.")
+
+    def hwprofiles_create(self, hwprofile):
+        """ Output for `gmsaas hwprofiles create` """
+        self.write_stdout(hwprofile.uuid)
+
+    def hwprofiles_get(self, hwprofile):
+        """ Output for `gmsaas hwprofiles get` """
+        hwprofiles = HwProfiles()
+        hwprofiles.hwprofiles = [hwprofile]
+        self.hwprofiles_list(hwprofiles)
+
+    def hwprofiles_list(self, hwprofiles):
+        """ Output for `gmsaas hwprofiles list` """
+        self.write_stdout(hwprofiles.tabulate())
+
+    def hwprofiles_delete(self, hwprofile_uuid):
+        """ Output for `gmsaas hwprofiles delete` """
+        self.write_stdout(f"HwProfile '{hwprofile_uuid}' deleted successfully.")
+
 
 class JSONOut(Out):
     """ Subclass for JSON format output implementation
     """
 
     def __init__(self, indent=4):
         self.indent = indent
 
     def write_data_stdout(self, data):
         """ Add exit OK to data and print it as JSON """
-        assert isinstance(data, OrderedDict), "write_data_stderr only accepts OrderedDict"
         data["exit_code"] = ExitCode.NO_ERROR.value
         data["exit_code_desc"] = ExitCode.NO_ERROR.name
         self.write_stdout(json.dumps(data, indent=self.indent, sort_keys=False))
 
     def write_data_stderr(self, data, exit_code):
         """ Add exit code to data and print it as JSON """
-        assert isinstance(data, OrderedDict), "write_data_stderr only accepts OrderedDict"
         data["exit_code"] = exit_code
         data["exit_code_desc"] = ExitCode(exit_code).name
         self.write_stderr(json.dumps(data, indent=self.indent, sort_keys=False))
 
     def error(self, exit_code, message, hint, details):
         """ Output for any error raised by gmsaas
         Note: `hint` is not used in JSON output
@@ -320,26 +433,80 @@
         """ Output for `gmsaas instances list` """
         self.write_data_stdout(OrderedDict([("instances", instances.as_list())]))
 
     def instances_start(self, instance):
         """ Output for `gmsaas instances start` """
         self.write_data_stdout(OrderedDict([("instance", instance.as_dict())]))
 
+    def instances_save(self, instance):
+        """ Output for `gmsaas instances save` """
+        self.write_data_stdout({"instance_uuid": instance.uuid})
+
+    def instances_saveas(self, instance, recipe_name, osimage_name):
+        """ Output for `gmsaas instances saveas` """
+        self.write_data_stdout(
+            {"instance_uuid": instance.uuid, "recipe_name": recipe_name, "osimage_name": osimage_name,}
+        )
+
     def instances_stop(self, instance):
         """ Output for `gmsaas instances stop` """
         self.instances_start(instance)
 
     def logzip(self, archive_path):
         """ Output for `gmsaas logzip` """
         self.write_data_stdout(OrderedDict([("archive_path", archive_path)]))
 
+    def recipes_create(self, recipe):
+        """ Output for `gmsaas recipes create` """
+        self.recipes_get(recipe)
+
+    def recipes_get(self, recipe):
+        """ Output for `gmsaas recipes get` """
+        self.write_data_stdout({"recipe": recipe.as_dict()})
+
     def recipes_list(self, recipes):
         """ Output for `gmsaas recipes list` """
         self.write_data_stdout(OrderedDict([("recipes", recipes.as_list())]))
 
+    def recipes_delete(self, recipe_uuid):
+        """ Output for `gmsaas recipes delete` """
+        self.write_data_stdout({"recipe_uuid": recipe_uuid})
+
+    def osimages_create(self, osimage):
+        """ Output for `gmsaas osimages create` """
+        self.osimages_get(osimage)
+
+    def osimages_get(self, osimage):
+        """ Output for `gmsaas osimages get` """
+        self.write_data_stdout({"osimage": osimage.as_dict()})
+
+    def osimages_list(self, osimages):
+        """ Output for `gmsaas osimages list` """
+        self.write_data_stdout({"osimages": osimages.as_list()})
+
+    def osimages_delete(self, osimage_uuid):
+        """ Output for `gmsaas osimages delete` """
+        self.write_data_stdout({"osimage_uuid": osimage_uuid})
+
+    def hwprofiles_create(self, hwprofile):
+        """ Output for `gmsaas hwprofiles create` """
+        self.hwprofiles_get(hwprofile)
+
+    def hwprofiles_get(self, hwprofile):
+        """ Output for `gmsaas hwprofiles get` """
+        self.write_data_stdout({"hwprofile": hwprofile.as_dict()})
+
+    def hwprofiles_list(self, hwprofiles):
+        """ Output for `gmsaas hwprofiles list` """
+        self.write_data_stdout({"hwprofiles": hwprofiles.as_list()})
+
+    def hwprofiles_delete(self, hwprofile_uuid):
+        """ Output for `gmsaas hwprofiles delete` """
+        self.write_data_stdout({"hwprofile_uuid": hwprofile_uuid})
+
 
 class CompactJSONOut(JSONOut):
     """ Subclass for compact JSON output implementation
     """
 
     def __init__(self):
         super().__init__(indent=None)
```

## gmsaas/cli/config.py

```diff
@@ -70,24 +70,24 @@
                 self.fail("Invalid choice '{}', choose from {}".format(value, OUTPUT_FORMATS))
         return value
 
 
 @click.group()
 def config():
     """
-    Manage gmsaas configuration properties
+    Configuration commands
     """
 
 
 @click.command("set")
 @click.argument("entry", type=click.Choice(VALID_KEYS))
 @click.argument("value", type=ConfigParamType())
 def config_set(entry, value):
     """
-    Set a gmsaas configuration property
+    Set one configuration property
 
     \b
     android-sdk-path    Android SDK path
     output-format       Default output format
     proxy               URL of HTTP/HTTPS/SOCKS5 proxy server
                         For an authenticated proxy, credentials
                         can be included in the URL or set through
@@ -98,28 +98,28 @@
     ui().config_set(entry, value)
 
 
 @click.command("get")
 @click.argument("entry", type=click.Choice(VALID_KEYS))
 def config_get(entry):
     """
-    Print a gmsaas configuration property
+    Print one configuration property
 
     \b
     android-sdk-path    Android SDK path
     output-format       Default output format
     proxy               URL of HTTP/HTTPS/SOCKS5 proxy server
     """
     ui().config_get(entry, str(cfg.get_config(entry)))
 
 
 @click.command("list")
 def config_list():
     """
-    List all gmsaas configuration properties
+    List all configuration properties
     """
     configuration = cfg.get_all()
     for key in VALID_KEYS:
         configuration.setdefault(key, "")
     ui().config_list(configuration)
```

## gmsaas/cli/instances.py

```diff
@@ -26,44 +26,144 @@
 from gmsaas.gmsaas.logger import LOGGER
 from gmsaas.cli.clioutput import ui
 
 
 @click.group("instances")
 def instances_cmd_group():
     """
-    Manage your Genymotion Cloud SaaS instances
+    Instances commands
     """
 
 
-@click.command("start")
+@click.command("start", short_help="Start an Instance.", help="Start an Instance from a Recipe.")
 @click.argument("RECIPE_UUID", type=click.UUID)
 @click.argument("INSTANCE_NAME")
 @click.option(
     "--stop-when-inactive",
     type=click.BOOL,
     is_flag=True,
-    help="Automatically stop the instance after long inactivity period",
+    help="<deprecated> Use '--max-run-duration' instead. If set, the Instance will be stopped if no web app interactions are made for a certain duration, this duration is the organization's default inactivity timeout.",
 )
-@click.option("--no-wait", type=click.BOOL, is_flag=True, help="Do not wait for the instance to be fully started")
+@click.option(
+    "--max-run-duration",
+    type=click.IntRange(0, 28800),
+    help="Duration in minute after which the Instance will be stopped, no matter what. The countdown starts when Instance is booted. 0 means no timeout. By default the organization's default global timeout is used.",
+)
+@click.option("--no-wait", type=click.BOOL, is_flag=True, help="Do not wait for the Instance to be fully started.")
 @click.pass_context
 @credentials_required
-def start_disposable_instance(ctx, recipe_uuid, instance_name, stop_when_inactive, no_wait):
+def start_disposable_instance(ctx, recipe_uuid, instance_name, stop_when_inactive, max_run_duration, no_wait):
     """
-    Start a disposable instance from a recipe
+    Start an instance from a Recipe
     """
     del ctx
     saas = _get_api_client()
 
-    instance = saas.start_disposable_instance(recipe_uuid, instance_name, bool(stop_when_inactive), no_wait)
+    if stop_when_inactive and max_run_duration is not None:
+        raise click.BadParameter("Options '--stop-when-inactive' and '--max-run-duration' are mutally exclusives.")
+
+    timeout_params = {}
+    if stop_when_inactive:
+        timeout_params["stop_when_inactive"] = True
+    else:
+        # gmsaas always disables the inactivity timeout (relevant from webapp, not from cmd line)
+        timeout_params["timeouts"] = {"inactivity": 0}
+        if isinstance(max_run_duration, int):
+            # Override organization's global timeout if set
+            timeout_params["timeouts"].update({"global": max_run_duration})
+
+    instance = saas.start_disposable_instance(recipe_uuid, instance_name, timeout_params, no_wait)
     ui().instances_start(instance)
 
 
-@click.command("stop")
+@click.command(
+    "save",
+    short_help="Save a running Instance.",
+    help="Save running Instance using owned Recipe/Image, Instance will stop in order to be saved.",
+)
+@click.argument("INSTANCE_UUID", type=click.UUID)
+@click.pass_context
+@credentials_required
+def save_instance(ctx, instance_uuid):
+    """
+    Save running Instance using owned Recipe/Image, Instance will stop in order to be saved.
+    """
+    del ctx
+    instance_uuid = str(instance_uuid)
+
+    saas = _get_api_client()
+
+    instance = saas.get_instance(instance_uuid)
+    email = authcache.get_email()
+
+    if instance.recipe.source != email:
+        raise err.SaveInstanceBadParamsError(
+            f"Instance '{instance.name}' does not use a owned Recipe, please use 'saveas' command instead."
+        )
+    if instance.recipe.osimage.source != email:
+        raise err.SaveInstanceBadParamsError(
+            f"Instance '{instance.name}' does not use an owned Image, please use 'saveas' command instead."
+        )
+    if instance.state != InstanceState.ONLINE:
+        raise err.SaveInstanceBadParamsError(f"Instance '{instance.name}' is not ready to be saved.")
+
+    adbtunnel = get_adbtunnel()
+    adbtunnel.disconnect(instance_uuid)
+    tunnel_state = adbtunnel.wait_for_adb_disconnected(instance_uuid).tunnel_state
+    if tunnel_state != TunnelState.DISCONNECTED:
+        LOGGER.error("[%s] Instance can't be disconnected from ADB tunnel", instance_uuid)
+    saas = _get_api_client()
+    saas.save_instance(instance)
+    ui().instances_save(instance)
+
+
+SAVEAS_HELP = """
+\b
+Save running Instance in a new owned Recipe/Image, Instance will stop in order to be saved.
+Note: you can not "Save As" a Recipe owned by another organization.
+"""
+
+
+@click.command("saveas", short_help="Save As a running Instance.", help=SAVEAS_HELP)
+@click.argument("INSTANCE_UUID", type=click.UUID)
+@click.option(
+    "--osimage-name", type=click.STRING, required=True, help="Name for saved Image.",
+)
+@click.option(
+    "--recipe-name", type=click.STRING, required=True, help="Name for saved Recipe.",
+)
+@click.pass_context
+@credentials_required
+def saveas_instance(ctx, instance_uuid, recipe_name, osimage_name):
+    """
+    Save running instance in a new owned Recipe/Image.
+    """
+    del ctx
+    instance_uuid = str(instance_uuid)
+
+    saas = _get_api_client()
+
+    instance = saas.get_instance(instance_uuid)
+
+    if instance.state != InstanceState.ONLINE:
+        raise err.SaveInstanceBadParamsError(f"Instance '{instance.name}' is not ready to be saved.")
+
+    adbtunnel = get_adbtunnel()
+    adbtunnel.disconnect(instance_uuid)
+    tunnel_state = adbtunnel.wait_for_adb_disconnected(instance_uuid).tunnel_state
+    if tunnel_state != TunnelState.DISCONNECTED:
+        LOGGER.error("[%s] Instance can't be disconnected from ADB tunnel", instance_uuid)
+    saas = _get_api_client()
+    saas.saveas_instance(instance, recipe_name, osimage_name)
+    ui().instances_saveas(instance, recipe_name, osimage_name)
+
+
+@click.command("stop", short_help="Stop a running Instance.")
 @click.argument("INSTANCE_UUID", type=click.UUID)
-@click.option("--no-wait", type=click.BOOL, is_flag=True, help="Do not wait for the instance to be fully stopped")
+@click.option("--no-wait", type=click.BOOL, is_flag=True, help="Do not wait for the Instance to be fully stopped.")
 @click.pass_context
 @credentials_required
 @adb_tools_required
 def stop_disposable_instance(ctx, instance_uuid, no_wait):
     """
     Stop a running disposable instance
     """
@@ -75,15 +175,15 @@
     if tunnel_state != TunnelState.DISCONNECTED:
         LOGGER.error("[%s] Instance can't be disconnected from ADB tunnel", instance_uuid)
     saas = _get_api_client()
     instance = saas.stop_disposable_instance(instance_uuid, no_wait)
     ui().instances_stop(instance)
 
 
-@click.command("get")
+@click.command("get", short_help="Get a running Instance.")
 @click.argument("INSTANCE_UUID", type=click.UUID)
 @click.pass_context
 @credentials_required
 @adb_tools_required
 def get_instance(ctx, instance_uuid):
     """
     Get instance information
@@ -95,16 +195,16 @@
     saas_instance = saas.get_instance(instance_uuid)
     adbtunnel_instance = adbtunnel.get_instance(instance_uuid)
     instance = Instance.merge(saas_instance, adbtunnel_instance)
 
     ui().instances_get(instance)
 
 
-@click.command("list")
-@click.option("--quiet", "-q", is_flag=True, help="Only display running instance UUIDs")
+@click.command("list", short_help="List running Instances.")
+@click.option("--quiet", "-q", is_flag=True, help="Only display running Instance UUIDs.")
 @click.pass_context
 @credentials_required
 @adb_tools_required
 def list_instances(ctx, quiet):
     """
     List all currently running instances
     """
@@ -115,15 +215,15 @@
     adbtunnel_instances = adbtunnel.get_instances()
     instances = Instances.merge(saas_instances, adbtunnel_instances)
 
     LOGGER.debug("%d Instances available", len(instances))
     ui().instances_list(instances, quiet)
 
 
-@click.command("adbconnect")
+@click.command("adbconnect", short_help="Connect ADB to a running Instance.")
 @click.option("--adb-serial-port", type=click.IntRange(1024, 65535))
 @click.argument("INSTANCE_UUID", type=click.UUID)
 @click.pass_context
 @credentials_required
 @adb_tools_required
 def connect_instance_to_adb(ctx, instance_uuid, adb_serial_port):
     """
@@ -162,15 +262,15 @@
         ui().instances_adbconnect(instance)
         return
     if instance.tunnel_state == TunnelState.PORT_BUSY:
         raise err.AdbTunnelBusyPortError(instance_uuid, adb_serial_port)
     raise err.AdbTunnelGenericError(instance_uuid)
 
 
-@click.command("adbdisconnect")
+@click.command("adbdisconnect", short_help="Disconnect ADB from a running Instance.")
 @click.argument("INSTANCE_UUID", type=click.UUID)
 @click.pass_context
 @credentials_required
 @adb_tools_required
 def disconnect_instance_from_adb(ctx, instance_uuid):
     """
     Disconnect a running instance from ADB
@@ -199,12 +299,14 @@
     """
     Get the Genymotion Cloud SaaS API client
     """
     return get_client(authcache.get_email(), authcache.get_password())
 
 
 instances_cmd_group.add_command(start_disposable_instance)
+instances_cmd_group.add_command(save_instance)
+instances_cmd_group.add_command(saveas_instance)
 instances_cmd_group.add_command(stop_disposable_instance)
 instances_cmd_group.add_command(get_instance)
 instances_cmd_group.add_command(list_instances)
 instances_cmd_group.add_command(connect_instance_to_adb)
 instances_cmd_group.add_command(disconnect_instance_from_adb)
```

## gmsaas/cli/logzip.py

```diff
@@ -11,26 +11,67 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """
 Cli for command logzip
 """
 
+import pathlib
 import click
+import os
 
 from gmsaas.gmsaas.errors import LogzipError
 from gmsaas.saas.logcollector import LogCollector
 from gmsaas.cli.clioutput import ui
 
 
+def validate_zip_path(ctx, _, zip_path: str):
+    """
+    Check if path is correct:
+    - absolute
+    - must have read and write permissions
+    - if zip_path is a file:
+        - parent dir must exist
+        - must end with .zip extension
+    - if zip_path is a dir:
+        - must exist
+    """
+    del ctx
+    if not zip_path:
+        return None
+    try:
+        zip_path = pathlib.Path(os.path.expandvars(zip_path)).expanduser()
+        if not zip_path.is_absolute():
+            raise click.BadParameter(f"Path `{zip_path}` must be absolute.")
+        if zip_path.is_dir():
+            if not zip_path.exists():
+                raise click.BadParameter(f"Path `{zip_path}` must exist.")
+        else:
+            if not zip_path.parent.exists():
+                raise click.BadParameter(f"Path `{zip_path.parent}` must exist.")
+            if not str(zip_path).endswith(".zip"):
+                raise click.BadParameter(f"Path `{zip_path}` must end with '.zip'")
+    except PermissionError as exception:
+        raise click.BadParameter(f"Path `{zip_path.parent}` must have read and write permissions.") from exception
+    return str(zip_path)
+
+
 @click.command("logzip")
-def logzip():
+@click.option(
+    "--out",
+    "out_path",
+    type=click.Path(),
+    callback=validate_zip_path,
+    required=False,
+    help="Either a ZIP archive path or a directory.",
+)
+def logzip(out_path):
     """
-    Zip all 'gmsaas' log files into a ZIP archive
+    Create a ZIP archive containing all 'gmsaas' logs
     """
     collector = LogCollector()
     try:
-        archive_path = collector.process()
+        archive_path = collector.process(out_path)
     except Exception as exception:
         raise LogzipError(exception) from exception
 
     ui().logzip(archive_path)
```

## gmsaas/cli/recipes.py

```diff
@@ -23,32 +23,94 @@
 from gmsaas.gmsaas.logger import LOGGER
 from gmsaas.cli.clioutput import ui
 
 
 @click.group("recipes")
 def recipes_cmd_group():
     """
-    View your Genymotion Cloud SaaS recipes
+    Recipes commands
     """
 
 
-@click.command("list")
-@click.option("--name", help="Filter results with substring")
+@click.command("create", help="Create a custom Recipe.")
+@click.argument("HWPROFILE_UUID", type=click.UUID)
+@click.argument("OSIMAGE_UUID", type=click.UUID)
+@click.argument("RECIPE_NAME")
+@click.option(
+    "--description", type=click.STRING, help="Description text for this Recipe.",
+)
 @click.pass_context
 @credentials_required
-def list_recipes(ctx, name):
+def create_recipe(ctx, hwprofile_uuid, osimage_uuid, recipe_name, description):
     """
-    List all available recipes
+    Create a custom Recipe
     """
     del ctx
+    hwprofile_uuid = str(hwprofile_uuid)
+    osimage_uuid = str(osimage_uuid)
+
     saas = get_client(authcache.get_email(), authcache.get_password())
-    recipes = saas.list_recipes()
 
-    LOGGER.debug("%d Recipes available", len(recipes))
+    recipe = saas.create_recipe(recipe_name, hwprofile_uuid, osimage_uuid, description)
+    ui().recipes_create(recipe)
+
+
+@click.command("get", help="Get a Recipe details.")
+@click.argument("RECIPE_UUID", type=click.UUID)
+@click.pass_context
+@credentials_required
+def get_recipe(ctx, recipe_uuid):
+    """
+    Get a Recipe details
+    """
+    del ctx
+    recipe_uuid = str(recipe_uuid)
+    saas = get_client(authcache.get_email(), authcache.get_password())
+    recipe = saas.get_recipe(recipe_uuid)
+    ui().recipes_get(recipe)
 
-    if name:
-        recipes.filter_by_name(name)
+
+@click.command("list", help="List available Recipes.")
+@click.option("--name", help="Filter results with substring.")
+@click.option("--source", type=click.Choice(["all", "official", "custom"]), default="all", show_default=True)
+@click.pass_context
+@credentials_required
+def list_recipes(ctx, name, source):
+    """
+    List available Recipes
+    """
+    del ctx
+    if source == "custom":
+        source = "shared"
+    saas = get_client(authcache.get_email(), authcache.get_password())
+    recipes = saas.list_recipes(source=source, search=name)
+
+    LOGGER.debug("%d Recipes available", len(recipes))
 
     ui().recipes_list(recipes)
 
 
+@click.command("delete", help="Delete a Recipe.")
+@click.argument("RECIPE_UUID", type=click.UUID)
+@click.option(
+    "--delete-osimage", type=click.BOOL, is_flag=True, help="If set, the associated Image is deleted too.",
+)
+@click.option(
+    "--delete-hwprofile", type=click.BOOL, is_flag=True, help="If set, the associated Hardware Profile is deleted too.",
+)
+@click.pass_context
+@credentials_required
+def delete_recipe(ctx, recipe_uuid, delete_osimage, delete_hwprofile):
+    """
+    Delete a Recipe
+    """
+    del ctx
+    recipe_uuid = str(recipe_uuid)
+    saas = get_client(authcache.get_email(), authcache.get_password())
+    saas.delete_recipe(recipe_uuid, delete_osimage, delete_hwprofile)
+    ui().recipes_delete(recipe_uuid)
+
+
+recipes_cmd_group.add_command(create_recipe)
+recipes_cmd_group.add_command(get_recipe)
 recipes_cmd_group.add_command(list_recipes)
+recipes_cmd_group.add_command(delete_recipe)
```

## gmsaas/gmsaas/errors.py

```diff
@@ -43,14 +43,15 @@
     INSTANCE_ERROR = 10
     ADBTUNNEL_BUSY_PORT_ERROR = 11
     ADBTUNNEL_GENERIC_ERROR = 12
     ADBTUNNEL_DIFFERENT_PORT_ERROR = 13
     ADBTUNNEL_INSTANCE_NOT_READY = 14
     REQUEST_ERROR = 15
     LOGZIP_ERROR = 16
+    SAVE_INSTANCE_ERROR = 17
 
 
 class ApiErrorCode:
     """
     Error codes return by the API
     """
 
@@ -264,14 +265,23 @@
             _get_instance_error(instance_uuid, expected_state, actual_state),
             details="Instance '{}' expects to be '{}' but reached '{}'".format(
                 instance_uuid, expected_state, actual_state
             ),
         )
 
 
+class SaveInstanceBadParamsError(GmsaasError):
+    """
+    Save instance error
+    """
+
+    def __init__(self, message):
+        super().__init__(ExitCode.SAVE_INSTANCE_ERROR.value, message)
+
+
 class AdbTunnelBusyPortError(GmsaasError):
     """
     AdbTunnel Busy Port Error
     """
 
     def __init__(self, instance_uuid, port):
         super().__init__(
```

## gmsaas/gmsaas/timeout.py

```diff
@@ -42,14 +42,21 @@
 def get_stop_timeout():
     """
     Return stop timeout in seconds
     """
     return int(os.environ.get("GMSAAS_STOP_TIMEOUT", 60))
 
 
+def get_save_timeout():
+    """
+    Return stop timeout in seconds
+    """
+    return int(os.environ.get("GMSAAS_SAVE_TIMEOUT", 300))
+
+
 def get_adbconnect_timeout():
     """
     Return adbtunnel connection timeout in seconds
     """
     return int(os.environ.get("GMSAAS_ADBCONNECT_TIMEOUT", 40))
```

## gmsaas/model/instanceinfo.py

```diff
@@ -46,14 +46,15 @@
     SAVED = "SAVED"
     STOPPING = "STOPPING"
     DELETING = "DELETING"
     DELETED = "DELETED"
     MAINTENANCE = "MAINTENANCE"
     RECYCLED = "RECYCLED"
     ERROR = "ERROR"
+    SAVING = "SAVING"
 
 
 class TunnelState:
     """
     Possible states for AdbTunnel
     """
 
@@ -86,53 +87,71 @@
         InstanceState.UNKNOWN,
         InstanceState.STOPPING,
         InstanceState.OFFLINE,
         InstanceState.DELETING,
     ]
 
 
+def is_instance_saving(actual_state):
+    """
+    Return True if instance is neither stopped nor in failure, False otherwise.
+    """
+    return actual_state in [
+        InstanceState.UNKNOWN,
+        InstanceState.STOPPING,
+        InstanceState.SAVING,
+        InstanceState.SAVED,
+        InstanceState.OFFLINE,
+        InstanceState.DELETING,
+    ]
+
+
 def is_adbtunnel_connecting(actual_state):
     """
     Return True if instance is neither connected nor in failure, False otherwise.
     """
     return actual_state in [TunnelState.DISCONNECTED, TunnelState.PENDING]
 
 
 class Instance:
     """
     Class representing one Instance with both API and ADB Tunnel information
     """
 
     def __init__(self, uuid=None):
-        self.uuid = uuid
-        self.name = None
+        self.uuid = uuid or ""
+        self.name = ""
         self.created_at = datetime.utcfromtimestamp(0).strftime("%Y-%m-%dT%H:%M:%S.000Z")
+        self.max_run_duration = 0
+        self.max_inactivity_duration = 0
         self.state = InstanceState.UNKNOWN
         self.tunnel_state = TunnelState.DISCONNECTED
         self._adb_serial = DEFAULT_ADB_SERIAL
-        self.recipe = Recipe()
+        self.recipe: Recipe = None
 
     def __str__(self):
         return "uuid={}, name={}, state={}, adb_serial={}, tunnel_state={}".format(
             self.uuid, self.name, self.state, self.adb_serial, self.tunnel_state
         )
 
     def as_dict(self):
         """ Return Instance as a dict object
         Using OrderedDict here because dict() preserves insertion order since Python 3.7 only
         """
         data = OrderedDict()
-        data["uuid"] = self.uuid or ""
-        data["name"] = self.name or ""
+        data["uuid"] = self.uuid
+        data["name"] = self.name
         data["created_at"] = self.created_at
+        data["max_run_duration"] = self.max_run_duration
+        data["max_inactivity_duration"] = self.max_inactivity_duration
         data["state"] = self.state
         data["adbtunnel_state"] = self.tunnel_state
         data["adb_serial"] = self.adb_serial
         data["adb_serial_port"] = self.adb_serial_port or 0
-        data["recipe"] = self.recipe.as_dict()
+        data["recipe"] = self.recipe.as_dict() if self.recipe else None
         return data
 
     @property
     def adb_serial(self):
         """ Return adb_serial """
         return self._adb_serial
 
@@ -180,16 +199,21 @@
         assert "name" in raw_instance
         assert "created_at" in raw_instance
         assert "state" in raw_instance
         instance = Instance()
         instance.uuid = raw_instance["uuid"]
         instance.name = raw_instance["name"]
         instance.created_at = raw_instance["created_at"]
+        instance.max_run_duration = raw_instance["timeouts"]["global"]
+        instance.max_inactivity_duration = raw_instance["timeouts"]["inactivity"]
         instance.state = raw_instance["state"]
-        instance.recipe = Recipe.create_from_saas(raw_instance["recipe"])
+        if "recipe" in raw_instance:
+            instance.recipe = Recipe.create_from_instance_endpoint(
+                raw_instance.get("recipe"), raw_instance.get("hardware_profile"), raw_instance.get("os_image")
+            )
         return instance
 
     @staticmethod
     def merge(saas_instance, adbtunnel_instance):
         """ Merge Instance coming from ADB Tunnel into Instance coming from SaaS API """
         merged_instance = saas_instance
         merged_instance.tunnel_state = adbtunnel_instance.tunnel_state
@@ -223,16 +247,15 @@
             instances.instances.append(Instance.create_from_adbtunnel(raw_instance))
         return instances
 
     @staticmethod
     def create_from_saas(raw_instances):
         """ Factory function to get Instances object from SaaS API content """
         instances = Instances()
-        for raw_instance in raw_instances:
-            instances.instances.append(Instance.create_from_saas(raw_instance))
+        instances.instances = [Instance.create_from_saas(raw_instance) for raw_instance in raw_instances]
         return instances
 
     @staticmethod
     def merge(saas_instances, adbtunnel_instances):
         """ Merge Instances coming from ADB Tunnel into Instances coming from SaaS API """
         merged_instances = saas_instances
```

## gmsaas/model/recipeinfo.py

```diff
@@ -15,94 +15,102 @@
 Recipe data
 """
 from distutils.version import LooseVersion
 from collections import OrderedDict
 
 from tabulate import tabulate
 
+from gmsaas.model.hwprofileinfo import HwProfile
+from gmsaas.model.osimageinfo import OsImage
+from gmsaas.utils.dictionnary import safe_get
+
 
 RECIPES_TABLE_HEADERS = ["UUID", "NAME", "ANDROID", "SCREEN", "SOURCE"]
-NONE_PLACEHOLDER = "Unknown"
 
 
 def _key_for_entry(entry):
     source = entry.source
-    version = entry.android_version
+    is_official = entry.source == "genymotion"
+    version = entry.osimage.android_version if entry.osimage else "0.0.0"
     name = entry.name
-
-    if version == NONE_PLACEHOLDER:
-        version = "0.0.0"
     version = LooseVersion(version)
 
-    return (source, version, name)
+    return (not is_official, source, version, name)
 
 
 class Recipe:
     """ Class representing one Recipe
     """
 
     def __init__(self, uuid=None):
-        self.uuid = uuid
-        self.name = None
-        self.android_version = None
-        self.screen_width = None
-        self.screen_height = None
-        self.screen_density = None
-        self.source = None
+        self.uuid = uuid or ""
+        self.name = ""
+        self.source = ""
+        self.is_shared = False
+        self.hwprofile: HwProfile = None
+        self.osimage: OsImage = None
 
     def as_dict(self):
         """ Return Recipe as dict object
         Using OrderedDict here because dict() preserves insertion order since Python 3.7 only
         """
         data = OrderedDict()
-        data["uuid"] = self.uuid or ""
-        data["name"] = self.name or ""
-        data["android_version"] = self.android_version or NONE_PLACEHOLDER
-        data["screen_width"] = self.screen_width or 0
-        data["screen_height"] = self.screen_height or 0
-        data["screen_density"] = self.screen_density or 0
-        data["screen"] = self.screen or NONE_PLACEHOLDER
-        data["source"] = self.source or NONE_PLACEHOLDER
+        data["uuid"] = self.uuid
+        data["name"] = self.name
+        data["android_version"] = self.osimage.android_version if self.osimage else "0.0.0"
+        data["screen_width"] = self.hwprofile.screen_width if self.hwprofile else 0
+        data["screen_height"] = self.hwprofile.screen_height if self.hwprofile else 0
+        data["screen_density"] = self.hwprofile.screen_density if self.hwprofile else 0
+        data["screen"] = self.hwprofile.screen if self.hwprofile else "Unknown"
+        data["source"] = self.source
+        data["hwprofile"] = self.hwprofile.as_dict() if self.hwprofile else None
+        data["osimage"] = self.osimage.as_dict() if self.osimage else None
         return data
 
-    @property
-    def screen(self):
-        """ Return string representation of screen properties """
-        if all([self.screen_width, self.screen_height, self.screen_density]):
-            return "{} x {} dpi {}".format(self.screen_width, self.screen_height, self.screen_density)
-        return NONE_PLACEHOLDER
-
     @staticmethod
     def create_from_saas(raw_recipe):
         """ Factory function to get Recipe object from SaaS API content """
-
-        def _get_item_data(raw_recipe, item):
-            """
-            Retrieve the data of the given item, return empty dict if not found
-            """
-            for i in raw_recipe["items"]:
-                if i["type"] == item:
-                    return i["data"]
-            return {}
-
-        recipe = Recipe()
         if not raw_recipe:
-            # Recipe might be None depending on the state of the instance.
-            # For example when the instance is almost stopped. Need investigation
-            # on the SaaS API side to fix this inconsistency.
-            return recipe
+            return None
+        recipe = Recipe()
+        recipe.uuid = raw_recipe["uuid"]
+        recipe.name = raw_recipe["name"]
+        recipe.source = "genymotion" if raw_recipe["is_official"] else raw_recipe["owner"]["email"]
+        recipe.is_shared = False if raw_recipe.get("share", None) is None else True
+        recipe.hwprofile = HwProfile.create_from_saas(raw_recipe["hardware_profile"])
+        recipe.osimage = OsImage.create_from_saas(raw_recipe["os_image"])
+        return recipe
 
+    @staticmethod
+    def create_from_instance_endpoint(raw_recipe, raw_hwprofile, raw_osimage):
+        """ Factory function to get Recipe object from SaaS API content
+        Limitations:
+        - does not provide share object
+        """
+        if raw_recipe is None:
+            return None
+        recipe = Recipe()
         recipe.uuid = raw_recipe["uuid"]
         recipe.name = raw_recipe["name"]
-        recipe.android_version = _get_item_data(raw_recipe, "ova").get("android_version", NONE_PLACEHOLDER)
-        screen_data = _get_item_data(raw_recipe, "screen")
-        recipe.screen_width = screen_data.get("width")
-        recipe.screen_height = screen_data.get("height")
-        recipe.screen_density = screen_data.get("density")
-        recipe.source = raw_recipe["source"]
+        recipe.source = "genymotion" if not raw_recipe["owner"] else raw_recipe["owner"]["email"]
+        recipe.is_shared = False  # TODO missing info from endpoint
+        # If hwprofile is not official, owner is the same than the recipe
+        if raw_hwprofile and not safe_get(raw_hwprofile, "is_official", True):
+            # If recipe has been deleted during instance run,
+            # owner is null, in this edge case, owner is set to "Unknown"
+            email = safe_get(raw_recipe, ["owner", "email"], "Unknown")
+            raw_hwprofile["owner"] = {"email": email}
+        # If osimage is not official, owner is the same than the recipe
+        if raw_osimage and not safe_get(raw_osimage, "is_official", True):
+            # If recipe has been deleted during instance run,
+            # owner is null, in this edge case, owner is set to "Unknown"
+            email = safe_get(raw_recipe, ["owner", "email"], "Unknown")
+            raw_osimage["owner"] = {"email": email}
+        recipe.hwprofile = HwProfile.create_from_instance_endpoint(raw_hwprofile)
+        recipe.osimage = OsImage.create_from_saas(raw_osimage)
         return recipe
 
 
 class Recipes:
     """ Class storing a list of Recipe """
 
     def __init__(self):
@@ -118,24 +126,18 @@
         """ Return list of dict structured Recipe """
         self.sort()
         return [r.as_dict() for r in self.recipes]
 
     @staticmethod
     def create_from_saas(raw_recipes):
         """ Factory function to get Recipes object from SaaS API content """
-        raw_recipes = raw_recipes["base"] + raw_recipes["user"] + raw_recipes["shared"]
         recipes = Recipes()
-        for raw_recipe in raw_recipes:
-            recipes.recipes.append(Recipe.create_from_saas(raw_recipe))
+        recipes.recipes = [Recipe.create_from_saas(raw_recipe) for raw_recipe in raw_recipes]
         return recipes
 
-    def filter_by_name(self, name):
-        """ Filter recipes in place by name """
-        self.recipes = [r for r in self.recipes if name.strip().casefold() in r.name.casefold()]
-
     def sort(self):
         """ Sort recipes in place
         Recipes are sorted by several criteria which are (by priority ASC):
         NAME, ANDROID, SOURCE
         """
         self.recipes = sorted(self.recipes, key=_key_for_entry)
 
@@ -145,9 +147,18 @@
         recipes_table = self._get_table_format()
         return tabulate(recipes_table, headers=RECIPES_TABLE_HEADERS, numalign="left")
 
     def _get_table_format(self):
         """
         Return recipes as a two dimension table structure
         """
-        formated_recipes = [[r.uuid, r.name, r.android_version, r.screen, r.source] for r in self.recipes]
+        formated_recipes = [
+            [
+                r.uuid,
+                r.name,
+                r.osimage.android_version if r.osimage else "0.0.0",
+                r.hwprofile.screen if r.hwprofile else "",
+                r.source,
+            ]
+            for r in self.recipes
+        ]
         return formated_recipes
```

## gmsaas/saas/api.py

```diff
@@ -15,52 +15,140 @@
 Genymotion Cloud SaaS API constants
 """
 
 import os
 
 CLOUD_BASE_URL = os.environ.get("GM_PLATFORM_BASE_URL", "https://api.geny.io/cloud")
 LOGIN_URL = "{}/v1/users/login".format(CLOUD_BASE_URL)
-RECIPES_URL = "{}/v1/recipes".format(CLOUD_BASE_URL)
+LOGOUT_URL = "{}/v1/users/signout".format(CLOUD_BASE_URL)
+RECIPES_V1_URL = "{}/v1/recipes".format(CLOUD_BASE_URL)
+RECIPES_URL = "{}/v3/recipes/".format(CLOUD_BASE_URL)
 INSTANCES_V1_URL = "{}/v1/instances".format(CLOUD_BASE_URL)
 INSTANCES_V2_URL = "{}/v2/instances".format(CLOUD_BASE_URL)
+OSIMAGES_URL = "{}/v1/os-images/".format(CLOUD_BASE_URL)
+HWPROFILES_URL = "{}/v1/hardware-profiles/".format(CLOUD_BASE_URL)
 
 
 def get_login_url():
     """
     Return URL to login
     """
     return LOGIN_URL
 
 
-def get_recipes_url():
+def get_logout_url():
+    """
+    Return URL to logout
+    """
+    return LOGOUT_URL
+
+
+def get_recipes_list_url():
     """
     Return URL to get recipes
     """
     return RECIPES_URL
 
 
-def get_start_disposable_url(recipe_uuid):
+def get_recipes_create_url():
+    """
+    Return URL to create one recipe
+    """
+    return RECIPES_V1_URL
+
+
+def get_recipes_delete_url(recipe_uuid: str):
+    """
+    Return URL to delete one recipe
+    """
+    return f"{RECIPES_V1_URL}/{recipe_uuid}"
+
+
+def get_instances_start_url(recipe_uuid):
     """
     Return URL to start an instance
     """
-    return "{}/{}/start-disposable".format(RECIPES_URL, recipe_uuid)
+    return "{}/{}/start-disposable".format(RECIPES_V1_URL, recipe_uuid)
 
 
-def get_stop_disposable_url(instance_uuid):
+def get_instances_stop_url(instance_uuid):
     """
     Return URL to stop an instance
     """
     return "{}/{}/stop-disposable".format(INSTANCES_V1_URL, instance_uuid)
 
 
-def get_instance_url(instance_uuid):
+def get_instances_save_url(instance_uuid):
+    """
+    Return URL to save an instance
+    """
+    return "{}/{}/save".format(INSTANCES_V1_URL, instance_uuid)
+
+
+def get_instances_get_url(instance_uuid):
     """
     Return URL to get details of one instance
     """
     return "{}/{}".format(INSTANCES_V1_URL, instance_uuid)
 
 
-def get_instance_list_url():
+def get_instances_list_url():
     """
     Return URL to get instances
     """
     return INSTANCES_V2_URL
+
+
+def get_osimages_create_url(base_osimage_uuid):
+    """
+    Return URL to create one OsImage
+    """
+    return f"{OSIMAGES_URL}{base_osimage_uuid}/duplicate/"
+
+
+def get_osimages_get_url(osimage_uuid):
+    """
+    Return URL to get one OsImage
+    """
+    return f"{OSIMAGES_URL}{osimage_uuid}"
+
+
+def get_osimages_list_url():
+    """
+    Return URL to list OsImages
+    """
+    return OSIMAGES_URL
+
+
+def get_osimages_delete_url(osimage_uuid):
+    """
+    Return URL to delete one OsImage
+    """
+    return f"{OSIMAGES_URL}{osimage_uuid}"
+
+
+def get_hwprofiles_create_url():
+    """
+    Return URL to create one HwProfile
+    """
+    return HWPROFILES_URL
+
+
+def get_hwprofiles_get_url(hwprofile_uuid):
+    """
+    Return URL to get one HwProfile
+    """
+    return f"{HWPROFILES_URL}{hwprofile_uuid}"
+
+
+def get_hwprofiles_list_url():
+    """
+    Return URL to list HwProfiles
+    """
+    return HWPROFILES_URL
+
+
+def get_hwprofiles_delete_url(hwprofile_uuid):
+    """
+    Return URL to delete one HwProfile
+    """
+    return f"{HWPROFILES_URL}{hwprofile_uuid}"
```

## gmsaas/saas/client.py

```diff
@@ -18,33 +18,56 @@
 import os
 import requests
 from requests_toolbelt.utils import dump
 
 import gmsaas
 
 from gmsaas.gmsaas.triggererrors import get_fake_http_instance_state
+from gmsaas.model.hwprofileinfo import HwProfiles, HwProfile
 from gmsaas.storage import authcache
 from gmsaas.gmsaas.proxy import get_proxies_from_config
 from gmsaas.saas.sioclient import SIOClient
 from gmsaas.gmsaas import errors as err
 from gmsaas.gmsaas.logger import LOGGER
-from gmsaas.model.recipeinfo import Recipes
-from gmsaas.model.instanceinfo import Instance, Instances, InstanceState, is_instance_starting, is_instance_stopping
+from gmsaas.model.recipeinfo import Recipes, Recipe
+from gmsaas.model.osimageinfo import OsImages, OsImage
+from gmsaas.model.instanceinfo import (
+    Instance,
+    Instances,
+    InstanceState,
+    is_instance_starting,
+    is_instance_stopping,
+    is_instance_saving,
+)
 from gmsaas.saas.api import (
+    get_hwprofiles_create_url,
+    get_hwprofiles_get_url,
+    get_hwprofiles_list_url,
+    get_hwprofiles_delete_url,
     get_login_url,
-    get_recipes_url,
-    get_start_disposable_url,
-    get_stop_disposable_url,
-    get_instance_url,
-    get_instance_list_url,
+    get_recipes_list_url,
+    get_recipes_create_url,
+    get_recipes_delete_url,
+    get_instances_start_url,
+    get_instances_stop_url,
+    get_instances_save_url,
+    get_instances_get_url,
+    get_instances_list_url,
+    get_logout_url,
+    get_osimages_create_url,
+    get_osimages_get_url,
+    get_osimages_list_url,
+    get_osimages_delete_url,
 )
-from gmsaas.gmsaas.timeout import wait_until, get_start_timeout, get_stop_timeout
+from gmsaas.gmsaas.timeout import wait_until, get_start_timeout, get_stop_timeout, get_save_timeout
 
 
 HTTP_FAKE_INSTANCE_STATE = get_fake_http_instance_state()
+SAVE_ACTION = "SAVE"
+SAVE_AS_ACTION = "SAVE_AS"
 
 
 def _http_call(method, url, **kwargs):
     """
     Perform HTTP call and log around it
     """
     LOGGER.info("Request: %s %s", method.upper(), url)
@@ -103,39 +126,42 @@
         token = self._get_jwt()
         return "Bearer {}".format(token)
 
     def _get_headers(self, authorization_needed=True):
         """
         Craft HTTP headers for request
         """
-        headers = {"user-agent": self._get_user_agent()}
+        headers = {"user-agent": self._get_user_agent(), "Content-Type": "application/json"}
 
         if authorization_needed:
             headers["Authorization"] = self._get_authorization()
 
         return headers
 
     def _make_session_api_call(self, api_call):
         response = api_call()
         if response.status_code == 401 or os.environ.get("GMSAAS_FORCE_JWT_REFRESH"):
             self._fetch_jwt()
             return api_call()
         return response
 
-    def _get_paginated_results(self, url, ordering, page_size):
+    def _get_paginated_results(self, url, ordering, page_size, **kwargs):
         """
         Perform HTTP calls on paginated endpoint, until all elements are fetched.
         Return results array.
         """
         count = None
         current_page = 1
         results = []
 
         while count is None or len(results) < count:
-            params = {"page_size": page_size, "page": current_page, "ordering": ordering}
+            params = {"page_size": page_size, "page": current_page}
+            params.update(**kwargs)
+            if ordering:
+                params["ordering"] = ordering
             response = self._make_session_api_call(
                 lambda: _http_call("get", url, headers=self._get_headers(), params=params)
             )
 
             if response.status_code == 200:
                 try:
                     data = response.json()
@@ -149,38 +175,225 @@
                 except Exception as exception:
                     raise err.InvalidJsonError(response.status_code, response.text) from exception
             else:
                 raise err.ApiError(response.status_code, response.text)
 
         return results
 
-    def list_recipes(self):
+    def create_recipe(self, recipe_name, hwprofile_uuid, osimage_uuid, description):
+        """
+        Create custom recipe, return Recipe object
+        """
+        LOGGER.debug("Create Recipe %s from HwProfile %s and OsImage %s", recipe_name, hwprofile_uuid, osimage_uuid)
+
+        payload = {"hardware_profile_uuid": hwprofile_uuid, "os_image_uuid": osimage_uuid, "name": recipe_name}
+        if description:
+            payload["description"] = description
+
+        response = self._make_session_api_call(
+            lambda: _http_call("post", get_recipes_create_url(), json=payload, headers=self._get_headers())
+        )
+
+        if response.status_code == 201:
+            try:
+                data = response.json()
+                return Recipe.create_from_saas(data)
+            except Exception as exception:
+                raise err.InvalidJsonError(response.status_code, response.text) from exception
+        else:
+            raise err.ApiError(response.status_code, response.text)
+
+    def get_recipe(self, recipe_uuid):
+        """
+        Get one Recipe
+        Note: /v2/recipes/{uuid} does not return all information required
+              to build correctly the Recipe object, hence the use of list endpoint
+        """
+        LOGGER.debug("Get Recipe %s", recipe_uuid)
+        recipes = self.list_recipes(source="all", search=recipe_uuid)
+        for recipe in recipes.recipes:
+            if recipe.uuid == recipe_uuid:
+                return recipe
+        raise err.ApiError(404, "Recipe not found")
+
+    def list_recipes(self, source, search=None):
         """
         List available Recipes for user, return Recipes object
         """
         LOGGER.debug("Listing available Recipes")
+        results = self._get_paginated_results(
+            get_recipes_list_url(), ordering=None, page_size=50, source=source, search=search
+        )
+        return Recipes.create_from_saas(results)
+
+    def delete_recipe(self, recipe_uuid, delete_osimage, delete_hwprofile):
+        """
+        Delete Recipe and (if wanted) associated OsImage / HwProfiles
+        """
+        LOGGER.debug(
+            "Deleting Recipe %s, delete OsImage: %s, delete HwProfile %s", recipe_uuid, delete_osimage, delete_hwprofile
+        )
+        payload = {}
+        if delete_osimage:
+            payload["delete_hardware_profile"] = True
+        if delete_hwprofile:
+            payload["delete_os_image"] = True
+
+        url = get_recipes_delete_url(recipe_uuid)
+
         response = self._make_session_api_call(
-            lambda: _http_call("get", get_recipes_url(), headers=self._get_headers())
+            lambda: _http_call("delete", url, json=payload, headers=self._get_headers())
+        )
+        if response.status_code == 204:
+            return
+        raise err.ApiError(response.status_code, response.text)
+
+    def create_osimage(self, base_osimage_uuid, name):
+        """
+        Create a custom OsImage
+        """
+        LOGGER.debug("Creating OsImage %s from %s", name, base_osimage_uuid)
+        payload = {"name": name}
+
+        url = get_osimages_create_url(base_osimage_uuid)
+
+        response = self._make_session_api_call(
+            lambda: _http_call("post", url, json=payload, headers=self._get_headers())
         )
 
+        if response.status_code == 201:
+            try:
+                data = response.json()
+                return OsImage.create_from_saas(data)
+            except Exception as exception:
+                raise err.InvalidJsonError(response.status_code, response.text) from exception
+        else:
+            raise err.ApiError(response.status_code, response.text)
+
+    def get_osimage(self, osimage_uuid):
+        """
+        Get one OsImage
+        """
+        LOGGER.debug("Get OsImage %s", osimage_uuid)
+
+        url = get_osimages_get_url(osimage_uuid)
+
+        response = self._make_session_api_call(lambda: _http_call("get", url, headers=self._get_headers()))
+
         if response.status_code == 200:
             try:
-                return Recipes.create_from_saas(response.json())
+                data = response.json()
+                return OsImage.create_from_saas(data)
             except Exception as exception:
                 raise err.InvalidJsonError(response.status_code, response.text) from exception
         else:
             raise err.ApiError(response.status_code, response.text)
 
+    def list_osimages(self):
+        """
+        List available OsImages for user, return Recipes object
+        """
+        LOGGER.debug("Listing available OsImages")
+        results = self._get_paginated_results(get_osimages_list_url(), ordering=None, page_size=-1)
+        return OsImages.create_from_saas(results)
+
+    def delete_osimage(self, osimage_uuid):
+        """
+        Delete OsImage
+        """
+        LOGGER.debug("Deleting OsImage %s", osimage_uuid)
+        url = get_osimages_delete_url(osimage_uuid)
+
+        response = self._make_session_api_call(lambda: _http_call("delete", url, headers=self._get_headers()))
+        if response.status_code == 204:
+            return
+        raise err.ApiError(response.status_code, response.text)
+
+    def create_hwprofile(
+        self, name, width, height, density, navigation_bar, form_factor, cpu_count, ram_size, data_disk_size
+    ):
+        """
+        Create a custom HwProfile
+        """
+        LOGGER.debug("Creating HwProfile %s", name)
+
+        payload = {
+            "name": name,
+            "device_properties": {},
+            "display_settings": {
+                "displays": [{"width": width, "height": height, "density": density}],
+                "hw_navigation_keys": not navigation_bar,
+            },
+            "form_factor": form_factor,
+            "cpu_count": cpu_count,
+            "ram_size": ram_size,
+            "data_disk_size": data_disk_size,
+        }
+
+        url = get_hwprofiles_create_url()
+
+        response = self._make_session_api_call(
+            lambda: _http_call("post", url, json=payload, headers=self._get_headers())
+        )
+
+        if response.status_code == 201:
+            try:
+                data = response.json()
+                return HwProfile.create_from_saas(data)
+            except Exception as exception:
+                raise err.InvalidJsonError(response.status_code, response.text) from exception
+        else:
+            raise err.ApiError(response.status_code, response.text)
+
+    def get_hwprofile(self, hwprofile_uuid):
+        """
+        Get one HwProfile
+        """
+        LOGGER.debug("Get HwProfile %s", hwprofile_uuid)
+
+        url = get_hwprofiles_get_url(hwprofile_uuid)
+
+        response = self._make_session_api_call(lambda: _http_call("get", url, headers=self._get_headers()))
+
+        if response.status_code == 200:
+            try:
+                data = response.json()
+                return HwProfile.create_from_saas(data)
+            except Exception as exception:
+                raise err.InvalidJsonError(response.status_code, response.text) from exception
+        else:
+            raise err.ApiError(response.status_code, response.text)
+
+    def list_hwprofiles(self):
+        """
+        List available HwProfiles for user, return HwProfiles object
+        """
+        LOGGER.debug("Listing available HwProfiles")
+        results = self._get_paginated_results(get_hwprofiles_list_url(), ordering=None, page_size=50)
+        return HwProfiles.create_from_saas(results)
+
+    def delete_hwprofile(self, hwprofile_uuid):
+        """
+        Delete HwProfile
+        """
+        LOGGER.debug("Deleting HwProfile %s", hwprofile_uuid)
+        url = get_hwprofiles_delete_url(hwprofile_uuid)
+
+        response = self._make_session_api_call(lambda: _http_call("delete", url, headers=self._get_headers()))
+        if response.status_code == 204:
+            return
+        raise err.ApiError(response.status_code, response.text)
+
     def get_instance(self, instance_uuid):
         """
         Return Instance from SaaS API
         """
         LOGGER.debug("Get instance")
         response = self._make_session_api_call(
-            lambda: _http_call("get", get_instance_url(instance_uuid), headers=self._get_headers())
+            lambda: _http_call("get", get_instances_get_url(instance_uuid), headers=self._get_headers())
         )
         if response.status_code == 200:
             try:
                 data = response.json()
                 return Instance.create_from_saas(data)
             except Exception as exception:
                 raise err.InvalidJsonError(response.status_code, response.text) from exception
@@ -188,15 +401,15 @@
             raise err.ApiError(response.status_code, response.text)
 
     def get_instances(self):
         """
         Return Instances from SaaS API
         """
         LOGGER.debug("Listing Instances")
-        results = self._get_paginated_results(get_instance_list_url(), ordering="+created_at", page_size=50)
+        results = self._get_paginated_results(get_instances_list_url(), ordering="+created_at", page_size=50)
         return Instances.create_from_saas(results)
 
     def _get_jwt(self):
         """
         Get JWT for user
         """
         self.jwt = authcache.get_jwt()
@@ -223,18 +436,18 @@
         """
         LOGGER.info("[%s] Request instance details", instance_uuid)
 
         if HTTP_FAKE_INSTANCE_STATE:
             LOGGER.info("Using fake instance state %s", HTTP_FAKE_INSTANCE_STATE)
             return HTTP_FAKE_INSTANCE_STATE
 
-        url = get_instance_url(instance_uuid)
+        url = get_instances_get_url(instance_uuid)
         response = self._make_session_api_call(lambda: _http_call("get", url, json={}, headers=self._get_headers()))
 
-        if response.status_code == 200:
+        if response.status_code in [200, 204]:
             try:
                 return response.json()["state"]
             except Exception as exception:
                 raise err.InvalidJsonError(response.status_code, response.text) from exception
         elif response.status_code == 404:
             LOGGER.info("[%s] Instance not found, considering it as DELETED", instance_uuid)
             return InstanceState.DELETED
@@ -256,45 +469,73 @@
         """
         LOGGER.debug("Waiting for %s started (HTTP fallback)", instance_uuid)
         wait_until(
             lambda: not is_instance_starting(self._request_instance_state(instance_uuid)), get_start_timeout(), period=3
         )
         return self._request_instance_state(instance_uuid)
 
+    def _wait_for_instance_saved(self, instance_uuid):
+        """
+        Return the actual state whether it succeeds or not, the caller needs to check it.
+        """
+        LOGGER.debug("Waiting for %s saved (HTTP fallback)", instance_uuid)
+        wait_until(
+            lambda: not is_instance_saving(self._request_instance_state(instance_uuid)), get_save_timeout(), period=3
+        )
+        return self._request_instance_state(instance_uuid)
+
     def login(self):
         """
         Perform a login request
         """
         return self._get_jwt()
 
-    def _start_api_call(self, recipe_uuid, instance_name, stop_when_inactive):
+    def logout(self):
+        """
+        Call signout endpoint to trash the JWT properly on the platform
+        """
+        if not authcache.get_jwt():
+            # No need to signout if no JWT present
+            return
+
+        url = get_logout_url()
+        try:
+            # Single shot call (retry is not required here)
+            _http_call("post", url, headers=self._get_headers())
+            LOGGER.info("Signed out from the platform")
+        except Exception as exception:
+            # Signout from the platform should not trigger any error
+            LOGGER.warning("Cannot signout from the platform due to: %s", str(exception))
+
+    def _start_api_call(self, recipe_uuid, instance_name, timeout_params):
         """
         Start instance with API, returns dict response on success
         """
-        payload = {"instance_name": instance_name, "stop_when_inactive": stop_when_inactive}
-        url = get_start_disposable_url(recipe_uuid)
+        payload = {"instance_name": instance_name}
+        payload.update(timeout_params)
+        url = get_instances_start_url(recipe_uuid)
 
         response = self._make_session_api_call(
             lambda: _http_call("post", url, json=payload, headers=self._get_headers())
         )
         if response.status_code == 201:
             try:
                 return response.json()
             except Exception as exception:
                 raise err.InvalidJsonError(response.status_code, response.text) from exception
         else:
             raise err.ApiError(response.status_code, response.text)
 
-    def start_disposable_instance(self, recipe_uuid, instance_name, stop_when_inactive, no_wait):
+    def start_disposable_instance(self, recipe_uuid, instance_name, timeout_params, no_wait):
         """
         Start a new disposable instance, return Instance object
         """
         LOGGER.debug('Starting new "%s" disposable Instance', instance_name)
 
-        instance = Instance.create_from_saas(self._start_api_call(recipe_uuid, instance_name, stop_when_inactive))
+        instance = Instance.create_from_saas(self._start_api_call(recipe_uuid, instance_name, timeout_params))
         if no_wait:
             return instance
 
         with SIOClient(jwt=self._get_jwt()) as sio:
             if not sio.exception:
                 instance.state = sio.wait_for_instance_started(instance.uuid)
             else:
@@ -316,15 +557,15 @@
         LOGGER.info("[%s] Instance started", instance.uuid)
         return instance
 
     def _stop_api_call(self, instance_uuid):
         """
         Stop instance with API returns dict response on success
         """
-        url = get_stop_disposable_url(instance_uuid)
+        url = get_instances_stop_url(instance_uuid)
         response = self._make_session_api_call(lambda: _http_call("post", url, json={}, headers=self._get_headers()))
 
         if response.status_code == 200:
             try:
                 return response.json()
             except Exception as exception:
                 raise err.InvalidJsonError(response.status_code, response.text) from exception
@@ -358,7 +599,67 @@
 
         if instance.state != InstanceState.DELETED:
             LOGGER.error("[%s] Instance not stopped", instance_uuid)
             raise err.InstanceError(instance_uuid, InstanceState.DELETED, instance.state)
 
         LOGGER.info("[%s] Instance stopped", instance_uuid)
         return instance
+
+    def _save_api_call(self, instance_uuid, action, recipe_name, osimage_name):
+        """
+        Save instance with API returns dict response on success
+        """
+        assert action in [SAVE_ACTION, SAVE_AS_ACTION]
+        url = get_instances_save_url(instance_uuid)
+        body = {"action": action}
+        if recipe_name:
+            body["new_recipe_name"] = recipe_name
+        if osimage_name:
+            body["new_os_image_name"] = osimage_name
+        response = self._make_session_api_call(lambda: _http_call("post", url, json=body, headers=self._get_headers()))
+
+        if response.status_code in [201, 204]:
+            try:
+                return
+            except Exception as exception:
+                raise err.InvalidJsonError(response.status_code, response.text) from exception
+        else:
+            raise err.ApiError(response.status_code, response.text)
+
+    def _save_instance(self, instance, action, recipe_name, osimage_name):
+        self._save_api_call(instance.uuid, action, recipe_name, osimage_name)
+
+        with SIOClient(jwt=self._get_jwt()) as sio:
+            if not sio.exception:
+                instance.state = sio.wait_for_instance_saved(instance.uuid)
+            else:
+                LOGGER.warning(
+                    "[%s] SIO client unreachable (%s), fallback to HTTP polling", instance.uuid, str(sio.exception)
+                )
+                instance.state = self._wait_for_instance_saved(instance.uuid)
+
+        if is_instance_saving(instance.state):
+            # Perform an HTTP call to be sure in case Socket.IO server got down,
+            # or missed to push one message.
+            LOGGER.info("[%s] Instance not saved yet, perform HTTP request to confirm", instance.uuid)
+            instance.state = self._request_instance_state(instance.uuid)
+
+        if instance.state != InstanceState.DELETED:
+            LOGGER.error("[%s] Instance not saved", instance.uuid)
+            raise err.InstanceError(instance.uuid, InstanceState.DELETED, instance.state)
+
+        LOGGER.info("[%s] Instance saved", instance.uuid)
+        return instance
+
+    def save_instance(self, instance):
+        """
+        Save a running disposable instance
+        """
+        LOGGER.debug("[%s] Saving Instance", instance.uuid)
+        return self._save_instance(instance, SAVE_ACTION, recipe_name=None, osimage_name=None)
+
+    def saveas_instance(self, instance, recipe_name, osimage_name):
+        """
+        Save as a running disposable instance
+        """
+        LOGGER.debug("[%s] Saving as Instance", instance.uuid)
+        return self._save_instance(instance, SAVE_AS_ACTION, recipe_name, osimage_name)
```

## gmsaas/saas/logcollector.py

```diff
@@ -10,14 +10,15 @@
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """
 Log collector
 """
+import pathlib
 import os
 import platform
 import datetime
 import shlex
 
 from zipfile import ZipFile
 from tabulate import tabulate
@@ -131,17 +132,20 @@
         for log_file in self.log_files:
             if os.path.exists(log_file):
                 LOGGER.info("Added `%s` to logs archive", log_file)
                 archive.write(log_file, os.path.basename(log_file))
             else:
                 LOGGER.info("`%s` not added to logs archive: file does not exist", log_file)
 
-    def process(self):
+    def process(self, archive_path=None):
         """
         Generate logs archive
         """
-        archive_path = os.path.join(_get_log_archive_dir(), _get_log_archive_name())
+        if not archive_path:
+            archive_path = os.path.join(_get_log_archive_dir(), _get_log_archive_name())
+        elif pathlib.Path(archive_path).is_dir():
+            archive_path = os.path.join(archive_path, _get_log_archive_name())
         with ZipFile(archive_path, "w") as archive:
             self.add_ps_log(archive)
             self.add_logcat_logs(archive)
             self.add_static_log_files(archive)
         return archive_path
```

## gmsaas/saas/sioclient.py

```diff
@@ -18,18 +18,24 @@
 import os
 import json
 from collections import namedtuple
 from urllib.parse import urlparse
 import socketio
 import engineio
 
-from gmsaas.gmsaas.timeout import get_start_timeout, get_stop_timeout, wait_until
+from gmsaas.gmsaas.timeout import get_start_timeout, get_stop_timeout, get_save_timeout, wait_until
 from gmsaas.gmsaas.triggererrors import trigger_sio_unreachable, get_fake_sio_instance_state, trigger_unrecognized_state
 from gmsaas.gmsaas.logger import LOGGER, get_logger
-from gmsaas.model.instanceinfo import Instance, InstanceState, is_instance_starting, is_instance_stopping
+from gmsaas.model.instanceinfo import (
+    Instance,
+    InstanceState,
+    is_instance_starting,
+    is_instance_stopping,
+    is_instance_saving,
+)
 
 
 SIO_BASE_URL = os.environ.get("GM_PLATFORM_SIO_BASE_URL", "https://ws.geny.io/cloud")
 SIO_QUERY_STRING = "?token=Bearer%20{}"
 SIO_FAKE_INSTANCE_STATE = get_fake_sio_instance_state()
 SIO_UNRECOGNIZED_INSTANCE_STATE = trigger_unrecognized_state()
 SIO_LOGGER = get_logger(logger_name="sio", version=None)
@@ -179,7 +185,15 @@
     def wait_for_instance_stopped(self, instance_uuid):
         """
         Return the actual state whether it succeeds or not, the caller needs to check it.
         """
         LOGGER.debug("Waiting for %s stopped", instance_uuid)
         wait_until(lambda: not is_instance_stopping(self._get_instance_state(instance_uuid)), get_stop_timeout())
         return self._get_instance_state(instance_uuid)
+
+    def wait_for_instance_saved(self, instance_uuid):
+        """
+        Return the actual state whether it succeeds or not, the caller needs to check it.
+        """
+        LOGGER.debug("Waiting for %s saved", instance_uuid)
+        wait_until(lambda: not is_instance_saving(self._get_instance_state(instance_uuid)), get_save_timeout())
+        return self._get_instance_state(instance_uuid)
```

## Comparing `gmsaas-1.7.1.dist-info/METADATA` & `gmsaas-1.8.0.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: gmsaas
-Version: 1.7.1
+Version: 1.8.0
 Summary: Universal Command Line Interface for Genymotion Cloud SaaS
 Home-page: https://cloud.geny.io
 Author: Genymobile
 Author-email: contact@genymobile.com
 License: Proprietary
 Platform: any
 Classifier: Development Status :: 5 - Production/Stable
@@ -16,37 +16,37 @@
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
 Classifier: Topic :: Software Development :: Quality Assurance
 Classifier: Topic :: Software Development :: Testing
 Classifier: Topic :: Software Development :: Embedded Systems
 Classifier: Topic :: System :: Emulators
-Requires-Python: >=3.6
+Requires-Python: >=3.8
 Description-Content-Type: text/markdown
 Requires-Dist: click
 Requires-Dist: PySocks
 Requires-Dist: requests
 Requires-Dist: requests-toolbelt
 Requires-Dist: tabulate
-Requires-Dist: python-engineio (>=3.13.0)
-Requires-Dist: python-socketio
+Requires-Dist: python-engineio
+Requires-Dist: python-socketio (>=5)
 Requires-Dist: websocket-client
 Requires-Dist: psutil
 
 # gmsaas
 
 ## Description
 
 `gmsaas` is a command line interface to rule all your virtual devices hosted in Genymotion SaaS solution without opening an Internet browser. With it you can list, start and stop devices. Above all, you can securely connect to any devices through Android Debug Bridge.
 
 It is a lightweight binary, easy to install, easy to update.
 
 ## Requirements
 
-- Python 3.6 or above
+- Python 3.8 or above
 - pip3
 - Android SDK
 
 ## Installation
 
 ```bash
 pip3 install [--user] gmsaas
@@ -71,14 +71,33 @@
 Full documentation can be found [here](https://docs.genymotion.com/gmsaas/1.x/)
 
 
 # Change Log
 
 All notable changes of `gmsaas` are documented in this file.
 
+## 1.8.0
+
+### Added
+
+- Added `--max-run-duration` option for command `gmsaas instances start`.
+- Added `gmsaas hwprofiles get|list|create|delete` commands.
+- Added `gmsaas osimages get|list|clone|delete` commands.
+- Added `gmsaas recipes get|create|delete` commands.
+- Added `gmsaas instances save|saveas` commands.
+
+### Changed
+
+- Require at least Python 3.8.
+- Marked as deprecated `--stop-when-inactive` option, replaced by `--max-run-duration`.
+- Added `--out` option to `gmsaas logzip` command.
+- Added `--source` option to `gmsaas recipes list` command.
+- Improved help wording which is now accessible with `-h` in addition of `--help`.
+- Added more details in JSON output format regarding Recipes and Instances.
+
 ## 1.7.1
 
 ### Fixed
 
 - Fix gmsaas when system temp directory is mounted on a separate partition.
 
 ## 1.7.0
```

## Comparing `gmsaas-1.7.1.dist-info/RECORD` & `gmsaas-1.8.0.dist-info/RECORD`

 * *Files 13% similar despite different names*

```diff
@@ -1,49 +1,55 @@
-gmsaas/__init__.py,sha256=Dz5WrAQprlLypO4UDB0gVVSzBezRosV3WAFtyXLViJA,1237
+gmsaas/__init__.py,sha256=3z0Uwvwxwb29c4KrHIhlB35Ry0d8v5dJsjNPMurt7r4,1237
 gmsaas/adbtunnel/__init__.py,sha256=jHKRXYh8H7O8x9qEORelURkiUpmi1TpmFmXYZu30jUM,1618
 gmsaas/adbtunnel/adbclient.py,sha256=CX8J1jaEJ5JoqIrQAGmfPC6qSH76J8YrrCLmSoGenx4,1975
 gmsaas/adbtunnel/adbtunnelclient.py,sha256=R5QKymt1KMoeieWqXGfXKag9zXdP3NM7F1zuB_YzxBo,7604
 gmsaas/adbtunnel/gmadbtunneld/Qt5Core.dll,sha256=wjsPPCN-jynLjpKrqdcqSSXcTUTiKDJogAMOIetGpdY,6631064
 gmsaas/adbtunnel/gmadbtunneld/Qt5Network.dll,sha256=zjUj8M4jj-KBCcZYqLRiX2B5IQ5rRt78WK5FfLEARRY,1891992
 gmsaas/adbtunnel/gmadbtunneld/Qt5WebSockets.dll,sha256=O0irkIiJ93-u0X7KuO6zklOHlI97LsQVX8hhwGrhavQ,184984
-gmsaas/adbtunnel/gmadbtunneld/gmadbtunneld.exe,sha256=es32YTgqyZvzr2FAG95sBco_8epk8VQkklKAZruq4Ps,1424912
+gmsaas/adbtunnel/gmadbtunneld/gmadbtunneld.exe,sha256=B1MSnbPPav3FnwbUaflpOnNAvRsJJtD--WlFOalJcIk,1424912
 gmsaas/adbtunnel/gmadbtunneld/libcrypto-1_1.dll,sha256=OK7qRLnNCzihSjdKi6uGGBswUqX6WwxqEAH0pIIERM4,2892302
 gmsaas/adbtunnel/gmadbtunneld/libgcc_s_dw2-1.dll,sha256=qoGAtjqEnnVTI7savjZLZUwO7ZtDNzj8SR5bZMQQ73Y,113678
 gmsaas/adbtunnel/gmadbtunneld/libssl-1_1.dll,sha256=H4ucGXqpNjsNQyXQXDRQJpV-lP8DbuhUOiVGkhf4Qps,582670
 gmsaas/adbtunnel/gmadbtunneld/libstdc++-6.dll,sha256=wFtxS5S6t13ft3M5ql9IdyvnrCw-nXMi4tFUn8CjnP0,1542158
 gmsaas/adbtunnel/gmadbtunneld/libwinpthread-1.dll,sha256=rhtP5l2lgZb-pZtNwL5krmjW7wRJcCf62928LcONhD0,47104
 gmsaas/cli/__init__.py,sha256=VoSVJU3u5cFsQ80XUo8gxukzOjiCQB9eSNa6EJSPTO4,630
-gmsaas/cli/auth.py,sha256=0_rr26L03QOsUUiKg8ZhZDBDtzjJAbQZL1i_SYBbWh8,2267
+gmsaas/cli/auth.py,sha256=hRscyuV-QNKQqFOn54pCWH3-E9TdqrUDN8hnPGzBHGM,2259
 gmsaas/cli/checks.py,sha256=UmNU8Asbyta3FokszKz57mM1x9BLlp9DUFIZaoZNAso,2493
-gmsaas/cli/cli.py,sha256=QP_A4i-AT8CnkBuIKz-MXujh6en5-K_21JoLqTi0kSo,3894
-gmsaas/cli/clioutput.py,sha256=h3nUn9Smk5YtYqtwUNBtroDc276s1b6n7vbMvcdiG2Q,12060
-gmsaas/cli/config.py,sha256=MAPDkYAYcMN7479mOBNJaEttQp4O0j1QkEVf1HjkpJg,4129
-gmsaas/cli/instances.py,sha256=G62RncVCuOOtfIT15L3CDCwUAkQjCX-FYC0G1BTo52c,7468
-gmsaas/cli/logzip.py,sha256=DbxTiMb6sf1Z0kDnlqHXkoeA7Xn11dBk_NyyQOTWsQQ,1095
-gmsaas/cli/recipes.py,sha256=6x8mpir6-M5KxQnHggvnMdFQkDMbTHOs6ruYxpmoCYY,1495
+gmsaas/cli/cli.py,sha256=3HaQaILO0aufCbw4J5JndqH56QybEqkeyDs5q9_zLLk,4136
+gmsaas/cli/clioutput.py,sha256=2MnDeZ-9UNKyAUrVGaE-zq7iP1j78VRHKvxp8sdlsbs,18043
+gmsaas/cli/config.py,sha256=5LX83rq4mYSDuaKUtHR3hdTrIuNXm_Yoeti1F7_Aukk,4096
+gmsaas/cli/hwprofiles.py,sha256=ehz1KCzfA97o599iVeX5PrMpnvDMH8sPn-jgENhLQsA,4054
+gmsaas/cli/instances.py,sha256=dyz_9FsRgcVkm09zhO8qshXv93pYrAl_cSHW1YFFBzI,11981
+gmsaas/cli/logzip.py,sha256=qeeRpsyKoxiGubJNOurJgyvlVIuPZYmhLM4odLKUYvw,2510
+gmsaas/cli/osimages.py,sha256=1LuR7b0srDXOqVAcWv7zIQLrXF7noJ_8Ev1zM4SKr1E,2787
+gmsaas/cli/recipes.py,sha256=wl8swlnheKFei5DV7SOERLShwKPzn3dYnFwapEggvGY,3723
 gmsaas/gmsaas/__init__.py,sha256=QP9s5WT-5d336Mx4fyufKM7pB4Iz1fHOs4NdYdkQav4,618
-gmsaas/gmsaas/errors.py,sha256=HUADoloOPBmegN4akkn2zU10VPwLiZXthnEIL9pEd9c,12160
+gmsaas/gmsaas/errors.py,sha256=7RCK01ZrbPVCE6ahC7Hflf0zCdvwt5cfl1j6AA4nibY,12392
 gmsaas/gmsaas/logger.py,sha256=d0MpTZ9zn3NtfLHD8rFruz4KQGxjVvHkQY8JVGpcbf0,2266
 gmsaas/gmsaas/proxy.py,sha256=nlLqIjnMQuW00E21lX426Hwk8-HgFuncEpOspsBslEo,3039
-gmsaas/gmsaas/timeout.py,sha256=LPOJHLJYP0T6495-x25tP44MKADafYBz2Wxa-xS9-QA,1614
+gmsaas/gmsaas/timeout.py,sha256=aYGfpOr_orMNb1lx27f_FedxC-VNH3XB9wSISaoQ9jQ,1757
 gmsaas/gmsaas/triggererrors.py,sha256=ncfEPXCOb8yo0f-ssRfSITPAifaWg-Rn9K9dgiA7pSo,1858
 gmsaas/model/__init__.py,sha256=bSyWHatirnRXeyW2sv3k4RHCAzWWs1wM0Z35zEckhU4,587
 gmsaas/model/daemoninfo.py,sha256=NDYkJnOhyHHmceGeaU-Iq7OKTotOnIQwBut2fFFI4gU,758
-gmsaas/model/instanceinfo.py,sha256=reZ-hLj2PGejCCVYFMJ0AOLpw76jcokvsGn61LhEEe8,9212
-gmsaas/model/recipeinfo.py,sha256=UdXQiNDyzQr34fJk7JTlLbCGmGyID5825FziyOELkf4,5394
+gmsaas/model/hwprofileinfo.py,sha256=-RXo-NOpP92BwZC9hlvIsUKK-ownALyGcOZP5fvQw7M,6968
+gmsaas/model/instanceinfo.py,sha256=sf1nSNotHm3VWT2vb7Gx9N-kvncAr2Y8tE7rkNhKg3Y,10129
+gmsaas/model/osimageinfo.py,sha256=UhD-516KG4z0bq2TzCivEhfbkmNCONKEy7QKyO-Lw5g,4799
+gmsaas/model/recipeinfo.py,sha256=dbMMrB_YhapSAhIkvfVwqB-CruUtpzW2x7_tEo99_wo,6377
 gmsaas/saas/__init__.py,sha256=hKDw34Q7YBS-PbgG3YLBfDNdyGO-rfA6Grma92rHALg,811
-gmsaas/saas/api.py,sha256=2KVQ0nfHdpE1chC5nZi6g_WHPql-VLUDtF8As8p-4t0,1792
-gmsaas/saas/client.py,sha256=16mwBz80pfWe4pBzGKnOAGmsH4XhRF9k0UPbThNSiLw,14695
-gmsaas/saas/logcollector.py,sha256=SuUAvdblh-gy9QXPMSz_k2Onh27ybofGio6MvH8O59E,5715
-gmsaas/saas/sioclient.py,sha256=WrTvF6DFEsrf0MwSrq5fy4x_n6SAvAExy3ZnfNZMyS8,7436
+gmsaas/saas/api.py,sha256=0MVpZdenoUCR-mQTHhDY2RENhjWmCWv_qOs6zO-kUHI,3695
+gmsaas/saas/client.py,sha256=OsSqEZKl3S86JXKLt-UaefnvjpfykdQTemVuV3lvMpU,26519
+gmsaas/saas/logcollector.py,sha256=BuNvKnFeusCDDSSWdlYBW7y_RKdSkVXp2yaE4cbWy2s,5915
+gmsaas/saas/sioclient.py,sha256=-p0q2XN8aCgXU3WgdIqIPC7-uCTsB6OH9wzyEMz2g_Y,7909
 gmsaas/storage/__init__.py,sha256=uVcG0g9fhuoT8AWzsdrS3pys8-nSiI-BbpfEFDWkwt0,1178
 gmsaas/storage/authcache.py,sha256=0xSA4J7d2jHtdEqVWWfaLTKBrwoxQUKQU00ytXHM8-E,3009
 gmsaas/storage/configcache.py,sha256=fnTnVskyzt6y0QDYQ78gdezYCGTcAgVtHKeg7y-b5p8,1919
 gmsaas/storage/crypto.py,sha256=bkTmgM3Wx7d8DJrXK2KDiKRiFRD_nCEhJZyzJPew1bs,1931
 gmsaas/storage/json_file_storage.py,sha256=RSGvb5Gzbzucf6AdLFHYmfv8glivz4sYqCncfp6DvZg,2467
 gmsaas/storage/settings.py,sha256=VHmqyc8SdWr6McIShO3-7MHVhDwY6orIV0gecT4-pD0,2863
 gmsaas/storage/storage.py,sha256=q_DJqXk__-pLQTtd9DpDStyssugtIog9JNPwmidR9OU,1990
-gmsaas-1.7.1.dist-info/METADATA,sha256=-ByFYfig58NWfBKpgkAVNBJ_KfHDu4ftf4ParUrRYkU,4724
-gmsaas-1.7.1.dist-info/WHEEL,sha256=bUZreaFKbZJ4IMpypfwg10FxYbJRu-7H_s0Bo5-Iu10,103
-gmsaas-1.7.1.dist-info/entry_points.txt,sha256=lyIM6Rj-fZjlgyyt7ucl9KOUnonRVd2HcM0oLO5Hwnc,48
-gmsaas-1.7.1.dist-info/top_level.txt,sha256=eSuqxqOLilLmmVGNeRqCsst-wdioSD7-iKsJhMCOM8g,7
-gmsaas-1.7.1.dist-info/RECORD,,
+gmsaas/utils/__init__.py,sha256=WtNwvDl9u6XWn2JC_NfSQYMLn6EMJui6T87ooExJTZY,587
+gmsaas/utils/dictionnary.py,sha256=Dl3WS4yr4k5ef8MYbeHEIM_1mWq2NWupLUd4ELYzyXM,1772
+gmsaas-1.8.0.dist-info/METADATA,sha256=B0kHR3WHZsw5cAuaCLwzu9U5M-l8SGRkNw1UY3jWoOg,5439
+gmsaas-1.8.0.dist-info/WHEEL,sha256=bUZreaFKbZJ4IMpypfwg10FxYbJRu-7H_s0Bo5-Iu10,103
+gmsaas-1.8.0.dist-info/entry_points.txt,sha256=lyIM6Rj-fZjlgyyt7ucl9KOUnonRVd2HcM0oLO5Hwnc,48
+gmsaas-1.8.0.dist-info/top_level.txt,sha256=eSuqxqOLilLmmVGNeRqCsst-wdioSD7-iKsJhMCOM8g,7
+gmsaas-1.8.0.dist-info/RECORD,,
```

