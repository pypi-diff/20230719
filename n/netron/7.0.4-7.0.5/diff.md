# Comparing `tmp/netron-7.0.4-py3-none-any.whl.zip` & `tmp/netron-7.0.5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,146 +1,146 @@
-Zip file size: 1588009 bytes, number of entries: 144
--rw-r--r--  2.0 unx     1526 b- defN 23-Jul-15 04:23 netron/__init__.py
--rw-r--r--  2.0 unx    57889 b- defN 23-Jul-15 04:23 netron/acuity-metadata.json
--rw-r--r--  2.0 unx    24160 b- defN 23-Jul-15 04:23 netron/acuity.js
--rw-r--r--  2.0 unx    11340 b- defN 23-Jul-15 04:23 netron/armnn-metadata.json
--rw-r--r--  2.0 unx   108710 b- defN 23-Jul-15 04:23 netron/armnn-schema.js
--rw-r--r--  2.0 unx    13844 b- defN 23-Jul-15 04:23 netron/armnn.js
--rwxr-xr-x  2.0 unx    16619 b- defN 23-Jul-15 04:23 netron/barracuda.js
--rw-r--r--  2.0 unx    38147 b- defN 23-Jul-15 04:23 netron/base.js
--rw-r--r--  2.0 unx     2017 b- defN 23-Jul-15 04:23 netron/bigdl-metadata.json
--rw-r--r--  2.0 unx    24356 b- defN 23-Jul-15 04:23 netron/bigdl-proto.js
--rw-r--r--  2.0 unx    12793 b- defN 23-Jul-15 04:23 netron/bigdl.js
--rw-r--r--  2.0 unx    33629 b- defN 23-Jul-15 04:23 netron/browser.js
--rw-r--r--  2.0 unx     9505 b- defN 23-Jul-15 04:23 netron/caffe-metadata.json
--rw-r--r--  2.0 unx   188897 b- defN 23-Jul-15 04:23 netron/caffe-proto.js
--rw-r--r--  2.0 unx    25581 b- defN 23-Jul-15 04:23 netron/caffe.js
--rw-r--r--  2.0 unx   863689 b- defN 23-Jul-15 04:23 netron/caffe2-metadata.json
--rw-r--r--  2.0 unx    61210 b- defN 23-Jul-15 04:23 netron/caffe2-proto.js
--rw-r--r--  2.0 unx    22669 b- defN 23-Jul-15 04:23 netron/caffe2.js
--rw-r--r--  2.0 unx      902 b- defN 23-Jul-15 04:23 netron/cambricon.js
--rw-r--r--  2.0 unx    13245 b- defN 23-Jul-15 04:23 netron/circle-metadata.json
--rw-r--r--  2.0 unx    99313 b- defN 23-Jul-15 04:23 netron/circle-schema.js
--rw-r--r--  2.0 unx    24512 b- defN 23-Jul-15 04:23 netron/circle.js
--rw-r--r--  2.0 unx    14193 b- defN 23-Jul-15 04:23 netron/cntk-metadata.json
--rw-r--r--  2.0 unx    11578 b- defN 23-Jul-15 04:23 netron/cntk-proto.js
--rw-r--r--  2.0 unx    43826 b- defN 23-Jul-15 04:23 netron/cntk.js
--rw-r--r--  2.0 unx    15775 b- defN 23-Jul-15 04:23 netron/coreml-metadata.json
--rw-r--r--  2.0 unx   415701 b- defN 23-Jul-15 04:23 netron/coreml-proto.js
--rw-r--r--  2.0 unx    67894 b- defN 23-Jul-15 04:23 netron/coreml.js
--rw-r--r--  2.0 unx   102126 b- defN 23-Jul-15 04:23 netron/dagre.js
--rw-r--r--  2.0 unx    20570 b- defN 23-Jul-15 04:23 netron/darknet-metadata.json
--rw-r--r--  2.0 unx    54924 b- defN 23-Jul-15 04:23 netron/darknet.js
--rw-r--r--  2.0 unx     1417 b- defN 23-Jul-15 04:23 netron/dl4j-metadata.json
--rw-r--r--  2.0 unx    17003 b- defN 23-Jul-15 04:23 netron/dl4j.js
--rw-r--r--  2.0 unx      735 b- defN 23-Jul-15 04:23 netron/dlc-metadata.json
--rw-r--r--  2.0 unx     3277 b- defN 23-Jul-15 04:23 netron/dlc-schema.js
--rw-r--r--  2.0 unx    17870 b- defN 23-Jul-15 04:23 netron/dlc.js
--rw-r--r--  2.0 unx     1777 b- defN 23-Jul-15 04:23 netron/dnn-metadata.json
--rw-r--r--  2.0 unx    11533 b- defN 23-Jul-15 04:23 netron/dnn-proto.js
--rw-r--r--  2.0 unx    10601 b- defN 23-Jul-15 04:23 netron/dnn.js
--rw-r--r--  2.0 unx    34494 b- defN 23-Jul-15 04:23 netron/favicon.ico
--rw-r--r--  2.0 unx    11358 b- defN 23-Jul-15 04:23 netron/flatbuffers.js
--rw-r--r--  2.0 unx     7734 b- defN 23-Jul-15 04:23 netron/flax.js
--rw-r--r--  2.0 unx     7568 b- defN 23-Jul-15 04:23 netron/flexbuffers.js
--rw-r--r--  2.0 unx        3 b- defN 23-Jul-15 04:23 netron/flux-metadata.json
--rw-r--r--  2.0 unx     2409 b- defN 23-Jul-15 04:23 netron/flux.js
--rw-r--r--  2.0 unx     6061 b- defN 23-Jul-15 04:23 netron/grapher.css
--rw-r--r--  2.0 unx    25528 b- defN 23-Jul-15 04:23 netron/grapher.js
--rw-r--r--  2.0 unx    29456 b- defN 23-Jul-15 04:23 netron/hailo-metadata.json
--rw-r--r--  2.0 unx    11796 b- defN 23-Jul-15 04:23 netron/hailo.js
--rwxr-xr-x  2.0 unx    57289 b- defN 23-Jul-15 04:23 netron/hdf5.js
--rw-r--r--  2.0 unx     6799 b- defN 23-Jul-15 04:23 netron/hickle.js
--rw-r--r--  2.0 unx    58106 b- defN 23-Jul-15 04:23 netron/icon.png
--rw-r--r--  2.0 unx     1402 b- defN 23-Jul-15 04:23 netron/imgdnn.js
--rw-r--r--  2.0 unx    44057 b- defN 23-Jul-15 04:26 netron/index.html
--rw-r--r--  2.0 unx     4014 b- defN 23-Jul-15 04:23 netron/index.js
--rwxr-xr-x  2.0 unx    18643 b- defN 23-Jul-15 04:23 netron/json.js
--rw-r--r--  2.0 unx   254682 b- defN 23-Jul-15 04:23 netron/keras-metadata.json
--rw-r--r--  2.0 unx    54590 b- defN 23-Jul-15 04:23 netron/keras.js
--rw-r--r--  2.0 unx    64052 b- defN 23-Jul-15 04:23 netron/kmodel.js
--rw-r--r--  2.0 unx      244 b- defN 23-Jul-15 04:23 netron/lasagne-metadata.json
--rw-r--r--  2.0 unx     7061 b- defN 23-Jul-15 04:23 netron/lasagne.js
--rw-r--r--  2.0 unx     5172 b- defN 23-Jul-15 04:23 netron/lightgbm.js
--rw-r--r--  2.0 unx    12839 b- defN 23-Jul-15 04:23 netron/mediapipe.js
--rw-r--r--  2.0 unx    91710 b- defN 23-Jul-15 04:23 netron/megengine-metadata.json
--rw-r--r--  2.0 unx    82284 b- defN 23-Jul-15 04:23 netron/megengine-schema.js
--rw-r--r--  2.0 unx    32109 b- defN 23-Jul-15 04:23 netron/megengine.js
--rw-r--r--  2.0 unx    44765 b- defN 23-Jul-15 04:23 netron/mlir.js
--rw-r--r--  2.0 unx     3423 b- defN 23-Jul-15 04:23 netron/mlnet-metadata.json
--rw-r--r--  2.0 unx    78299 b- defN 23-Jul-15 04:23 netron/mlnet.js
--rw-r--r--  2.0 unx    10058 b- defN 23-Jul-15 04:23 netron/mnn-metadata.json
--rw-r--r--  2.0 unx    62288 b- defN 23-Jul-15 04:23 netron/mnn-schema.js
--rw-r--r--  2.0 unx    17641 b- defN 23-Jul-15 04:23 netron/mnn.js
--rw-r--r--  2.0 unx    85458 b- defN 23-Jul-15 04:23 netron/mslite-metadata.json
--rw-r--r--  2.0 unx   171745 b- defN 23-Jul-15 04:23 netron/mslite-schema.js
--rw-r--r--  2.0 unx    14997 b- defN 23-Jul-15 04:23 netron/mslite.js
--rw-r--r--  2.0 unx    11884 b- defN 23-Jul-15 04:23 netron/mxnet-metadata.json
--rw-r--r--  2.0 unx    37803 b- defN 23-Jul-15 04:23 netron/mxnet.js
--rw-r--r--  2.0 unx    30899 b- defN 23-Jul-15 04:23 netron/ncnn-metadata.json
--rw-r--r--  2.0 unx    38024 b- defN 23-Jul-15 04:23 netron/ncnn.js
--rw-r--r--  2.0 unx   290482 b- defN 23-Jul-15 04:23 netron/nnabla-metadata.json
--rw-r--r--  2.0 unx   434215 b- defN 23-Jul-15 04:23 netron/nnabla-proto.js
--rw-r--r--  2.0 unx    11418 b- defN 23-Jul-15 04:23 netron/nnabla.js
--rw-r--r--  2.0 unx     2224 b- defN 23-Jul-15 04:23 netron/nnef.js
--rw-r--r--  2.0 unx    15163 b- defN 23-Jul-15 04:23 netron/numpy.js
--rw-r--r--  2.0 unx    53079 b- defN 23-Jul-15 04:23 netron/om-metadata.json
--rw-r--r--  2.0 unx    37006 b- defN 23-Jul-15 04:23 netron/om-proto.js
--rw-r--r--  2.0 unx    31227 b- defN 23-Jul-15 04:23 netron/om.js
--rw-r--r--  2.0 unx     6818 b- defN 23-Jul-15 04:23 netron/onednn-metadata.json
--rw-r--r--  2.0 unx    12047 b- defN 23-Jul-15 04:23 netron/onednn.js
--rw-r--r--  2.0 unx  2903924 b- defN 23-Jul-15 04:23 netron/onnx-metadata.json
--rw-r--r--  2.0 unx    59899 b- defN 23-Jul-15 04:23 netron/onnx-proto.js
--rw-r--r--  2.0 unx    15717 b- defN 23-Jul-15 04:23 netron/onnx-schema.js
--rw-r--r--  2.0 unx    83598 b- defN 23-Jul-15 04:23 netron/onnx.js
--rw-r--r--  2.0 unx     9053 b- defN 23-Jul-15 04:23 netron/onnx.py
--rw-r--r--  2.0 unx    84585 b- defN 23-Jul-15 04:23 netron/openvino-metadata.json
--rw-r--r--  2.0 unx    44609 b- defN 23-Jul-15 04:23 netron/openvino.js
--rw-r--r--  2.0 unx     2894 b- defN 23-Jul-15 04:23 netron/paddle-metadata.json
--rw-r--r--  2.0 unx    60111 b- defN 23-Jul-15 04:23 netron/paddle-proto.js
--rw-r--r--  2.0 unx    19797 b- defN 23-Jul-15 04:23 netron/paddle-schema.js
--rw-r--r--  2.0 unx    37551 b- defN 23-Jul-15 04:23 netron/paddle.js
--rw-r--r--  2.0 unx     5537 b- defN 23-Jul-15 04:23 netron/pickle.js
--rw-r--r--  2.0 unx    42713 b- defN 23-Jul-15 04:23 netron/protobuf.js
--rw-r--r--  2.0 unx   303560 b- defN 23-Jul-15 04:23 netron/python.js
--rwxr-xr-x  2.0 unx   410224 b- defN 23-Jul-15 04:23 netron/pytorch-metadata.json
--rw-r--r--  2.0 unx    13170 b- defN 23-Jul-15 04:23 netron/pytorch-schema.js
--rw-r--r--  2.0 unx   182217 b- defN 23-Jul-15 04:23 netron/pytorch.js
--rw-r--r--  2.0 unx    24259 b- defN 23-Jul-15 04:23 netron/pytorch.py
--rw-r--r--  2.0 unx     5473 b- defN 23-Jul-15 04:23 netron/rknn-metadata.json
--rw-r--r--  2.0 unx     4263 b- defN 23-Jul-15 04:23 netron/rknn-schema.js
--rw-r--r--  2.0 unx    24816 b- defN 23-Jul-15 04:23 netron/rknn.js
--rw-r--r--  2.0 unx     4571 b- defN 23-Jul-15 04:23 netron/safetensors.js
--rw-r--r--  2.0 unx     5972 b- defN 23-Jul-15 04:23 netron/server.js
--rw-r--r--  2.0 unx    11874 b- defN 23-Jul-15 04:26 netron/server.py
--rw-r--r--  2.0 unx   160693 b- defN 23-Jul-15 04:23 netron/sklearn-metadata.json
--rw-r--r--  2.0 unx    14713 b- defN 23-Jul-15 04:23 netron/sklearn.js
--rw-r--r--  2.0 unx     4908 b- defN 23-Jul-15 04:23 netron/tar.js
--rwxr-xr-x  2.0 unx    27914 b- defN 23-Jul-15 04:23 netron/tengine-metadata.json
--rwxr-xr-x  2.0 unx    28126 b- defN 23-Jul-15 04:23 netron/tengine.js
--rw-r--r--  2.0 unx     5304 b- defN 23-Jul-15 04:23 netron/tensorrt.js
--rw-r--r--  2.0 unx    11085 b- defN 23-Jul-15 04:23 netron/text.js
--rw-r--r--  2.0 unx  2221625 b- defN 23-Jul-15 04:23 netron/tf-metadata.json
--rw-r--r--  2.0 unx   361929 b- defN 23-Jul-15 04:23 netron/tf-proto.js
--rw-r--r--  2.0 unx   106628 b- defN 23-Jul-15 04:23 netron/tf.js
--rw-r--r--  2.0 unx    29780 b- defN 23-Jul-15 04:23 netron/tflite-metadata.json
--rw-r--r--  2.0 unx   110995 b- defN 23-Jul-15 04:23 netron/tflite-schema.js
--rw-r--r--  2.0 unx    25214 b- defN 23-Jul-15 04:23 netron/tflite.js
--rw-r--r--  2.0 unx    20380 b- defN 23-Jul-15 04:23 netron/tnn-metadata.json
--rw-r--r--  2.0 unx    26888 b- defN 23-Jul-15 04:23 netron/tnn.js
--rw-r--r--  2.0 unx    12510 b- defN 23-Jul-15 04:23 netron/torch-metadata.json
--rw-r--r--  2.0 unx    41580 b- defN 23-Jul-15 04:23 netron/torch.js
--rw-r--r--  2.0 unx     2333 b- defN 23-Jul-15 04:23 netron/uff-metadata.json
--rw-r--r--  2.0 unx    30910 b- defN 23-Jul-15 04:23 netron/uff-proto.js
--rw-r--r--  2.0 unx    12805 b- defN 23-Jul-15 04:23 netron/uff.js
--rw-r--r--  2.0 unx   235511 b- defN 23-Jul-15 04:23 netron/view.js
--rw-r--r--  2.0 unx     8031 b- defN 23-Jul-15 04:23 netron/weka.js
--rw-r--r--  2.0 unx    64034 b- defN 23-Jul-15 04:23 netron/xml.js
--rw-r--r--  2.0 unx    55685 b- defN 23-Jul-15 04:23 netron/xmodel-proto.js
--rw-r--r--  2.0 unx    13916 b- defN 23-Jul-15 04:23 netron/xmodel.js
--rw-r--r--  2.0 unx    30755 b- defN 23-Jul-15 04:23 netron/zip.js
--rw-r--r--  2.0 unx     1576 b- defN 23-Jul-15 04:26 netron-7.0.4.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-15 04:26 netron-7.0.4.dist-info/WHEEL
--rw-r--r--  2.0 unx       39 b- defN 23-Jul-15 04:26 netron-7.0.4.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        7 b- defN 23-Jul-15 04:26 netron-7.0.4.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    11131 b- defN 23-Jul-15 04:26 netron-7.0.4.dist-info/RECORD
-144 files, 12935260 bytes uncompressed, 1571317 bytes compressed:  87.9%
+Zip file size: 1587695 bytes, number of entries: 144
+-rw-r--r--  2.0 unx     1526 b- defN 23-Jul-19 11:34 netron/__init__.py
+-rw-r--r--  2.0 unx    57889 b- defN 23-Jul-19 11:34 netron/acuity-metadata.json
+-rw-r--r--  2.0 unx    24160 b- defN 23-Jul-19 11:34 netron/acuity.js
+-rw-r--r--  2.0 unx    11340 b- defN 23-Jul-19 11:34 netron/armnn-metadata.json
+-rw-r--r--  2.0 unx   108710 b- defN 23-Jul-19 11:34 netron/armnn-schema.js
+-rw-r--r--  2.0 unx    13793 b- defN 23-Jul-19 11:34 netron/armnn.js
+-rwxr-xr-x  2.0 unx    16571 b- defN 23-Jul-19 11:34 netron/barracuda.js
+-rw-r--r--  2.0 unx    38147 b- defN 23-Jul-19 11:34 netron/base.js
+-rw-r--r--  2.0 unx     2017 b- defN 23-Jul-19 11:34 netron/bigdl-metadata.json
+-rw-r--r--  2.0 unx    24356 b- defN 23-Jul-19 11:34 netron/bigdl-proto.js
+-rw-r--r--  2.0 unx    12745 b- defN 23-Jul-19 11:34 netron/bigdl.js
+-rw-r--r--  2.0 unx    34585 b- defN 23-Jul-19 11:34 netron/browser.js
+-rw-r--r--  2.0 unx     9505 b- defN 23-Jul-19 11:34 netron/caffe-metadata.json
+-rw-r--r--  2.0 unx   188897 b- defN 23-Jul-19 11:34 netron/caffe-proto.js
+-rw-r--r--  2.0 unx    25529 b- defN 23-Jul-19 11:34 netron/caffe.js
+-rw-r--r--  2.0 unx   863689 b- defN 23-Jul-19 11:34 netron/caffe2-metadata.json
+-rw-r--r--  2.0 unx    61210 b- defN 23-Jul-19 11:34 netron/caffe2-proto.js
+-rw-r--r--  2.0 unx    22617 b- defN 23-Jul-19 11:34 netron/caffe2.js
+-rw-r--r--  2.0 unx      902 b- defN 23-Jul-19 11:34 netron/cambricon.js
+-rw-r--r--  2.0 unx    13245 b- defN 23-Jul-19 11:34 netron/circle-metadata.json
+-rw-r--r--  2.0 unx    99313 b- defN 23-Jul-19 11:34 netron/circle-schema.js
+-rw-r--r--  2.0 unx    24420 b- defN 23-Jul-19 11:34 netron/circle.js
+-rw-r--r--  2.0 unx    14193 b- defN 23-Jul-19 11:34 netron/cntk-metadata.json
+-rw-r--r--  2.0 unx    11578 b- defN 23-Jul-19 11:34 netron/cntk-proto.js
+-rw-r--r--  2.0 unx    43790 b- defN 23-Jul-19 11:34 netron/cntk.js
+-rw-r--r--  2.0 unx    15775 b- defN 23-Jul-19 11:34 netron/coreml-metadata.json
+-rw-r--r--  2.0 unx   415701 b- defN 23-Jul-19 11:34 netron/coreml-proto.js
+-rw-r--r--  2.0 unx    68026 b- defN 23-Jul-19 11:34 netron/coreml.js
+-rw-r--r--  2.0 unx   102126 b- defN 23-Jul-19 11:34 netron/dagre.js
+-rw-r--r--  2.0 unx    20570 b- defN 23-Jul-19 11:34 netron/darknet-metadata.json
+-rw-r--r--  2.0 unx    54898 b- defN 23-Jul-19 11:34 netron/darknet.js
+-rw-r--r--  2.0 unx     1417 b- defN 23-Jul-19 11:34 netron/dl4j-metadata.json
+-rw-r--r--  2.0 unx    16955 b- defN 23-Jul-19 11:34 netron/dl4j.js
+-rw-r--r--  2.0 unx      735 b- defN 23-Jul-19 11:34 netron/dlc-metadata.json
+-rw-r--r--  2.0 unx     3277 b- defN 23-Jul-19 11:34 netron/dlc-schema.js
+-rw-r--r--  2.0 unx    17870 b- defN 23-Jul-19 11:34 netron/dlc.js
+-rw-r--r--  2.0 unx     1777 b- defN 23-Jul-19 11:34 netron/dnn-metadata.json
+-rw-r--r--  2.0 unx    11533 b- defN 23-Jul-19 11:34 netron/dnn-proto.js
+-rw-r--r--  2.0 unx    10601 b- defN 23-Jul-19 11:34 netron/dnn.js
+-rw-r--r--  2.0 unx    34494 b- defN 23-Jul-19 11:34 netron/favicon.ico
+-rw-r--r--  2.0 unx    11358 b- defN 23-Jul-19 11:34 netron/flatbuffers.js
+-rw-r--r--  2.0 unx     7734 b- defN 23-Jul-19 11:34 netron/flax.js
+-rw-r--r--  2.0 unx     7568 b- defN 23-Jul-19 11:34 netron/flexbuffers.js
+-rw-r--r--  2.0 unx        3 b- defN 23-Jul-19 11:34 netron/flux-metadata.json
+-rw-r--r--  2.0 unx     2409 b- defN 23-Jul-19 11:34 netron/flux.js
+-rw-r--r--  2.0 unx     6061 b- defN 23-Jul-19 11:34 netron/grapher.css
+-rw-r--r--  2.0 unx    25528 b- defN 23-Jul-19 11:34 netron/grapher.js
+-rw-r--r--  2.0 unx    29456 b- defN 23-Jul-19 11:34 netron/hailo-metadata.json
+-rw-r--r--  2.0 unx    11698 b- defN 23-Jul-19 11:34 netron/hailo.js
+-rwxr-xr-x  2.0 unx    57289 b- defN 23-Jul-19 11:34 netron/hdf5.js
+-rw-r--r--  2.0 unx     6799 b- defN 23-Jul-19 11:34 netron/hickle.js
+-rw-r--r--  2.0 unx    58106 b- defN 23-Jul-19 11:34 netron/icon.png
+-rw-r--r--  2.0 unx     1402 b- defN 23-Jul-19 11:34 netron/imgdnn.js
+-rw-r--r--  2.0 unx    44057 b- defN 23-Jul-19 11:37 netron/index.html
+-rw-r--r--  2.0 unx     4014 b- defN 23-Jul-19 11:34 netron/index.js
+-rwxr-xr-x  2.0 unx    18643 b- defN 23-Jul-19 11:34 netron/json.js
+-rw-r--r--  2.0 unx   254682 b- defN 23-Jul-19 11:34 netron/keras-metadata.json
+-rw-r--r--  2.0 unx    54548 b- defN 23-Jul-19 11:34 netron/keras.js
+-rw-r--r--  2.0 unx    64052 b- defN 23-Jul-19 11:34 netron/kmodel.js
+-rw-r--r--  2.0 unx      244 b- defN 23-Jul-19 11:34 netron/lasagne-metadata.json
+-rw-r--r--  2.0 unx     7061 b- defN 23-Jul-19 11:34 netron/lasagne.js
+-rw-r--r--  2.0 unx     5172 b- defN 23-Jul-19 11:34 netron/lightgbm.js
+-rw-r--r--  2.0 unx    10385 b- defN 23-Jul-19 11:34 netron/mediapipe.js
+-rw-r--r--  2.0 unx    91710 b- defN 23-Jul-19 11:34 netron/megengine-metadata.json
+-rw-r--r--  2.0 unx    82284 b- defN 23-Jul-19 11:34 netron/megengine-schema.js
+-rw-r--r--  2.0 unx    30574 b- defN 23-Jul-19 11:34 netron/megengine.js
+-rw-r--r--  2.0 unx    44765 b- defN 23-Jul-19 11:34 netron/mlir.js
+-rw-r--r--  2.0 unx     3423 b- defN 23-Jul-19 11:34 netron/mlnet-metadata.json
+-rw-r--r--  2.0 unx    78251 b- defN 23-Jul-19 11:34 netron/mlnet.js
+-rw-r--r--  2.0 unx    10058 b- defN 23-Jul-19 11:34 netron/mnn-metadata.json
+-rw-r--r--  2.0 unx    62342 b- defN 23-Jul-19 11:34 netron/mnn-schema.js
+-rw-r--r--  2.0 unx    17641 b- defN 23-Jul-19 11:34 netron/mnn.js
+-rw-r--r--  2.0 unx    85458 b- defN 23-Jul-19 11:34 netron/mslite-metadata.json
+-rw-r--r--  2.0 unx   171745 b- defN 23-Jul-19 11:34 netron/mslite-schema.js
+-rw-r--r--  2.0 unx    14997 b- defN 23-Jul-19 11:34 netron/mslite.js
+-rw-r--r--  2.0 unx    11884 b- defN 23-Jul-19 11:34 netron/mxnet-metadata.json
+-rw-r--r--  2.0 unx    37803 b- defN 23-Jul-19 11:34 netron/mxnet.js
+-rw-r--r--  2.0 unx    30899 b- defN 23-Jul-19 11:34 netron/ncnn-metadata.json
+-rw-r--r--  2.0 unx    37984 b- defN 23-Jul-19 11:34 netron/ncnn.js
+-rw-r--r--  2.0 unx   290482 b- defN 23-Jul-19 11:34 netron/nnabla-metadata.json
+-rw-r--r--  2.0 unx   434215 b- defN 23-Jul-19 11:34 netron/nnabla-proto.js
+-rw-r--r--  2.0 unx    11418 b- defN 23-Jul-19 11:34 netron/nnabla.js
+-rw-r--r--  2.0 unx     2224 b- defN 23-Jul-19 11:34 netron/nnef.js
+-rw-r--r--  2.0 unx    15163 b- defN 23-Jul-19 11:34 netron/numpy.js
+-rw-r--r--  2.0 unx    53079 b- defN 23-Jul-19 11:34 netron/om-metadata.json
+-rw-r--r--  2.0 unx    37006 b- defN 23-Jul-19 11:34 netron/om-proto.js
+-rw-r--r--  2.0 unx    28732 b- defN 23-Jul-19 11:34 netron/om.js
+-rw-r--r--  2.0 unx     6818 b- defN 23-Jul-19 11:34 netron/onednn-metadata.json
+-rw-r--r--  2.0 unx    12047 b- defN 23-Jul-19 11:34 netron/onednn.js
+-rw-r--r--  2.0 unx  2903924 b- defN 23-Jul-19 11:34 netron/onnx-metadata.json
+-rw-r--r--  2.0 unx    59899 b- defN 23-Jul-19 11:34 netron/onnx-proto.js
+-rw-r--r--  2.0 unx    15717 b- defN 23-Jul-19 11:34 netron/onnx-schema.js
+-rw-r--r--  2.0 unx    83598 b- defN 23-Jul-19 11:34 netron/onnx.js
+-rw-r--r--  2.0 unx     9053 b- defN 23-Jul-19 11:34 netron/onnx.py
+-rw-r--r--  2.0 unx    84585 b- defN 23-Jul-19 11:34 netron/openvino-metadata.json
+-rw-r--r--  2.0 unx    44560 b- defN 23-Jul-19 11:34 netron/openvino.js
+-rw-r--r--  2.0 unx     2894 b- defN 23-Jul-19 11:34 netron/paddle-metadata.json
+-rw-r--r--  2.0 unx    60111 b- defN 23-Jul-19 11:34 netron/paddle-proto.js
+-rw-r--r--  2.0 unx    19797 b- defN 23-Jul-19 11:34 netron/paddle-schema.js
+-rw-r--r--  2.0 unx    37551 b- defN 23-Jul-19 11:34 netron/paddle.js
+-rw-r--r--  2.0 unx     5537 b- defN 23-Jul-19 11:34 netron/pickle.js
+-rw-r--r--  2.0 unx    42713 b- defN 23-Jul-19 11:34 netron/protobuf.js
+-rw-r--r--  2.0 unx   303560 b- defN 23-Jul-19 11:34 netron/python.js
+-rwxr-xr-x  2.0 unx   410224 b- defN 23-Jul-19 11:34 netron/pytorch-metadata.json
+-rw-r--r--  2.0 unx    13170 b- defN 23-Jul-19 11:34 netron/pytorch-schema.js
+-rw-r--r--  2.0 unx   182243 b- defN 23-Jul-19 11:34 netron/pytorch.js
+-rw-r--r--  2.0 unx    24259 b- defN 23-Jul-19 11:34 netron/pytorch.py
+-rw-r--r--  2.0 unx     5473 b- defN 23-Jul-19 11:34 netron/rknn-metadata.json
+-rw-r--r--  2.0 unx     4263 b- defN 23-Jul-19 11:34 netron/rknn-schema.js
+-rw-r--r--  2.0 unx    24816 b- defN 23-Jul-19 11:34 netron/rknn.js
+-rw-r--r--  2.0 unx     4571 b- defN 23-Jul-19 11:34 netron/safetensors.js
+-rw-r--r--  2.0 unx     5876 b- defN 23-Jul-19 11:34 netron/server.js
+-rw-r--r--  2.0 unx    11874 b- defN 23-Jul-19 11:37 netron/server.py
+-rw-r--r--  2.0 unx   160693 b- defN 23-Jul-19 11:34 netron/sklearn-metadata.json
+-rw-r--r--  2.0 unx    14713 b- defN 23-Jul-19 11:34 netron/sklearn.js
+-rw-r--r--  2.0 unx     4908 b- defN 23-Jul-19 11:34 netron/tar.js
+-rwxr-xr-x  2.0 unx    27914 b- defN 23-Jul-19 11:34 netron/tengine-metadata.json
+-rwxr-xr-x  2.0 unx    28094 b- defN 23-Jul-19 11:34 netron/tengine.js
+-rw-r--r--  2.0 unx     5304 b- defN 23-Jul-19 11:34 netron/tensorrt.js
+-rw-r--r--  2.0 unx    11085 b- defN 23-Jul-19 11:34 netron/text.js
+-rw-r--r--  2.0 unx  2221625 b- defN 23-Jul-19 11:34 netron/tf-metadata.json
+-rw-r--r--  2.0 unx   361929 b- defN 23-Jul-19 11:34 netron/tf-proto.js
+-rw-r--r--  2.0 unx   106578 b- defN 23-Jul-19 11:34 netron/tf.js
+-rw-r--r--  2.0 unx    29824 b- defN 23-Jul-19 11:34 netron/tflite-metadata.json
+-rw-r--r--  2.0 unx   110995 b- defN 23-Jul-19 11:34 netron/tflite-schema.js
+-rw-r--r--  2.0 unx    25098 b- defN 23-Jul-19 11:34 netron/tflite.js
+-rw-r--r--  2.0 unx    20380 b- defN 23-Jul-19 11:34 netron/tnn-metadata.json
+-rw-r--r--  2.0 unx    26868 b- defN 23-Jul-19 11:34 netron/tnn.js
+-rw-r--r--  2.0 unx    12510 b- defN 23-Jul-19 11:34 netron/torch-metadata.json
+-rw-r--r--  2.0 unx    41544 b- defN 23-Jul-19 11:34 netron/torch.js
+-rw-r--r--  2.0 unx     2333 b- defN 23-Jul-19 11:34 netron/uff-metadata.json
+-rw-r--r--  2.0 unx    30910 b- defN 23-Jul-19 11:34 netron/uff-proto.js
+-rw-r--r--  2.0 unx    12757 b- defN 23-Jul-19 11:34 netron/uff.js
+-rw-r--r--  2.0 unx   236292 b- defN 23-Jul-19 11:34 netron/view.js
+-rw-r--r--  2.0 unx     8031 b- defN 23-Jul-19 11:34 netron/weka.js
+-rw-r--r--  2.0 unx    64034 b- defN 23-Jul-19 11:34 netron/xml.js
+-rw-r--r--  2.0 unx    55685 b- defN 23-Jul-19 11:34 netron/xmodel-proto.js
+-rw-r--r--  2.0 unx    13916 b- defN 23-Jul-19 11:34 netron/xmodel.js
+-rw-r--r--  2.0 unx    30755 b- defN 23-Jul-19 11:34 netron/zip.js
+-rw-r--r--  2.0 unx     1576 b- defN 23-Jul-19 11:37 netron-7.0.5.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-19 11:37 netron-7.0.5.dist-info/WHEEL
+-rw-r--r--  2.0 unx       39 b- defN 23-Jul-19 11:37 netron-7.0.5.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        7 b- defN 23-Jul-19 11:37 netron-7.0.5.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    11131 b- defN 23-Jul-19 11:37 netron-7.0.5.dist-info/RECORD
+144 files, 12929641 bytes uncompressed, 1571003 bytes compressed:  87.9%
```

## zipnote {}

```diff
@@ -411,23 +411,23 @@
 
 Filename: netron/xmodel.js
 Comment: 
 
 Filename: netron/zip.js
 Comment: 
 
-Filename: netron-7.0.4.dist-info/METADATA
+Filename: netron-7.0.5.dist-info/METADATA
 Comment: 
 
-Filename: netron-7.0.4.dist-info/WHEEL
+Filename: netron-7.0.5.dist-info/WHEEL
 Comment: 
 
-Filename: netron-7.0.4.dist-info/entry_points.txt
+Filename: netron-7.0.5.dist-info/entry_points.txt
 Comment: 
 
-Filename: netron-7.0.4.dist-info/top_level.txt
+Filename: netron-7.0.5.dist-info/top_level.txt
 Comment: 
 
-Filename: netron-7.0.4.dist-info/RECORD
+Filename: netron-7.0.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## netron/armnn.js

### js-beautify {}

```diff
@@ -62,31 +62,26 @@
         this._graphs.push(new armnn.Graph(metadata, model));
     }
 
     get format() {
         return 'Arm NN';
     }
 
-    get description() {
-        return '';
-    }
-
     get graphs() {
         return this._graphs;
     }
 };
 
 armnn.Graph = class {
 
     constructor(metadata, graph) {
         this._name = '';
         this._nodes = [];
         this._inputs = [];
         this._outputs = [];
-
         const counts = new Map();
         for (const layer of graph.layers) {
             const base = armnn.Node.getBase(layer);
             for (const slot of base.inputSlots) {
                 const name = slot.connection.sourceLayerIndex.toString() + ':' + slot.connection.outputSlotIndex.toString();
                 counts.set(name, counts.has(name) ? counts.get(name) + 1 : 1);
             }
```

## netron/barracuda.js

### js-beautify {}

```diff
@@ -238,18 +238,14 @@
     get name() {
         return this._name;
     }
 
     get value() {
         return this._value;
     }
-
-    get visible() {
-        return true;
-    }
 };
 
 barracuda.Tensor = class {
 
     constructor(tensor) {
         this._type = new barracuda.TensorType(tensor.itemsize, new barracuda.TensorShape(tensor.shape));
         this._values = tensor.data;
```

## netron/bigdl.js

### js-beautify {}

```diff
@@ -316,18 +316,14 @@
     get name() {
         return this._name;
     }
 
     get value() {
         return this._value;
     }
-
-    get visible() {
-        return true;
-    }
 };
 
 bigdl.Tensor = class {
 
     constructor(tensor /*, tensors */ ) {
         this._type = new bigdl.TensorType(tensor.datatype, new bigdl.TensorShape(tensor.size));
         /*
```

## netron/browser.js

### js-beautify {}

```diff
@@ -569,14 +569,46 @@
             if (entry[0].trim() === name) {
                 return entry[1].trim();
             }
         }
         return '';
     }
 
+    get(context, name) {
+        if (context === 'configuration' && typeof localStorage !== 'undefined') {
+            try {
+                const content = localStorage.getItem(name);
+                return JSON.parse(content);
+            } catch (error) {
+                // continue regardless of error
+            }
+        }
+        return undefined;
+    }
+
+    set(context, name, value) {
+        if (context === 'configuration' && typeof localStorage !== 'undefined') {
+            try {
+                localStorage.setItem(name, JSON.stringify(value));
+            } catch (error) {
+                // continue regardless of error
+            }
+        }
+    }
+
+    delete(context, name) {
+        if (context === 'configuration' && typeof localStorage !== 'undefined') {
+            try {
+                localStorage.removeItem(name);
+            } catch (error) {
+                // continue regardless of error
+            }
+        }
+    }
+
     _element(id) {
         return this.document.getElementById(id);
     }
 
     _message(message, action) {
         return new Promise((resolve) => {
             this._element('message-text').innerText = message;
```

## netron/caffe.js

### js-beautify {}

```diff
@@ -548,15 +548,15 @@
         if (metadata && metadata.type) {
             this._type = metadata.type;
         }
         if (value instanceof caffe.proto.BlobShape) {
             this._value = new caffe.TensorShape(value.dim.map((dim) => dim.toNumber()));
             this._type = 'shape';
         }
-        if (metadata && Object.prototype.hasOwnProperty.call(metadata, 'visible') && !metadata.visible) {
+        if (metadata && metadata.visible === false) {
             this._visible = false;
         }
         if (metadata && Object.prototype.hasOwnProperty.call(metadata, 'default')) {
             defaultValue = metadata.default;
         }
         if (defaultValue !== undefined) {
             if (this._value == defaultValue) {
```

## netron/caffe2.js

### js-beautify {}

```diff
@@ -509,15 +509,15 @@
                 if (this._type == 'boolean') {
                     this._value = this._value !== 0 && this._value.toString() !== '0' ? true : false;
                 }
             }
         }
 
         if (metadata) {
-            if (Object.prototype.hasOwnProperty.call(metadata, 'visible') && !metadata.visible) {
+            if (metadata.visible === false) {
                 this._visible = false;
             } else if (metadata.default !== undefined) {
                 if (this._value == metadata.default || (this._value && this._value.toString() == metadata.default.toString())) {
                     this._visible = false;
                 }
             }
         }
```

## netron/circle.js

### js-beautify {}

```diff
@@ -313,15 +313,15 @@
                 const inputArguments = [];
                 if (this._type && this._type.inputs && inputIndex < this._type.inputs.length) {
                     const input = this._type.inputs[inputIndex];
                     inputName = input.name;
                     if (input.option == 'variadic') {
                         count = inputs.length - inputIndex;
                     }
-                    if (Object.prototype.hasOwnProperty.call(input, 'visible') && !input.visible) {
+                    if (input && input.visible === false) {
                         inputVisible = false;
                     }
                 }
                 const inputArray = inputs.slice(inputIndex, inputIndex + count);
                 for (const index of inputArray) {
                     const value = args(index);
                     if (value) {
@@ -445,15 +445,15 @@
         if (this._name == 'fused_activation_function') {
             this._visible = false;
         }
         if (this._type) {
             this._value = circle.Utility.enum(this._type, this._value);
         }
         if (metadata) {
-            if (Object.prototype.hasOwnProperty.call(metadata, 'visible') && !metadata.visible) {
+            if (metadata.visible === false) {
                 this._visible = false;
             } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
                 value = this._value;
                 if (typeof value == 'function') {
                     value = value();
                 }
                 if (value == metadata.default) {
```

## netron/cntk.js

### js-beautify {}

```diff
@@ -452,15 +452,15 @@
     get outputs() {
         return this._outputs;
     }
 };
 
 cntk.Attribute = class {
 
-    constructor(schema, name, value) {
+    constructor(metadata, name, value) {
         this._name = name;
         this._value = value;
         this._type = null;
         if (cntk_v1 && this._value instanceof cntk_v1.TensorShape) {
             this._value = new cntk.TensorShape(1, value);
             this._type = 'shape';
         }
@@ -473,26 +473,26 @@
                 __type__: 'Axis'
             };
             for (const key of Object.keys(value).filter((key) => key !== 'name')) {
                 axis[key] = value[key];
             }
             this._value = axis;
         }
-        if (schema) {
-            if (schema.type) {
-                this._type = schema.type;
+        if (metadata) {
+            if (metadata.type) {
+                this._type = metadata.type;
                 const type = cntk_v1[this._type] || cntk_v2[this._type];
                 if (type && type[this._value]) {
                     this._value = type[this._value];
                 }
             }
-            if (Object.prototype.hasOwnProperty.call(schema, 'visible') && !schema.visible) {
+            if (metadata.visible === false) {
                 this._visible = false;
-            } else if (Object.prototype.hasOwnProperty.call(schema, 'default')) {
-                let defaultValue = schema.default;
+            } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
+                let defaultValue = metadata.default;
                 value = this._value;
                 if (typeof value == 'function') {
                     value = value();
                 }
                 if (this._type == 'shape') {
                     value = value.dimensions;
                 }
```

## netron/coreml.js

### js-beautify {}

```diff
@@ -392,15 +392,16 @@
                     return false;
                 });
             }
             const values = new Map();
             const value = (name, type, description, tensor) => {
                 if (!values.has(name)) {
                     values.set(name, new coreml.Value(name, type, description, tensor));
-                } else if ((type && !type.equals(values.get(name).type)) || description || tensor) {
+                } else if ((type && !type.equals(values.get(name).type)) ||
+                    (tensor && tensor !== values.get(name).initializer) || description) {
                     throw new coreml.Error("Duplicate value '" + name + "'.");
                 }
                 return values.get(name);
             };
             for (const op of operations.filter((op) => !op.delete)) {
                 op.inputs = op.inputs.map((input) => new coreml.Argument(input.name, true, input.arguments.map((v) => value(v.name, v.type, null, v.value))));
                 op.outputs = op.outputs.map((output) => new coreml.Argument(output.name, true, output.arguments.map((v) => value(v.name, v.type, null, v.value))));
@@ -1229,15 +1230,15 @@
         if (metadata) {
             if (metadata.type) {
                 this._type = metadata.type;
             }
             if (this._type && coreml.proto) {
                 this._value = coreml.Utility.enum(this._type, this._value);
             }
-            if (Object.prototype.hasOwnProperty.call(metadata, 'visible') && !metadata.visible) {
+            if (metadata.visible === false) {
                 this._visible = false;
             } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
                 if (Array.isArray(value)) {
                     value = value.map((item) => item.toNumber());
                 }
                 if (JSON.stringify(metadata.default) == JSON.stringify(value)) {
                     this._visible = false;
@@ -1322,35 +1323,35 @@
     }
 
     get shape() {
         return this._shape;
     }
 
     equals(obj) {
-        return obj && this._dataType === obj.dataType && this._shape && this._shape.equals(obj.shape);
+        return obj && this.dataType === obj.dataType && this.shape && this.shape.equals(obj.shape);
     }
 
     toString() {
         return this.dataType + this._shape.toString();
     }
 };
 
 coreml.TensorShape = class {
 
     constructor(dimensions) {
-        this._dimensions = dimensions;
+        this._dimensions = dimensions.map((dim) => typeof dim === 'string' || Number.isInteger(dim) ? dim : dim.toNumber());
     }
 
     get dimensions() {
         return this._dimensions;
     }
 
     equals(obj) {
-        return obj && Array.isArray(obj.dimensions) &&
-            Array.isArray(this._dimensions) && this._dimensions.length === obj.dimensions.length &&
+        return obj && Array.isArray(obj.dimensions) && Array.isArray(this._dimensions) &&
+            this._dimensions.length === obj.dimensions.length &&
             obj.dimensions.every((value, index) => this._dimensions[index] === value);
     }
 
     toString() {
         if (!this._dimensions || this._dimensions.length == 0) {
             return '';
         }
@@ -1480,15 +1481,15 @@
     static featureType(type) {
         let result = '?';
         if (type) {
             switch (type.Type) {
                 case 'multiArrayType': {
                     let shape = new coreml.TensorShape([]);
                     if (type.multiArrayType.shape && type.multiArrayType.shape.length > 0) {
-                        shape = new coreml.TensorShape(type.multiArrayType.shape);
+                        shape = new coreml.TensorShape(type.multiArrayType.shape.map((dim) => dim.toNumber()));
                     }
                     let dataType;
                     const ArrayDataType = coreml.proto.ArrayFeatureType.ArrayDataType;
                     switch (type.multiArrayType.dataType) {
                         case ArrayDataType.INVALID_ARRAY_DATA_TYPE:
                             dataType = '?';
                             break;
```

## netron/darknet.js

### js-beautify {}

```diff
@@ -1081,19 +1081,19 @@
     get chain() {
         return this._chain;
     }
 };
 
 darknet.Attribute = class {
 
-    constructor(schema, name, value) {
+    constructor(metadata, name, value) {
         this._name = name;
         this._value = value;
-        if (schema) {
-            this._type = schema.type || '';
+        if (metadata) {
+            this._type = metadata.type || '';
             switch (this._type) {
                 case '':
                 case 'string': {
                     break;
                 }
                 case 'int32': {
                     const number = parseInt(this._value, 10);
@@ -1116,18 +1116,18 @@
                     }
                     break;
                 }
                 default: {
                     throw new darknet.Error("Unsupported attribute type '" + this._type + "'.");
                 }
             }
-            if (Object.prototype.hasOwnProperty.call(schema, 'visible') && !schema.visible) {
+            if (metadata && metadata.visible === false) {
                 this._visible = false;
-            } else if (Object.prototype.hasOwnProperty.call(schema, 'default')) {
-                if (this._value == schema.default) {
+            } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
+                if (this._value == metadata.default) {
                     this._visible = false;
                 }
             }
         }
     }
 
     get name() {
```

## netron/dl4j.js

### js-beautify {}

```diff
@@ -353,22 +353,19 @@
         }
         return result;
     }
 };
 
 dl4j.Attribute = class {
 
-    constructor(schema, name, value) {
+    constructor(metadata, name, value) {
         this._name = name;
         this._value = value;
-        this._visible = false;
-        if (schema) {
-            if (schema.visible) {
-                this._visible = true;
-            }
+        if (metadata && metadata.visible === false) {
+            this._visible = false;
         }
     }
 
     get name() {
         return this._name;
     }
```

## netron/hailo.js

### js-beautify {}

```diff
@@ -242,15 +242,17 @@
 
 hailo.Attribute = class {
 
     constructor(metadata, name, value) {
         this._name = name;
         this._value = value;
         this._type = metadata && metadata.type ? metadata.type : '';
-        this._visible = metadata && metadata.visible !== false ? true : false;
+        if (metadata && metadata.visible === false) {
+            this._visible = false;
+        }
         if (name === 'original_names') {
             this._visible = false;
         }
     }
 
     get name() {
         return this._name;
@@ -279,32 +281,24 @@
         return this._type;
     }
 };
 
 hailo.TensorType = class {
 
     constructor(dataType, shape) {
-        this._dataType = dataType;
-        this._shape = shape;
-    }
-
-    get dataType() {
-        return this._dataType;
-    }
-
-    get shape() {
-        return this._shape;
+        this.dataType = dataType;
+        this.shape = shape;
     }
 
     equals(obj) {
-        return obj && this._dataType === obj.dataType && this._shape && this._shape.equals(obj.shape);
+        return obj && this.dataType === obj.dataType && this.shape && this.shape.equals(obj.shape);
     }
 
     toString() {
-        return (this.dataType || '?') + this._shape.toString();
+        return (this.dataType || '?') + this.shape.toString();
     }
 };
 
 hailo.TensorShape = class {
 
     constructor(dimensions) {
         this._dimensions = dimensions;
```

## netron/index.html

```diff
@@ -1,15 +1,15 @@
 <!DOCTYPE html>
 <html lang="en">
 <head>
 <meta charset="utf-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
 <meta http-equiv="Content-Security-Policy" content="script-src 'self' www.google-analytics.com;">
-<meta name="version" content="7.0.4">
-<meta name="date" content="2023-07-15 04:18:14">
+<meta name="version" content="7.0.5">
+<meta name="date" content="2023-07-19 11:34:24">
 <title>Netron</title>
 <link rel="stylesheet" type="text/css" href="grapher.css">
 <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
 <link rel="icon" type="image/png" href="icon.png">
 <link rel="apple-touch-icon" type="image/png" href="icon.png">
 <link rel="apple-touch-icon-precomposed" type="image/png" href="icon.png">
 <link rel="fluid-icon" type="image/png" href="icon.png">
```

## netron/keras.js

### js-beautify {}

```diff
@@ -941,16 +941,16 @@
                 this._visible = false;
                 break;
             default: {
                 if (metadata) {
                     if (metadata.type) {
                         this._type = metadata.type;
                     }
-                    if (Object.prototype.hasOwnProperty.call(metadata, 'visible')) {
-                        this._visible = metadata.visible;
+                    if (metadata.visible === false) {
+                        this._visible = false;
                     } else if (metadata.default !== undefined) {
                         if (Array.isArray(value)) {
                             if (Array.isArray(metadata.default)) {
                                 this._visible = value.length !== metadata.default || !this.value.every((item, index) => item == metadata.default[index]);
                             } else {
                                 this._visible = !this.value.every((item) => item == metadata.default);
                             }
```

## netron/mediapipe.js

### js-beautify {}

```diff
@@ -26,155 +26,117 @@
         }
         return new mediapipe.Model(config);
     }
 };
 
 mediapipe.Model = class {
 
-    constructor(root) {
-        this._graphs = [new mediapipe.Graph(root)];
-    }
-
-    get format() {
-        return 'MediaPipe';
-    }
-
-    get graphs() {
-        return this._graphs;
+    constructor(config) {
+        this.format = 'MediaPipe';
+        this.graphs = [new mediapipe.Graph(config)];
     }
 };
 
 mediapipe.Graph = class {
 
-    constructor(root) {
-        this._inputs = [];
-        this._outputs = [];
-        this._nodes = [];
-
-        if (root) {
-            if (root.input_stream) {
-                const inputs = Array.isArray(root.input_stream) ? root.input_stream : [root.input_stream];
-                for (const input of inputs) {
-                    const parts = input.split(':');
-                    const type = (parts.length > 1) ? parts.shift() : '';
-                    const name = parts.shift();
-                    this._inputs.push(new mediapipe.Argument(name, [
-                        new mediapipe.Value(name, type, null)
-                    ]));
-                }
-            }
-            if (root.output_stream) {
-                const outputs = Array.isArray(root.output_stream) ? root.output_stream : [root.output_stream];
-                for (const output of outputs) {
-                    const parts = output.split(':');
-                    const type = (parts.length > 1) ? parts.shift() : '';
-                    const name = parts.shift();
-                    this._outputs.push(new mediapipe.Argument(name, [
-                        new mediapipe.Value(name, type, null)
-                    ]));
-                }
-            }
-            if (root.input_side_packet) {
-                const inputs = Array.isArray(root.input_side_packet) ? root.input_side_packet : [root.input_side_packet];
-                for (const input of inputs) {
-                    const parts = input.split(':');
-                    const type = (parts.length > 1) ? parts.shift() : '';
-                    const name = parts.shift();
-                    this._inputs.push(new mediapipe.Argument(name, [
-                        new mediapipe.Value(name, type, null)
-                    ]));
-                }
-            }
-            if (root.output_side_packet) {
-                const outputs = Array.isArray(root.output_side_packet) ? root.output_side_packet : [root.output_side_packet];
-                for (const output of outputs) {
-                    const parts = output.split(':');
-                    const type = (parts.length > 1) ? parts.shift() : '';
-                    const name = parts.shift();
-                    this._outputs.push(new mediapipe.Argument(output, [
-                        new mediapipe.Value(name, type, null)
-                    ]));
-                }
-            }
-            if (root.node) {
-                const nodes = Array.isArray(root.node) ? root.node : [root.node];
-                for (const node of nodes) {
-                    this._nodes.push(new mediapipe.Node(node));
+    constructor(config) {
+        config = config || {};
+        this.inputs = [];
+        this.outputs = [];
+        this.nodes = [];
+        const types = new Map();
+        const type = (list) => {
+            list = list ? Array.isArray(list) ? list : [list] : [];
+            return list.map((item) => {
+                const parts = item.split(':');
+                const name = parts.pop();
+                const type = parts.join(':');
+                if (!types.has(name)) {
+                    const value = new Set();
+                    if (type) {
+                        value.add(type);
+                    }
+                    types.set(name, value);
+                } else if (type && !types.get(name).has(type)) {
+                    types.get(name).add(type);
                 }
-            }
+                return name;
+            });
+        };
+        config.input_stream = type(config.input_stream);
+        config.output_stream = type(config.output_stream);
+        config.input_side_packet = type(config.input_side_packet);
+        config.output_side_packet = type(config.output_side_packet);
+        config.node = config.node ? Array.isArray(config.node) ? config.node : [config.node] : [];
+        for (const node of config.node) {
+            node.input_stream = type(node.input_stream);
+            node.output_stream = type(node.output_stream);
+            node.input_side_packet = type(node.input_side_packet);
+            node.output_side_packet = type(node.output_side_packet);
+        }
+        const values = new Map();
+        for (const entry of types) {
+            const type = Array.from(entry[1]).join(',');
+            values.set(entry[0], new mediapipe.Value(entry[0], type || null));
+        }
+        const value = (name) => {
+            return values.get(name);
+        };
+        for (const name of config.input_stream) {
+            const argument = new mediapipe.Argument(name, [value(name)]);
+            this.inputs.push(argument);
+        }
+        for (const name of config.output_stream) {
+            const argument = new mediapipe.Argument(name, [value(name)]);
+            this.outputs.push(argument);
+        }
+        for (const name of config.input_side_packet) {
+            const argument = new mediapipe.Argument(name, [value(name, type)]);
+            this.inputs.push(argument);
+        }
+        for (const output of config.output_side_packet) {
+            const parts = output.split(':');
+            const type = (parts.length > 1) ? parts.shift() : '';
+            const name = parts.shift();
+            const argument = new mediapipe.Argument(name, [value(name, type)]);
+            this.outputs.push(argument);
+        }
+        for (const node of config.node) {
+            this.nodes.push(new mediapipe.Node(node, value));
         }
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
     }
 };
 
 mediapipe.Node = class {
 
-    constructor(node) {
+    constructor(node, value) {
         const type = node.calculator || '?';
-        this._type = {
+        this.name = '';
+        this.type = {
             name: type.replace(/Calculator$/, '')
         };
-        this._inputs = [];
-        this._outputs = [];
-        this._attributes = [];
-
+        this.inputs = [];
+        this.outputs = [];
+        this.attributes = [];
         if (node.input_stream) {
-            const args = [];
-            const inputs = Array.isArray(node.input_stream) ? node.input_stream : [node.input_stream];
-            for (const input of inputs) {
-                const parts = input.split(':');
-                const type = (parts.length > 1) ? parts.shift() : '';
-                const name = parts.shift();
-                args.push(new mediapipe.Value(name, type, null));
-            }
-            this._inputs.push(new mediapipe.Argument('input_stream', args));
+            const values = node.input_stream.map((name) => value(name));
+            const argument = new mediapipe.Argument('input_stream', values);
+            this.inputs.push(argument);
         }
         if (node.output_stream) {
-            const args = [];
-            const outputs = Array.isArray(node.output_stream) ? node.output_stream : [node.output_stream];
-            for (const output of outputs) {
-                const parts = output.split(':');
-                const type = (parts.length > 1) ? parts.shift() : '';
-                const name = parts.shift();
-                args.push(new mediapipe.Value(name, type, null));
-            }
-            this._outputs.push(new mediapipe.Argument('output_stream', args));
+            const values = node.output_stream.map((name) => value(name));
+            this.outputs.push(new mediapipe.Argument('output_stream', values));
         }
         if (node.input_side_packet) {
-            const args = [];
-            const inputs = Array.isArray(node.input_side_packet) ? node.input_side_packet : [node.input_side_packet];
-            for (const input of inputs) {
-                const parts = input.split(':');
-                const type = (parts.length > 1) ? parts.shift() : '';
-                const name = parts.shift();
-                args.push(new mediapipe.Value(name, type, null));
-            }
-            this._inputs.push(new mediapipe.Argument('input_side_packet', args));
+            const values = node.input_side_packet.map((name) => value(name));
+            this.inputs.push(new mediapipe.Argument('output_stream', values));
         }
         if (node.output_side_packet) {
-            const args = [];
-            const outputs = Array.isArray(node.output_side_packet) ? node.output_side_packet : [node.output_side_packet];
-            for (const output of outputs) {
-                const parts = output.split(':');
-                const type = (parts.length > 1) ? parts.shift() : '';
-                const name = parts.shift();
-                args.push(new mediapipe.Value(name, type, null));
-            }
-            this._outputs.push(new mediapipe.Argument('output_side_packet', args));
+            const values = node.output_side_packet.map((name) => value(name));
+            this.outputs.push(new mediapipe.Argument('output_side_packet', values));
         }
         const options = new Map();
         if (node.options) {
             for (const key of Object.keys(node.options)) {
                 options.set(key, node.options[key]);
             }
         }
@@ -191,120 +153,52 @@
                         for (const key of Object.keys(message)) {
                             options.set(key, message[key]);
                         }
                         continue;
                     }
                 }
                 const message = new mediapipe.Object(reader);
-                for (const key of Object.keys(message)) {
-                    options.set(key, message[key]);
+                for (const entry of Object.entries(message)) {
+                    options.set(entry[0], entry[1]);
                 }
             }
         } else {
-            for (const entry of node_options) {
-                for (const key of Object.keys(entry)) {
-                    if (key !== '__type__') {
-                        options.set(key, entry[key]);
+            for (const option of node_options) {
+                for (const entry of Object.entries(option)) {
+                    if (entry[0] !== '__type__') {
+                        options.set(entry[0], entry[1]);
                     }
                 }
             }
         }
         for (const pair of options) {
-            this._attributes.push(new mediapipe.Attribute(pair[0], pair[1]));
+            this.attributes.push(new mediapipe.Argument(pair[0], pair[1]));
         }
     }
-
-    get name() {
-        return '';
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-};
-
-mediapipe.Attribute = class {
-
-    constructor(name, value) {
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
-    }
 };
 
 mediapipe.Argument = class {
 
     constructor(name, value) {
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get visible() {
-        return true;
-    }
-
-    get value() {
-        return this._value;
+        this.name = name;
+        this.value = value;
     }
 };
 
 mediapipe.Value = class {
 
-    constructor(name, type, initializer) {
+    constructor(name, type) {
         if (typeof name !== 'string') {
             throw new mediapipe.Error("Invalid value identifier '" + JSON.stringify(name) + "'.");
         }
-        this._name = name;
-        this._type = type || null;
-        this._initializer = initializer || null;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        if (this._type) {
-            return this._type;
-        }
-        if (this._initializer) {
-            return this._initializer.type;
-        }
-        return null;
-    }
-
-    get initializer() {
-        return this._initializer;
+        this.name = name;
+        this.type = type || null;
     }
 };
 
-
 mediapipe.Object = class {
 
     constructor(reader, block) {
         if (!block) {
             reader.start();
         }
         const type = reader.token();
```

## netron/megengine.js

### js-beautify {}

```diff
@@ -65,39 +65,31 @@
         }
     }
 };
 
 megengine.Model = class {
 
     constructor(metadata, obj, type) {
-        this._format = 'MegEngine';
+        this.format = 'MegEngine';
         if (type === 'megengine.tm') {
-            this._format += (obj.dump_info && obj.dump_info.version ? ' v' + obj.dump_info.version : '');
+            this.format += (obj.dump_info && obj.dump_info.version ? ' v' + obj.dump_info.version : '');
         } else if (type === 'megengine.mge') {
-            this._format += ' Mge' + (obj.model_version ? ' v' + obj.model_version : '');
+            this.format += ' Mge' + (obj.model_version ? ' v' + obj.model_version : '');
         }
-        this._graphs = [new megengine.Graph(metadata, obj)];
-    }
-
-    get format() {
-        return this._format;
-    }
-
-    get graphs() {
-        return this._graphs;
+        this.graphs = [new megengine.Graph(metadata, obj)];
     }
 };
 
 megengine.Graph = class {
 
     constructor(metadata, obj) {
-        this._name = '';
-        this._nodes = [];
-        this._inputs = [];
-        this._outputs = [];
+        this.name = '';
+        this.nodes = [];
+        this.inputs = [];
+        this.outputs = [];
         const values = new Map();
         const value = (name, type, tensor) => {
             if (tensor && name.length === 0) {
                 return new megengine.Value(name, type || null, tensor);
             }
             if (!values.has(name)) {
                 values.set(name, new megengine.Value(name, type || null, tensor || null));
@@ -109,35 +101,35 @@
         const loadGraph = (tmodule, igraph, context, namePrefix, metadata, isRoot) => {
             const expressions = igraph._exprs;
             const getTensorType = (dtype, shape) => {
                 dtype = dtype ? dtype.__name__ : null;
                 return new megengine.TensorType(dtype, new megengine.TensorShape(shape));
             };
             const getOpNode = (metadata, item, expr, state) => {
-                const op = new megengine.Node(metadata, item);
+                const node = new megengine.Node(metadata, item);
                 let inpIdx = 0;
                 for (const i of expr.inputs) {
                     if (i.__class__.__name__ !== 'ModuleNode') {
                         const initializer = i.initializer !== undefined ? i.initializer : null;
                         const name = 'inp' + inpIdx;
                         const type = getTensorType(i._dtype, i._shape);
                         const argument = new megengine.Argument(name, [value(i._fullname, type, initializer)]);
-                        op._inputs.push(argument);
+                        node.inputs.push(argument);
                         inpIdx += 1;
                     }
                 }
                 const outIdx = 0;
                 let qparams = null;
                 for (const o of expr.outputs) {
                     if (o._qparams !== null) {
                         qparams = o._qparams[1];
                     }
                     const type = getTensorType(o._dtype, o._shape);
                     const argument = new megengine.Argument('out' + outIdx, [value(o._fullname, type, null)]);
-                    op._outputs.push(argument);
+                    node.outputs.push(argument);
                 }
                 if (qparams !== null) {
                     state = state === null ? {} : state;
                     state.scale = qparams.scale;
                     state.zero_point = qparams.zero_point;
                     state.quant_dtype_meta = qparams.dtype_meta;
                 }
@@ -148,40 +140,40 @@
                         };
                         const isTensor = (obj) => {
                             return obj && obj.__class__ && obj.__class__.__module__ == 'megengine.tensor' && (obj.__class__.__name__ === 'Tensor' || obj.__class__.__name__ === 'Parameter');
                         };
                         if (!key.startsWith('_') && !isModule(state[key])) {
                             if (!isTensor(state[key])) {
                                 const attribute = new megengine.Attribute(null, key, state[key] !== null ? state[key] : 'None');
-                                op._attributes.push(attribute);
+                                node.attributes.push(attribute);
                             } else {
                                 const tensor = state[key];
                                 const type = getTensorType(tensor.dtype, tensor.data.shape);
                                 const data = tensor.data.data;
                                 const initializer = new megengine.Tensor(key, type, data);
                                 const argument = new megengine.Argument(key, [value('', type, initializer)]);
-                                op._inputs.push(argument);
+                                node.inputs.push(argument);
                             }
                         }
                     }
                 }
-                return op;
+                return node;
             };
             if (isRoot) {
                 for (const node of igraph._inputs) {
                     if (node.__class__.__name__ !== 'ModuleNode') {
                         const type = getTensorType(node._dtype, node._shape);
                         const argument = new megengine.Argument(node._name, [value(node._name, type, null)]);
-                        this._inputs.push(argument);
+                        this.inputs.push(argument);
                     }
                 }
                 for (const node of igraph._outputs) {
                     const type = getTensorType(node._dtype, node._shape);
                     const argument = new megengine.Argument(node._name, [value(node._name, type, null)]);
-                    this._outputs.push(argument);
+                    this.outputs.push(argument);
                 }
             }
             const parseGetAttr = (module, expression) => {
                 let names = expression.name.split('.');
                 while (expression.inputs[0].expr.__class__.__name__ === 'GetAttr') {
                     expression = expression.inputs[0].expr;
                     names = expression.name.split('.').concat(names);
@@ -339,26 +331,26 @@
                                 'type': moduleType
                             };
                             let state = module.__class__.__name__ !== 'TracedModule' ? module.state : module;
                             if (state === undefined) {
                                 state = module;
                             }
                             const node = getOpNode(metadata, item, expression, state);
-                            this._nodes.push(node);
+                            this.nodes.push(node);
                         } else {
                             const item = {
                                 'name': '',
                                 'type': expression.method
                             };
                             const args = expression.arg_def.children_defs[0];
                             const kwargs = expression.arg_def.children_defs[1];
                             const schema = metadata.type(expression.method);
                             const state = parseArgs(args, kwargs, schema);
                             const node = getOpNode(metadata, item, expression, state);
-                            this._nodes.push(node);
+                            this.nodes.push(node);
                         }
                         break;
                     }
                     case 'CallFunction': {
                         const getFunctionType = (obj) => {
                             if (obj.func.__module__ !== undefined) {
                                 return obj.func.__module__ + '.' + obj.func.__name__;
@@ -371,25 +363,25 @@
                             'type': func
                         };
                         const args = expression.arg_def.children_defs[0];
                         const kwargs = expression.arg_def.children_defs[1];
                         const schema = metadata.type(func);
                         const state = parseArgs(args, kwargs, schema);
                         const node = getOpNode(metadata, item, expression, state);
-                        this._nodes.push(node);
+                        this.nodes.push(node);
                         break;
                     }
                     case 'Apply': {
                         const opdef = expression.opdef_state ? expression.opdef_state.opdef_type : expression.opdef.type;
                         const item = {
                             'name': '',
                             'type': opdef.__module__ + '.' + opdef.__name__
                         };
                         const node = getOpNode(metadata, item, expression, expression.opdef_state);
-                        this._nodes.push(node);
+                        this.nodes.push(node);
                         break;
                     }
                     default: {
                         break;
                     }
                 }
             }
@@ -473,236 +465,148 @@
             return allOprAndTensor;
         };
         const allOprAndTensor = getAllOprAndTensor(obj.oprs);
         for (const entry of allOprAndTensor) {
             const op = entry[1];
             if (op.type === 'Host2DeviceCopy') {
                 const argument = new megengine.Argument('input', op.extraInfo.args);
-                this._inputs.push(argument);
+                this.inputs.push(argument);
             } else if (op.type !== 'ImmutableTensor') {
-                this._nodes.push(new megengine.Node(metadata, op, allOprAndTensor));
+                this.nodes.push(new megengine.Node(metadata, op, allOprAndTensor));
             }
         }
         for (let i = 0; i < obj.output_vars_idx.length; i++) {
             const id = obj.output_vars_idx[i].compact_id;
             const out_type = 'output' + (i === 0 ? '' : i);
             const argument = new megengine.Argument(out_type, allOprAndTensor.get(id).extraInfo.args);
-            this._outputs.push(argument);
+            this.outputs.push(argument);
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
-    }
 };
 
 megengine.Argument = class {
 
     constructor(name, value) {
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
+        this.name = name;
+        this.value = value;
     }
 };
 
 megengine.Value = class {
 
     constructor(name, type, initializer, quantization) {
         if (typeof name !== 'string') {
             throw new megengine.Error("Invalid value identifier '" + JSON.stringify(name) + "'.");
         }
-        this._name = name;
-        this._initializer = initializer;
+        this.name = name;
+        this.initializer = initializer;
         this._type = type;
         if (quantization && this._type.dataType.startsWith('q')) {
             this._scale = quantization.scale;
             this._zeroPoint = quantization.zeroPoint;
         }
     }
 
-    get name() {
-        return this._name;
-    }
-
     get type() {
-        if (this._initializer) {
-            return this._initializer.type;
+        if (this.initializer) {
+            return this.initializer.type;
         }
         return this._type;
     }
 
-    get initializer() {
-        return this._initializer;
-    }
-
     get quantization() {
         if (this._scale !== undefined && this._zeroPoint !== undefined) {
             return this._scale.toString() + ' * ' + (this._zeroPoint == 0 ? 'q' : '(q - ' + this._zeroPoint.toString() + ')');
         }
         return undefined;
     }
 };
 
 megengine.Node = class {
 
     constructor(metadata, item, allOprAndTensor) {
-        this._name = '';
-        this._type = Object.assign({}, metadata.type(item.type));
-        this._type.name = this._type.name.replace(/V(\d+)$/, '');
-        if (this._type.name.length > 4 && this._type.name.startsWith('__') && this._type.name.endsWith('__')) {
-            this._type.name = this._type.name.substring(2, this._type.name.length - 2);
-        }
-        this._type.category = this._type.category ? this._type.category : metadata.type(item.type.replace(/V(\d+)$/, '')).category;
-        this._inputs = [];
-        this._outputs = [];
-        this._chain = [];
-        this._attributes = [];
+        this.name = '';
+        this.type = Object.assign({}, metadata.type(item.type));
+        this.type.name = this.type.name.replace(/V(\d+)$/, '');
+        if (this.type.name.length > 4 && this.type.name.startsWith('__') && this.type.name.endsWith('__')) {
+            this.type.name = this.type.name.substring(2, this.type.name.length - 2);
+        }
+        this.type.category = this.type.category ? this.type.category : metadata.type(item.type.replace(/V(\d+)$/, '')).category;
+        this.inputs = [];
+        this.outputs = [];
+        this.chain = [];
+        this.attributes = [];
         if (item.inputs && item.outputs) {
-            const inputSchemas = this._type && this._type.inputs ? [...this._type.inputs] : [];
+            const inputSchemas = this.type && this.type.inputs ? [...this.type.inputs] : [];
             for (let i = 0; i < item.inputs.length; i++) {
                 const inputOpr = allOprAndTensor.get(item.inputs[i]);
                 const inputSchema = inputSchemas.length > 0 ? inputSchemas.shift() : {
                     name: ('input' + i)
                 };
                 const argument = new megengine.Argument(inputSchema.name, inputOpr.extraInfo.args);
-                this._inputs.push(argument);
+                this.inputs.push(argument);
             }
-            const outputSchemas = this._type && this._type.outputs ? [...this._type.outputs] : [];
+            const outputSchemas = this.type && this.type.outputs ? [...this.type.outputs] : [];
             for (let i = 0; i < item.outputs.length; i++) {
                 const outputOpr = allOprAndTensor.get(item.outputs[i]);
                 const outputSchema = outputSchemas.length > 0 ? outputSchemas.shift() : {
                     name: ('output' + i)
                 };
                 const argument = new megengine.Argument(outputSchema.name, outputOpr.extraInfo.args);
-                this._outputs.push(argument);
+                this.outputs.push(argument);
             }
             if (item.param) {
                 for (const pair of Object.entries(item.param)) {
                     const name = pair[0];
                     const value = pair[1];
                     if (value !== null) {
                         const attribute = new megengine.Attribute(metadata.attribute(item.param.constructor.name, name), name, value);
-                        this._attributes.push(attribute);
+                        this.attributes.push(attribute);
                     }
                 }
             }
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
-    }
 };
 
 megengine.Attribute = class {
 
     constructor(metadata, name, value) {
-        this._type = metadata ? metadata.type : null;
-        this._name = name;
-        this._value = ArrayBuffer.isView(value) ? Array.from(value) : value;
-        if (this._name === 'training') {
-            this._visible = false;
-            this._type = 'boolean';
+        this.type = metadata ? metadata.type : null;
+        this.name = name;
+        this.value = ArrayBuffer.isView(value) ? Array.from(value) : value;
+        if (this.name === 'training') {
+            this.visible = false;
+            this.type = 'boolean';
         }
         if (megengine.schema) {
-            if (megengine.schema.param[this._type]) {
-                this._value = megengine.Utility.enum(megengine.schema.param, this._type, this._value);
-            } else if (megengine.schema[this._type]) {
-                this._value = megengine.Utility.enum(megengine.schema, this._type, this._value);
-            } else if (megengine.schema.v2[this._type]) {
-                this._value = megengine.Utility.enum(megengine.schema.v2, this._type, this._value);
+            if (megengine.schema.param[this.type]) {
+                this.value = megengine.Utility.enum(megengine.schema.param, this.type, this.value);
+            } else if (megengine.schema[this.type]) {
+                this.value = megengine.Utility.enum(megengine.schema, this.type, this.value);
+            } else if (megengine.schema.v2[this.type]) {
+                this.value = megengine.Utility.enum(megengine.schema.v2, this.type, this.value);
             }
         }
     }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
-    }
-
-    get visible() {
-        return this._visible == false ? false : true;
-    }
 };
 
 megengine.Tensor = class {
 
     constructor(name, type, data) {
-        this._name = name || '';
-        this._type = type;
-        this._data = data;
-    }
-
-    get category() {
-        return 'Tensor';
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get values() {
-        return this._data;
+        this.category = 'Tensor';
+        this.name = name || '';
+        this.type = type;
+        this.values = data;
     }
 };
 
 megengine.TensorType = class {
 
     constructor(dataType, shape) {
-        this._shape = shape;
         dataType = megengine.Utility.enum(megengine.schema, 'DTypeEnum', dataType).toLowerCase();
         megengine.TensorType._dataTypes = megengine.TensorType._dataTypes || new Map([
             ['bool', 'boolean'],
             ['byte', 'uint8'],
             ['quantizeds4asymm', 'uint8'],
             ['quantizeds8asymm', 'uint8'],
             ['uintb4', 'uint8'],
@@ -712,53 +616,42 @@
             ['intb1', 'int8'],
             ['intb2', 'int8'],
             ['intb4', 'int8'],
             ['qint8', 'int8'],
             ['quantizeds16', 'int16'],
             ['quantizeds32', 'int32']
         ]);
-        this._dataType = megengine.TensorType._dataTypes.get(dataType) || dataType;
-    }
-
-    get dataType() {
-        return this._dataType;
-    }
-
-    get shape() {
-        return this._shape;
+        this.dataType = megengine.TensorType._dataTypes.get(dataType) || dataType;
+        this.shape = shape;
     }
 
     equals(obj) {
-        return obj && this._dataType === obj.dataType && this._shape && this._shape.equals(obj.shape);
+        return obj && this.dataType === obj.dataType && this.shape && this.shape.equals(obj.shape);
     }
 
     toString() {
-        return this._dataType + this._shape.toString();
+        return this.dataType + this.shape.toString();
     }
 };
 
 megengine.TensorShape = class {
 
     constructor(dimensions) {
-        this._dimensions = Array.from(dimensions || []);
-    }
-
-    get dimensions() {
-        return this._dimensions;
+        this.dimensions = Array.from(dimensions || []);
     }
 
     equals(obj) {
         return obj && Array.isArray(obj.dimensions) &&
-            Array.isArray(this._dimensions) && this._dimensions.length === obj.dimensions.length &&
-            obj.dimensions.every((value, index) => this._dimensions[index] === value);
+            Array.isArray(this.dimensions) && this.dimensions.length === obj.dimensions.length &&
+            obj.dimensions.every((value, index) => this.dimensions[index] === value);
     }
 
     toString() {
-        if (this._dimensions && this._dimensions.length > 0) {
-            return '[' + this._dimensions.map((dimension) => dimension.toString()).join(',') + ']';
+        if (this.dimensions && this.dimensions.length > 0) {
+            return '[' + this.dimensions.map((dimension) => dimension.toString()).join(',') + ']';
         }
         return '';
     }
 };
 
 megengine.Utility = class {
```

## netron/mlnet.js

### js-beautify {}

```diff
@@ -266,18 +266,14 @@
     get name() {
         return this._name;
     }
 
     get value() {
         return this._value;
     }
-
-    get visible() {
-        return true;
-    }
 };
 
 mlnet.TensorType = class {
 
     constructor(codec) {
 
         mlnet.TensorType._map = mlnet.TensorType._map || new Map([
```

## netron/mnn-schema.js

### js-beautify {}

```diff
@@ -1673,14 +1673,15 @@
 
     static decode(reader, position) {
         const $ = new $root.MNN.Extra();
         $.type = reader.string_(position, 4, null);
         $.engine = reader.string_(position, 6, null);
         $.info = reader.typedArray(position, 8, Int8Array);
         $.attr = reader.tableArray(position, 10, $root.MNN.Attribute.decode);
+        $.vector = reader.bool_(position, 12, false);
         return $;
     }
 };
 
 $root.MNN.StringVec = class StringVec {
 
     static decode(reader, position) {
```

## netron/ncnn.js

### js-beautify {}

```diff
@@ -607,15 +607,15 @@
                 default: {
                     if (this._type) {
                         this._value = ncnn.Utility.value(this._value, this._type);
                     }
                     break;
                 }
             }
-            if (Object.prototype.hasOwnProperty.call(metadata, 'visible') && !metadata.visible) {
+            if (metadata && metadata.visible === false) {
                 this._visible = false;
             } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
                 if (this._value == metadata.default || (this._value && this._value.toString() == metadata.default.toString())) {
                     this._visible = false;
                 }
             }
         }
```

## netron/om.js

### js-beautify {}

```diff
@@ -7,441 +7,314 @@
 om.ModelFactory = class {
 
     match(context) {
         return om.Container.open(context);
     }
 
     async open(context, target) {
-        const container = target;
-        await container.open();
+        await target.open();
         const metadata = await context.metadata('om-metadata.json');
-        return new om.Model(metadata, container);
+        return new om.Model(metadata, target);
     }
 };
 
 om.Model = class {
 
-    constructor(metadata, container) {
-        this._graphs = [];
-        this._format = container.format;
+    constructor(metadata, target) {
+        this.graphs = [];
+        this.format = target.format;
         const context = {
             metadata: metadata,
-            weights: container.weights
+            weights: target.weights
         };
-        for (const graph of container.model.graph) {
-            this._graphs.push(new om.Graph(context, graph));
+        for (const graph of target.model.graph) {
+            this.graphs.push(new om.Graph(context, graph));
         }
     }
-
-    get format() {
-        return this._format;
-    }
-
-    get graphs() {
-        return this._graphs;
-    }
 };
 
 om.Graph = class {
 
     constructor(context, graph) {
-        this._name = graph.name;
-        this._nodes = [];
-        this._inputs = [];
-        this._outputs = [];
+        this.name = graph.name;
+        this.nodes = [];
+        this.inputs = [];
+        this.outputs = [];
+        const values = new Map();
+        const value = (name, type, tensor) => {
+            if (!values.has(name)) {
+                values.set(name, new om.Value(name, type || null, tensor || null));
+            } else if ((type && !type.equals(values.get(name).type)) || tensor) {
+                throw new om.Error("Duplicate value '" + name + "'.");
+            }
+            return values.get(name);
+        };
+        const tensors = new Map();
+        const ops = [];
         for (const op of graph.op) {
-            if (op.type === 'Const') {
+            if (op.type === 'Const' && op.attr && op.attr.value) {
+                const desc = op.attr.value.t.desc;
+                let data = null;
+                if (op.attr.value.t.data.length !== 0) {
+                    data = op.attr.value.t.data;
+                } else if (context.weights == null) {
+                    data = null;
+                } else if (desc.attr.merged_offset) {
+                    const offset = desc.attr.merged_offset.i;
+                    data = context.weights.slice(offset, offset + desc.weight_size);
+                } else {
+                    const offset = desc.data_offset;
+                    data = context.weights.slice(offset, offset + desc.weight_size);
+                }
+                const type = om.Utility.tensorType(desc);
+                const tensor = new om.Tensor('Constant', type, data);
+                tensors.set(op.name, tensor);
                 continue;
             }
-            const node = new om.Node(context, op, graph);
-            this._nodes.push(node);
+            ops.push(op);
+        }
+        for (const op of ops) {
+            const node = new om.Node(context, op, graph, value, tensors);
+            this.nodes.push(node);
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get nodes() {
-        return this._nodes;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
 };
 
 om.Node = class {
 
-    constructor(context, op, graph) {
-        this._name = op.name;
-        this._type = context.metadata.type(op.type) || {
+    constructor(context, op, graph, value, tensors) {
+        this.name = op.name || '';
+        this.type = context.metadata.type(op.type) || {
             name: op.type
         };
-        this._inputs = [];
-        this._outputs = [];
-        this._attributes = [];
-        this._chain = [];
-        this._controlDependencies = [];
-        this._device = null;
+        this.inputs = [];
+        this.outputs = [];
+        this.attributes = [];
+        this.chain = [];
+        this.controlDependencies = [];
+        this.device = null;
         if (op.input) {
             for (let i = 0; i < op.input.length; i++) {
-                if (op.input[i] === '') {
+                const input = op.input[i];
+                if (input === '') {
                     continue;
                 }
-                const pos = op.input[i].lastIndexOf(':');
-                const name = pos === 0 ? 'internal_unnamed' : op.input[i].slice(0, pos);
-                const src_index = op.input[i].slice(pos + 1);
+                const index = input.lastIndexOf(':');
+                const identifier = input.substring(0, index);
+                const src_index = input.substring(index + 1);
                 if (src_index === '-1') {
-                    this._controlDependencies.push(new om.Value(name));
+                    this.controlDependencies.push(value(name));
                     continue;
                 }
-                const parameterName = this._type.inputs && i < this._type.inputs.length ? this._type.inputs[i].name : 'input' + (i === 0 ? '' : i.toString());
-                const inputNode = graph.op.find(node => node.name === name);
-                const desc = op.input_desc[i];
-                const layout = desc.layout;
-                if (inputNode && inputNode.type === 'Const' && inputNode.attr && inputNode.attr.value && inputNode.attr) {
-                    let shape = null;
-                    const value = inputNode.attr.value.t;
-                    if (value.desc.shape != null) {
-                        shape = value.desc.shape.dim;
-                    } else if (value.desc.attr.origin_shape) {
-                        shape = value.desc.attr.origin_shape.list.i;
-                    }
-                    let data = null;
-                    if (value.data.length === 0) {
-                        if (context.weights == null) {
-                            data = null;
-                        } else if (value.desc.attr.merged_offset) {
-                            const offset = value.desc.attr.merged_offset.i;
-                            data = context.weights.slice(offset, offset + value.desc.weight_size);
-                        } else {
-                            const offset = value.desc.data_offset;
-                            data = context.weights.slice(offset, offset + value.desc.weight_size);
-                        }
-                    } else {
-                        data = value.data;
-                    }
-                    const dataType = desc && desc.dtype ? om.Utility.dtype(value.desc.dtype) : '?';
-                    const tensorType = new om.TensorType(dataType, shape, layout, value.desc.layout);
-                    const tensor = new om.Tensor('Constant', tensorType, data);
-                    this._inputs.push(new om.Argument(parameterName, [new om.Value(name, null, tensor)]));
-                } else {
-                    const dataType = desc && desc.dtype ? om.Utility.dtype(desc.dtype) : '?';
-                    const shape = desc.shape ? desc.shape.dim : undefined;
-                    const tensorType = new om.TensorType(dataType, shape, layout, null);
-                    const identifier = src_index === '0' ? name : name + ':' + src_index;
-                    this._inputs.push(new om.Argument(parameterName, [new om.Value(identifier, tensorType, null)]));
-                }
+                const name = this.type.inputs && i < this.type.inputs.length ? this.type.inputs[i].name : 'input' + (i === 0 ? '' : i.toString());
+                const type = om.Utility.tensorType(op.input_desc[i]);
+                const tensor = tensors.get(identifier);
+                const argument = new om.Argument(name, [value(input, type, tensor)]);
+                this.inputs.push(argument);
             }
         }
         if (op.output_desc) {
             for (let i = 0; i < op.output_desc.length; i++) {
-                const desc = op.output_desc[i];
-                let shape = desc.shape ? desc.shape.dim : undefined;
-                if (op.type === 'Data' || op.type === 'ImageData' || op.type === 'DynamicImageData') {
-                    shape = desc.shape ? desc.shape.dim : op.input_desc[0].shape.dim;
-                }
-                const dataType = desc && desc.dtype ? om.Utility.dtype(desc.dtype) : '?';
-                const format = desc.layout;
-                const type = new om.TensorType(dataType, shape, format);
-                const identifier = i === 0 ? this._name : this._name + ':' + i;
-                const value = new om.Value(identifier, type, null);
-                const outputName = this._type.outputs && i < this._type.outputs.length ? this._type.outputs[i].name : 'output' + (i === 0 ? '' : i.toString());
-                this._outputs.push(new om.Argument(outputName, [value]));
+                const identifier = this.name + ':' + i.toString();
+                const type = om.Utility.tensorType(op.output_desc[i]);
+                const name = this.type.outputs && i < this.type.outputs.length ? this.type.outputs[i].name : 'output' + (i === 0 ? '' : i.toString());
+                const argument = new om.Argument(name, [value(identifier, type)]);
+                this.outputs.push(argument);
             }
         }
-        if (op.attr) {
-            for (const attr of Object.entries(op.attr)) {
-                const name = attr[0];
-                const value = attr[1];
-                if (name === 'device') {
-                    this._device = value;
-                    continue;
-                }
-                if (name === 'original_op_names') {
-                    continue;
-                }
-                if (name === 'relu_flag' && value.b) {
-                    this._chain.push(new om.Node(context, {
-                        type: 'ReLU'
-                    }, graph));
-                    continue;
-                }
-                const attribute = new om.Attribute(context, name, value);
-                this._attributes.push(attribute);
+        for (const attr of Object.entries(op.attr || {})) {
+            const name = attr[0];
+            const value = attr[1];
+            if (name === 'device') {
+                this.device = value;
+                continue;
+            }
+            if (name === 'original_op_names') {
+                continue;
+            }
+            if (name === 'relu_flag' && value.b) {
+                this.chain.push(new om.Node(context, {
+                    type: 'ReLU'
+                }, graph, value));
+                continue;
             }
+            const attribute = new om.Attribute(context, name, value);
+            this.attributes.push(attribute);
         }
     }
-
-    get device() {
-        return this._device;
-    }
-
-    get name() {
-        return this._name || '';
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-
-    get chain() {
-        return this._chain;
-    }
-
-    get controlDependencies() {
-        return this._controlDependencies;
-    }
 };
 
 om.Attribute = class {
 
     constructor(context, name, value) {
-        this._name = name;
-        this._value = value;
+        this.name = name;
+        this.value = value;
         switch (value.value) {
             case 'i': {
-                this._value = value.i;
-                this._type = 'int64';
+                this.value = value.i;
+                this.type = 'int64';
                 break;
             }
             case 'f': {
-                this._value = value.f;
-                this._type = 'float32';
+                this.value = value.f;
+                this.type = 'float32';
                 break;
             }
             case 'b': {
-                this._value = value.b;
-                this._type = 'boolean';
+                this.value = value.b;
+                this.type = 'boolean';
                 break;
             }
             case 'bt': {
-                this._value = null;
+                this.value = null;
                 if (value.bt.length !== 0) {
-                    this._type = 'tensor';
-                    this._value = new om.Tensor('Constant', new om.TensorType('float32', [value.bt.length / 4], null), value.bt);
+                    this.type = 'tensor';
+                    const shape = new om.TensorShape([value.bt.length / 4]);
+                    const type = new om.TensorType('float32', shape);
+                    this.value = new om.Tensor('Constant', type, value.bt);
                 }
                 break;
             }
             case 'dt': {
-                this._type = 'DataType';
-                this._value = om.Utility.dtype(value.dt.toNumber());
+                this.type = 'DataType';
+                this.value = om.Utility.dtype(value.dt.toNumber());
                 break;
             }
             case 's': {
                 if (typeof value.s === 'string') {
-                    this._value = value.s;
+                    this.value = value.s;
                 } else if (value.s.filter(c => c <= 32 && c >= 128).length === 0) {
-                    this._value = om.Utility.decodeText(value.s);
+                    this.value = om.Utility.decodeText(value.s);
                 } else {
-                    this._value = value.s;
+                    this.value = value.s;
                 }
-                this._type = 'string';
+                this.type = 'string';
                 break;
             }
             case 'g': {
-                this._type = 'graph';
-                this._value = new om.Graph(context, value.g);
+                this.type = 'graph';
+                this.value = new om.Graph(context, value.g);
                 break;
             }
             case 'func': {
                 break;
             }
             case 'list': {
                 const list = value.list;
-                this._value = [];
+                this.value = [];
                 if (list.s && list.s.length > 0) {
-                    this._value = list.s.map(v => String.fromCharCode.apply(null, new Uint16Array(v))).join(', ');
-                    this._type = 'string[]';
+                    this.value = list.s.map(v => String.fromCharCode.apply(null, new Uint16Array(v))).join(', ');
+                    this.type = 'string[]';
                 } else if (list.b && list.b.length > 0) {
-                    this._value = list.b;
-                    this._type = 'boolean[]';
+                    this.value = list.b;
+                    this.type = 'boolean[]';
                 } else if (list.i && list.i.length > 0) {
-                    this._value = list.i;
-                    this._type = 'int64[]';
+                    this.value = list.i;
+                    this.type = 'int64[]';
                 } else if (list.f && list.f.length > 0) {
-                    this._value = list.f;
-                    this._type = 'float32[]';
+                    this.value = list.f;
+                    this.type = 'float32[]';
                 } else if (list.type && list.type.length > 0) {
-                    this._type = 'type[]';
-                    this._value = list.type.map((type) => om.Node.enum2Dtype(type) || '?');
+                    this.type = 'type[]';
+                    this.value = list.type.map((type) => om.Node.enum2Dtype(type) || '?');
                 } else if (list.shape && list.shape.length > 0) {
-                    this._type = 'shape[]';
-                    this._value = list.shape.map((shape) => new om.TensorShape(shape));
+                    this.type = 'shape[]';
+                    this.value = list.shape.map((shape) => new om.TensorShape(shape));
                 }
                 break;
             }
             case 'list_list_int': {
-                this._value = value.list_list_int.list_list_i.map((list) => list.list_i);
+                this.value = value.list_list_int.list_list_i.map((list) => list.list_i);
                 break;
             }
             case 't': {
-                const desc = value.t.desc;
-                const dataType = desc && desc.dtype ? om.Utility.dtype(desc.dtype) : '?';
-                const shape = desc.shape ? desc.shape.dim : undefined;
-                const layout = desc.layout;
-                const type = new om.TensorType(dataType, shape, layout, null);
-                this._value = new om.Tensor('Constant', type, value.t.bytes);
-                this._type = 'tensor';
+                const type = om.Utility.tensorType(value.t.desc);
+                this.value = new om.Tensor('Constant', type, value.t.bytes);
+                this.type = 'tensor';
                 break;
             }
             case undefined: {
-                this._value = null;
+                this.value = null;
                 break;
             }
             default: {
                 throw new om.Error("Unsupported attribute type '" + JSON.stringify(value).substring(0, 32) + "'.");
             }
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get value() {
-        return this._value;
-    }
-
-    get visible() {
-        return true;
-    }
 };
 
 om.Argument = class {
 
     constructor(name, value) {
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
+        this.name = name;
+        this.value = value;
     }
 };
 
 om.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
             throw new om.Error("Invalid value identifier '" + JSON.stringify(name) + "'.");
         }
-        this._name = name;
+        this.name = name;
         this._type = type || null;
-        this._initializer = initializer || null;
-    }
-
-    get name() {
-        return this._name;
+        this.initializer = initializer || null;
     }
 
     get type() {
-        if (this._initializer) {
-            return this._initializer.type;
+        if (this.initializer) {
+            return this.initializer.type;
         }
         return this._type;
     }
-
-    get initializer() {
-        return this._initializer;
-    }
 };
 
 om.Tensor = class {
 
     constructor(category, type, value) {
-        this._category = category;
-        this._type = type;
-        this._data = value;
-    }
-
-    get category() {
-        return this._category;
-    }
-
-    get type() {
-        return this._type;
+        this.category = category;
+        this.type = type;
+        this.data = value;
     }
 };
 
 om.TensorType = class {
 
-    constructor(dataType, shape, format, denotation) {
-        this._dataType = dataType;
-        this._shape = new om.TensorShape(shape);
-        const list = [];
-        if (format) {
-            list.push(format);
-        }
-        if (denotation && denotation !== format) {
-            list.push(denotation);
-        }
-        this._denotation = list.join(' ');
-    }
-
-    get dataType() {
-        return this._dataType;
+    constructor(dataType, shape, denotation) {
+        this.dataType = dataType;
+        this.shape = shape;
+        this.denotation = denotation;
     }
 
-    set shape(dims) {
-        this._shape = dims;
-    }
-
-    get shape() {
-        return this._shape;
-    }
-
-    get denotation() {
-        return this._denotation;
+    equals(obj) {
+        return obj && this.dataType === obj.dataType && this.shape && this.shape.equals(obj.shape);
     }
 
     toString() {
-        return this._dataType + this._shape.toString();
+        return this.dataType + this.shape.toString();
     }
 };
 
 om.TensorShape = class {
 
-    constructor(shape) {
-        this._shape = shape;
+    constructor(dimensions) {
+        this.dimensions = dimensions.map((dim) => Number.isInteger(dim) ? dim : dim.toNumber());
     }
 
-    get dimensions() {
-        return this._shape;
+    equals(obj) {
+        return obj && Array.isArray(obj.dimensions) &&
+            Array.isArray(this.dimensions) && this.dimensions.length === obj.dimensions.length &&
+            obj.dimensions.every((value, index) => this.dimensions[index] === value);
     }
 
     toString() {
-        if (this._shape && Array.isArray(this._shape) && this._shape.length > 0) {
-            return '[' + this._shape.map((dim) => dim ? dim.toString() : '?').join(',') + ']';
+        if (this.dimensions && Array.isArray(this.dimensions) && this.dimensions.length > 0) {
+            return '[' + this.dimensions.map((dim) => dim ? dim.toString() : '?').join(',') + ']';
         }
         return '';
     }
 };
 
 om.Container = class {
 
@@ -582,14 +455,23 @@
         ];
         if (value >= om.Utility._types.length) {
             throw new om.Error("Unsupported dtype '" + value + "'.");
         }
         return om.Utility._types[value];
     }
 
+    static tensorType(desc) {
+        if (desc.shape && Array.isArray(desc.shape.dim)) {
+            const dataType = desc && desc.dtype ? om.Utility.dtype(desc.dtype) : '?';
+            const shape = new om.TensorShape(desc.shape.dim);
+            return new om.TensorType(dataType, shape, desc.layout);
+        }
+        return null;
+    }
+
     static decodeText(value) {
         om.Utility._textDecoder = om.Utility._textDecoder || new TextDecoder('utf-8');
         return om.Utility._textDecoder.decode(value);
     }
 };
 
 om.Error = class extends Error {
```

## netron/openvino.js

### js-beautify {}

```diff
@@ -771,15 +771,15 @@
                             }
                         }
                         break;
                     default:
                         throw new openvino.Error("Unsupported attribute type '" + schema.type + "'.");
                 }
             }
-            if (Object.prototype.hasOwnProperty.call(schema, 'visible') && schema.visible == false) {
+            if (schema && schema.visible == false) {
                 this._visible = false;
             } else if (Object.prototype.hasOwnProperty.call(schema, 'default')) {
                 let defaultValue = schema.default;
                 if (this._value == defaultValue) {
                     this._visible = false;
                 } else if (Array.isArray(this._value) && Array.isArray(defaultValue)) {
                     defaultValue = defaultValue.slice(0, defaultValue.length);
```

## netron/pytorch.js

### js-beautify {}

```diff
@@ -620,15 +620,14 @@
 };
 
 pytorch.Attribute = class {
 
     constructor(metadata, name, value) {
         this._name = name;
         this._value = value;
-
         if (this._name === 'training') {
             this._visible = false;
             this._type = 'boolean';
         } else if (metadata) {
             if (metadata.type) {
                 this._type = metadata.type;
             }
@@ -3282,15 +3281,15 @@
                 return obj.__class__.__name__ === 'Parameter' ? obj.data : null;
             default:
                 return null;
         }
     }
 
     static getType(value) {
-        if (value === null) {
+        if (value === null || value === undefined) {
             return undefined;
         } else if (value === true || value === false) {
             return 'boolean';
         } else if (pytorch.Utility.isTensor(value)) {
             return 'Tensor';
         } else if (typeof value === 'string') {
             return 'string';
@@ -4103,14 +4102,18 @@
         this._nodes = [];
         this._inputs = [];
         this._outputs = [];
 
         const args = new Map();
         const arg = (operand) => {
             if (!args.has(operand.index)) {
+
+
+
+
                 const value = new pytorch.nnapi.Argument(operand);
                 args.set(operand.index, value);
             }
             return args.get(operand.index);
         };
 
         const metadata = new pytorch.nnapi.Metadata();
```

## netron/server.js

### js-beautify {}

```diff
@@ -119,18 +119,14 @@
     get name() {
         return this._name;
     }
 
     get value() {
         return this._value;
     }
-
-    get visible() {
-        return true;
-    }
 };
 
 message.Value = class {
 
     constructor(data) {
         this._name = data.name || '';
         this._type = data.type ? new message.TensorType(data.type) : null;
@@ -202,18 +198,14 @@
     get value() {
         return this._value;
     }
 
     get type() {
         return this._type;
     }
-
-    get visible() {
-        return true;
-    }
 };
 
 message.TensorType = class {
 
     constructor(data) {
         this._dataType = data.dataType;
         this._shape = new message.TensorShape(data.shape);
```

## netron/server.py

```diff
@@ -11,15 +11,15 @@
 import socketserver
 import sys
 import threading
 import time
 import webbrowser
 import urllib.parse
 
-__version__ = '7.0.4'
+__version__ = '7.0.5'
 
 class _ContentProvider: # pylint: disable=too-few-public-methods
     data = bytearray()
     base_dir = ''
     base = ''
     identifier = ''
     def __init__(self, data, path, file):
```

## netron/tengine.js

### js-beautify {}

```diff
@@ -204,27 +204,27 @@
     get outputs() {
         return this._outputs;
     }
 };
 
 tengine.Attribute = class {
 
-    constructor(schema, key, value) {
+    constructor(metadata, key, value) {
         this._type = '';
         this._name = key;
         this._value = value;
-        if (schema) {
-            this._name = schema.name;
-            if (schema.type) {
-                this._type = schema.type;
+        if (metadata) {
+            this._name = metadata.name;
+            if (metadata.type) {
+                this._type = metadata.type;
             }
-            if (Object.prototype.hasOwnProperty.call(schema, 'visible') && !schema.visible) {
+            if (metadata.visible === false) {
                 this._visible = false;
-            } else if (Object.prototype.hasOwnProperty.call(schema, 'default')) {
-                if (this._value == schema.default || (this._value && this._value.toString() == schema.default.toString())) {
+            } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
+                if (this._value == metadata.default || (this._value && this._value.toString() == metadata.default.toString())) {
                     this._visible = false;
                 }
             }
         }
     }
 
     get type() {
```

## netron/tf.js

### js-beautify {}

```diff
@@ -1229,15 +1229,15 @@
                 break;
             }
             default: {
                 throw new tf.Error("Unsupported attribute value type '" + JSON.stringify(value).substring(0, 32) + "'.");
             }
         }
         if (schema) {
-            if (Object.prototype.hasOwnProperty.call(schema, 'visible') && !schema.visible) {
+            if (schema.visible === false) {
                 this._visible = false;
             } else if (Object.prototype.hasOwnProperty.call(schema, 'default')) {
                 const equals = (value, defaultValue) => {
                     if (!Array.isArray(defaultValue) && defaultValue === Object(defaultValue)) {
                         switch (defaultValue.type) {
                             case 'type':
                                 defaultValue = tf.Utility.dataType(defaultValue.value);
```

## netron/tflite-metadata.json

### Pretty-printed

 * *Similarity: 0.9996348314606742%*

 * *Differences: {'78': "{'inputs': {insert: [(4, OrderedDict([('name', 'state'), ('type', 'T')]))]}, 'outputs': "*

 * *       "{0: {'name': 'state_out'}}}"}*

```diff
@@ -1879,20 +1879,24 @@
             {
                 "name": "time",
                 "type": "T"
             },
             {
                 "name": "bias",
                 "type": "T"
+            },
+            {
+                "name": "state",
+                "type": "T"
             }
         ],
         "name": "SVDF",
         "outputs": [
             {
-                "name": "state",
+                "name": "state_out",
                 "type": "T"
             },
             {
                 "name": "output",
                 "type": "T"
             }
         ]
```

## netron/tflite.js

### js-beautify {}

```diff
@@ -317,37 +317,38 @@
             let inputs = [];
             let outputs = [];
             inputs = Array.from(node.inputs || new Int32Array(0));
             outputs = Array.from(node.outputs || new Int32Array(0));
             let inputIndex = 0;
             while (inputIndex < inputs.length) {
                 let count = 1;
-                let inputName = null;
-                let inputVisible = true;
-                const inputArguments = [];
+                let name = null;
+                let visible = true;
+                const values = [];
                 if (this._type && this._type.inputs && inputIndex < this._type.inputs.length) {
                     const input = this._type.inputs[inputIndex];
-                    inputName = input.name;
+                    name = input.name;
                     if (input.list) {
                         count = inputs.length - inputIndex;
                     }
-                    if (Object.prototype.hasOwnProperty.call(input, 'visible') && !input.visible) {
-                        inputVisible = false;
+                    if (input.visible === false) {
+                        visible = false;
                     }
                 }
                 const inputArray = inputs.slice(inputIndex, inputIndex + count);
                 for (const index of inputArray) {
                     const value = args(index);
                     if (value) {
-                        inputArguments.push(value);
+                        values.push(value);
                     }
                 }
                 inputIndex += count;
-                inputName = inputName ? inputName : inputIndex.toString();
-                this._inputs.push(new tflite.Argument(inputName, inputVisible, inputArguments));
+                name = name ? name : inputIndex.toString();
+                const argument = new tflite.Argument(name, visible, values);
+                this._inputs.push(argument);
             }
             for (let k = 0; k < outputs.length; k++) {
                 const index = outputs[k];
                 const outputArguments = [];
                 const value = args(index);
                 if (value) {
                     outputArguments.push(value);
@@ -458,15 +459,15 @@
         if (this._name == 'fused_activation_function') {
             this._visible = false;
         }
         if (this._type) {
             this._value = tflite.Utility.enum(this._type, this._value);
         }
         if (metadata) {
-            if (Object.prototype.hasOwnProperty.call(metadata, 'visible') && !metadata.visible) {
+            if (metadata && metadata.visible == false) {
                 this._visible = false;
             } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
                 value = this._value;
                 if (typeof value == 'function') {
                     value = value();
                 }
                 if (value == metadata.default) {
```

## netron/tnn.js

### js-beautify {}

```diff
@@ -376,22 +376,22 @@
     get outputs() {
         return this._outputs;
     }
 };
 
 tnn.Attribute = class {
 
-    constructor(schema, key, value) {
+    constructor(metadata, key, value) {
         this._type = '';
         this._name = key.toString();
         this._value = value;
-        if (schema) {
-            this._name = schema.name;
-            if (schema.type) {
-                this._type = schema.type;
+        if (metadata) {
+            this._name = metadata.name;
+            if (metadata.type) {
+                this._type = metadata.type;
             }
             switch (this._type) {
                 case '':
                     break;
                 case 'int32':
                     this._value = parseInt(this._value, 10);
                     break;
@@ -403,18 +403,18 @@
                     break;
                 case 'float32[]':
                     this._value = this._value.map((v) => parseFloat(v));
                     break;
                 default:
                     throw new tnn.Error("Unsupported attribute type '" + this._type + "'.");
             }
-            if (Object.prototype.hasOwnProperty.call(schema, 'visible') && !schema.visible) {
+            if (metadata && metadata.visible === false) {
                 this._visible = false;
-            } else if (Object.prototype.hasOwnProperty.call(schema, 'default')) {
-                if (this._value == schema.default || (this._value && this._value.toString() == schema.default.toString())) {
+            } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
+                if (this._value == metadata.default || (this._value && this._value.toString() == metadata.default.toString())) {
                     this._visible = false;
                 }
             }
         }
     }
 
     get type() {
```

## netron/torch.js

### js-beautify {}

```diff
@@ -448,20 +448,20 @@
 
     constructor(metadata, type, name, value) {
         this._name = name;
         this._value = value;
         if (name == 'train') {
             this._visible = false;
         }
-        const schema = metadata.attribute(type, name);
-        if (schema) {
-            if (Object.prototype.hasOwnProperty.call(schema, 'visible')) {
-                this._visible = schema.visible;
-            } else if (Object.prototype.hasOwnProperty.call(schema, 'default')) {
-                if (JSON.stringify(schema.default) == JSON.stringify(this._value)) {
+        metadata = metadata.attribute(type, name);
+        if (metadata) {
+            if (metadata.visible === false) {
+                this._visible = false;
+            } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
+                if (JSON.stringify(metadata.default) == JSON.stringify(this._value)) {
                     this._visible = false;
                 }
             }
         }
     }
 
     get name() {
```

## netron/uff.js

### js-beautify {}

```diff
@@ -335,18 +335,14 @@
     get name() {
         return this._name;
     }
 
     get value() {
         return this._value;
     }
-
-    get visible() {
-        return true;
-    }
 };
 
 uff.Tensor = class {
 
     constructor(dataType, shape, values) {
         this._type = new uff.TensorType(dataType, shape);
         switch (values.type) {
```

## netron/view.js

### js-beautify {}

```diff
@@ -10,32 +10,38 @@
 var python = require('./python');
 var grapher = require('./grapher');
 
 view.View = class {
 
     constructor(host) {
         this._host = host;
-        this._options = {
+        this._defaultOptions = {
             weights: true,
             attributes: false,
             names: false,
             direction: 'vertical',
             mousewheel: 'scroll'
         };
+        this._options = Object.assign({}, this._defaultOptions);
         this._model = null;
         this._graphs = [];
         this._selection = [];
         this._sidebar = new view.Sidebar(this._host);
         this._searchText = '';
         this._modelFactoryService = new view.ModelFactoryService(this._host);
     }
 
     async start() {
         try {
             await this._host.view(this);
+            const options = this._host.get('configuration', 'options') || {};
+            for (const entry of Object.entries(options)) {
+                const name = entry[0];
+                this._options[name] = entry[1];
+            }
             this._element('sidebar-button').addEventListener('click', () => {
                 this.showModelProperties();
             });
             this._element('zoom-in-button').addEventListener('click', () => {
                 this.zoomIn();
             });
             this._element('zoom-out-button').addEventListener('click', () => {
@@ -297,14 +303,26 @@
                 break;
             case 'mousewheel':
                 this._options.mousewheel = this._options.mousewheel === 'scroll' ? 'zoom' : 'scroll';
                 break;
             default:
                 throw new view.Error("Unsupported toogle '" + name + "'.");
         }
+        const options = {};
+        for (const entry of Object.entries(this._options)) {
+            const name = entry[0];
+            if (this._defaultOptions[name] !== entry[1]) {
+                options[name] = entry[1];
+            }
+        }
+        if (Object.entries(options).length == 0) {
+            this._host.delete('configuration', 'options');
+        } else {
+            this._host.set('configuration', 'options', options);
+        }
     }
 
     recents(recents) {
         if (this._recents) {
             this._recents.clear();
             for (let i = 0; i < recents.length; i++) {
                 const recent = recents[i];
@@ -1913,15 +1931,15 @@
                     hiddenInitializers = true;
                 }
             }
         }
         let sortedAttributes = [];
         const attributes = node.attributes || [];
         if (this.context.view.options.attributes) {
-            sortedAttributes = attributes.filter((attribute) => attribute.visible).slice();
+            sortedAttributes = attributes.filter((attribute) => attribute.visible !== false).slice();
         }
         sortedAttributes.sort((a, b) => {
             const au = a.name.toUpperCase();
             const bu = b.name.toUpperCase();
             return (au < bu) ? -1 : (au > bu) ? 1 : 0;
         });
         if (initializers.length > 0 || hiddenInitializers || sortedAttributes.length > 0) {
@@ -1963,15 +1981,15 @@
                 list.add(value.name ? 'initializer-' + value.name : '', initializer.name, shape, type ? type.toString() : '', separator);
             }
             if (hiddenInitializers) {
                 list.add(null, '\u3008' + '\u2026' + '\u3009', '', null, '');
             }
 
             for (const attribute of sortedAttributes) {
-                if (attribute.visible) {
+                if (attribute.visible !== false) {
                     let value = new view.Formatter(attribute.value, attribute.type).toString();
                     if (value && value.length > 25) {
                         value = value.substring(0, 25) + '\u2026';
                     }
                     list.add(null, attribute.name, value, attribute.type, ' = ');
                 }
             }
```

## Comparing `netron-7.0.4.dist-info/METADATA` & `netron-7.0.5.dist-info/METADATA`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: netron
-Version: 7.0.4
+Version: 7.0.5
 Summary: Viewer for neural network, deep learning, and machine learning models
 Home-page: https://github.com/lutzroeder/netron
 Author: Lutz Roeder
 Author-email: lutzroeder@users.noreply.github.com
 License: MIT
 Keywords: onnx,keras,tensorflow,tflite,coreml,mxnet,caffe,caffe2,torchscript,pytorch,ncnn,mnn,openvino,darknet,paddlepaddle,chainer,artificial intelligence,machine learning,deep learning,neural network,visualizer,viewer
 Classifier: Intended Audience :: Developers
```

## Comparing `netron-7.0.4.dist-info/RECORD` & `netron-7.0.5.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,40 +1,40 @@
 netron/__init__.py,sha256=4X_FliRM4GvcwqYDnJ7SHmJoR6u4vdcPBgzfGe62os0,1526
 netron/acuity-metadata.json,sha256=QWN9j-u1qIO3fDekkb81x2htnA2_fBcBza54PmIswYg,57889
 netron/acuity.js,sha256=gGKqgzMxq2xrNEtV8IXvNatrEQ57y4TguVSRKIIsa8U,24160
 netron/armnn-metadata.json,sha256=QF244hVPg7xbSSg1EHff8sQCPEKf8-KqGEOHa-AE3io,11340
 netron/armnn-schema.js,sha256=D0drkSXP9KuMls2jd_GipMEgvT2EX_ItpejdUALrCiU,108710
-netron/armnn.js,sha256=9H9C75YOHvE1mak920MgodkHd1mlV6kRqtvQphNXYak,13844
-netron/barracuda.js,sha256=y_XVrqlaJAMxhVizuxDvf5XHXcOycI0MSP0O-Gtk8ww,16619
+netron/armnn.js,sha256=bcnJ3H2TdfQlmtDEnvi3H7OPLrWf6E0NDbj9b1MmSn8,13793
+netron/barracuda.js,sha256=jTlPAGGYv1x23ftW5Bt2VGIQU_RAwcmgUV9qXTa3VbQ,16571
 netron/base.js,sha256=e61sbYtfBXDNFrC7px0CVdlgQ2PpMajccjahieDXFJo,38147
 netron/bigdl-metadata.json,sha256=TRtkhMaMeFVOIG7C7sB5cdedbGRifKEQFGQKjqikIBM,2017
 netron/bigdl-proto.js,sha256=i9PTO7r9Z0JktlrmY6n8BIcj1E9AJ7Gc0U_FoZvtcXI,24356
-netron/bigdl.js,sha256=b7rCVWHDOthpjCybe6zERokh1tQ-KQAbp7v8oDm9WuI,12793
-netron/browser.js,sha256=kWpNX4fmqY-W1EVP0XvrX_V7Q3fq6gCLiMUux7UzKns,33629
+netron/bigdl.js,sha256=on2pXMueLaI-Hc6wYLHDCrVQsRPE40s7iwY6UgUnmcI,12745
+netron/browser.js,sha256=1Zx77T0RIeDViRgFlzo5rqVoOlldYSNbIOlP74wmwyo,34585
 netron/caffe-metadata.json,sha256=PfjdGkv0ND0C_RRZTlBp8xU4dbO7IaRVsJswgfS6l-k,9505
 netron/caffe-proto.js,sha256=ffOrbx6VC-rT-hXfFau666KqiP80fpfIzi5IpppkNNw,188897
-netron/caffe.js,sha256=bYQbCLtFXEA0Ylu9an48OdDcwEyTKXDHrmo50SWXmdk,25581
+netron/caffe.js,sha256=AsavT0bjEh3RSlMuuz3KtPZuV9sBskYEYoxn_mhsEUs,25529
 netron/caffe2-metadata.json,sha256=2uApNj06QES26k3krNU4UeLhnhihnLl9un09bd54saI,863689
 netron/caffe2-proto.js,sha256=Tm1juVx6gRP3Vrw0K0WTMN_n_iOIWKCf9UJNou84hyY,61210
-netron/caffe2.js,sha256=SH5h6cZNqTGiHbXsRRcFvmXMhHkYxj9f0d-Unl9k3HA,22669
+netron/caffe2.js,sha256=cqs9PwjICFUVRESWklIIiBNTckNHP6rB1m7fYMHOhJA,22617
 netron/cambricon.js,sha256=0DrtZS3ylvm6O1Yx8tiFWXrUopR2bd7sjSI2B9hQJos,902
 netron/circle-metadata.json,sha256=QiCiiauBNSkjeSU4rSayYHNxbnhv9_tuxzKvFvPgJRM,13245
 netron/circle-schema.js,sha256=PP1bNREsniKkUyvI6hG66qI6TrXRnlbhWUw43ZSQaAU,99313
-netron/circle.js,sha256=QrrRTZjbEH3jlVXcp0LtHyS6fuimf53dATMHgkk7aPY,24512
+netron/circle.js,sha256=Oq2DArcGCmeyQx8kLlk0sSUk3CU656mK6qF-2H0O148,24420
 netron/cntk-metadata.json,sha256=XTsJD8M0AvBUS8jYtOS_pfhJsXLNuRdltqy3jnp0Mjc,14193
 netron/cntk-proto.js,sha256=xizxpkzQiIJkJIjRTud0qtY7_yq4q77bvDXWAwCcwmw,11578
-netron/cntk.js,sha256=zhpZY2MvlkROULL57Q4BF0kwIIB3YSyn6BYDIHgbpW8,43826
+netron/cntk.js,sha256=rmgjsBVyVz9gsdwdgmlD2rrpPFTtvYC695FVgUpHjGs,43790
 netron/coreml-metadata.json,sha256=ZbbnTKcCcZ8b031-9TSGuRMh6V5eurStjmT8h59jSO0,15775
 netron/coreml-proto.js,sha256=3tC_Q_sup8cSzgHzdflSKVz97Ghrkzr1BJAbvCU0HYA,415701
-netron/coreml.js,sha256=L3cbKzg_5OSMpyAWWzIhvp3SqvzWkHZKobuNCuwJjhg,67894
+netron/coreml.js,sha256=YjBzthva8lxHjrcZhpeJyuSnIb4lTNbeDvEg1S4clcw,68026
 netron/dagre.js,sha256=HqqcEi6GVLwlDZqmqToepYYnpjNEJSGirdNRfEabM9k,102126
 netron/darknet-metadata.json,sha256=dw1vThEJwGVlV74G2cvyzQ6v7LWoGdF_LAnUM77JfXk,20570
-netron/darknet.js,sha256=AzXWzMV-X9Qg-HeodXdrwPPdFUPxv6tDnPMz8VNgRPY,54924
+netron/darknet.js,sha256=JmtzBnhTtdc3KcotccVoRgM7Zx44-dkeUXvRZKhL89U,54898
 netron/dl4j-metadata.json,sha256=wh1OJVSWT2PQtQRq35NanPXfNF8s0bspM2Ww573U8To,1417
-netron/dl4j.js,sha256=OWS2j0HYBK_MQvng0I0pANy7t7UkIcpVrNn45UZNGeA,17003
+netron/dl4j.js,sha256=5RCP4eaRqHlV8k9M7aO3puMrKcHlrzS6rjNM3oaS96I,16955
 netron/dlc-metadata.json,sha256=XIWHz1A0Wvi65Nh5ztVtilFUwZCdxjrGv-0XRTUzQdQ,735
 netron/dlc-schema.js,sha256=5fIESjqcEXdAWfJQGEfJ7nqAvkRcZ3OIEvKG_VZh998,3277
 netron/dlc.js,sha256=damZ9NWQDolzGt_GogyZW97We3d1lhoQtP1HYqNeNJ8,17870
 netron/dnn-metadata.json,sha256=5-48ChRcuDJQ5WA6_c5xOYs66J3XjsPYbrz7LyH_d9E,1777
 netron/dnn-proto.js,sha256=vpoxH8Jw21cerjYxea6AL1EAfcnO-lhqEjAbJWYu5L0,11533
 netron/dnn.js,sha256=ZGVn8YMbh1JRWRmcCPKHgbOUv3qCmK6uLHcGV0hCRF0,10601
 netron/favicon.ico,sha256=o3hrI04KVfImdrgo9Ucs1f27tMPVjCiJzGogjeR8pHg,34494
@@ -42,103 +42,103 @@
 netron/flax.js,sha256=qrjY7mxfDamGjpxfscTN8-C0_jYDz9Lx4j8q5Qw6qxU,7734
 netron/flexbuffers.js,sha256=djGSf33a0wTn_3Ux2i7ZO5kJwESfB7WqnEcS2eXRiEI,7568
 netron/flux-metadata.json,sha256=lK6y0flbBJakM3nkhtmqqPtuJrN4D2n9pM_k0MPDR0c,3
 netron/flux.js,sha256=wk8auutcR8pX2X1EeGEYiQWI8bIn_r77O6qYo2tj1OI,2409
 netron/grapher.css,sha256=SEFVqi9GiIiYiZ-HN6vzxoqhBKk14uJrwJaARcvBca4,6061
 netron/grapher.js,sha256=MYfStDExyjpBUDXbP8-LABRUnN-lCQxsIH_cyyGPqyY,25528
 netron/hailo-metadata.json,sha256=RVG-oCGnGid9UOHRdIQ_BINS-GkvG7uyTenguCiKdMs,29456
-netron/hailo.js,sha256=eNaX5bllMYDOpCdXVJWL7W4MYmka08cfNux_mwDbfDE,11796
+netron/hailo.js,sha256=RPjuFCWF6LkmdQuqrifXR8IYVzQN7pWc9Y_l-QXAf9w,11698
 netron/hdf5.js,sha256=-iS1B7LVP_ogiXwyz0GlKh5rxScT8HWSsHl5YakMNK4,57289
 netron/hickle.js,sha256=WvNNH6BrjXri-hOy5bLUojeCJi_pUE79MjepDNu4mFA,6799
 netron/icon.png,sha256=8PZX7X6-sLBgonyQTGelX60C661x3YZ13eIGcuXQcHc,58106
 netron/imgdnn.js,sha256=PaI-2nhmN96FZbtNSgL34kCx-WE348-oBNgcqecMfmY,1402
-netron/index.html,sha256=BvpSZL8xdfIXAcHbj_Mpdd9zIwL6gdPFT5-L2ioA1CE,44057
+netron/index.html,sha256=JiGoUI4nkLu98CL7DwOBtRNwcXi-VGQqkvCxvxSHg1U,44057
 netron/index.js,sha256=sGjUrFEQJk93bjbYQ8ULhUJwY9LgNuYqNMuNuMm4cu0,4014
 netron/json.js,sha256=cor_V2_vWltKePIM5OQMvmZRwyl4wsn9vkejf2i4G2c,18643
 netron/keras-metadata.json,sha256=PExbUAIA4PpP35ARwz8Lp66EKfgIuAEY1b2_yWTZzLQ,254682
-netron/keras.js,sha256=Y_r2XSQl77DnpWook3b7XO5xz5DgTN5WaFXy8auLqaM,54590
+netron/keras.js,sha256=1t34PLnXpGmPus8c0qEXUMo_y1z-7tfJdoZTlXvTLLA,54548
 netron/kmodel.js,sha256=l0zlbLQY2chZCGbQKQpEomsQo3tD7Vv3j7RsRBQAckA,64052
 netron/lasagne-metadata.json,sha256=UAy5q6DnjJWEav_Vo-G-OncwvHVuytNlTStpDJ8MB2U,244
 netron/lasagne.js,sha256=1jGqP4NaBDgr-R3HYFldvGZ-LWWF3EZvKS8rZuJef9Y,7061
 netron/lightgbm.js,sha256=50bTm5pbp_va_Cm-Upmdd6DL-XgvvAg_uyQVk6_oNLQ,5172
-netron/mediapipe.js,sha256=dYNcxR8qrRbzDd9s_9mX2JXYYLIHtEwn3A5o7vdU57M,12839
+netron/mediapipe.js,sha256=zofYVEzUtEmshokfLdzSp8EVJVApvNEOQUPFyV3FBjU,10385
 netron/megengine-metadata.json,sha256=I3m7qRW_yQWJkzNf_XBK6DcxqFcoL-gZvPzSuRzk2Us,91710
 netron/megengine-schema.js,sha256=eZi_wSjkIqR0A0CcXB3gcEqBuKEI14Ug2mTTH0niI9c,82284
-netron/megengine.js,sha256=CC9rAT0pnOGR43XCzA6UFOCnyn6wdJdAfON1VO0GaQE,32109
+netron/megengine.js,sha256=3Uv0EAJzn0vu6AiTLlBIV6CCy3z77P817Kfj13yWnTc,30574
 netron/mlir.js,sha256=EiR1q4W73kF7h6KKrXOR2tQM0QWIncMapAy_H7zyD7s,44765
 netron/mlnet-metadata.json,sha256=y_pySnY22XYqxvTVdLSEvDLfD76B0UZeB3uZiQp4dys,3423
-netron/mlnet.js,sha256=5RNhieIPdnm1-A0p9zUhMMgS640K-3qQ_NO1DeM1cZ8,78299
+netron/mlnet.js,sha256=xK0c2me1_EBzY8urcQ988KmKCvOscHf37hJFMmiqoTo,78251
 netron/mnn-metadata.json,sha256=ghs-wFIV0Ih-hkeSVP6WJ6djVM6UuVZ4B7saxonOb3E,10058
-netron/mnn-schema.js,sha256=_aveqs9VoXclGp-C6OR2_yNFHhkA4nPBhFiuc_TqH-k,62288
+netron/mnn-schema.js,sha256=aMlg3o0N8z-cfp0QdoDf3vUjC4oimLrNwLkhJTOPyQ0,62342
 netron/mnn.js,sha256=jZCYGnnjfeG6M5-JbZikBi8ca4BOvIKlPIKFuUWsYpk,17641
 netron/mslite-metadata.json,sha256=auv76wwLS_Cg4R2t1VXZcUMSUp0louocjSSOXwibMAk,85458
 netron/mslite-schema.js,sha256=-f6KUBaFsKh6q8mJi_8r6ZGK93B6Ih2RKcRRKLsABlA,171745
 netron/mslite.js,sha256=Q1XHky40Y-VaBC-3FxWjCPaZ4GZfYH57losB50-zpCY,14997
 netron/mxnet-metadata.json,sha256=sf1taquijGWKNTAkxVbDMAk4wbkiZ-IYkkYekHxtKfc,11884
 netron/mxnet.js,sha256=IR3XwlDzHpZADr_FJHIGFPSYQqLC2BeY5Y1PlEqbImQ,37803
 netron/ncnn-metadata.json,sha256=uokKe5QeTBOjxVo4jcuSMQAFqsm9SXETwWLZlv67JRU,30899
-netron/ncnn.js,sha256=CrklBs2oXxvD4Asp0xIH0zcxyFMaaxdy6HKNsnOfzkM,38024
+netron/ncnn.js,sha256=Mrhfvg6n74pmwtMbz1ncg9M8kTbYVOWelno04wFP-ac,37984
 netron/nnabla-metadata.json,sha256=fqBPePVmcKoHTp6YAzEpOaSZBrdEUv-SOEUVGM6fJ50,290482
 netron/nnabla-proto.js,sha256=sWfuD9QEF9nRxNfTo4eQSMu8lV5mpmQRJXUkpPIDlrI,434215
 netron/nnabla.js,sha256=lKpVO2UzNuk9ni2CdPQRObAv6twblwHxMfu4hn_Xc6E,11418
 netron/nnef.js,sha256=gOoqFv531ftHkGbC_otlXYE79qAnzkDjDXkCFSGbnt8,2224
 netron/numpy.js,sha256=rFVSNsdTf5NjTCyagrvLgkGhq1Z8X4ElDPf-aZPOn0E,15163
 netron/om-metadata.json,sha256=nWz35Zjqfe_JqM9F9mydQnso0k4j3D1YuKgMJpS8_4Y,53079
 netron/om-proto.js,sha256=1SbZHKiX3S0r98-rX8dGl4bsF7x-DrQDbNxseeunpks,37006
-netron/om.js,sha256=1LVRS7DsmfSqpXWPP4fYrA4Fl3lrTRYDG7jCIwNa_68,31227
+netron/om.js,sha256=yheMTNB174qaGSgF_bugL6mtmMnpsD6OpFmjt7Jpogc,28732
 netron/onednn-metadata.json,sha256=ZzCrrVEwXx36AWZ_TbOLa6PM-VL4LpEit0u35yj_-LU,6818
 netron/onednn.js,sha256=We_25VGJthNLhQrD1HR20N5flwIo5z3SzTgV3A9KDXU,12047
 netron/onnx-metadata.json,sha256=DJeNAQc5H05uK99k5V0C2mnfO7Ea516Np5wr0aRVQ_g,2903924
 netron/onnx-proto.js,sha256=l35_Dhs_wpLvGTuSmWuHsRfXBiJU97JdCA7PzzsvV_s,59899
 netron/onnx-schema.js,sha256=bCJy80ZVAxcNbsa60fBbpJCzOoapMZjf4TnAutaBzqU,15717
 netron/onnx.js,sha256=E-k7pxetvdRA7keyP94YHF85ArairCeNAAXLfsuKAYY,83598
 netron/onnx.py,sha256=GkNnqLXIZjHMviBblu_XorcDKrNcvmVZ0A-Yxg5l2Hg,9053
 netron/openvino-metadata.json,sha256=heC0fS0DL26NLrlVXcEcs4GldF_LYWDBJp2iI1G8_zo,84585
-netron/openvino.js,sha256=GrKqOgawHLgKFe3hESkRhm0OndfeRJLOMS1CZXb5BCI,44609
+netron/openvino.js,sha256=15FmjUQlWAuqQC2hFWdHfHV7oKMXSugFoFc-LLI5ZXA,44560
 netron/paddle-metadata.json,sha256=iyV8jUl7AhSOMTVcWLrChsBqS1l8iqGYl99KLYFl93w,2894
 netron/paddle-proto.js,sha256=2vXAa6JSlrxnI7UXYaGwDik4RyaT90QQR7Kc-Kbc5qI,60111
 netron/paddle-schema.js,sha256=DmewWGVK8zHjPz-7GQ6md9WqQsX0sexfw3UizluGedU,19797
 netron/paddle.js,sha256=9_QmEZvgqWCJ2PfObKjgH09cgxhqNNhgNUfLXDO0n9I,37551
 netron/pickle.js,sha256=x7yo3teKKUaarCpyQ03gZsnDjyJ-ggZW4yOvJvBPnnM,5537
 netron/protobuf.js,sha256=ywdCgnvVRrpARySOloWs_P7e9MliActsCYuqgYZvayM,42713
 netron/python.js,sha256=aaX1cmJZkX697_ow8DfKoY6JO90izXsYKxN3HTT0m4s,303560
 netron/pytorch-metadata.json,sha256=wMK91ihAcneKcpDdg48boEj2Gf4OWl4GzcsIBJizttI,410224
 netron/pytorch-schema.js,sha256=DsFhOphzFGysPeVnnxcqvHgs0zhYy2mTEpBwre8r6IA,13170
-netron/pytorch.js,sha256=CIXK1r27D_LeAr3gJD8mTyA8GSODu47YSSGGeOtTl90,182217
+netron/pytorch.js,sha256=Hn_LfE3Je6HE9BAgr6AqNN6y8zDFQe9D7fp8HQTarRs,182243
 netron/pytorch.py,sha256=gkEnA4OGqooxARhnsEZfzDYmAsycMSTkLXIB1hMJm9Y,24259
 netron/rknn-metadata.json,sha256=KaVXz6q_TPrAFBaOaSvHhNDU2m-rmeyIl2NThAa7lxY,5473
 netron/rknn-schema.js,sha256=i5gzD6mHjr1jFjTv30mHJk13KErOdaX3O4xSWabkLzE,4263
 netron/rknn.js,sha256=Ox1eKNUIMhUiPVz04VjE7KFBJDm_n_h3sHuraxCkw-w,24816
 netron/safetensors.js,sha256=sNrm4dJlfj5cPKOzMH_IknrxS3juImytbC_2Pl-l9xI,4571
-netron/server.js,sha256=QiQrFtYnWJKpXLmM59Y339DwaCZGqY05RGUhvrQUO3c,5972
-netron/server.py,sha256=A38ZGEWFyknSPTKubCjiCIwFxgKQZWC9XiaahPSzLGo,11874
+netron/server.js,sha256=PL7pKx6yS-5h09-TnCtmrXLnfunJaBHTA3rDF3vkZv8,5876
+netron/server.py,sha256=bJ3QTEo5yC8DpcTJ1j1WZ7YtVOeScx64Lc9IUxYw5aY,11874
 netron/sklearn-metadata.json,sha256=L9UWeoEfqkFzZOT4WiupFpVwdDvcuwlXiesuChzqIwc,160693
 netron/sklearn.js,sha256=QPFvFkr6_v25ZhoOsap6Es-CCqdHK8jNDru3CvsQd6I,14713
 netron/tar.js,sha256=0Lr1Ez0QreewNBH2QPq-5oNW63EaeUwwvgov4ypGmFM,4908
 netron/tengine-metadata.json,sha256=v4dIwOf9t_f1bhYkJBORa71SBWlYuwi3LuZZJQjcYGY,27914
-netron/tengine.js,sha256=Hd8drHBAtgf7VKv32yYIZYMC-ULUHN_XB5dmvxaaHIA,28126
+netron/tengine.js,sha256=ZLNFxRmPo4hNLJaFQbBa5ZRIkZxvUnPj7eq9DbkeYiQ,28094
 netron/tensorrt.js,sha256=g_95J0_u3AvdSb8W17UbwOn1RqtGVpUL3UKSmEnOXRQ,5304
 netron/text.js,sha256=z5u9vVf4wMSITISKa3CqColrXlVYRmiYFNWPgo9ziJ4,11085
 netron/tf-metadata.json,sha256=So93YVb3S4dCJTbySDhaVdhsUqMTCtp-_OZQpCnKXyE,2221625
 netron/tf-proto.js,sha256=b-YUWe3a2eNhVgblSQQISCl_ptEU8EAYiR-T7j0EuT0,361929
-netron/tf.js,sha256=jSVYSzxRDJfs5Kos0WAcmSMRNo76DNx5U-boy2RL1CU,106628
-netron/tflite-metadata.json,sha256=sGUxg9ubyeoF1urhm9GjNcqOnXcjRTKgOBbASwWqprs,29780
+netron/tf.js,sha256=1pA_ADwOWO1mmbU5h_KC1A-u8Ng6E2v9stGA7ceipDA,106578
+netron/tflite-metadata.json,sha256=4m1DYqLQIdjRr_Uc2As8fHnEESlfTq2JsRsOt7RFskQ,29824
 netron/tflite-schema.js,sha256=jNEC9GMvUsKb2alsDWKtrgaTuNXb6CsDI_P41Ah13i4,110995
-netron/tflite.js,sha256=m85si-KIZPzVQNeYFu2pf2PF9biIVFbF6EP_WPKrjhw,25214
+netron/tflite.js,sha256=S18nbCeCNE22JdX_unKbPR3MnVT5CxfLPvlLE3Qqtmg,25098
 netron/tnn-metadata.json,sha256=Je5JnWH0t4gWsSkj9YbWIzzbcYEoP3XXwVMa7sAH3_A,20380
-netron/tnn.js,sha256=EgCy_wjzLg9BY8jYiSo7WwxqpEU5qnAgddegS962f9U,26888
+netron/tnn.js,sha256=sBCYEleRWan_kJg_r3p8qalT3JM3Xacv9JIv13LpvMo,26868
 netron/torch-metadata.json,sha256=fj2b1n_Ih7eZdst4ohdUEAL5T3XmjTMlkUBmUo3Ogng,12510
-netron/torch.js,sha256=28XwRQ7IxBoQOpKfOLQMn5eYlmCNKYjIVr1AqYjWdZs,41580
+netron/torch.js,sha256=AL3dejzy__JQZdEDxaphO89fG-3iGyehx2vXrceeIhw,41544
 netron/uff-metadata.json,sha256=kVCe02DZKfSoTgwqfjh18jQcImre1KcYkg76_WNOagI,2333
 netron/uff-proto.js,sha256=U7-KLsLgvBdSeBEclHE8-xaWMqMN_PjoziTOmH7EK9Y,30910
-netron/uff.js,sha256=FElkDN7PN_e3jxI7q4wJklGocSYA0TAZzaHrU7iOS24,12805
-netron/view.js,sha256=G9UUPSynH4taFq1q80zjtT-08OCSVhzGifQctAqB33U,235511
+netron/uff.js,sha256=O6pZ6rgcU29WPuTQ6dF05i8lMwaF4Utx5l7agdrmggU,12757
+netron/view.js,sha256=FHblgqCun4AaW2bYQfiqibIrePDPdH6716EL0DzIqB8,236292
 netron/weka.js,sha256=QNhjYBIbmQXB7PBQKLoILyvlT0XOXe5x2VBUc0KQ9bY,8031
 netron/xml.js,sha256=_zng3WkOrLR4OvBYMs0aD04pbmUq6Q2QJQxtETbi2Rw,64034
 netron/xmodel-proto.js,sha256=mFk07nBgAyXBOWllxg-fw-2EGEaIxF231wXlNLK6v5A,55685
 netron/xmodel.js,sha256=FYHJt1B-Ony6vPc_GiGoq9YIkXZyNqrgCfGD3RQTIHg,13916
 netron/zip.js,sha256=x-6tEIJ_d2gw7Cqipx_mqi_i2wHLfcVb6BR8AenXhLs,30755
-netron-7.0.4.dist-info/METADATA,sha256=kOTAPvKtEwDWQXiG_o8x9Mybw83lYxu_gShIrFt3r8c,1576
-netron-7.0.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-netron-7.0.4.dist-info/entry_points.txt,sha256=3fHM6H_AIEjt21838iCMZ72hmRqtnNTuL66UnCIOSpU,39
-netron-7.0.4.dist-info/top_level.txt,sha256=qt4XhfLsmugdsjAczetcmraULS1GexprL8Ruo2YQubU,7
-netron-7.0.4.dist-info/RECORD,,
+netron-7.0.5.dist-info/METADATA,sha256=T4iv0-5qVlLsLt51nFyRwJER_okk5Kgl6VdCuwmZGh0,1576
+netron-7.0.5.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+netron-7.0.5.dist-info/entry_points.txt,sha256=3fHM6H_AIEjt21838iCMZ72hmRqtnNTuL66UnCIOSpU,39
+netron-7.0.5.dist-info/top_level.txt,sha256=qt4XhfLsmugdsjAczetcmraULS1GexprL8Ruo2YQubU,7
+netron-7.0.5.dist-info/RECORD,,
```

