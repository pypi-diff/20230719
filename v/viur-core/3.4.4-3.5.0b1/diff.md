# Comparing `tmp/viur_core-3.4.4-py3-none-any.whl.zip` & `tmp/viur_core-3.5.0b1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,94 +1,94 @@
-Zip file size: 246946 bytes, number of entries: 92
--rw-r--r--  2.0 unx    18870 b- defN 23-Jun-23 16:42 viur/requirements.txt
+Zip file size: 277627 bytes, number of entries: 92
+-rw-r--r--  2.0 unx    33986 b- defN 23-Jun-27 11:53 viur/requirements.txt
 -rw-r--r--  2.0 unx      304 b- defN 23-Apr-18 16:00 viur/tox.ini
 -rw-r--r--  2.0 unx    16000 b- defN 23-Jun-22 21:08 viur/core/__init__.py
 -rw-r--r--  2.0 unx    13627 b- defN 23-Apr-18 16:00 viur/core/cache.py
--rw-r--r--  2.0 unx    12369 b- defN 23-Jun-23 16:42 viur/core/config.py
+-rw-r--r--  2.0 unx    12723 b- defN 23-Jun-27 11:53 viur/core/config.py
 -rw-r--r--  2.0 unx      272 b- defN 23-Apr-18 16:00 viur/core/current.py
 -rw-r--r--  2.0 unx      579 b- defN 23-Jan-18 08:13 viur/core/db.py
 -rw-r--r--  2.0 unx    17528 b- defN 23-Jan-18 08:13 viur/core/email.py
--rw-r--r--  2.0 unx     7048 b- defN 23-Jun-23 16:42 viur/core/errors.py
+-rw-r--r--  2.0 unx     8267 b- defN 23-Jun-27 11:52 viur/core/errors.py
 -rw-r--r--  2.0 unx    12654 b- defN 23-Apr-18 16:00 viur/core/i18n.py
 -rw-r--r--  2.0 unx     6360 b- defN 23-Apr-18 16:00 viur/core/logging.py
--rw-r--r--  2.0 unx     7185 b- defN 23-Jun-22 21:31 viur/core/module.py
+-rw-r--r--  2.0 unx     8487 b- defN 23-Jun-27 11:53 viur/core/module.py
 -rw-r--r--  2.0 unx     6141 b- defN 22-Dec-08 12:57 viur/core/pagination.py
 -rw-r--r--  2.0 unx     5647 b- defN 23-Apr-18 16:00 viur/core/ratelimit.py
--rw-r--r--  2.0 unx    32734 b- defN 23-Jun-23 16:42 viur/core/request.py
+-rw-r--r--  2.0 unx    32628 b- defN 23-Jun-27 11:52 viur/core/request.py
 -rw-r--r--  2.0 unx    14954 b- defN 23-Apr-18 16:00 viur/core/securityheaders.py
--rw-r--r--  2.0 unx     4651 b- defN 23-Jun-19 22:09 viur/core/securitykey.py
--rw-r--r--  2.0 unx    10338 b- defN 23-Jun-19 22:09 viur/core/session.py
--rw-r--r--  2.0 unx    71253 b- defN 23-Jun-23 16:42 viur/core/skeleton.py
--rw-r--r--  2.0 unx    33528 b- defN 23-Jun-23 16:42 viur/core/tasks.py
+-rw-r--r--  2.0 unx     4543 b- defN 23-Jun-27 11:53 viur/core/securitykey.py
+-rw-r--r--  2.0 unx     8647 b- defN 23-Jun-27 11:53 viur/core/session.py
+-rw-r--r--  2.0 unx    71202 b- defN 23-Jun-27 11:53 viur/core/skeleton.py
+-rw-r--r--  2.0 unx    33741 b- defN 23-Jun-27 11:53 viur/core/tasks.py
 -rw-r--r--  2.0 unx    12355 b- defN 23-May-19 21:24 viur/core/utils.py
--rw-r--r--  2.0 unx      429 b- defN 23-Jun-23 16:48 viur/core/version.py
+-rw-r--r--  2.0 unx      435 b- defN 23-Jun-27 12:23 viur/core/version.py
 -rw-r--r--  2.0 unx     2765 b- defN 23-Apr-18 16:00 viur/core/bones/__init__.py
--rw-r--r--  2.0 unx    42403 b- defN 23-Jun-23 16:42 viur/core/bones/base.py
--rw-r--r--  2.0 unx     2554 b- defN 23-Jun-23 16:42 viur/core/bones/boolean.py
--rw-r--r--  2.0 unx     2742 b- defN 23-Jun-23 16:42 viur/core/bones/captcha.py
--rw-r--r--  2.0 unx     1910 b- defN 23-Jun-23 16:42 viur/core/bones/color.py
--rw-r--r--  2.0 unx     1908 b- defN 23-Jun-23 16:42 viur/core/bones/credential.py
--rw-r--r--  2.0 unx    12901 b- defN 23-Jun-23 16:42 viur/core/bones/date.py
--rw-r--r--  2.0 unx     1211 b- defN 23-Jun-23 16:42 viur/core/bones/email.py
--rw-r--r--  2.0 unx     8870 b- defN 23-Jun-23 16:42 viur/core/bones/file.py
--rw-r--r--  2.0 unx     3268 b- defN 23-Jun-22 21:31 viur/core/bones/json.py
--rw-r--r--  2.0 unx     7115 b- defN 23-Jun-23 16:42 viur/core/bones/key.py
--rw-r--r--  2.0 unx     6703 b- defN 23-Jun-23 16:42 viur/core/bones/numeric.py
--rw-r--r--  2.0 unx     5806 b- defN 23-Jun-23 16:42 viur/core/bones/password.py
--rw-r--r--  2.0 unx     6453 b- defN 23-Jun-23 16:42 viur/core/bones/randomslice.py
--rw-r--r--  2.0 unx      873 b- defN 23-Jun-23 16:42 viur/core/bones/raw.py
--rw-r--r--  2.0 unx     4415 b- defN 23-Jun-23 16:42 viur/core/bones/record.py
--rw-r--r--  2.0 unx    48776 b- defN 23-Jun-23 16:42 viur/core/bones/relational.py
--rw-r--r--  2.0 unx     3034 b- defN 23-Jun-23 16:42 viur/core/bones/select.py
--rw-r--r--  2.0 unx    16814 b- defN 23-Jun-23 16:42 viur/core/bones/selectcountry.py
--rw-r--r--  2.0 unx      505 b- defN 23-Jun-23 16:42 viur/core/bones/sortindex.py
--rw-r--r--  2.0 unx    16500 b- defN 23-Jun-23 16:42 viur/core/bones/spatial.py
--rw-r--r--  2.0 unx     7374 b- defN 23-Jun-23 16:42 viur/core/bones/string.py
--rw-r--r--  2.0 unx    16275 b- defN 23-Jun-23 16:42 viur/core/bones/text.py
--rw-r--r--  2.0 unx      214 b- defN 23-Jun-23 16:42 viur/core/bones/treeleaf.py
--rw-r--r--  2.0 unx      126 b- defN 23-Jun-23 16:42 viur/core/bones/treenode.py
--rw-r--r--  2.0 unx     1074 b- defN 23-Jun-23 16:42 viur/core/bones/user.py
+-rw-r--r--  2.0 unx    54117 b- defN 23-Jun-27 11:52 viur/core/bones/base.py
+-rw-r--r--  2.0 unx     4921 b- defN 23-Jun-27 11:53 viur/core/bones/boolean.py
+-rw-r--r--  2.0 unx     3621 b- defN 23-Jun-27 11:52 viur/core/bones/captcha.py
+-rw-r--r--  2.0 unx     3079 b- defN 23-Jun-27 11:52 viur/core/bones/color.py
+-rw-r--r--  2.0 unx     3947 b- defN 23-Jun-27 11:53 viur/core/bones/credential.py
+-rw-r--r--  2.0 unx    17144 b- defN 23-Jun-27 11:52 viur/core/bones/date.py
+-rw-r--r--  2.0 unx     2648 b- defN 23-Jun-27 11:52 viur/core/bones/email.py
+-rw-r--r--  2.0 unx    14136 b- defN 23-Jun-27 11:52 viur/core/bones/file.py
+-rw-r--r--  2.0 unx     3268 b- defN 23-Jun-27 11:52 viur/core/bones/json.py
+-rw-r--r--  2.0 unx    10452 b- defN 23-Jun-27 11:52 viur/core/bones/key.py
+-rw-r--r--  2.0 unx    10434 b- defN 23-Jun-27 11:52 viur/core/bones/numeric.py
+-rw-r--r--  2.0 unx     9076 b- defN 23-Jun-27 11:52 viur/core/bones/password.py
+-rw-r--r--  2.0 unx     8194 b- defN 23-Jun-27 11:52 viur/core/bones/randomslice.py
+-rw-r--r--  2.0 unx     1662 b- defN 23-Jun-27 11:52 viur/core/bones/raw.py
+-rw-r--r--  2.0 unx     7872 b- defN 23-Jun-27 11:53 viur/core/bones/record.py
+-rw-r--r--  2.0 unx    67067 b- defN 23-Jun-27 11:52 viur/core/bones/relational.py
+-rw-r--r--  2.0 unx     5015 b- defN 23-Jun-27 11:52 viur/core/bones/select.py
+-rw-r--r--  2.0 unx    18919 b- defN 23-Jun-27 11:52 viur/core/bones/selectcountry.py
+-rw-r--r--  2.0 unx     1492 b- defN 23-Jun-27 11:52 viur/core/bones/sortindex.py
+-rw-r--r--  2.0 unx    20334 b- defN 23-Jun-27 11:52 viur/core/bones/spatial.py
+-rw-r--r--  2.0 unx    11935 b- defN 23-Jun-27 11:52 viur/core/bones/string.py
+-rw-r--r--  2.0 unx    24571 b- defN 23-Jun-27 11:52 viur/core/bones/text.py
+-rw-r--r--  2.0 unx      700 b- defN 23-Jun-27 11:52 viur/core/bones/treeleaf.py
+-rw-r--r--  2.0 unx      844 b- defN 23-Jun-27 11:52 viur/core/bones/treenode.py
+-rw-r--r--  2.0 unx     2760 b- defN 23-Jun-27 11:52 viur/core/bones/user.py
 -rw-r--r--  2.0 unx       38 b- defN 23-Jan-18 08:13 viur/core/languages/__init__.py
--rw-r--r--  2.0 unx    12778 b- defN 23-Jun-22 21:31 viur/core/languages/de.py
--rw-r--r--  2.0 unx     1660 b- defN 23-May-10 08:55 viur/core/languages/en.py
+-rw-r--r--  2.0 unx    12984 b- defN 23-Jun-27 11:53 viur/core/languages/de.py
+-rw-r--r--  2.0 unx     1660 b- defN 23-Jun-26 22:46 viur/core/languages/en.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Dec-08 12:57 viur/core/modules/__init__.py
--rw-r--r--  2.0 unx    33556 b- defN 23-Jun-23 16:42 viur/core/modules/file.py
--rw-r--r--  2.0 unx     1916 b- defN 23-Jun-19 22:09 viur/core/modules/formmailer.py
+-rw-r--r--  2.0 unx    34072 b- defN 23-Jun-27 11:53 viur/core/modules/file.py
+-rw-r--r--  2.0 unx     1896 b- defN 23-Jun-27 11:53 viur/core/modules/formmailer.py
 -rw-r--r--  2.0 unx     2502 b- defN 23-Jun-22 21:31 viur/core/modules/moduleconf.py
 -rw-r--r--  2.0 unx      973 b- defN 23-Apr-18 16:00 viur/core/modules/page.py
--rw-r--r--  2.0 unx     4071 b- defN 23-Apr-18 16:00 viur/core/modules/script.py
+-rw-r--r--  2.0 unx     4114 b- defN 23-Jun-27 11:53 viur/core/modules/script.py
 -rw-r--r--  2.0 unx      556 b- defN 22-Dec-08 12:57 viur/core/modules/site.py
--rw-r--r--  2.0 unx    42063 b- defN 23-Jun-22 21:31 viur/core/modules/user.py
+-rw-r--r--  2.0 unx    44470 b- defN 23-Jun-27 11:53 viur/core/modules/user.py
 -rw-r--r--  2.0 unx      816 b- defN 23-Apr-18 16:00 viur/core/prototypes/__init__.py
--rw-r--r--  2.0 unx    22782 b- defN 23-Jun-22 21:31 viur/core/prototypes/list.py
--rw-r--r--  2.0 unx    10123 b- defN 23-Jun-22 21:31 viur/core/prototypes/singleton.py
--rw-r--r--  2.0 unx     2897 b- defN 23-Jun-22 21:31 viur/core/prototypes/skelmodule.py
--rw-r--r--  2.0 unx    34002 b- defN 23-Jun-22 21:31 viur/core/prototypes/tree.py
+-rw-r--r--  2.0 unx    22698 b- defN 23-Jun-27 11:53 viur/core/prototypes/list.py
+-rw-r--r--  2.0 unx    10083 b- defN 23-Jun-27 11:53 viur/core/prototypes/singleton.py
+-rw-r--r--  2.0 unx     2141 b- defN 23-Jun-27 11:53 viur/core/prototypes/skelmodule.py
+-rw-r--r--  2.0 unx    33959 b- defN 23-Jun-27 11:53 viur/core/prototypes/tree.py
 -rw-r--r--  2.0 unx      204 b- defN 23-Apr-18 16:00 viur/core/render/__init__.py
 -rw-r--r--  2.0 unx      169 b- defN 23-Jan-18 08:13 viur/core/render/html/__init__.py
--rw-r--r--  2.0 unx    19851 b- defN 23-Jun-23 16:42 viur/core/render/html/default.py
+-rw-r--r--  2.0 unx    20470 b- defN 23-Jun-27 11:52 viur/core/render/html/default.py
 -rw-r--r--  2.0 unx     3584 b- defN 22-Dec-08 12:57 viur/core/render/html/user.py
 -rw-r--r--  2.0 unx     1949 b- defN 23-Jan-18 08:13 viur/core/render/html/utils.py
 -rw-r--r--  2.0 unx      142 b- defN 23-Jan-18 08:13 viur/core/render/html/env/__init__.py
 -rw-r--r--  2.0 unx      942 b- defN 22-Dec-08 12:57 viur/core/render/html/env/date.py
 -rw-r--r--  2.0 unx     1353 b- defN 22-Dec-08 12:57 viur/core/render/html/env/debug.py
 -rw-r--r--  2.0 unx     1753 b- defN 22-Dec-08 12:57 viur/core/render/html/env/regex.py
 -rw-r--r--  2.0 unx     1161 b- defN 23-Apr-18 16:00 viur/core/render/html/env/session.py
 -rw-r--r--  2.0 unx      540 b- defN 22-Dec-08 12:57 viur/core/render/html/env/strings.py
 -rw-r--r--  2.0 unx      435 b- defN 23-Jan-18 08:13 viur/core/render/html/env/tests.py
 -rw-r--r--  2.0 unx    25465 b- defN 23-Apr-18 16:00 viur/core/render/html/env/viur.py
--rw-r--r--  2.0 unx     1027 b- defN 23-Jun-22 21:31 viur/core/render/json/__init__.py
--rw-r--r--  2.0 unx     8699 b- defN 23-Jun-23 15:57 viur/core/render/json/default.py
+-rw-r--r--  2.0 unx     1243 b- defN 23-Jun-27 11:53 viur/core/render/json/__init__.py
+-rw-r--r--  2.0 unx     9075 b- defN 23-Jun-27 11:53 viur/core/render/json/default.py
 -rw-r--r--  2.0 unx      963 b- defN 23-Jan-18 08:13 viur/core/render/json/user.py
--rw-r--r--  2.0 unx     5703 b- defN 23-Jun-22 21:31 viur/core/render/vi/__init__.py
+-rw-r--r--  2.0 unx     5703 b- defN 23-Jun-23 17:27 viur/core/render/vi/__init__.py
 -rw-r--r--  2.0 unx      899 b- defN 22-Dec-08 12:57 viur/core/render/vi/user.py
 -rw-r--r--  2.0 unx     1046 b- defN 23-Apr-18 16:00 viur/core/render/xml/__init__.py
 -rw-r--r--  2.0 unx     7319 b- defN 23-Apr-18 16:00 viur/core/render/xml/default.py
 -rw-r--r--  2.0 unx      957 b- defN 22-Dec-08 12:57 viur/core/render/xml/user.py
--rw-r--r--  2.0 unx     7644 b- defN 23-Jun-23 16:42 viur/core/template/error.html
+-rw-r--r--  2.0 unx     7642 b- defN 23-Jun-27 11:52 viur/core/template/error.html
 -rw-r--r--  2.0 unx     1083 b- defN 22-Dec-08 12:57 viur/core/template/vi_user_google_login.html
--rw-r--r--  2.0 unx     7651 b- defN 23-Jun-23 16:51 viur_core-3.4.4.dist-info/LICENSE
--rw-r--r--  2.0 unx     5023 b- defN 23-Jun-23 16:51 viur_core-3.4.4.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-23 16:51 viur_core-3.4.4.dist-info/WHEEL
--rw-r--r--  2.0 unx        5 b- defN 23-Jun-23 16:51 viur_core-3.4.4.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     7652 b- defN 23-Jun-23 16:51 viur_core-3.4.4.dist-info/RECORD
-92 files, 811459 bytes uncompressed, 235000 bytes compressed:  71.0%
+-rw-r--r--  2.0 unx     7651 b- defN 23-Jun-27 12:25 viur_core-3.5.0b1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     5713 b- defN 23-Jun-27 12:25 viur_core-3.5.0b1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-27 12:25 viur_core-3.5.0b1.dist-info/WHEEL
+-rw-r--r--  2.0 unx        5 b- defN 23-Jun-27 12:25 viur_core-3.5.0b1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     7667 b- defN 23-Jun-27 12:25 viur_core-3.5.0b1.dist-info/RECORD
+92 files, 920240 bytes uncompressed, 265661 bytes compressed:  71.1%
```

## zipnote {}

```diff
@@ -255,23 +255,23 @@
 
 Filename: viur/core/template/error.html
 Comment: 
 
 Filename: viur/core/template/vi_user_google_login.html
 Comment: 
 
-Filename: viur_core-3.4.4.dist-info/LICENSE
+Filename: viur_core-3.5.0b1.dist-info/LICENSE
 Comment: 
 
-Filename: viur_core-3.4.4.dist-info/METADATA
+Filename: viur_core-3.5.0b1.dist-info/METADATA
 Comment: 
 
-Filename: viur_core-3.4.4.dist-info/WHEEL
+Filename: viur_core-3.5.0b1.dist-info/WHEEL
 Comment: 
 
-Filename: viur_core-3.4.4.dist-info/top_level.txt
+Filename: viur_core-3.5.0b1.dist-info/top_level.txt
 Comment: 
 
-Filename: viur_core-3.4.4.dist-info/RECORD
+Filename: viur_core-3.5.0b1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## viur/requirements.txt

```diff
@@ -1,252 +1,41 @@
-viur-datastore==1.3.9 --hash=sha256:a06355c8002e11be863d96040babc590c9200f474c553be96b855ab38454e694
-
-google-auth==2.6.3 --hash=sha256:d65bb0e3701eaaa64fd2aa85e1325580524b0bddc6dc5db3ab89c481b6a20141
-
-# Dependencies for google-auth:
-cachetools==5.0.0 --hash=sha256:486471dfa8799eb7ec503a8059e263db000cdda20075ce5e48903087f79d5fd6
-six==1.16.0 --hash=sha256:8abb2f1d86890a2dfb989f9a77cfcfd3e47c2a354b01111771326f8aa26e0254
-pyasn1-modules==0.2.8 --hash=sha256:a50b808ffeb97cb3601dd25981f6b016cbb3d31fbf57a8b8a87428e6158d0c74
-rsa==4.8 --hash=sha256:5c6bd9dc7a543b7fe4304a631f8a8a3b674e2bbfc49c2ae96200cdbe55df6b17
-pyasn1==0.4.8 --hash=sha256:39c7e2ec30515947ff4e87fb6f456dfc6e84857d34be479c9d4a4ba4bf46aa5d
-google-cloud-datastore==2.5.1 --hash=sha256:d5fa56a2fb20eb4bb2006a6cf502974dda95e16a9938ec9e0c5c57f187e000c7
-
-# Dependencies for google-cloud-datastore
-proto-plus==1.20.6 --hash=sha256:449b4537e83f4776bd69051c4d776db8ffe3f9d0641f1e87b06c116eb94c90e9 \
-  --hash=sha256:c6c43c3fcfc360fdab46b47e2e9e805ff56e13169f9f2e45caf88b6b593215ab
-google-cloud-core==2.3.0 --hash=sha256:35900f614045a33d5208e1d50f0d7945df98ce088388ce7237e7a2db12d5656e \
-  --hash=sha256:fdaa629e6174b4177c2d56eb8ab1ddd87661064d0a3e9bb06b62e4d7e2344669
-google-api-core[grpc]==2.7.2 --hash=sha256:65480309a7437f739e4476da037af02a3ec8263f1d1f89f72bbdc8f54fe402d2 \
-  --hash=sha256:8fcbe52dc129fd83dca4e638a76f22b3a11579c493e643134e50e9870b233302
-google-api-core==2.7.2 --hash=sha256:65480309a7437f739e4476da037af02a3ec8263f1d1f89f72bbdc8f54fe402d2 \
-  --hash=sha256:8fcbe52dc129fd83dca4e638a76f22b3a11579c493e643134e50e9870b233302
-pytz==2022.1 --hash=sha256:1e760e2fe6a8163bc0b3d9a19c4f84342afa0a2affebfaa84b01b978a02ecaa7
-tzlocal==4.2 --hash=sha256:ee5842fa3a795f023514ac2d801c4a81d1743bbe642e3940143326b3a00addd7
-packaging==21.3 --hash=sha256:dd47c42927d89ab911e606518907cc2d3a1f38bbd026385970643f9c5b8ecfeb
-googleapis-common-protos==1.56.0 --hash=sha256:4007500795bcfc269d279f0f7d253ae18d6dc1ff5d5a73613ffe452038b1ec5f
-googleapis-common-protos[grpc]==1.56.0 --hash=sha256:4007500795bcfc269d279f0f7d253ae18d6dc1ff5d5a73613ffe452038b1ec5f
-protobuf==3.20.2 \
-  --hash=sha256:03d76b7bd42ac4a6e109742a4edf81ffe26ffd87c5993126d894fe48a120396a \
-  --hash=sha256:09e25909c4297d71d97612f04f41cea8fa8510096864f2835ad2f3b3df5a5559 \
-  --hash=sha256:18e34a10ae10d458b027d7638a599c964b030c1739ebd035a1dfc0e22baa3bfe \
-  --hash=sha256:291fb4307094bf5ccc29f424b42268640e00d5240bf0d9b86bf3079f7576474d \
-  --hash=sha256:2c0b040d0b5d5d207936ca2d02f00f765906622c07d3fa19c23a16a8ca71873f \
-  --hash=sha256:384164994727f274cc34b8abd41a9e7e0562801361ee77437099ff6dfedd024b \
-  --hash=sha256:3cb608e5a0eb61b8e00fe641d9f0282cd0eedb603be372f91f163cbfbca0ded0 \
-  --hash=sha256:5d9402bf27d11e37801d1743eada54372f986a372ec9679673bfcc5c60441151 \
-  --hash=sha256:712dca319eee507a1e7df3591e639a2b112a2f4a62d40fe7832a16fd19151750 \
-  --hash=sha256:7a5037af4e76c975b88c3becdf53922b5ffa3f2cddf657574a4920a3b33b80f3 \
-  --hash=sha256:8228e56a865c27163d5d1d1771d94b98194aa6917bcfb6ce139cbfa8e3c27334 \
-  --hash=sha256:84a1544252a933ef07bb0b5ef13afe7c36232a774affa673fc3636f7cee1db6c \
-  --hash=sha256:84fe5953b18a383fd4495d375fe16e1e55e0a3afe7b4f7b4d01a3a0649fcda9d \
-  --hash=sha256:9c673c8bfdf52f903081816b9e0e612186684f4eb4c17eeb729133022d6032e3 \
-  --hash=sha256:a9e5ae5a8e8985c67e8944c23035a0dff2c26b0f5070b2f55b217a1c33bbe8b1 \
-  --hash=sha256:b4fdb29c5a7406e3f7ef176b2a7079baa68b5b854f364c21abe327bbeec01cdb \
-  --hash=sha256:c184485e0dfba4dfd451c3bd348c2e685d6523543a0f91b9fd4ae90eb09e8422 \
-  --hash=sha256:c9cdf251c582c16fd6a9f5e95836c90828d51b0069ad22f463761d27c6c19019 \
-  --hash=sha256:e39cf61bb8582bda88cdfebc0db163b774e7e03364bbf9ce1ead13863e81e359 \
-  --hash=sha256:e8fbc522303e09036c752a0afcc5c0603e917222d8bedc02813fd73b4b4ed804 \
-  --hash=sha256:f34464ab1207114e73bba0794d1257c150a2b89b7a9faf504e00af7c9fd58978 \
-  --hash=sha256:f52dabc96ca99ebd2169dadbe018824ebda08a795c7684a0b7d203a290f3adb0
-
+-i https://pypi.org/simple
+attrs==23.1.0 ; python_version >= '3.7' --hash=sha256:1f28b4522cdc2fb4256ac1a020c78acf9cba2c6b461ccd2c126f3aa8e8335d04 --hash=sha256:6279836d581513a26f1bf235f9acd333bc9115683f14f7e8fae46c98fc50e015
+cachetools==5.3.1 ; python_version >= '3.7' --hash=sha256:95ef631eeaea14ba2e36f06437f36463aac3a096799e876ee55e5cdccb102590 --hash=sha256:dce83f2d9b4e1f732a8cd44af8e8fab2dbe46201467fc98b3ef8f269092bf62b
+certifi==2023.5.7 ; python_version >= '3.6' --hash=sha256:0f0d56dc5a6ad56fd4ba36484d6cc34451e1c6548c61daad8c320169f91eddc7 --hash=sha256:c6c2e98f5c7869efca1f8916fed228dd91539f9f1b444c314c06eef02980c716
+charset-normalizer==3.1.0 ; python_full_version >= '3.7.0' --hash=sha256:04afa6387e2b282cf78ff3dbce20f0cc071c12dc8f685bd40960cc68644cfea6 --hash=sha256:04eefcee095f58eaabe6dc3cc2262f3bcd776d2c67005880894f447b3f2cb9c1 --hash=sha256:0be65ccf618c1e7ac9b849c315cc2e8a8751d9cfdaa43027d4f6624bd587ab7e --hash=sha256:0c95f12b74681e9ae127728f7e5409cbbef9cd914d5896ef238cc779b8152373 --hash=sha256:0ca564606d2caafb0abe6d1b5311c2649e8071eb241b2d64e75a0d0065107e62 --hash=sha256:10c93628d7497c81686e8e5e557aafa78f230cd9e77dd0c40032ef90c18f2230 --hash=sha256:11d117e6c63e8f495412d37e7dc2e2fff09c34b2d09dbe2bee3c6229577818be --hash=sha256:11d3bcb7be35e7b1bba2c23beedac81ee893ac9871d0ba79effc7fc01167db6c --hash=sha256:12a2b561af122e3d94cdb97fe6fb2bb2b82cef0cdca131646fdb940a1eda04f0 --hash=sha256:12d1a39aa6b8c6f6248bb54550efcc1c38ce0d8096a146638fd4738e42284448 --hash=sha256:1435ae15108b1cb6fffbcea2af3d468683b7afed0169ad718451f8db5d1aff6f --hash=sha256:1c60b9c202d00052183c9be85e5eaf18a4ada0a47d188a83c8f5c5b23252f649 --hash=sha256:1e8fcdd8f672a1c4fc8d0bd3a2b576b152d2a349782d1eb0f6b8e52e9954731d --hash=sha256:20064ead0717cf9a73a6d1e779b23d149b53daf971169289ed2ed43a71e8d3b0 --hash=sha256:21fa558996782fc226b529fdd2ed7866c2c6ec91cee82735c98a197fae39f706 --hash=sha256:22908891a380d50738e1f978667536f6c6b526a2064156203d418f4856d6e86a --hash=sha256:3160a0fd9754aab7d47f95a6b63ab355388d890163eb03b2d2b87ab0a30cfa59 --hash=sha256:322102cdf1ab682ecc7d9b1c5eed4ec59657a65e1c146a0da342b78f4112db23 --hash=sha256:34e0a2f9c370eb95597aae63bf85eb5e96826d81e3dcf88b8886012906f509b5 --hash=sha256:3573d376454d956553c356df45bb824262c397c6e26ce43e8203c4c540ee0acb --hash=sha256:3747443b6a904001473370d7810aa19c3a180ccd52a7157aacc264a5ac79265e --hash=sha256:38e812a197bf8e71a59fe55b757a84c1f946d0ac114acafaafaf21667a7e169e --hash=sha256:3a06f32c9634a8705f4ca9946d667609f52cf130d5548881401f1eb2c39b1e2c --hash=sha256:3a5fc78f9e3f501a1614a98f7c54d3969f3ad9bba8ba3d9b438c3bc5d047dd28 --hash=sha256:3d9098b479e78c85080c98e1e35ff40b4a31d8953102bb0fd7d1b6f8a2111a3d --hash=sha256:3dc5b6a8ecfdc5748a7e429782598e4f17ef378e3e272eeb1340ea57c9109f41 --hash=sha256:4155b51ae05ed47199dc5b2a4e62abccb274cee6b01da5b895099b61b1982974 --hash=sha256:49919f8400b5e49e961f320c735388ee686a62327e773fa5b3ce6721f7e785ce --hash=sha256:53d0a3fa5f8af98a1e261de6a3943ca631c526635eb5817a87a59d9a57ebf48f --hash=sha256:5f008525e02908b20e04707a4f704cd286d94718f48bb33edddc7d7b584dddc1 --hash=sha256:628c985afb2c7d27a4800bfb609e03985aaecb42f955049957814e0491d4006d --hash=sha256:65ed923f84a6844de5fd29726b888e58c62820e0769b76565480e1fdc3d062f8 --hash=sha256:6734e606355834f13445b6adc38b53c0fd45f1a56a9ba06c2058f86893ae8017 --hash=sha256:6baf0baf0d5d265fa7944feb9f7451cc316bfe30e8df1a61b1bb08577c554f31 --hash=sha256:6f4f4668e1831850ebcc2fd0b1cd11721947b6dc7c00bf1c6bd3c929ae14f2c7 --hash=sha256:6f5c2e7bc8a4bf7c426599765b1bd33217ec84023033672c1e9a8b35eaeaaaf8 --hash=sha256:6f6c7a8a57e9405cad7485f4c9d3172ae486cfef1344b5ddd8e5239582d7355e --hash=sha256:7381c66e0561c5757ffe616af869b916c8b4e42b367ab29fedc98481d1e74e14 --hash=sha256:73dc03a6a7e30b7edc5b01b601e53e7fc924b04e1835e8e407c12c037e81adbd --hash=sha256:74db0052d985cf37fa111828d0dd230776ac99c740e1a758ad99094be4f1803d --hash=sha256:75f2568b4189dda1c567339b48cba4ac7384accb9c2a7ed655cd86b04055c795 --hash=sha256:78cacd03e79d009d95635e7d6ff12c21eb89b894c354bd2b2ed0b4763373693b --hash=sha256:80d1543d58bd3d6c271b66abf454d437a438dff01c3e62fdbcd68f2a11310d4b --hash=sha256:830d2948a5ec37c386d3170c483063798d7879037492540f10a475e3fd6f244b --hash=sha256:891cf9b48776b5c61c700b55a598621fdb7b1e301a550365571e9624f270c203 --hash=sha256:8f25e17ab3039b05f762b0a55ae0b3632b2e073d9c8fc88e89aca31a6198e88f --hash=sha256:9a3267620866c9d17b959a84dd0bd2d45719b817245e49371ead79ed4f710d19 --hash=sha256:a04f86f41a8916fe45ac5024ec477f41f886b3c435da2d4e3d2709b22ab02af1 --hash=sha256:aaf53a6cebad0eae578f062c7d462155eada9c172bd8c4d250b8c1d8eb7f916a --hash=sha256:abc1185d79f47c0a7aaf7e2412a0eb2c03b724581139193d2d82b3ad8cbb00ac --hash=sha256:ac0aa6cd53ab9a31d397f8303f92c42f534693528fafbdb997c82bae6e477ad9 --hash=sha256:ac3775e3311661d4adace3697a52ac0bab17edd166087d493b52d4f4f553f9f0 --hash=sha256:b06f0d3bf045158d2fb8837c5785fe9ff9b8c93358be64461a1089f5da983137 --hash=sha256:b116502087ce8a6b7a5f1814568ccbd0e9f6cfd99948aa59b0e241dc57cf739f --hash=sha256:b82fab78e0b1329e183a65260581de4375f619167478dddab510c6c6fb04d9b6 --hash=sha256:bd7163182133c0c7701b25e604cf1611c0d87712e56e88e7ee5d72deab3e76b5 --hash=sha256:c36bcbc0d5174a80d6cccf43a0ecaca44e81d25be4b7f90f0ed7bcfbb5a00909 --hash=sha256:c3af8e0f07399d3176b179f2e2634c3ce9c1301379a6b8c9c9aeecd481da494f --hash=sha256:c84132a54c750fda57729d1e2599bb598f5fa0344085dbde5003ba429a4798c0 --hash=sha256:cb7b2ab0188829593b9de646545175547a70d9a6e2b63bf2cd87a0a391599324 --hash=sha256:cca4def576f47a09a943666b8f829606bcb17e2bc2d5911a46c8f8da45f56755 --hash=sha256:cf6511efa4801b9b38dc5546d7547d5b5c6ef4b081c60b23e4d941d0eba9cbeb --hash=sha256:d16fd5252f883eb074ca55cb622bc0bee49b979ae4e8639fff6ca3ff44f9f854 --hash=sha256:d2686f91611f9e17f4548dbf050e75b079bbc2a82be565832bc8ea9047b61c8c --hash=sha256:d7fc3fca01da18fbabe4625d64bb612b533533ed10045a2ac3dd194bfa656b60 --hash=sha256:dd5653e67b149503c68c4018bf07e42eeed6b4e956b24c00ccdf93ac79cdff84 --hash=sha256:de5695a6f1d8340b12a5d6d4484290ee74d61e467c39ff03b39e30df62cf83a0 --hash=sha256:e0ac8959c929593fee38da1c2b64ee9778733cdf03c482c9ff1d508b6b593b2b --hash=sha256:e1b25e3ad6c909f398df8921780d6a3d120d8c09466720226fc621605b6f92b1 --hash=sha256:e633940f28c1e913615fd624fcdd72fdba807bf53ea6925d6a588e84e1151531 --hash=sha256:e89df2958e5159b811af9ff0f92614dabf4ff617c03a4c1c6ff53bf1c399e0e1 --hash=sha256:ea9f9c6034ea2d93d9147818f17c2a0860d41b71c38b9ce4d55f21b6f9165a11 --hash=sha256:f645caaf0008bacf349875a974220f1f1da349c5dbe7c4ec93048cdc785a3326 --hash=sha256:f8303414c7b03f794347ad062c0516cee0e15f7a612abd0ce1e25caf6ceb47df --hash=sha256:fca62a8301b605b954ad2e9c3666f9d97f63872aa4efcae5492baca2056b74ab
+google-api-core[grpc]==2.11.1 ; python_version >= '3.7' --hash=sha256:25d29e05a0058ed5f19c61c0a78b1b53adea4d9364b464d014fbda941f6d1c9a --hash=sha256:d92a5a92dc36dd4f4b9ee4e55528a90e432b059f93aee6ad857f9de8cc7ae94a
+google-auth==2.20.0 --hash=sha256:030af34138909ccde0fbce611afc178f1d65d32fbff281f25738b1fe1c6f3eaa --hash=sha256:23b7b0950fcda519bfb6692bf0d5289d2ea49fc143717cc7188458ec620e63fa
+google-cloud-appengine-logging==1.3.0 ; python_version >= '3.7' --hash=sha256:97272ed554c9077d666e045b6686b46cb67e9b072aab76726c5404d6098b52d2 --hash=sha256:d52f14e1e9a993797a086eff3d4772dea7908390c6ad612d26281341f17c9a49
+google-cloud-audit-log==0.2.5 ; python_version >= '3.7' --hash=sha256:18b94d4579002a450b7902cd2e8b8fdcb1ea2dd4df3b41f8f82be6d9f7fcd746 --hash=sha256:86e2faba3383adc8fd04a5bd7fd4f960b3e4aedaa7ed950f2f891ce16902eb6b
+google-cloud-core==2.3.2 ; python_version >= '3.7' --hash=sha256:8417acf6466be2fa85123441696c4badda48db314c607cf1e5d543fa8bdc22fe --hash=sha256:b9529ee7047fd8d4bf4a2182de619154240df17fbe60ead399078c1ae152af9a
+google-cloud-datastore==2.16.0 --hash=sha256:087a184eee4c1c4a68be4b165b98eda8de71028d536de53790466a0a1b8df8df --hash=sha256:ef49fd8e03af4793985813ca491e74135493ffad2e1b395bb226170a424da35f
+google-cloud-iam==2.12.0 --hash=sha256:511a8e2014f7bc12f7a0018b76d7d94d5cdc6bdab262abba9e4bb85084c802d1 --hash=sha256:95f4f89605b89f793916cd8ec2783c2681c6603c23a0a4f368a8447f7e4ef950
+google-cloud-logging==3.5.0 --hash=sha256:def71f6a7bb6652ce8fee18f0cad8c32157ac606fe1512802254a471bcdfe5e8 --hash=sha256:f11544a21ea3556f70ebac7bc338ffa8a197913834ecdd8853d176b870823aaa
+google-cloud-storage==2.9.0 --hash=sha256:83a90447f23d5edd045e0037982c270302e3aeb45fc1288d2c2ca713d27bad94 --hash=sha256:9b6ae7b509fc294bdacb84d0f3ea8e20e2c54a8b4bbe39c5707635fec214eff3
+google-cloud-tasks==2.13.1 --hash=sha256:616f2c32945cf68e812375a32f8a0f1d9cc39f4a39de03942593af6d13af7c20 --hash=sha256:99b845055c7a1b27b73349429f2d6f6a0eb9f409b4cdeec89df99e16bd197833
+google-crc32c==1.5.0 ; python_version >= '3.7' --hash=sha256:024894d9d3cfbc5943f8f230e23950cd4906b2fe004c72e29b209420a1e6b05a --hash=sha256:02c65b9817512edc6a4ae7c7e987fea799d2e0ee40c53ec573a692bee24de876 --hash=sha256:02ebb8bf46c13e36998aeaad1de9b48f4caf545e91d14041270d9dca767b780c --hash=sha256:07eb3c611ce363c51a933bf6bd7f8e3878a51d124acfc89452a75120bc436289 --hash=sha256:1034d91442ead5a95b5aaef90dbfaca8633b0247d1e41621d1e9f9db88c36298 --hash=sha256:116a7c3c616dd14a3de8c64a965828b197e5f2d121fedd2f8c5585c547e87b02 --hash=sha256:19e0a019d2c4dcc5e598cd4a4bc7b008546b0358bd322537c74ad47a5386884f --hash=sha256:1c7abdac90433b09bad6c43a43af253e688c9cfc1c86d332aed13f9a7c7f65e2 --hash=sha256:1e986b206dae4476f41bcec1faa057851f3889503a70e1bdb2378d406223994a --hash=sha256:272d3892a1e1a2dbc39cc5cde96834c236d5327e2122d3aaa19f6614531bb6eb --hash=sha256:278d2ed7c16cfc075c91378c4f47924c0625f5fc84b2d50d921b18b7975bd210 --hash=sha256:2ad40e31093a4af319dadf503b2467ccdc8f67c72e4bcba97f8c10cb078207b5 --hash=sha256:2e920d506ec85eb4ba50cd4228c2bec05642894d4c73c59b3a2fe20346bd00ee --hash=sha256:3359fc442a743e870f4588fcf5dcbc1bf929df1fad8fb9905cd94e5edb02e84c --hash=sha256:37933ec6e693e51a5b07505bd05de57eee12f3e8c32b07da7e73669398e6630a --hash=sha256:398af5e3ba9cf768787eef45c803ff9614cc3e22a5b2f7d7ae116df8b11e3314 --hash=sha256:3b747a674c20a67343cb61d43fdd9207ce5da6a99f629c6e2541aa0e89215bcd --hash=sha256:461665ff58895f508e2866824a47bdee72497b091c730071f2b7575d5762ab65 --hash=sha256:4c6fdd4fccbec90cc8a01fc00773fcd5fa28db683c116ee3cb35cd5da9ef6c37 --hash=sha256:5829b792bf5822fd0a6f6eb34c5f81dd074f01d570ed7f36aa101d6fc7a0a6e4 --hash=sha256:596d1f98fc70232fcb6590c439f43b350cb762fb5d61ce7b0e9db4539654cc13 --hash=sha256:5ae44e10a8e3407dbe138984f21e536583f2bba1be9491239f942c2464ac0894 --hash=sha256:635f5d4dd18758a1fbd1049a8e8d2fee4ffed124462d837d1a02a0e009c3ab31 --hash=sha256:64e52e2b3970bd891309c113b54cf0e4384762c934d5ae56e283f9a0afcd953e --hash=sha256:66741ef4ee08ea0b2cc3c86916ab66b6aef03768525627fd6a1b34968b4e3709 --hash=sha256:67b741654b851abafb7bc625b6d1cdd520a379074e64b6a128e3b688c3c04740 --hash=sha256:6ac08d24c1f16bd2bf5eca8eaf8304812f44af5cfe5062006ec676e7e1d50afc --hash=sha256:6f998db4e71b645350b9ac28a2167e6632c239963ca9da411523bb439c5c514d --hash=sha256:72218785ce41b9cfd2fc1d6a017dc1ff7acfc4c17d01053265c41a2c0cc39b8c --hash=sha256:74dea7751d98034887dbd821b7aae3e1d36eda111d6ca36c206c44478035709c --hash=sha256:759ce4851a4bb15ecabae28f4d2e18983c244eddd767f560165563bf9aefbc8d --hash=sha256:77e2fd3057c9d78e225fa0a2160f96b64a824de17840351b26825b0848022906 --hash=sha256:7c074fece789b5034b9b1404a1f8208fc2d4c6ce9decdd16e8220c5a793e6f61 --hash=sha256:7c42c70cd1d362284289c6273adda4c6af8039a8ae12dc451dcd61cdabb8ab57 --hash=sha256:7f57f14606cd1dd0f0de396e1e53824c371e9544a822648cd76c034d209b559c --hash=sha256:83c681c526a3439b5cf94f7420471705bbf96262f49a6fe546a6db5f687a3d4a --hash=sha256:8485b340a6a9e76c62a7dce3c98e5f102c9219f4cfbf896a00cf48caf078d438 --hash=sha256:84e6e8cd997930fc66d5bb4fde61e2b62ba19d62b7abd7a69920406f9ecca946 --hash=sha256:89284716bc6a5a415d4eaa11b1726d2d60a0cd12aadf5439828353662ede9dd7 --hash=sha256:8b87e1a59c38f275c0e3676fc2ab6d59eccecfd460be267ac360cc31f7bcde96 --hash=sha256:8f24ed114432de109aa9fd317278518a5af2d31ac2ea6b952b2f7782b43da091 --hash=sha256:98cb4d057f285bd80d8778ebc4fde6b4d509ac3f331758fb1528b733215443ae --hash=sha256:998679bf62b7fb599d2878aa3ed06b9ce688b8974893e7223c60db155f26bd8d --hash=sha256:9ba053c5f50430a3fcfd36f75aff9caeba0440b2d076afdb79a318d6ca245f88 --hash=sha256:9c99616c853bb585301df6de07ca2cadad344fd1ada6d62bb30aec05219c45d2 --hash=sha256:a1fd716e7a01f8e717490fbe2e431d2905ab8aa598b9b12f8d10abebb36b04dd --hash=sha256:a2355cba1f4ad8b6988a4ca3feed5bff33f6af2d7f134852cf279c2aebfde541 --hash=sha256:b1f8133c9a275df5613a451e73f36c2aea4fe13c5c8997e22cf355ebd7bd0728 --hash=sha256:b8667b48e7a7ef66afba2c81e1094ef526388d35b873966d8a9a447974ed9178 --hash=sha256:ba1eb1843304b1e5537e1fca632fa894d6f6deca8d6389636ee5b4797affb968 --hash=sha256:be82c3c8cfb15b30f36768797a640e800513793d6ae1724aaaafe5bf86f8f346 --hash=sha256:c02ec1c5856179f171e032a31d6f8bf84e5a75c45c33b2e20a3de353b266ebd8 --hash=sha256:c672d99a345849301784604bfeaeba4db0c7aae50b95be04dd651fd2a7310b93 --hash=sha256:c6c777a480337ac14f38564ac88ae82d4cd238bf293f0a22295b66eb89ffced7 --hash=sha256:cae0274952c079886567f3f4f685bcaf5708f0a23a5f5216fdab71f81a6c0273 --hash=sha256:cd67cf24a553339d5062eff51013780a00d6f97a39ca062781d06b3a73b15462 --hash=sha256:d3515f198eaa2f0ed49f8819d5732d70698c3fa37384146079b3799b97667a94 --hash=sha256:d5280312b9af0976231f9e317c20e4a61cd2f9629b7bfea6a693d1878a264ebd --hash=sha256:de06adc872bcd8c2a4e0dc51250e9e65ef2ca91be023b9d13ebd67c2ba552e1e --hash=sha256:e1674e4307fa3024fc897ca774e9c7562c957af85df55efe2988ed9056dc4e57 --hash=sha256:e2096eddb4e7c7bdae4bd69ad364e55e07b8316653234a56552d9c988bd2d61b --hash=sha256:e560628513ed34759456a416bf86b54b2476c59144a9138165c9a1575801d0d9 --hash=sha256:edfedb64740750e1a3b16152620220f51d58ff1b4abceb339ca92e934775c27a --hash=sha256:f13cae8cc389a440def0c8c52057f37359014ccbc9dc1f0827936bcd367c6100 --hash=sha256:f314013e7dcd5cf45ab1945d92e713eec788166262ae8deb2cfacd53def27325 --hash=sha256:f583edb943cf2e09c60441b910d6a20b4d9d626c75a36c8fcac01a6c96c01183 --hash=sha256:fd8536e902db7e365f49e7d9029283403974ccf29b13fc7028b97e2295b33556 --hash=sha256:fe70e325aa68fa4b5edf7d1a4b6f691eb04bbccac0ace68e34820d283b5f80d4
+google-resumable-media==2.5.0 --hash=sha256:218931e8e2b2a73a58eb354a288e03a0fd5fb1c4583261ac6e4c078666468c93 --hash=sha256:da1bd943e2e114a56d85d6848497ebf9be6a14d3db23e9fc57581e7c3e8170ec
+googleapis-common-protos==1.59.1 ; python_version >= '3.7' --hash=sha256:0cbedb6fb68f1c07e18eb4c48256320777707e7d0c55063ae56c15db3224a61e --hash=sha256:b35d530fe825fb4227857bc47ad84c33c809ac96f312e13182bdeaa2abe1178a
+grpc-google-iam-v1==0.12.6 ; python_version >= '3.7' --hash=sha256:2bc4b8fdf22115a65d751c9317329322602c39b7c86a289c9b72d228d960ef5f --hash=sha256:5c10f3d8dc2d88678ab1a9b0cb5482735c5efee71e6c0cd59f872eef22913f5c
+grpcio==1.56.0 --hash=sha256:008767c0aed4899e657b50f2e0beacbabccab51359eba547f860e7c55f2be6ba --hash=sha256:03a80451530fd3b8b155e0c4480434f6be669daf7ecba56f73ef98f94222ee01 --hash=sha256:0409de787ebbf08c9d2bca2bcc7762c1efe72eada164af78b50567a8dfc7253c --hash=sha256:14e70b4dda3183abea94c72d41d5930c333b21f8561c1904a372d80370592ef3 --hash=sha256:17f47aeb9be0da5337f9ff33ebb8795899021e6c0741ee68bd69774a7804ca86 --hash=sha256:187b8f71bad7d41eea15e0c9812aaa2b87adfb343895fffb704fb040ca731863 --hash=sha256:1eadd6de258901929223f422ffed7f8b310c0323324caf59227f9899ea1b1674 --hash=sha256:38fdf5bd0a1c754ce6bf9311a3c2c7ebe56e88b8763593316b69e0e9a56af1de --hash=sha256:4241a1c2c76e748023c834995cd916570e7180ee478969c2d79a60ce007bc837 --hash=sha256:437af5a7673bca89c4bc0a993382200592d104dd7bf55eddcd141cef91f40bab --hash=sha256:43c50d810cc26349b093bf2cfe86756ab3e9aba3e7e681d360930c1268e1399a --hash=sha256:4c08ee21b3d10315b8dc26f6c13917b20ed574cdbed2d2d80c53d5508fdcc0f2 --hash=sha256:4f84a6fd4482e5fe73b297d4874b62a535bc75dc6aec8e9fe0dc88106cd40397 --hash=sha256:4feee75565d1b5ab09cb3a5da672b84ca7f6dd80ee07a50f5537207a9af543a4 --hash=sha256:50f4daa698835accbbcc60e61e0bc29636c0156ddcafb3891c987e533a0031ba --hash=sha256:59c4e606993a47146fbeaf304b9e78c447f5b9ee5641cae013028c4cca784617 --hash=sha256:5d2fc471668a7222e213f86ef76933b18cdda6a51ea1322034478df8c6519959 --hash=sha256:64bd3abcf9fb4a9fa4ede8d0d34686314a7075f62a1502217b227991d9ca4245 --hash=sha256:66f0369d27f4c105cd21059d635860bb2ea81bd593061c45fb64875103f40e4a --hash=sha256:6b5ce42a5ebe3e04796246ba50357f1813c44a6efe17a37f8dc7a5c470377312 --hash=sha256:72836b5a1d4f508ffbcfe35033d027859cc737972f9dddbe33fb75d687421e2e --hash=sha256:76b6e6e1ee9bda32e6e933efd61c512e9a9f377d7c580977f090d1a9c78cca44 --hash=sha256:79d4c5911d12a7aa671e5eb40cbb50a830396525014d2d6f254ea2ba180ce637 --hash=sha256:7beb84ebd0a3f732625124b73969d12b7350c5d9d64ddf81ae739bbc63d5b1ed --hash=sha256:8219f17baf069fe8e42bd8ca0b312b875595e43a70cabf397be4fda488e2f27d --hash=sha256:83ec714bbbe9b9502177c842417fde39f7a267031e01fa3cd83f1ca49688f537 --hash=sha256:8674fdbd28266d8efbcddacf4ec3643f76fe6376f73283fd63a8374c14b0ef7c --hash=sha256:881575f240eb5db72ddca4dc5602898c29bc082e0d94599bf20588fb7d1ee6a0 --hash=sha256:8b3b2c7b5feef90bc9a5fa1c7f97637e55ec3e76460c6d16c3013952ee479cd9 --hash=sha256:991224fd485e088d3cb5e34366053691a4848a6b7112b8f5625a411305c26691 --hash=sha256:aa08affbf672d051cd3da62303901aeb7042a2c188c03b2c2a2d346fc5e81c14 --hash=sha256:b1f4b6f25a87d80b28dd6d02e87d63fe1577fe6d04a60a17454e3f8077a38279 --hash=sha256:b4638a796778329cc8e142e4f57c705adb286b3ba64e00b0fa91eeb919611be8 --hash=sha256:bd55f743e654fb050c665968d7ec2c33f03578a4bbb163cfce38024775ff54cc --hash=sha256:c0bc9dda550785d23f4f025be614b7faa8d0293e10811f0f8536cf50435b7a30 --hash=sha256:c2148170e01d464d41011a878088444c13413264418b557f0bdcd1bf1b674a0e --hash=sha256:c243b158dd7585021d16c50498c4b2ec0a64a6119967440c5ff2d8c89e72330e --hash=sha256:c63bc5ac6c7e646c296fed9139097ae0f0e63f36f0864d7ce431cce61fe0118a --hash=sha256:c6f36621aabecbaff3e70c4d1d924c76c8e6a7ffec60c331893640a4af0a8037 --hash=sha256:d596408bab632ec7b947761e83ce6b3e7632e26b76d64c239ba66b554b7ee286 --hash=sha256:defdd14b518e6e468466f799aaa69db0355bca8d3a5ea75fb912d28ba6f8af31 --hash=sha256:e2db108b4c8e29c145e95b0226973a66d73ae3e3e7fae00329294af4e27f1c42 --hash=sha256:f92a99ab0c7772fb6859bf2e4f44ad30088d18f7c67b83205297bfb229e0d2cf --hash=sha256:fb34ace11419f1ae321c36ccaa18d81cd3f20728cd191250be42949d6845bb2d --hash=sha256:fdc3a895791af4addbb826808d4c9c35917c59bb5c430d729f44224e51c92d61
+grpcio-status==1.56.0 --hash=sha256:9eca0b2dcda0782d3702df225918efd6d820f75f93cd5c51c7fb6a4ffbfea12c --hash=sha256:e5f101c96686e9d4e94a114567960fdb00052aa3c818b029745e3db37dc9c613
+gunicorn==20.1.0 --hash=sha256:9dcc4547dbb1cb284accfb15ab5667a0e5d1881cc443e0677b4882a4067a807e --hash=sha256:e0a968b5ba15f8a328fdfd7ab1fcb5af4470c28aaf7e55df02a99bc13138e6e8
+idna==3.4 ; python_version >= '3.5' --hash=sha256:814f528e8dead7d329833b91c5faa87d60bf71824cd12a7530b5526063d02cb4 --hash=sha256:90b77e79eaa3eba6de819a0c442c0b4ceefc341a7a2ab77d7562bf49f425c5c2
+jinja2==3.1.2 --hash=sha256:31351a702a408a9e7595a8fc6150fc3f43bb6bf7e319770cbc0db9df9437e852 --hash=sha256:6088930bfe239f0e6710546ab9c19c9ef35e29792895fed6e6e31a023a182a61
+jsonschema==4.17.3 --hash=sha256:0f864437ab8b6076ba6707453ef8f98a6a0d512a80e93f8abdb676f737ecb60d --hash=sha256:a870ad254da1a8ca84b6a2905cac29d265f805acc57af304784962a2aa6508f6
+markupsafe==2.1.3 ; python_version >= '3.7' --hash=sha256:05fb21170423db021895e1ea1e1f3ab3adb85d1c2333cbc2310f2a26bc77272e --hash=sha256:0a4e4a1aff6c7ac4cd55792abf96c915634c2b97e3cc1c7129578aa68ebd754e --hash=sha256:10bbfe99883db80bdbaff2dcf681dfc6533a614f700da1287707e8a5d78a8431 --hash=sha256:134da1eca9ec0ae528110ccc9e48041e0828d79f24121a1a146161103c76e686 --hash=sha256:1577735524cdad32f9f694208aa75e422adba74f1baee7551620e43a3141f559 --hash=sha256:1b40069d487e7edb2676d3fbdb2b0829ffa2cd63a2ec26c4938b2d34391b4ecc --hash=sha256:282c2cb35b5b673bbcadb33a585408104df04f14b2d9b01d4c345a3b92861c2c --hash=sha256:2c1b19b3aaacc6e57b7e25710ff571c24d6c3613a45e905b1fde04d691b98ee0 --hash=sha256:2ef12179d3a291be237280175b542c07a36e7f60718296278d8593d21ca937d4 --hash=sha256:338ae27d6b8745585f87218a3f23f1512dbf52c26c28e322dbe54bcede54ccb9 --hash=sha256:3c0fae6c3be832a0a0473ac912810b2877c8cb9d76ca48de1ed31e1c68386575 --hash=sha256:3fd4abcb888d15a94f32b75d8fd18ee162ca0c064f35b11134be77050296d6ba --hash=sha256:42de32b22b6b804f42c5d98be4f7e5e977ecdd9ee9b660fda1a3edf03b11792d --hash=sha256:504b320cd4b7eff6f968eddf81127112db685e81f7e36e75f9f84f0df46041c3 --hash=sha256:525808b8019e36eb524b8c68acdd63a37e75714eac50e988180b169d64480a00 --hash=sha256:56d9f2ecac662ca1611d183feb03a3fa4406469dafe241673d521dd5ae92a155 --hash=sha256:5bbe06f8eeafd38e5d0a4894ffec89378b6c6a625ff57e3028921f8ff59318ac --hash=sha256:65c1a9bcdadc6c28eecee2c119465aebff8f7a584dd719facdd9e825ec61ab52 --hash=sha256:68e78619a61ecf91e76aa3e6e8e33fc4894a2bebe93410754bd28fce0a8a4f9f --hash=sha256:69c0f17e9f5a7afdf2cc9fb2d1ce6aabdb3bafb7f38017c0b77862bcec2bbad8 --hash=sha256:6b2b56950d93e41f33b4223ead100ea0fe11f8e6ee5f641eb753ce4b77a7042b --hash=sha256:787003c0ddb00500e49a10f2844fac87aa6ce977b90b0feaaf9de23c22508b24 --hash=sha256:7ef3cb2ebbf91e330e3bb937efada0edd9003683db6b57bb108c4001f37a02ea --hash=sha256:8023faf4e01efadfa183e863fefde0046de576c6f14659e8782065bcece22198 --hash=sha256:8758846a7e80910096950b67071243da3e5a20ed2546e6392603c096778d48e0 --hash=sha256:8afafd99945ead6e075b973fefa56379c5b5c53fd8937dad92c662da5d8fd5ee --hash=sha256:8c41976a29d078bb235fea9b2ecd3da465df42a562910f9022f1a03107bd02be --hash=sha256:8e254ae696c88d98da6555f5ace2279cf7cd5b3f52be2b5cf97feafe883b58d2 --hash=sha256:9402b03f1a1b4dc4c19845e5c749e3ab82d5078d16a2a4c2cd2df62d57bb0707 --hash=sha256:962f82a3086483f5e5f64dbad880d31038b698494799b097bc59c2edf392fce6 --hash=sha256:9dcdfd0eaf283af041973bff14a2e143b8bd64e069f4c383416ecd79a81aab58 --hash=sha256:aa7bd130efab1c280bed0f45501b7c8795f9fdbeb02e965371bbef3523627779 --hash=sha256:ab4a0df41e7c16a1392727727e7998a467472d0ad65f3ad5e6e765015df08636 --hash=sha256:ad9e82fb8f09ade1c3e1b996a6337afac2b8b9e365f926f5a61aacc71adc5b3c --hash=sha256:af598ed32d6ae86f1b747b82783958b1a4ab8f617b06fe68795c7f026abbdcad --hash=sha256:b076b6226fb84157e3f7c971a47ff3a679d837cf338547532ab866c57930dbee --hash=sha256:b7ff0f54cb4ff66dd38bebd335a38e2c22c41a8ee45aa608efc890ac3e3931bc --hash=sha256:bfce63a9e7834b12b87c64d6b155fdd9b3b96191b6bd334bf37db7ff1fe457f2 --hash=sha256:c011a4149cfbcf9f03994ec2edffcb8b1dc2d2aede7ca243746df97a5d41ce48 --hash=sha256:c9c804664ebe8f83a211cace637506669e7890fec1b4195b505c214e50dd4eb7 --hash=sha256:ca379055a47383d02a5400cb0d110cef0a776fc644cda797db0c5696cfd7e18e --hash=sha256:cb0932dc158471523c9637e807d9bfb93e06a95cbf010f1a38b98623b929ef2b --hash=sha256:cd0f502fe016460680cd20aaa5a76d241d6f35a1c3350c474bac1273803893fa --hash=sha256:ceb01949af7121f9fc39f7d27f91be8546f3fb112c608bc4029aef0bab86a2a5 --hash=sha256:d080e0a5eb2529460b30190fcfcc4199bd7f827663f858a226a81bc27beaa97e --hash=sha256:dd15ff04ffd7e05ffcb7fe79f1b98041b8ea30ae9234aed2a9168b5797c3effb --hash=sha256:df0be2b576a7abbf737b1575f048c23fb1d769f267ec4358296f31c2479db8f9 --hash=sha256:e09031c87a1e51556fdcb46e5bd4f59dfb743061cf93c4d6831bf894f125eb57 --hash=sha256:e4dd52d80b8c83fdce44e12478ad2e85c64ea965e75d66dbeafb0a3e77308fcc --hash=sha256:fec21693218efe39aa7f8599346e90c705afa52c5b31ae019b2e57e8f6542bb2
+pillow==9.5.0 --hash=sha256:07999f5834bdc404c442146942a2ecadd1cb6292f5229f4ed3b31e0a108746b1 --hash=sha256:0852ddb76d85f127c135b6dd1f0bb88dbb9ee990d2cd9aa9e28526c93e794fba --hash=sha256:1781a624c229cb35a2ac31cc4a77e28cafc8900733a864870c49bfeedacd106a --hash=sha256:1e7723bd90ef94eda669a3c2c19d549874dd5badaeefabefd26053304abe5799 --hash=sha256:229e2c79c00e85989a34b5981a2b67aa079fd08c903f0aaead522a1d68d79e51 --hash=sha256:22baf0c3cf0c7f26e82d6e1adf118027afb325e703922c8dfc1d5d0156bb2eeb --hash=sha256:252a03f1bdddce077eff2354c3861bf437c892fb1832f75ce813ee94347aa9b5 --hash=sha256:2dfaaf10b6172697b9bceb9a3bd7b951819d1ca339a5ef294d1f1ac6d7f63270 --hash=sha256:322724c0032af6692456cd6ed554bb85f8149214d97398bb80613b04e33769f6 --hash=sha256:35f6e77122a0c0762268216315bf239cf52b88865bba522999dc38f1c52b9b47 --hash=sha256:375f6e5ee9620a271acb6820b3d1e94ffa8e741c0601db4c0c4d3cb0a9c224bf --hash=sha256:3ded42b9ad70e5f1754fb7c2e2d6465a9c842e41d178f262e08b8c85ed8a1d8e --hash=sha256:432b975c009cf649420615388561c0ce7cc31ce9b2e374db659ee4f7d57a1f8b --hash=sha256:482877592e927fd263028c105b36272398e3e1be3269efda09f6ba21fd83ec66 --hash=sha256:489f8389261e5ed43ac8ff7b453162af39c3e8abd730af8363587ba64bb2e865 --hash=sha256:54f7102ad31a3de5666827526e248c3530b3a33539dbda27c6843d19d72644ec --hash=sha256:560737e70cb9c6255d6dcba3de6578a9e2ec4b573659943a5e7e4af13f298f5c --hash=sha256:5671583eab84af046a397d6d0ba25343c00cd50bce03787948e0fff01d4fd9b1 --hash=sha256:5ba1b81ee69573fe7124881762bb4cd2e4b6ed9dd28c9c60a632902fe8db8b38 --hash=sha256:5d4ebf8e1db4441a55c509c4baa7a0587a0210f7cd25fcfe74dbbce7a4bd1906 --hash=sha256:60037a8db8750e474af7ffc9faa9b5859e6c6d0a50e55c45576bf28be7419705 --hash=sha256:608488bdcbdb4ba7837461442b90ea6f3079397ddc968c31265c1e056964f1ef --hash=sha256:6608ff3bf781eee0cd14d0901a2b9cc3d3834516532e3bd673a0a204dc8615fc --hash=sha256:662da1f3f89a302cc22faa9f14a262c2e3951f9dbc9617609a47521c69dd9f8f --hash=sha256:7002d0797a3e4193c7cdee3198d7c14f92c0836d6b4a3f3046a64bd1ce8df2bf --hash=sha256:763782b2e03e45e2c77d7779875f4432e25121ef002a41829d8868700d119392 --hash=sha256:77165c4a5e7d5a284f10a6efaa39a0ae8ba839da344f20b111d62cc932fa4e5d --hash=sha256:7c9af5a3b406a50e313467e3565fc99929717f780164fe6fbb7704edba0cebbe --hash=sha256:7ec6f6ce99dab90b52da21cf0dc519e21095e332ff3b399a357c187b1a5eee32 --hash=sha256:833b86a98e0ede388fa29363159c9b1a294b0905b5128baf01db683672f230f5 --hash=sha256:84a6f19ce086c1bf894644b43cd129702f781ba5751ca8572f08aa40ef0ab7b7 --hash=sha256:8507eda3cd0608a1f94f58c64817e83ec12fa93a9436938b191b80d9e4c0fc44 --hash=sha256:85ec677246533e27770b0de5cf0f9d6e4ec0c212a1f89dfc941b64b21226009d --hash=sha256:8aca1152d93dcc27dc55395604dcfc55bed5f25ef4c98716a928bacba90d33a3 --hash=sha256:8d935f924bbab8f0a9a28404422da8af4904e36d5c33fc6f677e4c4485515625 --hash=sha256:8f36397bf3f7d7c6a3abdea815ecf6fd14e7fcd4418ab24bae01008d8d8ca15e --hash=sha256:91ec6fe47b5eb5a9968c79ad9ed78c342b1f97a091677ba0e012701add857829 --hash=sha256:965e4a05ef364e7b973dd17fc765f42233415974d773e82144c9bbaaaea5d089 --hash=sha256:96e88745a55b88a7c64fa49bceff363a1a27d9a64e04019c2281049444a571e3 --hash=sha256:99eb6cafb6ba90e436684e08dad8be1637efb71c4f2180ee6b8f940739406e78 --hash=sha256:9adf58f5d64e474bed00d69bcd86ec4bcaa4123bfa70a65ce72e424bfb88ed96 --hash=sha256:9b1af95c3a967bf1da94f253e56b6286b50af23392a886720f563c547e48e964 --hash=sha256:a0aa9417994d91301056f3d0038af1199eb7adc86e646a36b9e050b06f526597 --hash=sha256:a0f9bb6c80e6efcde93ffc51256d5cfb2155ff8f78292f074f60f9e70b942d99 --hash=sha256:a127ae76092974abfbfa38ca2d12cbeddcdeac0fb71f9627cc1135bedaf9d51a --hash=sha256:aaf305d6d40bd9632198c766fb64f0c1a83ca5b667f16c1e79e1661ab5060140 --hash=sha256:aca1c196f407ec7cf04dcbb15d19a43c507a81f7ffc45b690899d6a76ac9fda7 --hash=sha256:ace6ca218308447b9077c14ea4ef381ba0b67ee78d64046b3f19cf4e1139ad16 --hash=sha256:b416f03d37d27290cb93597335a2f85ed446731200705b22bb927405320de903 --hash=sha256:bf548479d336726d7a0eceb6e767e179fbde37833ae42794602631a070d630f1 --hash=sha256:c1170d6b195555644f0616fd6ed929dfcf6333b8675fcca044ae5ab110ded296 --hash=sha256:c380b27d041209b849ed246b111b7c166ba36d7933ec6e41175fd15ab9eb1572 --hash=sha256:c446d2245ba29820d405315083d55299a796695d747efceb5717a8b450324115 --hash=sha256:c830a02caeb789633863b466b9de10c015bded434deb3ec87c768e53752ad22a --hash=sha256:cb841572862f629b99725ebaec3287fc6d275be9b14443ea746c1dd325053cbd --hash=sha256:cfa4561277f677ecf651e2b22dc43e8f5368b74a25a8f7d1d4a3a243e573f2d4 --hash=sha256:cfcc2c53c06f2ccb8976fb5c71d448bdd0a07d26d8e07e321c103416444c7ad1 --hash=sha256:d3c6b54e304c60c4181da1c9dadf83e4a54fd266a99c70ba646a9baa626819eb --hash=sha256:d3d403753c9d5adc04d4694d35cf0391f0f3d57c8e0030aac09d7678fa8030aa --hash=sha256:d9c206c29b46cfd343ea7cdfe1232443072bbb270d6a46f59c259460db76779a --hash=sha256:e49eb4e95ff6fd7c0c402508894b1ef0e01b99a44320ba7d8ecbabefddcc5569 --hash=sha256:f8286396b351785801a976b1e85ea88e937712ee2c3ac653710a4a57a8da5d9c --hash=sha256:f8fc330c3370a81bbf3f88557097d1ea26cd8b019d6433aa59f71195f5ddebbf --hash=sha256:fbd359831c1657d69bb81f0db962905ee05e5e9451913b18b831febfe0519082 --hash=sha256:fe7e1c262d3392afcf5071df9afa574544f28eac825284596ac6db56e6d11062 --hash=sha256:fed1e1cf6a42577953abbe8e6cf2fe2f566daebde7c34724ec8803c4c0cda579
+proto-plus==1.22.3 ; python_version >= '3.6' --hash=sha256:a49cd903bc0b6ab41f76bf65510439d56ca76f868adf0274e738bfdd096894df --hash=sha256:fdcd09713cbd42480740d2fe29c990f7fbd885a67efc328aa8be6ee3e9f76a6b
+protobuf==4.23.3 ; python_version >= '3.7' --hash=sha256:0149053336a466e3e0b040e54d0b615fc71de86da66791c592cc3c8d18150bf8 --hash=sha256:08fe19d267608d438aa37019236db02b306e33f6b9902c3163838b8e75970223 --hash=sha256:29660574cd769f2324a57fb78127cda59327eb6664381ecfe1c69731b83e8288 --hash=sha256:2991f5e7690dab569f8f81702e6700e7364cc3b5e572725098215d3da5ccc6ac --hash=sha256:3b01a5274ac920feb75d0b372d901524f7e3ad39c63b1a2d55043f3887afe0c1 --hash=sha256:3bcbeb2bf4bb61fe960dd6e005801a23a43578200ea8ceb726d1f6bd0e562ba1 --hash=sha256:447b9786ac8e50ae72cae7a2eec5c5df6a9dbf9aa6f908f1b8bda6032644ea62 --hash=sha256:514b6bbd54a41ca50c86dd5ad6488afe9505901b3557c5e0f7823a0cf67106fb --hash=sha256:5cb9e41188737f321f4fce9a4337bf40a5414b8d03227e1d9fbc59bc3a216e35 --hash=sha256:7a92beb30600332a52cdadbedb40d33fd7c8a0d7f549c440347bc606fb3fe34b --hash=sha256:84ea0bd90c2fdd70ddd9f3d3fc0197cc24ecec1345856c2b5ba70e4d99815359 --hash=sha256:aca6e86a08c5c5962f55eac9b5bd6fce6ed98645d77e8bfc2b952ecd4a8e4f6a --hash=sha256:cc14358a8742c4e06b1bfe4be1afbdf5c9f6bd094dff3e14edb78a1513893ff5
+pyasn1==0.5.0 ; python_version >= '2.7' and python_version not in '3.0, 3.1, 3.2, 3.3, 3.4, 3.5' --hash=sha256:87a2121042a1ac9358cabcaf1d07680ff97ee6404333bacca15f76aa8ad01a57 --hash=sha256:97b7290ca68e62a832558ec3976f15cbf911bf5d7c7039d8b861c2a0ece69fde
+pyasn1-modules==0.3.0 ; python_version >= '2.7' and python_version not in '3.0, 3.1, 3.2, 3.3, 3.4, 3.5' --hash=sha256:5bd01446b736eb9d31512a30d46c1ac3395d676c6f3cafa4c03eb54b9925631c --hash=sha256:d3ccd6ed470d9ffbc716be08bd90efbd44d0734bc9303818f7336070984a162d
+pyrsistent==0.19.3 ; python_version >= '3.7' --hash=sha256:016ad1afadf318eb7911baa24b049909f7f3bb2c5b1ed7b6a8f21db21ea3faa8 --hash=sha256:1a2994773706bbb4995c31a97bc94f1418314923bd1048c6d964837040376440 --hash=sha256:20460ac0ea439a3e79caa1dbd560344b64ed75e85d8703943e0b66c2a6150e4a --hash=sha256:3311cb4237a341aa52ab8448c27e3a9931e2ee09561ad150ba94e4cfd3fc888c --hash=sha256:3a8cb235fa6d3fd7aae6a4f1429bbb1fec1577d978098da1252f0489937786f3 --hash=sha256:3ab2204234c0ecd8b9368dbd6a53e83c3d4f3cab10ecaf6d0e772f456c442393 --hash=sha256:42ac0b2f44607eb92ae88609eda931a4f0dfa03038c44c772e07f43e738bcac9 --hash=sha256:49c32f216c17148695ca0e02a5c521e28a4ee6c5089f97e34fe24163113722da --hash=sha256:4b774f9288dda8d425adb6544e5903f1fb6c273ab3128a355c6b972b7df39dcf --hash=sha256:4c18264cb84b5e68e7085a43723f9e4c1fd1d935ab240ce02c0324a8e01ccb64 --hash=sha256:5a474fb80f5e0d6c9394d8db0fc19e90fa540b82ee52dba7d246a7791712f74a --hash=sha256:64220c429e42a7150f4bfd280f6f4bb2850f95956bde93c6fda1b70507af6ef3 --hash=sha256:878433581fc23e906d947a6814336eee031a00e6defba224234169ae3d3d6a98 --hash=sha256:99abb85579e2165bd8522f0c0138864da97847875ecbd45f3e7e2af569bfc6f2 --hash=sha256:a2471f3f8693101975b1ff85ffd19bb7ca7dd7c38f8a81701f67d6b4f97b87d8 --hash=sha256:aeda827381f5e5d65cced3024126529ddc4289d944f75e090572c77ceb19adbf --hash=sha256:b735e538f74ec31378f5a1e3886a26d2ca6351106b4dfde376a26fc32a044edc --hash=sha256:c147257a92374fde8498491f53ffa8f4822cd70c0d85037e09028e478cababb7 --hash=sha256:c4db1bd596fefd66b296a3d5d943c94f4fac5bcd13e99bffe2ba6a759d959a28 --hash=sha256:c74bed51f9b41c48366a286395c67f4e894374306b197e62810e0fdaf2364da2 --hash=sha256:c9bb60a40a0ab9aba40a59f68214eed5a29c6274c83b2cc206a359c4a89fa41b --hash=sha256:cc5d149f31706762c1f8bda2e8c4f8fead6e80312e3692619a75301d3dbb819a --hash=sha256:ccf0d6bd208f8111179f0c26fdf84ed7c3891982f2edaeae7422575f47e66b64 --hash=sha256:e42296a09e83028b3476f7073fcb69ffebac0e66dbbfd1bd847d61f74db30f19 --hash=sha256:e8f2b814a3dc6225964fa03d8582c6e0b6650d68a232df41e3cc1b66a5d2f8d1 --hash=sha256:f0774bf48631f3a20471dd7c5989657b639fd2d285b861237ea9e82c36a415a9 --hash=sha256:f0e7c4b2f77593871e918be000b96c8107da48444d57005b6a6bc61fb4331b2c
+pytz==2023.3 --hash=sha256:1d8ce29db189191fb55338ee6d0387d82ab59f3d00eac103412d64e0ebd0c588 --hash=sha256:a151b3abb88eda1d4e34a9814df37de2a80e301e68ba0fd856fb9b46bfbbbffb
 requests==2.31.0 --hash=sha256:58cd2187c01e70e6e26505bca751777aa9f2ee0b7f4300988b709f44e013003f --hash=sha256:942c5a758f98d790eaed1a29cb6eefc7ffb0d1cf7af05c3d2791656dbd6ad1e1
-
-google-resumable-media==2.3.2 --hash=sha256:06924e8b1e79f158f0202e7dd151ad75b0ea9d59b997c850f56bdd4a5a361513
-pyparsing==3.0.8 --hash=sha256:7bf433498c016c4314268d95df76c81b842a4cb2b276fa3312cfb1e1d85f6954 \
-  --hash=sha256:ef7b523f6356f763771559412c0d7134753f037822dad1b16945b7b846f7ad06
-
-idna==3.3 --hash=sha256:84d9dd047ffa80596e0f246e2eab0b391788b0503584e8945f2368256d2735ff \
-  --hash=sha256:9d643ff0a55b762d5cdb124b8eaa99c66322e2157b69160bc32796e824360e6d
-
-certifi==2022.12.7 --hash=sha256:35824b4c3a97115964b408844d64aa14db1cc518f6562e8d7261699d1350a9e3 --hash=sha256:4ad3232f5e926d6718ec31cfc1fcadfde020920e278684144551c91769c7bc18
-urllib3==1.26.9 --hash=sha256:aabaf16477806a5e1dd19aa41f8c2b7950dd3c746362d7e3223dbe6de6ac448e
-grpcio-status==1.44.0 --hash=sha256:ac613ab7a45380cbfa3e529022d0b37317d858f172ba6e65c188aa7355539398
-pytz-deprecation-shim==0.1.0.post0 --hash=sha256:8314c9692a636c8eb3bda879b9f119e350e93223ae83e70e80c31675a0fdc1a6
-tzdata==2022.1 --hash=sha256:8b536a8ec63dc0751342b3984193a3118f8fca2afe25752bb9b7fffd398552d3
-
-google-cloud-logging==3.0.0 --hash=sha256:452e361e1dcbc28f2208c0805c1a7cbac030764556703d97656d05218b933708
-google-cloud-storage==2.2.1  --hash=sha256:0244f4612710cb5ec445fc6774387564e23f9823363fb408b28724e2102401b7
-google-cloud-tasks==2.8.1 --hash=sha256:55f443651830ab5a4ec23ce6aba99d6d5a9c4fac10743eaa38c8af427e146b5d
-
-# Dependencies for google-cloud-tasks
-grpc-google-iam-v1==0.12.4 --hash=sha256:3f0ac2c940b9a855d7ce7e31fde28bddb0d9ac362d32d07c67148306931a0e30
-google-crc32c==1.3.0 \
-  --hash=sha256:7f6fe42536d9dcd3e2ffb9d3053f5d05221ae3bbcefbe472bdf2c71c793e3183 \
-  --hash=sha256:5da2c81575cc3ccf05d9830f9e8d3c70954819ca9a63828210498c0774fda1a3 \
-  --hash=sha256:fc28e0db232c62ca0c3600884933178f0825c99be4474cdd645e378a10588125 \
-  --hash=sha256:c124b8c8779bf2d35d9b721e52d4adb41c9bfbde45e6a3f25f0820caa9aba73f \
-  --hash=sha256:95c68a4b9b7828ba0428f8f7e3109c5d476ca44996ed9a5f8aac6269296e2d59 \
-  --hash=sha256:cb6994fff247987c66a8a4e550ef374671c2b82e3c0d2115e689d21e511a652d \
-  --hash=sha256:127f9cc3ac41b6a859bd9dc4321097b1a4f6aa7fdf71b4f9227b9e3ebffb4422 \
-  --hash=sha256:ed447680ff21c14aaceb6a9f99a5f639f583ccfe4ce1a5e1d48eb41c3d6b3217 \
-  --hash=sha256:e0f1ff55dde0ebcfbef027edc21f71c205845585fffe30d4ec4979416613e9b3 \
-  --hash=sha256:13af315c3a0eec8bb8b8d80b8b128cb3fcd17d7e4edafc39647846345a3f003a \
-  --hash=sha256:96a8918a78d5d64e07c8ea4ed2bc44354e3f93f46a4866a40e8db934e4c0d74b \
-  --hash=sha256:58be56ae0529c664cc04a9c76e68bb92b091e0194d6e3c50bea7e0f266f73713 \
-  --hash=sha256:a7f9cbea4245ee36190f85fe1814e2d7b1e5f2186381b082f5d59f99b7f11328 \
-  --hash=sha256:12674a4c3b56b706153a358eaa1018c4137a5a04635b92b4652440d3d7386206 \
-  --hash=sha256:fec221a051150eeddfdfcff162e6db92c65ecf46cb0f7bb1bf812a1520ec026b \
-  --hash=sha256:dda4d8a3bb0b50f540f6ff4b6033f3a74e8bf0bd5320b70fab2c03e512a62812 \
-  --hash=sha256:bab4aebd525218bab4ee615786c4581952eadc16b1ff031813a2fd51f0cc7b08 \
-  --hash=sha256:05340b60bf05b574159e9bd940152a47d38af3fb43803ffe71f11d704b7696a6 \
-  --hash=sha256:9f58099ad7affc0754ae42e6d87443299f15d739b0ce03c76f515153a5cda06c \
-  --hash=sha256:e7a539b9be7b9c00f11ef16b55486141bc2cdb0c54762f84e3c6fc091917436d \
-  --hash=sha256:04e7c220798a72fd0f08242bc8d7a05986b2a08a0573396187fd32c1dcdd58b3
-
-google-cloud-iam==2.6.1 --hash=sha256:7355cf1393c10d7460a6228605f0211c1eb24cfcaf6f2dda6799c5e34faa1624
-
-# Dependencies for google-cloud-iam
-grpcio==1.44.0 \
-  --hash=sha256:4bae1c99896045d3062ab95478411c8d5a52cb84b91a1517312629fa6cfeb50e \
-  --hash=sha256:4ee51964edfd0a1293a95bb0d72d134ecf889379d90d2612cbf663623ce832b4 \
-  --hash=sha256:d1e22d3a510438b7f3365c0071b810672d09febac6e8ca8a47eab657ae5f347b \
-  --hash=sha256:9a86a91201f8345502ea81dee0a55ae13add5fafadf109b17acd858fe8239651 \
-  --hash=sha256:d2ec124a986093e26420a5fb10fa3f02b2c232f924cdd7b844ddf7e846c020cd \
-  --hash=sha256:4fcb53e4eb8c271032c91b8981df5fc1bb974bc73e306ec2c27da41bd95c44b5 \
-  --hash=sha256:e2de61005118ae59d48d5d749283ebfd1ba4ca68cc1000f8a395cd2bdcff7ceb \
-  --hash=sha256:cf220199b7b4992729ad4d55d5d3f652f4ccfe1a35b5eacdbecf189c245e1859 \
-  --hash=sha256:13343e7b840c20f43b44f0e6d3bbdc037c964f0aec9735d7cb685c407731c9ff \
-  --hash=sha256:36a7bdd6ef9bca050c7ade8cba5f0e743343ea0756d5d3d520e915098a9dc503 \
-  --hash=sha256:9075c0c003c1ff14ebce8f0ba55cc692158cb55c68da09cf8b0f9fc5b749e343 \
-  --hash=sha256:bfd36b959c3c4e945119387baed1414ea46f7116886aa23de0172302b49d7ff1 \
-  --hash=sha256:f6a9cf0e77f72f2ac30c9c6e086bc7446c984c51bebc6c7f50fbcd718037edba \
-  --hash=sha256:fdb0a3e0e64843441793923d9532a3a23907b07b2a1e0a7a31f186dc185bb772 \
-  --hash=sha256:89b390b1c0de909965280d175c53128ce2f0f4f5c0f011382243dd7f2f894060 \
-  --hash=sha256:14eefcf623890f3f7dd7831decd2a2116652b5ce1e0f1d4b464b8f52110743b0
-
-gunicorn==20.1.0 --hash=sha256:9dcc4547dbb1cb284accfb15ab5667a0e5d1881cc443e0677b4882a4067a807e
-
-jinja2==3.1.1 --hash=sha256:640bed4bb501cbd17194b3cace1dc2126f5b619cf068a726b98192a0fde74ae9
-
-# Dependencies for jinja2
-MarkupSafe==2.1.1 \
-  --hash=sha256:7f91197cc9e48f989d12e4e6fbc46495c446636dfc81b9ccf50bb0ec74b91d4b \
-  --hash=sha256:dda30ba7e87fbbb7eab1ec9f58678558fd9a6b8b853530e176eabd064da81417 \
-  --hash=sha256:efc1913fd2ca4f334418481c7e595c00aad186563bbc1ec76067848c7ca0a933 \
-  --hash=sha256:86b1f75c4e7c2ac2ccdaec2b9022845dbb81880ca318bb7a0a01fbf7813e3812 \
-  --hash=sha256:46d00d6cfecdde84d40e572d63735ef81423ad31184100411e6e3388d405e247 \
-  --hash=sha256:56442863ed2b06d19c37f94d999035e15ee982988920e12a5b4ba29b62ad1f77 \
-  --hash=sha256:e04e26803c9c3851c931eac40c695602c6295b8d432cbe78609649ad9bd2da8a \
-  --hash=sha256:fc7b548b17d238737688817ab67deebb30e8073c95749d55538ed473130ec0c7 \
-  --hash=sha256:4b9fe39a2ccc108a4accc2676e77da025ce383c108593d65cc909add5c3bd601 \
-  --hash=sha256:e8c843bbcda3a2f1e3c2ab25913c80a3c5376cd00c6e8c4a86a89a28c8dc5452 \
-  --hash=sha256:97a68e6ada378df82bc9f16b800ab77cbf4b2fada0081794318520138c088e4a \
-  --hash=sha256:e72591e9ecd94d7feb70c1cbd7be7b3ebea3f548870aa91e2732960fa4d57a37 \
-  --hash=sha256:671cd1187ed5e62818414afe79ed29da836dde67166a9fac6d435873c44fdd02
-
-
-pillow==9.3.0 \
-  --hash=sha256:03150abd92771742d4a8cd6f2fa6246d847dcd2e332a18d0c15cc75bf6703040 \
-  --hash=sha256:073adb2ae23431d3b9bcbcff3fe698b62ed47211d0716b067385538a1b0f28b8 \
-  --hash=sha256:0b07fffc13f474264c336298d1b4ce01d9c5a011415b79d4ee5527bb69ae6f65 \
-  --hash=sha256:0b7257127d646ff8676ec8a15520013a698d1fdc48bc2a79ba4e53df792526f2 \
-  --hash=sha256:12ce4932caf2ddf3e41d17fc9c02d67126935a44b86df6a206cf0d7161548627 \
-  --hash=sha256:15c42fb9dea42465dfd902fb0ecf584b8848ceb28b41ee2b58f866411be33f07 \
-  --hash=sha256:18498994b29e1cf86d505edcb7edbe814d133d2232d256db8c7a8ceb34d18cef \
-  --hash=sha256:1c7c8ae3864846fc95f4611c78129301e203aaa2af813b703c55d10cc1628535 \
-  --hash=sha256:22b012ea2d065fd163ca096f4e37e47cd8b59cf4b0fd47bfca6abb93df70b34c \
-  --hash=sha256:276a5ca930c913f714e372b2591a22c4bd3b81a418c0f6635ba832daec1cbcfc \
-  --hash=sha256:2e0918e03aa0c72ea56edbb00d4d664294815aa11291a11504a377ea018330d3 \
-  --hash=sha256:3033fbe1feb1b59394615a1cafaee85e49d01b51d54de0cbf6aa8e64182518a1 \
-  --hash=sha256:3168434d303babf495d4ba58fc22d6604f6e2afb97adc6a423e917dab828939c \
-  --hash=sha256:32a44128c4bdca7f31de5be641187367fe2a450ad83b833ef78910397db491aa \
-  --hash=sha256:3dd6caf940756101205dffc5367babf288a30043d35f80936f9bfb37f8355b32 \
-  --hash=sha256:40e1ce476a7804b0fb74bcfa80b0a2206ea6a882938eaba917f7a0f004b42502 \
-  --hash=sha256:41e0051336807468be450d52b8edd12ac60bebaa97fe10c8b660f116e50b30e4 \
-  --hash=sha256:4390e9ce199fc1951fcfa65795f239a8a4944117b5935a9317fb320e7767b40f \
-  --hash=sha256:502526a2cbfa431d9fc2a079bdd9061a2397b842bb6bc4239bb176da00993812 \
-  --hash=sha256:51e0e543a33ed92db9f5ef69a0356e0b1a7a6b6a71b80df99f1d181ae5875636 \
-  --hash=sha256:57751894f6618fd4308ed8e0c36c333e2f5469744c34729a27532b3db106ee20 \
-  --hash=sha256:5d77adcd56a42d00cc1be30843d3426aa4e660cab4a61021dc84467123f7a00c \
-  --hash=sha256:655a83b0058ba47c7c52e4e2df5ecf484c1b0b0349805896dd350cbc416bdd91 \
-  --hash=sha256:68943d632f1f9e3dce98908e873b3a090f6cba1cbb1b892a9e8d97c938871fbe \
-  --hash=sha256:6c738585d7a9961d8c2821a1eb3dcb978d14e238be3d70f0a706f7fa9316946b \
-  --hash=sha256:73bd195e43f3fadecfc50c682f5055ec32ee2c933243cafbfdec69ab1aa87cad \
-  --hash=sha256:772a91fc0e03eaf922c63badeca75e91baa80fe2f5f87bdaed4280662aad25c9 \
-  --hash=sha256:77ec3e7be99629898c9a6d24a09de089fa5356ee408cdffffe62d67bb75fdd72 \
-  --hash=sha256:7db8b751ad307d7cf238f02101e8e36a128a6cb199326e867d1398067381bff4 \
-  --hash=sha256:801ec82e4188e935c7f5e22e006d01611d6b41661bba9fe45b60e7ac1a8f84de \
-  --hash=sha256:82409ffe29d70fd733ff3c1025a602abb3e67405d41b9403b00b01debc4c9a29 \
-  --hash=sha256:828989c45c245518065a110434246c44a56a8b2b2f6347d1409c787e6e4651ee \
-  --hash=sha256:829f97c8e258593b9daa80638aee3789b7df9da5cf1336035016d76f03b8860c \
-  --hash=sha256:871b72c3643e516db4ecf20efe735deb27fe30ca17800e661d769faab45a18d7 \
-  --hash=sha256:89dca0ce00a2b49024df6325925555d406b14aa3efc2f752dbb5940c52c56b11 \
-  --hash=sha256:90fb88843d3902fe7c9586d439d1e8c05258f41da473952aa8b328d8b907498c \
-  --hash=sha256:97aabc5c50312afa5e0a2b07c17d4ac5e865b250986f8afe2b02d772567a380c \
-  --hash=sha256:9aaa107275d8527e9d6e7670b64aabaaa36e5b6bd71a1015ddd21da0d4e06448 \
-  --hash=sha256:9f47eabcd2ded7698106b05c2c338672d16a6f2a485e74481f524e2a23c2794b \
-  --hash=sha256:a0a06a052c5f37b4ed81c613a455a81f9a3a69429b4fd7bb913c3fa98abefc20 \
-  --hash=sha256:ab388aaa3f6ce52ac1cb8e122c4bd46657c15905904b3120a6248b5b8b0bc228 \
-  --hash=sha256:ad58d27a5b0262c0c19b47d54c5802db9b34d38bbf886665b626aff83c74bacd \
-  --hash=sha256:ae5331c23ce118c53b172fa64a4c037eb83c9165aba3a7ba9ddd3ec9fa64a699 \
-  --hash=sha256:af0372acb5d3598f36ec0914deed2a63f6bcdb7b606da04dc19a88d31bf0c05b \
-  --hash=sha256:afa4107d1b306cdf8953edde0534562607fe8811b6c4d9a486298ad31de733b2 \
-  --hash=sha256:b03ae6f1a1878233ac620c98f3459f79fd77c7e3c2b20d460284e1fb370557d4 \
-  --hash=sha256:b0915e734b33a474d76c28e07292f196cdf2a590a0d25bcc06e64e545f2d146c \
-  --hash=sha256:b4012d06c846dc2b80651b120e2cdd787b013deb39c09f407727ba90015c684f \
-  --hash=sha256:b472b5ea442148d1c3e2209f20f1e0bb0eb556538690fa70b5e1f79fa0ba8dc2 \
-  --hash=sha256:b59430236b8e58840a0dfb4099a0e8717ffb779c952426a69ae435ca1f57210c \
-  --hash=sha256:b90f7616ea170e92820775ed47e136208e04c967271c9ef615b6fbd08d9af0e3 \
-  --hash=sha256:b9a65733d103311331875c1dca05cb4606997fd33d6acfed695b1232ba1df193 \
-  --hash=sha256:bac18ab8d2d1e6b4ce25e3424f709aceef668347db8637c2296bcf41acb7cf48 \
-  --hash=sha256:bca31dd6014cb8b0b2db1e46081b0ca7d936f856da3b39744aef499db5d84d02 \
-  --hash=sha256:be55f8457cd1eac957af0c3f5ece7bc3f033f89b114ef30f710882717670b2a8 \
-  --hash=sha256:c7025dce65566eb6e89f56c9509d4f628fddcedb131d9465cacd3d8bac337e7e \
-  --hash=sha256:c935a22a557a560108d780f9a0fc426dd7459940dc54faa49d83249c8d3e760f \
-  --hash=sha256:dbb8e7f2abee51cef77673be97760abff1674ed32847ce04b4af90f610144c7b \
-  --hash=sha256:e6ea6b856a74d560d9326c0f5895ef8050126acfdc7ca08ad703eb0081e82b74 \
-  --hash=sha256:ebf2029c1f464c59b8bdbe5143c79fa2045a581ac53679733d3a91d400ff9efb \
-  --hash=sha256:f1ff2ee69f10f13a9596480335f406dd1f70c3650349e2be67ca3139280cade0
-
-webob==1.8.7 --hash=sha256:73aae30359291c14fa3b956f8b5ca31960e420c28c1bec002547fb04928cf89b
-PyYAML==6.0 --hash=sha256:68fb519c14306fec9720a2a5b45bc9f0c8d1b9c72adf45c37baedfcd949c35a2
-
-
-
-# Dependency for reqests
-charset-normalizer==2.0.12 --hash=sha256:2857e29ff0d34db842cd7ca3230549d1a697f96ee6d3fb071cfa6c7393832597
-
-# Dependency for google-cloud-logging
-google-cloud-audit-log==0.2.0 --hash=sha256:ecc7f5f2168ad4014331d6397fcea3750b2d41900f0ef6d1081cd78b3a6420e9
-google-cloud-appengine-logging==1.1.1 --hash=sha256:361450ed7d7bfd8efd0ef253e21680aeb6f6df3cf057e5e8253f5851f8cbbca7
-
-# Custom requirements to build ViUR on GCP
-setuptools==65.5.1 --hash=sha256:d0b9a8433464d5800cbe05094acf5c6d52a91bfac9b52bcfc4d41382be5d5d31 --hash=sha256:e197a19aa8ec9722928f2206f8de752def0e4c9fc6953527360d1c36d94ddb2f
-
-# Dependency for jsonschema
-attrs==22.2.0 \
-    --hash=sha256:29e95c7f6778868dbd49170f98f8818f78f3dc5e0e37c0b1f474e3561b240836 \
-    --hash=sha256:c9227bfc2f01993c03f68db37d1d15c9690188323c067c641f1a35ca58185f99
-    # via jsonschema
-jsonschema==4.17.3 \
-    --hash=sha256:0f864437ab8b6076ba6707453ef8f98a6a0d512a80e93f8abdb676f737ecb60d \
-    --hash=sha256:a870ad254da1a8ca84b6a2905cac29d265f805acc57af304784962a2aa6508f6
-    # via -r requirements.in
-pyrsistent==0.19.3 \
-    --hash=sha256:016ad1afadf318eb7911baa24b049909f7f3bb2c5b1ed7b6a8f21db21ea3faa8 \
-    --hash=sha256:1a2994773706bbb4995c31a97bc94f1418314923bd1048c6d964837040376440 \
-    --hash=sha256:20460ac0ea439a3e79caa1dbd560344b64ed75e85d8703943e0b66c2a6150e4a \
-    --hash=sha256:3311cb4237a341aa52ab8448c27e3a9931e2ee09561ad150ba94e4cfd3fc888c \
-    --hash=sha256:3a8cb235fa6d3fd7aae6a4f1429bbb1fec1577d978098da1252f0489937786f3 \
-    --hash=sha256:3ab2204234c0ecd8b9368dbd6a53e83c3d4f3cab10ecaf6d0e772f456c442393 \
-    --hash=sha256:42ac0b2f44607eb92ae88609eda931a4f0dfa03038c44c772e07f43e738bcac9 \
-    --hash=sha256:49c32f216c17148695ca0e02a5c521e28a4ee6c5089f97e34fe24163113722da \
-    --hash=sha256:4b774f9288dda8d425adb6544e5903f1fb6c273ab3128a355c6b972b7df39dcf \
-    --hash=sha256:4c18264cb84b5e68e7085a43723f9e4c1fd1d935ab240ce02c0324a8e01ccb64 \
-    --hash=sha256:5a474fb80f5e0d6c9394d8db0fc19e90fa540b82ee52dba7d246a7791712f74a \
-    --hash=sha256:64220c429e42a7150f4bfd280f6f4bb2850f95956bde93c6fda1b70507af6ef3 \
-    --hash=sha256:878433581fc23e906d947a6814336eee031a00e6defba224234169ae3d3d6a98 \
-    --hash=sha256:99abb85579e2165bd8522f0c0138864da97847875ecbd45f3e7e2af569bfc6f2 \
-    --hash=sha256:a2471f3f8693101975b1ff85ffd19bb7ca7dd7c38f8a81701f67d6b4f97b87d8 \
-    --hash=sha256:aeda827381f5e5d65cced3024126529ddc4289d944f75e090572c77ceb19adbf \
-    --hash=sha256:b735e538f74ec31378f5a1e3886a26d2ca6351106b4dfde376a26fc32a044edc \
-    --hash=sha256:c147257a92374fde8498491f53ffa8f4822cd70c0d85037e09028e478cababb7 \
-    --hash=sha256:c4db1bd596fefd66b296a3d5d943c94f4fac5bcd13e99bffe2ba6a759d959a28 \
-    --hash=sha256:c74bed51f9b41c48366a286395c67f4e894374306b197e62810e0fdaf2364da2 \
-    --hash=sha256:c9bb60a40a0ab9aba40a59f68214eed5a29c6274c83b2cc206a359c4a89fa41b \
-    --hash=sha256:cc5d149f31706762c1f8bda2e8c4f8fead6e80312e3692619a75301d3dbb819a \
-    --hash=sha256:ccf0d6bd208f8111179f0c26fdf84ed7c3891982f2edaeae7422575f47e66b64 \
-    --hash=sha256:e42296a09e83028b3476f7073fcb69ffebac0e66dbbfd1bd847d61f74db30f19 \
-    --hash=sha256:e8f2b814a3dc6225964fa03d8582c6e0b6650d68a232df41e3cc1b66a5d2f8d1 \
-    --hash=sha256:f0774bf48631f3a20471dd7c5989657b639fd2d285b861237ea9e82c36a415a9 \
-    --hash=sha256:f0e7c4b2f77593871e918be000b96c8107da48444d57005b6a6bc61fb4331b2c
-    # via jsonschema
+rsa==4.9 ; python_version >= '3.6' and python_version < '4' --hash=sha256:90260d9058e514786967344d0ef75fa8727eed8a7d2e43ce9f4bcf1b536174f7 --hash=sha256:e38464a49c6c85d7f1351b0126661487a7e0a14a50f1675ec50eb34d4f20ef21
+setuptools==68.0.0 ; python_version >= '3.7' --hash=sha256:11e52c67415a381d10d6b462ced9cfb97066179f0e871399e006c4ab101fc85f --hash=sha256:baf1fdb41c6da4cd2eae722e135500da913332ab3f2f5c7d33af9b492acb5235
+six==1.16.0 ; python_version >= '2.7' and python_version not in '3.0, 3.1, 3.2, 3.3' --hash=sha256:1e61c37477a1626458e36f7b1d82aa5c9b094fa4802892072e49de9c60c4c926 --hash=sha256:8abb2f1d86890a2dfb989f9a77cfcfd3e47c2a354b01111771326f8aa26e0254
+tzlocal==5.0.1 --hash=sha256:46eb99ad4bdb71f3f72b7d24f4267753e240944ecfc16f25d2719ba89827a803 --hash=sha256:f3596e180296aaf2dbd97d124fe76ae3a0e3d32b258447de7b939b3fd4be992f
+urllib3==1.26.16 ; python_version >= '2.7' and python_version not in '3.0, 3.1, 3.2, 3.3, 3.4, 3.5' --hash=sha256:8d36afa7616d8ab714608411b4a3b13e58f463aee519024578e062e141dce20f --hash=sha256:8f135f6502756bde6b2a9b28989df5fbe87c9970cecaa69041edcce7f0589b14
+viur-datastore==1.3.9 --hash=sha256:a06355c8002e11be863d96040babc590c9200f474c553be96b855ab38454e694
+webob==1.8.7 --hash=sha256:73aae30359291c14fa3b956f8b5ca31960e420c28c1bec002547fb04928cf89b --hash=sha256:b64ef5141be559cfade448f044fa45c2260351edcb6a8ef6b7e00c7dcef0c323
```

## viur/core/config.py

```diff
@@ -43,16 +43,15 @@
 
 # Some values used more than once below
 __project_id = google.auth.default()[1]
 __app_version = os.getenv("GAE_VERSION")
 
 # Determine our basePath (as os.getCWD is broken on appengine)
 __project_base_path = Path().absolute()
-
-__core_base_path = Path(__file__).parent.parent.parent
+__core_base_path = Path(__file__).parent.parent.parent  # fixme: this points to site-packages!!!
 
 # Conf is a static, local dictionary.
 # Changes here apply locally to the current instance only.
 
 conf = Conf({
     # Administration tool configuration
     "admin.name": "ViUR",
@@ -85,14 +84,15 @@
     # the computed cache-key
     "viur.cacheEnvironmentKey": None,
 
     # Backward compatibility flags; Remove to enforce new layout.
     "viur.compatibility": [
         "json.bone.structure.camelcasenames",  # use camelCase attribute names (see #637 for details)
         "json.bone.structure.keytuples",  # use classic structure notation: `"structure": [["key", {...}], ...]` (#649)
+        "json.bone.structure.inlists",  # dump skeleton structure with every JSON list response (#774 for details)
     ],
 
     # If set, viur will emit a CSP http-header with each request. Use the csp module to set this property
     "viur.contentSecurityPolicy": None,
 
     # Database engine module
     "viur.db.engine": "viur.datastore",
@@ -132,17 +132,14 @@
 
     # If set, this sender will be used, regardless of what the templates advertise as sender
     "viur.email.senderOverride": None,
 
     # If set, ViUR calls this function instead of rendering the viur.errorTemplate if an exception occurs
     "viur.errorHandler": None,
 
-    # Path to the template to render if an unhandled error occurs. This is a Python String-template, *not* Jinja
-    "viur.errorTemplate": "viur/core/template/error.html",
-
     # Path to the static SVGs folder. Will be used by the jinja-renderer-method: embedSvg
     "viur.static.embedSvg.path": "/static/svgs/",
 
     # If true, all requests must be encrypted (ignored on development server)
     "viur.forceSSL": True,
 
     # Hmac-Key used to sign download urls - set automatically
@@ -293,18 +290,31 @@
     # If set, these Fields will survive the session.reset() called on user/login
     "viur.session.persistentFieldsOnLogin": ["language"],
 
     # If set, these Fields will survive the session.reset() called on user/logout
     "viur.session.persistentFieldsOnLogout": ["language"],
 
     # Priority, in which skeletons are loaded
-    "viur.skeleton.searchPath": ["/skeletons/", "/viur/core/"],  # Priority, in which skeletons are loaded
+    "viur.skeleton.searchPath": [
+        "/skeletons/",  # skeletons of the project
+        "/viur/core/",  # system-defined skeletons of viur-core
+        "/viur-core/core/"  # system-defined skeletons of viur-core, only used by editable installation
+    ],
 
     # If set, must be a tuple of two functions serializing/restoring additional environmental data in deferred requests
     "viur.tasks.customEnvironmentHandler": None,
 
+    # User roles available on this project
+    "viur.user.roles": {
+        "custom": "Custom",
+        "user": "User",
+        "viewer": "Viewer",
+        "editor": "Editor",
+        "admin": "Administrator",
+    },
+
     # Which application-ids we're supposed to run on
     "viur.validApplicationIDs": [],
 
     # Semantic version number of viur-core as a tuple of 3 (major, minor, patch-level)
     "viur.version": tuple(int(part) if part.isdigit() else part for part in __version__.split(".", 3)),
 })
```

## viur/core/errors.py

```diff
@@ -121,17 +121,24 @@
 
     def __init__(self, descr: str = "The request has timed out."):
         super(RequestTimeout, self).__init__(status=408, name="Request Timeout", descr=descr)
 
 
 class Gone(HTTPException):
     """
-        Gone
+    Gone
 
-        Not used inside viur.core
+    The 410 (Gone) status code indicates that access to the target
+    resource is no longer available at the origin server and that this
+    condition is likely to be permanent.  If the origin server does not
+    know, or has no facility to determine, whether or not the condition
+    is permanent, the status code 404 (Not Found) ought to be used
+    instead.
+
+    See https://datatracker.ietf.org/doc/html/rfc7231#section-6.5.9
     """
 
     def __init__(self, descr: str = "Gone"):
         super(Gone, self).__init__(status=410, name="Gone", descr=descr)
 
 
 class PreconditionFailed(HTTPException):
@@ -175,14 +182,35 @@
         requests in a given amount of time ("rate limiting").
     """
 
     def __init__(self, descr: str = "Too Many Requests"):
         super(TooManyRequests, self).__init__(status=429, name="Too Many Requests", descr=descr)
 
 
+class UnprocessableEntity(HTTPException):
+    """
+    Unprocessable Entity
+
+    The 422 (Unprocessable Entity) status code means the server
+    understands the content type of the request entity (hence a
+    415 (Unsupported Media Type) status code is inappropriate), and the
+    syntax of the request entity is correct (thus a 400 (Bad Request)
+    status code is inappropriate) but was unable to process the contained
+    instructions.
+    For example, this error condition may occur if an XML
+    request body contains well-formed (i.e., syntactically correct), but
+    semantically erroneous, XML instructions
+
+    See https://www.rfc-editor.org/rfc/rfc4918#section-11.2
+    """
+
+    def __init__(self, descr: str = "Unprocessable Entity"):
+        super().__init__(status=422, name="Unprocessable Entity", descr=descr)
+
+
 class Censored(HTTPException):
     """
         Censored
 
         Not used inside viur.core
     """
```

## viur/core/module.py

```diff
@@ -1,22 +1,47 @@
-from typing import Dict, Any, Union, Callable
+from typing import Dict, Any, Union, Tuple, Callable
+from viur.core.config import conf
 
 
 class Module:
     """
         This is the root module prototype that serves a minimal module in the ViUR system without any other bindings.
     """
 
     handler: Union[str, Callable] = None
     """
     This is the module's handler, respectively its type.
     It can be provided as a callable() which determines the handler at runtime.
     A module without a handler setting is invalid.
     """
 
+    accessRights: Tuple[str] = None
+    """
+    If set, a tuple of access rights (like add, edit, delete) that this module supports.
+
+    These will be prefixed on instance startup with the actual module name (becoming file-add, file-edit etc)
+    and registered in ``conf["viur.accessRights"]`` so these will be available on the access bone in user/add
+    or user/edit.
+    """
+
+    roles: Dict = {}
+    """
+    Allows to specify role settings for a module.
+    Defaults to no role definition, which ignores the module entirely.
+    A "*" can either be used as key or as value to allow for "all roles", or "all rights".
+
+    Example:
+
+        >>> roles = {
+        >>>     "*": "view",                # Any role may only "view"
+        >>>     "editor": ("add", "edit"),  # Role "editor" may "add" or "edit", but not "delete"
+        >>>     "admin": "*",               # Role "admin" can do everything
+        >>> }
+    """
+
     adminInfo: Union[Dict[str, Any], Callable] = None
     """
         This is a ``dict`` holding the information necessary for the Vi/Admin to handle this module.
 
             name: ``str``
                 Human-readable module name that will be shown in Vi/Admin
 
@@ -97,14 +122,22 @@
 
     def __init__(self, moduleName: str, modulePath: str, *args, **kwargs):
         self.render = None  # will be set to the appropriate render instance at runtime
         self._cached_description = None  # caching used by describe()
         self.moduleName = moduleName  # Name of this module (usually it's class name, e.g. "file")
         self.modulePath = modulePath  # Path to this module in URL-routing (e.g. "json/file")
 
+        if self.handler and self.accessRights:
+            for right in self.accessRights:
+                right = f"{self.moduleName}-{right}"
+
+                # fixme: Turn conf["viur.accessRights"] into a set.
+                if right not in conf["viur.accessRights"]:
+                    conf["viur.accessRights"].append(right)
+
     def describe(self) -> Union[Dict, None]:
         """
         Meta description of this module.
         """
         # Use cached description?
         if isinstance(self._cached_description, dict):
             return self._cached_description
```

## viur/core/request.py

```diff
@@ -1,17 +1,16 @@
 import json
 import logging
 import os
+import time
 import traceback
 import typing
 import inspect
 import unicodedata
 from abc import ABC, abstractmethod
-from string import Template
-from time import time
 from urllib import parse
 from urllib.parse import unquote, urljoin, urlparse
 
 import webob
 
 from viur.core import current, db, errors, utils
 from viur.core.config import conf
@@ -98,15 +97,15 @@
     """
 
     # List of requestValidators used to preflight-check an request before it's being dispatched within ViUR
     requestValidators = [FetchMetaDataValidator]
 
     def __init__(self, request: webob.Request, response: webob.Response):
         super()
-        self.startTime = time()
+        self.startTime = time.time()
         self.request = request
         self.response = response
         self.maxLogLevel = logging.DEBUG
         self._traceID = request.headers.get('X-Cloud-Trace-Context', "").split("/")[0] or utils.generateRandomString()
         self.is_deferred = False
         self.path_list = ()
         db.currentDbAccessLog.set(set())
@@ -306,55 +305,51 @@
                     res = conf["viur.errorHandler"](e)
                 except Exception as newE:
                     logging.error("viur.errorHandler failed!")
                     logging.exception(newE)
                     res = None
             if not res:
                 descr = "The server encountered an unexpected error and is unable to process your request."
+
+                if isinstance(e, errors.HTTPException):
+                    error_info = {
+                        "status": e.status,
+                        "reason": e.name,
+                        "title": str(translate(e.name)),
+                        "descr": e.descr,
+                    }
+                else:
+                    error_info = {
+                        "status": 500,
+                        "reason": "Internal Server Error",
+                        "title": str(translate("Internal Server Error")),
+                        "descr": descr
+                    }
+
+                if conf["viur.instance.is_dev_server"]:
+                    error_info["traceback"] = traceback.format_exc()
+
                 if (len(self.path_list) > 0 and self.path_list[0] in ("vi", "json")) or \
                         current.request.get().response.headers["Content-Type"] == "application/json":
                     current.request.get().response.headers["Content-Type"] = "application/json"
-                    if isinstance(e, errors.HTTPException):
-                        res = {
-                            "status": e.status,
-                            "reason": e.name,
-                            "descr": str(translate(e.name)),
-                            "hint": e.descr,
-                        }
-                    else:
-                        res = {
-                            "status": 500,
-                            "reason": "Internal Server Error",
-                            "descr": descr
-                        }
+                    res = json.dumps(error_info)
+                else:  # We render the error in html
+                    # Try to get the template from html/error/
+                    if filename := conf["viur.mainApp"].render.getTemplateFileName((f"{error_info['status']}", "error"),
+                                                                                   raise_exception=False):
+                        template = conf["viur.mainApp"].render.getEnv().get_template(filename)
+                        res = template.render(error_info)
 
-                    if conf["viur.instance.is_dev_server"]:
-                        res["traceback"] = traceback.format_exc()
-
-                    res = json.dumps(res)
+                        # fixme: this might be the viur/core/template/error.html ...
+                        extendCsp({"style-src": ['sha256-Lwf7c88gJwuw6L6p6ILPSs/+Ui7zCk8VaIvp8wLhQ4A=']})
+                    else:
+                        res = f"""<html><h1>{error_info["status"]} - {error_info["reason"]}"""
 
-                else:
-                    with (conf["viur.instance.core_base_path"].joinpath(conf["viur.errorTemplate"]).open() as tpl_file):
-                        tpl = Template(tpl_file.read())
-                        if isinstance(e, errors.HTTPException):
-                            res = tpl.safe_substitute({
-                                "error_code": e.status,
-                                "error_name": translate(e.name),
-                                "error_descr": e.descr,
-                            })
-                        else:
-                            res = tpl.safe_substitute(
-                                {"error_code": "500",
-                                 "error_name": "Internal Server Error",
-                                 "error_descr": descr,
-                                 })
-                    extendCsp({"style-src": ['sha256-Lwf7c88gJwuw6L6p6ILPSs/+Ui7zCk8VaIvp8wLhQ4A=']})
             self.response.write(res.encode("UTF-8"))
 
-
         finally:
             self.saveSession()
             if conf["viur.instance.is_dev_server"] and conf["viur.dev_server_cloud_logging"]:
                 # Emit the outer log only on dev_appserver (we'll use the existing request log when live)
                 SEVERITY = "DEBUG"
                 if self.maxLogLevel >= 50:
                     SEVERITY = "CRITICAL"
@@ -369,15 +364,15 @@
 
                 REQUEST = {
                     'requestMethod': self.request.method,
                     'requestUrl': self.request.url,
                     'status': self.response.status_code,
                     'userAgent': self.request.headers.get('USER-AGENT'),
                     'responseSize': self.response.content_length,
-                    'latency': "%0.3fs" % (time() - self.startTime),
+                    'latency': "%0.3fs" % (time.time() - self.startTime),
                     'remoteIp': self.request.environ.get("HTTP_X_APPENGINE_USER_IP")
                 }
                 requestLogger.log_text(
                     "",
                     client=loggingClient,
                     severity=SEVERITY,
                     http_request=REQUEST,
```

## viur/core/securitykey.py

```diff
@@ -1,113 +1,117 @@
 """
-    This module provides one-time keys.
+    Implementation of one-time CSRF-security-keys.
 
-    There are two types of security keys:
-
-    1. If :meth:create is called without arguments, it returns the current session CSRF token. Repeated calls to
-        :meth:create will return the same CSRF token (for the same session) until that token has been redeemed.
-        This security key will be valid as long the session is active, and it's not possible to store data along with
-        that key. These are usually used as a CSRF token.
-        This has been changed from ViUR2 - where it was possible to create a arbitrary number of security keys per
-        session.
-    2. If :meth:create is called with a duration (and optional kwargs values), it will create a security key
-        that is *not* bound to the current session, but it's possible to store custom data (provided by kwargs).
-        As these are not bound to the session, each call to :meth:create will yield a new token.
-        These are used if it's expected that the token may be redeemed on a different device (e.g. when sending an
-        email address confirmation)
+    CSRF-security-keys (Cross-Site Request Forgery) are used mostly to make requests unique and non-reproducible.
+    Doing the same request again requires to obtain a fresh security key first.
+    Furthermore, security keys can be used to implemented credential-reset mechanisms or similar features, where a
+    URL is only valid for one call.
 
     ..note:
-        There's also a hidden 3rd type of security-key: The sessions static security key.
+        There's also a hidden 3rd type of security-key: The session's static security key.
 
-        This key is only revealed once (during login, as the protected header Sec-X-ViUR-StaticSKey).
+        This key is only revealed once during login, as the protected header "Sec-X-ViUR-StaticSessionKey".
 
         This can be used instead of the one-time sessions security key by sending it back as the same protected HTTP
-        header and setting the skey value to "staticSessionKey". This is only intended for non-web-browser,
+        header and setting the skey value to "Sec-X-ViUR-StaticSessionKey". This is only intended for non-web-browser,
         programmatic access (admin tools, import tools etc.) where CSRF attacks are not applicable.
 
         Therefor that header is prefixed with "Sec-" - so it cannot be read or set using JavaScript.
 """
-from viur.core import utils, current, db, tasks
+import typing
+import datetime
+import hmac
+from viur.core import conf, utils, current, db, tasks
 from viur.core.tasks import DeleteEntitiesIter
-from datetime import datetime, timedelta
-from typing import Union
 
 SECURITYKEY_KINDNAME = "viur-securitykey"
+SECURITYKEY_DURATION = 24 * 60 * 60  # one day
+SECURITYKEY_STATIC = "Sec-X-ViUR-StaticSessionKey"
 
 
-def create(duration: Union[None, int] = None, **custom_data) -> str:
+def create(duration: typing.Union[None, int] = None, session_bound: bool = True, **custom_data) -> str:
     """
-        Creates a new one-time security key or returns the current sessions CSRF-token.
+        Creates a new one-time CSRF-security-key.
 
         The custom data (given as **custom_data) that can be stored with the key.
         Any data provided must be serializable by the datastore.
 
-        :param duration: Make this key valid for a fixed timeframe of seconds (and independent of the current session)
+        :param duration: Make this CSRF-token valid for a fixed timeframe of seconds.
+        :param session_bound: Bind this CSRF-token to the current session.
+        :param custom_data: Any other data is stored with the CSRF-token, for later re-use.
+
         :returns: The new one-time key, which is a randomized string.
     """
-    if not duration:
-        if custom_data:
-            raise ValueError("Providing any custom_data is not allowed when session security key is wanted")
+    if any(k.startswith("viur_") for k in custom_data):
+        raise ValueError("custom_data keys with a 'viur_'-prefix are reserved.")
 
-        return current.session.get().getSecurityKey()
-
-    elif "until" in custom_data:
-        raise ValueError("The 'until' property is reserved and cannot be used in the custom_data")
+    if not duration:
+        duration = conf["viur.session.lifeTime"] if session_bound else SECURITYKEY_DURATION
 
     key = utils.generateRandomString()
 
     entity = db.Entity(db.Key(SECURITYKEY_KINDNAME, key))
     entity |= custom_data
 
-    entity["until"] = utils.utcNow() + timedelta(seconds=int(duration))
+    entity["viur_session"] = current.session.get().cookie_key if session_bound else None
+    entity["viur_until"] = utils.utcNow() + datetime.timedelta(seconds=int(duration))
     db.Put(entity)
 
     return key
 
 
-def validate(key: str, useSessionKey: bool) -> Union[bool, db.Entity]:
-    """
-        Validates a security key.
-
-        If useSessionKey is True, the key is expected to be the session's current security key
-        or its static security key.
-
-        Otherwise, it must be a key created with a duration, so that it is session independent.
-
-        :param key: The key to be validated
-        :param useSessionKey: If True, validate against the session's skey, otherwise lookup an unbound key
-        :returns: False if the key was not valid for whatever reasons, the data (given during createSecurityKey) as
-            dictionary or True if the dict is empty (or useSessionKey was True).
+def validate(key: str, session_bound: bool = True) -> typing.Union[bool, db.Entity]:
     """
-    if useSessionKey:
-        session = current.session.get()
-        if key == "staticSessionKey":
-            skey_header_value = current.request.get().request.headers.get("Sec-X-ViUR-StaticSKey")
-            if skey_header_value and session.validateStaticSecurityKey(skey_header_value):
-                return True
+        Validates a CSRF-security-key.
 
-        elif session.validateSecurityKey(key):
-            return True
+        :param key: The CSRF-token to be validated.
+        :param session_bound: If True, make sure the CSRF-token is created inside the current session.
+        :returns: False if the key was not valid for whatever reasons, the data (given during :meth:`create`) as
+            dictionary or True if the dict is empty (or session was True).
+    """
+    if session_bound and key == SECURITYKEY_STATIC:
+        if skey_header_value := current.request.get().request.headers.get(SECURITYKEY_STATIC):
+            return hmac.compare_digest(current.session.get().static_security_key, skey_header_value)
 
         return False
 
     if not key or not (entity := db.Get(db.Key(SECURITYKEY_KINDNAME, key))):
         return False
 
+    # First of all, delete the entity, validation is done afterward.
     db.Delete(entity)
 
     # Key has expired?
-    if entity["until"] < utils.utcNow():
+    if entity["viur_until"] < utils.utcNow():
         return False
 
-    del entity["until"]
+    del entity["viur_until"]
+
+    # Key is session bound?
+    if session_bound:
+        if entity["viur_session"] != current.session.get().cookie_key:
+            return False
+    elif entity["viur_session"]:
+        return False
+
+    del entity["viur_session"]
 
     return entity or True
 
 
 @tasks.PeriodicTask(60 * 4)
-def start_clear_skeys():
+def periodic_clear_skeys():
+    """
+        Removes expired CSRF-security-keys periodically.
+    """
+    query = db.Query(SECURITYKEY_KINDNAME).filter("viur_until <", utils.utcNow() - datetime.timedelta(seconds=300))
+    DeleteEntitiesIter.startIterOnQuery(query)
+
+
+@tasks.CallDeferred
+def clear_session_skeys(session_key):
     """
-        Removes old (expired) skeys
+        Removes any CSRF-security-keys bound to a specific session.
+        This function is called by the Session-module based on reset-actions.
     """
-    query = db.Query(SECURITYKEY_KINDNAME).filter("until <", datetime.now() - timedelta(seconds=300))
+    query = db.Query(SECURITYKEY_KINDNAME).filter("viur_session", session_key)
     DeleteEntitiesIter.startIterOnQuery(query)
```

## viur/core/session.py

```diff
@@ -26,115 +26,108 @@
 
 
 class Session:
     """
         Store Sessions inside the datastore.
         The behaviour of this module can be customized in the following ways:
 
-        - :prop:sameSite can be set to None, "none", "lax" or "strict" to influence the same-site tag on the cookies
+        - :prop:same_site can be set to None, "none", "lax" or "strict" to influence the same-site tag on the cookies
             we set
-        - :prop:sessionCookie is set to True by default, causing the cookie to be treated as a session cookie (it will
-            be deleted on browser close). If set to False, it will be emitted with the life-time in
+        - :prop:use_session_cookie is set to True by default, causing the cookie to be treated as a session cookie
+            (it will be deleted on browser close). If set to False, it will be emitted with the life-time in
             conf["viur.session.lifeTime"].
-        - The config variable conf["viur.session.lifeTime"]: Determines, how ling (in Minutes) a session stays valid.
-            Even if :prop:sessionCookie is set to True, we'll void a session server-side after no request has been made
-            within said lifeTime.
+        - The config variable conf["viur.session.lifeTime"]: Determines, how long (in seconds) a session is valid.
+            Even if :prop:use_session_cookie is set to True, the session is voided server-side after no request has been
+            made within the configured lifetime.
         - The config variables conf["viur.session.persistentFieldsOnLogin"] and
             conf["viur.session.persistentFieldsOnLogout"] lists fields, that may survive a login/logout action.
             For security reasons, we completely destroy a session on login/logout (it will be deleted, a new empty
             database object will be created and a new cookie with a different key is sent to the browser). This causes
             all data currently stored to be lost. Only keys listed in these variables will be copied into the new
             session.
-
     """
     kindName = "viur-session"
-    sameSite = "lax"  # Either None (don't issue sameSite header), "none", "lax" or "strict"
-    sessionCookie = True  # If True, issue the cookie without a lifeTime (will disappear on browser close)
-    cookieName = f"""viur_cookie_{conf["viur.instance.project_id"]}"""
+    same_site = "lax"  # Either None (don't issue same_site header), "none", "lax" or "strict"
+    use_session_cookie = True  # If True, issue the cookie without a lifeTime (will disappear on browser close)
+    cookie_name = f"""viur_cookie_{conf["viur.instance.project_id"]}"""
     GUEST_USER = "__guest__"
 
     def __init__(self):
         super().__init__()
         self.changed = False
-        self.isInitial = False
-        self.cookieKey = None
-        self.sslKey = None
-        self.staticSecurityKey = None
-        self.securityKey = None
-        self.session = {}
+        self.cookie_key = None
+        self.static_security_key = None
+        self.session = db.Entity()
 
     def load(self, req: BrowseHandler):
         """
             Initializes the Session.
 
             If the client supplied a valid Cookie, the session is read from the datastore, otherwise a new,
             empty session will be initialized.
         """
-        if self.cookieName in req.request.cookies:
-            cookie = str(req.request.cookies[self.cookieName])
-            if data := db.Get(db.Key(self.kindName, cookie)):  # Loaded successfully
+        if cookie_key := str(req.request.cookies.get(self.cookie_name)):
+            if data := db.Get(db.Key(self.kindName, cookie_key)):  # Loaded successfully
                 if data["lastseen"] < time.time() - conf["viur.session.lifeTime"]:
                     # This session is too old
                     self.reset()
                     return False
 
+                self.cookie_key = cookie_key
                 self.session = data["data"]
-                self.staticSecurityKey = data["staticSecurityKey"]
-                self.securityKey = data["securityKey"]
-                self.cookieKey = cookie
+                self.static_security_key = data["static_security_key"]
 
                 if data["lastseen"] < time.time() - 5 * 60:  # Refresh every 5 Minutes
                     self.changed = True
             else:
                 self.reset()
         else:
             self.reset()
 
     def save(self, req: BrowseHandler):
         """
             Writes the session into the database.
 
             Does nothing, in case the session hasn't been changed in the current request.
         """
-        if not (self.changed or self.isInitial):
+        if not self.changed:
             return
 
         # We will not issue sessions over http anymore
         if not (req.isSSLConnection or conf["viur.instance.is_dev_server"]):
             return
 
         # Get the current user's key
         try:
             # Check for our custom user-api
             user_key = conf["viur.mainApp"].user.getCurrentUser()["key"]
         except Exception:
             user_key = Session.GUEST_USER  # this is a guest
 
-        dbSession = db.Entity(db.Key(self.kindName, self.cookieKey))
+        dbSession = db.Entity(db.Key(self.kindName, self.cookie_key))
 
         dbSession["data"] = db.fixUnindexableProperties(self.session)
-        dbSession["staticSecurityKey"] = self.staticSecurityKey
-        dbSession["securityKey"] = self.securityKey
+        dbSession["static_security_key"] = self.static_security_key
         dbSession["lastseen"] = time.time()
         dbSession["user"] = str(user_key)  # allow filtering for users
         dbSession.exclude_from_indexes = ["data"]
 
         db.Put(dbSession)
 
-        # Provide Set-Cookie header entry with configured settings
+        # Provide Set-Cookie header entry with configured properties
         flags = (
             "Path=/",
             "HttpOnly",
-            f"SameSite={self.sameSite}" if self.sameSite else None,
+            f"SameSite={self.same_site}" if self.same_site else None,
             "Secure" if not conf["viur.instance.is_dev_server"] else None,
-            f"Max-Age={conf['viur.session.lifeTime']}" if not self.sessionCookie else None,
+            f"Max-Age={conf['viur.session.lifeTime']}" if not self.use_session_cookie else None,
         )
 
         req.response.headerlist.append(
-            ("Set-Cookie", f"{self.cookieName}={self.cookieKey};{';'.join([f for f in flags if f])}")
+            ("Set-Cookie", f"{self.cookie_name}={self.cookie_key};{';'.join([f for f in flags if f])}")
         )
 
     def __contains__(self, key: str) -> bool:
         """
             Returns True if the given *key* is set in the current session.
         """
         return key in self.session
@@ -195,65 +188,30 @@
             Invalidates the current session and starts a new one.
 
             This function is especially useful at login, where
             we might need to create an SSL-capable session.
 
             :warning: Everything is flushed.
         """
-        if self.cookieKey:
-            db.Delete(db.Key(self.kindName, self.cookieKey))
-
-        self.cookieKey = utils.generateRandomString(42)
-        self.staticSecurityKey = utils.generateRandomString(13)
-        self.securityKey = utils.generateRandomString(13)
+        if self.cookie_key:
+            db.Delete(db.Key(self.kindName, self.cookie_key))
+            from viur.core import securitykey
+            securitykey.clear_session_skeys(self.cookie_key)
+
+        self.cookie_key = utils.generateRandomString(42)
+        self.static_security_key = utils.generateRandomString(13)
+        self.session.clear()
         self.changed = True
-        self.isInitial = True
-        self.session = db.Entity()
 
     def items(self) -> 'dict_items':
         """
             Returns all items in the current session.
         """
         return self.session.items()
 
-    def getSecurityKey(self) -> Optional[str]:
-        return self.securityKey
-
-    def validateSecurityKey(self, key: str) -> bool:
-        """
-        Checks if key matches the current CSRF-Token of our session. On success, a new key is generated.
-        """
-        if hmac.compare_digest(self.securityKey, key):
-            # It looks good so far, check if we can acquire that skey inside a transaction
-            def exchangeSecurityKey():
-                dbSession = db.Get(db.Key(self.kindName, self.cookieKey))
-                if not dbSession:  # Should not happen (except if session.reset has been called in the same request)
-                    return False
-                if dbSession["securityKey"] != key:  # Race-Condidtion: That skey has been used in another instance
-                    return False
-                dbSession["securityKey"] = utils.generateRandomString(13)
-                db.Put(dbSession)
-                return dbSession["securityKey"]
-
-            try:
-                newSkey = db.RunInTransaction(exchangeSecurityKey)
-            except:  # This should be transaction collision
-                return False
-            if not newSkey:
-                return False
-            self.securityKey = newSkey
-            return True
-        return False
-
-    def validateStaticSecurityKey(self, key: str) -> bool:
-        """
-        Checks if key matches the current *static* CSRF-Token of our session.
-        """
-        return hmac.compare_digest(self.staticSecurityKey, key)
-
 
 @tasks.CallDeferred
 def killSessionByUser(user: Optional[Union[str, db.Key]] = None):
     """
         Invalidates all active sessions for the given *user*.
 
         This means that this user is instantly logged out.
```

## viur/core/skeleton.py

```diff
@@ -11,15 +11,15 @@
 from time import time
 from typing import Any, Callable, Dict, Iterable, List, Optional, Set, Tuple, Type, Union
 from viur.core import conf, db, email, errors, utils, current
 from viur.core.bones import BaseBone, DateBone, KeyBone, RelationalBone, RelationalUpdateLevel, SelectBone, StringBone
 from viur.core.bones.base import ReadFromClientError, ReadFromClientErrorSeverity, getSystemInitialized
 from viur.core.tasks import CallableTask, CallableTaskBase, QueryIter, CallDeferred
 
-__undefindedC__ = object()
+_undefined = object()
 
 
 class MetaBaseSkel(type):
     """
         This is the metaclass for Skeletons.
         It is used to enforce several restrictions on bone names, etc.
     """
@@ -423,28 +423,28 @@
         relNewFileName = inspect.getfile(cls) \
             .replace(str(conf["viur.instance.project_base_path"]), "") \
             .replace(str(conf["viur.instance.core_base_path"]), "")
 
         # Check if we have an abstract skeleton
         if cls.__name__.endswith("AbstractSkel"):
             # Ensure that it doesn't have a kindName
-            assert cls.kindName is __undefindedC__ or cls.kindName is None, "Abstract Skeletons can't have a kindName"
+            assert cls.kindName is _undefined or cls.kindName is None, "Abstract Skeletons can't have a kindName"
             # Prevent any further processing by this class; it has to be sub-classed before it can be used
             return
 
         # Automatic determination of the kindName, if the class is not part of viur.core.
-        if (cls.kindName is __undefindedC__
+        if (cls.kindName is _undefined
             and not relNewFileName.strip(os.path.sep).startswith("viur")
             and not "viur_doc_build" in dir(sys)):
             if cls.__name__.endswith("Skel"):
                 cls.kindName = cls.__name__.lower()[:-4]
             else:
                 cls.kindName = cls.__name__.lower()
         # Try to determine which skeleton definition takes precedence
-        if cls.kindName and cls.kindName is not __undefindedC__ and cls.kindName in MetaBaseSkel._skelCache:
+        if cls.kindName and cls.kindName is not _undefined and cls.kindName in MetaBaseSkel._skelCache:
             relOldFileName = inspect.getfile(MetaBaseSkel._skelCache[cls.kindName]) \
                 .replace(str(conf["viur.instance.project_base_path"]), "") \
                 .replace(str(conf["viur.instance.core_base_path"]), "")
             idxOld = min(
                 [x for (x, y) in enumerate(conf["viur.skeleton.searchPath"]) if relOldFileName.startswith(y)] + [999])
             idxNew = min(
                 [x for (x, y) in enumerate(conf["viur.skeleton.searchPath"]) if relNewFileName.startswith(y)] + [999])
@@ -461,19 +461,19 @@
             else:  # They seem to be from the same Package - raise as something is messed up
                 raise ValueError("Duplicate definition for %s in %s and %s" %
                                  (cls.kindName, relNewFileName, relOldFileName))
         # Ensure that all skeletons are defined in folders listed in conf["viur.skeleton.searchPath"]
         if (not any([relNewFileName.startswith(x) for x in conf["viur.skeleton.searchPath"]])
             and not "viur_doc_build" in dir(sys)):  # Do not check while documentation build
             raise NotImplementedError(
-                "Skeletons must be defined in a folder listed in conf[\"viur.skeleton.searchPath\"]")
-        if cls.kindName and cls.kindName is not __undefindedC__:
+                f"""{relNewFileName} must be defined in a folder listed in {conf["viur.skeleton.searchPath"]}""")
+        if cls.kindName and cls.kindName is not _undefined:
             MetaBaseSkel._skelCache[cls.kindName] = cls
         # Auto-Add ViUR Search Tags Adapter if the skeleton has no adapter attached
-        if cls.customDatabaseAdapter is __undefindedC__:
+        if cls.customDatabaseAdapter is _undefined:
             cls.customDatabaseAdapter = ViurTagsSearchAdapter()
 
 
 class CustomDatabaseAdapter:
     # Set to True if we can run a fulltext search using this database
     providesFulltextSearch: bool = False
     # Are results returned by `meth:fulltextSearch` guaranteed to also match the databaseQuery
@@ -627,16 +627,16 @@
                 res[language] = None
                 if language in newVal:
                     res[language] = self.singleValueSerialize(newVal[language], skel, name, parentIndexed)
             skel.dbEntity["viur"]["viurCurrentSeoKeys"] = res
         return True
 
 class Skeleton(BaseSkeleton, metaclass=MetaSkel):
-    kindName: str = __undefindedC__  # To which kind we save our data to
-    customDatabaseAdapter: Union[CustomDatabaseAdapter, None] = __undefindedC__
+    kindName: str = _undefined  # To which kind we save our data to
+    customDatabaseAdapter: Union[CustomDatabaseAdapter, None] = _undefined
     subSkels = {}  # List of pre-defined sub-skeletons of this type
     interBoneValidations: List[
         Callable[[Skeleton], List[ReadFromClientError]]] = []  # List of functions checking inter-bone dependencies
 
     # The "key" bone stores the current database key of this skeleton.
     # Warning: Assigning to this bones value now *will* set the key
     # it gets stored in. Must be kept readOnly to avoid security-issues with add/edit.
@@ -669,15 +669,15 @@
         return "<skeleton %s with data=%r>" % (self.kindName, {k: self[k] for k in self.keys()})
 
     def __str__(self):
         return str({k: self[k] for k in self.keys()})
 
     def __init__(self, *args, **kwargs):
         super(Skeleton, self).__init__(*args, **kwargs)
-        assert self.kindName and self.kindName is not __undefindedC__, "You must set kindName on this skeleton!"
+        assert self.kindName and self.kindName is not _undefined, "You must set kindName on this skeleton!"
 
     @classmethod
     def all(cls, skelValues, **kwargs) -> db.Query:
         """
             Create a query with the current Skeletons kindName.
 
             :returns: A db.Query object which allows for entity filtering and sorting.
@@ -1443,15 +1443,15 @@
         skel.toDB(update_relations=False)
 
     @classmethod
     def handleFinish(cls, totalCount: int, customData: Dict[str, str]):
         QueryIter.handleFinish(totalCount, customData)
         try:
             if customData["notify"]:
-                txt = f"Subject: Rebuild search index finished for {customData['module']}\n\n" \
+                txt = f"Rebuild search index finished for {customData['module']}\n\n" \
                       f"ViUR finished to rebuild the search index for module {customData['module']}.\n" \
                       f"{totalCount} records updated in total on this kind."
                 email.sendEMail(dests=customData["notify"], stringTemplate=txt, skel=None)
         except:  # OverQuota, whatever
             pass
 
 
@@ -1530,15 +1530,15 @@
         module, newTotalCount, newRemovedCount))
     if newCursor:
         # Start processing of the next chunk
         processVacuumRelationsChunk(module, newCursor, newTotalCount, newRemovedCount, notify)
     else:
         try:
             if notify:
-                txt = ("Subject: Vaccum Relations finished for %s\n\n" +
+                txt = ("Vaccum Relations finished for %s\n\n" +
                        "ViUR finished to vaccum viur-relations.\n" +
                        "%d records processed, %d entries removed") % (module, newTotalCount, newRemovedCount)
                 email.sendEMail(dests=[notify], stringTemplate=txt, skel=None)
         except:  # OverQuota, whatever
             pass
```

## viur/core/tasks.py

```diff
@@ -1,23 +1,23 @@
 import base64
 import json
 import logging
 import os
-import sys
 from datetime import datetime, timedelta
 from functools import wraps
-from time import sleep
 from typing import Any, Callable, Dict, Optional, Tuple
 
 import grpc
 import pytz
 import requests
+import sys
 from google.cloud import tasks_v2
 from google.cloud.tasks_v2.services.cloud_tasks.transports import CloudTasksGrpcTransport
 from google.protobuf import timestamp_pb2
+from time import sleep
 
 from viur.core import current, db, errors, utils
 from viur.core.config import conf
 
 
 # class JsonKeyEncoder(json.JSONEncoder):
 def preprocessJsonObject(o):
@@ -367,15 +367,15 @@
             return
         if not task.canCall():
             raise errors.Unauthorized()
         skel = task.dataSkel()
         skey = kwargs.get("skey", "")
         if len(kwargs) == 0 or not skel.fromClient(kwargs) or kwargs.get("bounce") == "1":
             return self.render.add(skel)
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
         task.execute(**skel.accessedValues)
         return self.render.addSuccess(skel)
 
     execute.exposed = True
 
 
@@ -742,15 +742,15 @@
                     try:
                         doCont = cls.handleError(item, qryDict["customData"], e)
                     except Exception as e:
                         logging.error("handleError failed on %s - bailing out" % item)
                         logging.exception(e)
                         doCont = False
                     if not doCont:
-                        logging.error("Exiting queryItor on cursor %s" % qry.getCursor())
+                        logging.error(f"Exiting queryIter on cursor {qry.getCursor()!r}")
                         return
             qryDict["totalCount"] += 1
         cursor = qry.getCursor()
         if cursor:
             qryDict["startCursor"] = cursor
             cls._requeueStep(qryDict)
         else:
@@ -783,16 +783,22 @@
         logging.debug("handleError called on %s with %s." % (cls, entry))
         logging.exception(exception)
         return True
 
 
 class DeleteEntitiesIter(QueryIter):
     """
-        Simple Query-Iter to delete all entities encountered.
+    Simple Query-Iter to delete all entities encountered.
 
-        ..Warning: Do not use this iter on skeletons. It only works on the low-level db API and would not clear
-            relations, locks etc.
+    ..Warning: When iterating over skeletons, make sure that the
+        query was created using `Skeleton().all()`.
+        This way the `Skeleton.delete()` method can be used and
+        the appropriate post-processing can be done.
     """
 
     @classmethod
     def handleEntry(cls, entry, customData):
-        db.Delete(entry.key)
+        from viur.core.skeleton import SkeletonInstance
+        if isinstance(entry, SkeletonInstance):
+            entry.delete()
+        else:
+            db.Delete(entry.key)
```

## viur/core/version.py

```diff
@@ -1,9 +1,9 @@
 # This is the place where the viur-core version number is defined;
 # For pre-releases, postfix with ".betaN" or ".rcN" where `N` is an incremented number for each pre-release.
 # This will mark it as a pre-release as well on PyPI.
 # See CONTRIBUTING.md for further information.
 
-__version__ = "3.4.4"
+__version__ = "3.5.0.beta1"
 
 assert __version__.count(".") >= 2 and "".join(__version__.split(".", 3)[:3]).isdigit(), \
     "Semantic __version__ expected!"
```

## viur/core/bones/base.py

```diff
@@ -1,69 +1,174 @@
+"""
+This module contains the base classes for the bones in ViUR. Bones are the fundamental building blocks of
+ViUR's data structures, representing the fields and their properties in the entities managed by the
+framework. The base classes defined in this module are the foundation upon which specific bone types are
+built, such as string, numeric, and date/time bones.
+"""
+
 import copy
 import hashlib
 import logging
 from dataclasses import dataclass, field
 from enum import Enum
 from typing import Any, Dict, Iterator, List, Optional, Set, Tuple, Union
 
 from viur.core import db
 from viur.core.config import conf
 
-__systemIsIntitialized_ = False
+
+__system_initialized = False
+"""
+Initializes the global variable __system_initialized
+"""
 
 
 def setSystemInitialized():
-    global __systemIsIntitialized_
+    """
+    Sets the global __system_initialized variable to True, indicating that the system is
+    initialized and ready for use. This function should be called once all necessary setup
+    tasks have been completed. It also iterates over all skeleton classes and calls their
+    setSystemInitialized() method.
+
+    Global variables:
+        __system_initialized: A boolean flag indicating if the system is initialized.
+    """
+    global __system_initialized
     from viur.core.skeleton import iterAllSkelClasses
-    __systemIsIntitialized_ = True
+    __system_initialized = True
     for skelCls in iterAllSkelClasses():
         skelCls.setSystemInitialized()
 
 
 def getSystemInitialized():
-    global __systemIsIntitialized_
-    return __systemIsIntitialized_
+    """
+    Retrieves the current state of the system initialization by returning the value of the
+    global variable __system_initialized.
+    """
+    global __system_initialized
+    return __system_initialized
 
 
 class ReadFromClientErrorSeverity(Enum):
+    """
+    ReadFromClientErrorSeverity is an enumeration that represents the severity levels of errors
+    that can occur while reading data from the client.
+    """
     NotSet = 0
+    """No error occurred"""
     InvalidatesOther = 1
+    # TODO: what is this error about?
+    """The data is valid, for this bone, but in relation to other invalid"""
     Empty = 2
+    """The data is empty, but the bone requires a value"""
     Invalid = 3
+    """The data is invalid, but the bone requires a value"""
 
 
 @dataclass
 class ReadFromClientError:
+    """
+    The ReadFromClientError class represents an error that occurs while reading data from the client.
+    This class is used to store information about the error, including its severity, an error message,
+    the field path where the error occurred, and a list of invalidated fields.
+    """
     severity: ReadFromClientErrorSeverity
+    """A ReadFromClientErrorSeverity enumeration value representing the severity of the error."""
     errorMessage: str
+    """A string containing a human-readable error message describing the issue."""
     fieldPath: List[str] = field(default_factory=list)
+    """A list of strings representing the path to the field where the error occurred."""
     invalidatedFields: List[str] = None
+    """A list of strings containing the names of invalidated fields, if any."""
 
 
 class UniqueLockMethod(Enum):
-    SameValue = 1  # Lock this value we have just one entry, or lock each value individually if bone is multiple
+    """
+    UniqueLockMethod is an enumeration that represents different locking methods for unique constraints
+    on bones. This is used to specify how the uniqueness of a value or a set of values should be
+    enforced.
+    """
+    SameValue = 1  # Lock this value for just one entry or each value individually if bone is multiple
+    """
+    Lock this value so that there is only one entry, or lock each value individually if the bone
+    is multiple.
+    """
     SameSet = 2  # Same Set of entries (including duplicates), any order
+    """Lock the same set of entries (including duplicates) regardless of their order."""
     SameList = 3  # Same Set of entries (including duplicates), in this specific order
+    """Lock the same set of entries (including duplicates) in a specific order."""
 
 
 @dataclass
 class UniqueValue:  # Mark a bone as unique (it must have a different value for each entry)
+    """
+    The UniqueValue class represents a unique constraint on a bone, ensuring that it must have a
+    different value for each entry. This class is used to store information about the unique
+    constraint, such as the locking method, whether to lock empty values, and an error message to
+    display to the user if the requested value is already taken.
+    """
     method: UniqueLockMethod  # How to handle multiple values (for bones with multiple=True)
-    lockEmpty: bool  # If False, empty values ("", 0) are not locked - needed if a field is unique but not required
+    """
+    A UniqueLockMethod enumeration value specifying how to handle multiple values for bones with
+    multiple=True.
+    """
+    lockEmpty: bool  # If False, empty values ("", 0) are not locked - needed if unique but not required
+    """
+    A boolean value indicating if empty values ("", 0) should be locked. If False, empty values are not
+    locked, which is needed if a field is unique but not required.
+    """
     message: str  # Error-Message displayed to the user if the requested value is already taken
+    """
+    A string containing an error message displayed to the user if the requested value is already
+    taken.
+    """
 
 
 @dataclass
 class MultipleConstraints:  # Used to define constraints on multiple bones
+    """
+    The MultipleConstraints class is used to define constraints on multiple bones, such as the minimum
+    and maximum number of entries allowed and whether duplicate values are allowed.
+    """
     minAmount: int = 0  # Lower bound of how many entries can be submitted
+    """An integer representing the lower bound of how many entries can be submitted (default: 0)."""
     maxAmount: int = 0  # Upper bound of how many entries can be submitted
+    """An integer representing the upper bound of how many entries can be submitted (default: 0)."""
     preventDuplicates: bool = False  # Prevent the same value of being used twice
+    """A boolean value indicating if the same value can be used twice (default: False)."""
 
 
 class BaseBone(object):
+    """
+    The BaseBone class serves as the base class for all bone types in the ViUR framework.
+    It defines the core functionality and properties that all bones should implement.
+
+    :param descr: Textual, human-readable description of that bone. Will be translated.
+    :param defaultValue: If set, this bone will be preinitialized with this value
+    :param required: If True, the user must enter a valid value for this bone (the viur.core refuses
+        to save the skeleton otherwise). If a list/tuple of languages (strings) is provided, these
+        language must be entered.
+    :param multiple: If True, multiple values can be given. (ie. n:m relations instead of n:1)
+    :param searchable: If True, this bone will be included in the fulltext search. Can be used
+        without the need of also been indexed.
+    :param vfunc: If given, a callable validating the user-supplied value for this bone.
+        This callable must return None if the value is valid, a String containing an meaningful
+        error-message for the user otherwise.
+    :param readOnly: If True, the user is unable to change the value of this bone. If a value for this
+        bone is given along the POST-Request during Add/Edit, this value will be ignored. Its still
+        possible for the developer to modify this value by assigning skel.bone.value.
+    :param visible: If False, the value of this bone should be hidden from the user. This does
+        *not* protect the value from being exposed in a template, nor from being transferred
+        to the client (ie to the admin or as hidden-value in html-forms)
+
+        Again: This is just a hint. It cannot be used as a security precaution.
+
+        .. NOTE::
+            The kwarg 'multiple' is not supported by all bones
+    """
     type = "hidden"
     isClonedInstance = False
 
     def __init__(
         self,
         *,
         defaultValue: Any = None,
@@ -78,37 +183,15 @@
         required: Union[bool, List[str], Tuple[str]] = False,
         searchable: bool = False,
         unique: Union[None, UniqueValue] = None,
         vfunc: callable = None,  # fixme: Rename this, see below.
         visible: bool = True,
     ):
         """
-            Initializes a new Bone.
-
-            :param descr: Textual, human-readable description of that bone. Will be translated.
-            :param defaultValue: If set, this bone will be preinitialized with this value
-            :param required: If True, the user must enter a valid value for this bone (the viur.core refuses to save the
-                skeleton otherwise).
-                If a list/tuple of languages (strings) is provided, these language must be entered.
-            :param multiple: If True, multiple values can be given. (ie. n:m relations instead of n:1)
-            :param searchable: If True, this bone will be included in the fulltext search. Can be used
-                without the need of also been indexed.
-            :param vfunc: If given, a callable validating the user-supplied value for this bone. This
-                callable must return None if the value is valid, a String containing an meaningful
-                error-message for the user otherwise.
-            :param readOnly: If True, the user is unable to change the value of this bone. If a value for
-                this bone is given along the POST-Request during Add/Edit, this value will be ignored.
-                Its still possible for the developer to modify this value by assigning skel.bone.value.
-            :param visible: If False, the value of this bone should be hidden from the user. This does *not*
-                protect the value from beeing exposed in a template, nor from being transferred to the
-                client (ie to the admin or as hidden-value in html-forms)
-                Again: This is just a hint. It cannot be used as a security precaution.
-
-            .. NOTE::
-                The kwarg 'multiple' is not supported by all bones
+        Initializes a new Bone.
         """
         self.isClonedInstance = getSystemInitialized()
 
         # Standard definitions
         self.descr = descr
         self.params = params or {}
         self.multiple = multiple
@@ -135,15 +218,16 @@
         if isinstance(required, (tuple, list)) and languages and (diff := set(required).difference(languages)):
             raise ValueError(f"The language(s) {', '.join(map(repr, diff))} can not be required, "
                              f"because they're not defined.")
 
         self.languages = languages
 
         # Default value
-        # Convert a None default-value to the empty container that's expected if the bone is multiple or has languages
+        # Convert a None default-value to the empty container that's expected if the bone is
+        # multiple or has languages
         if defaultValue is None and self.languages:
             self.defaultValue = {}
         elif defaultValue is None and self.multiple:
             self.defaultValue = []
         else:
             self.defaultValue = defaultValue
 
@@ -152,52 +236,63 @@
             if not isinstance(unique, UniqueValue):
                 raise ValueError("Unique must be an instance of UniqueValue")
             if not self.multiple and unique.method.value != 1:
                 raise ValueError("'SameValue' is the only valid method on non-multiple bones")
 
         self.unique = unique
 
-        # Override some validations and value functions by parameter instead of subclassing
+        # Overwrite some validations and value functions by parameter instead of subclassing
         # todo: This can be done better and more straightforward.
         if vfunc:
             self.isInvalid = vfunc  # fixme: why is this called just vfunc, and not isInvalidValue/isInvalidValueFunc?
 
         if isEmptyFunc:
             self.isEmpty = isEmptyFunc  # fixme: why is this not called isEmptyValue/isEmptyValueFunc?
 
         if getEmptyValueFunc:
             self.getEmptyValue = getEmptyValueFunc
 
     def setSystemInitialized(self):
         """
-            Can be overridden to initialize properties that depend on the Skeleton system being initialized
+            Can be overridden to initialize properties that depend on the Skeleton system
+            being initialized
         """
         pass
 
     def isInvalid(self, value):
         """
-            Returns None if the value would be valid for
-            this bone, an error-message otherwise.
+            Checks if the current value of the bone in the given skeleton is invalid.
+            Returns None if the value would be valid for this bone, an error-message otherwise.
         """
         return False
 
-    def isEmpty(self, rawValue: Any) -> bool:
+    def isEmpty(self, value: Any) -> bool:
         """
             Check if the given single value represents the "empty" value.
             This usually is the empty string, 0 or False.
 
-            Warning: isEmpty takes precedence over isInvalid! The empty value is always valid - unless the bone
-                is required. But even then the empty value will be reflected back to the client.
+            .. warning:: isEmpty takes precedence over isInvalid! The empty value is always
+                valid - unless the bone is required.
+                But even then the empty value will be reflected back to the client.
 
-            Warning: rawValue might be the string/object received from the user (untrusted input!) or the value
-                returned by get
+            .. warning:: value might be the string/object received from the user (untrusted
+                input!) or the value returned by get
         """
-        return not bool(rawValue)
+        return not bool(value)
 
     def getDefaultValue(self, skeletonInstance):
+        """
+        Retrieves the default value for the bone.
+
+        This method is called by the framework to obtain the default value of a bone when no value
+        is provided. Derived bone classes can overwrite this method to implement their own logic for
+        providing a default value.
+
+        :return: The default value of the bone, which can be of any data type.
+    """
         if callable(self.defaultValue):
             return self.defaultValue(skeletonInstance, self)
         elif isinstance(self.defaultValue, list):
             return self.defaultValue[:]
         elif isinstance(self.defaultValue, dict):
             return self.defaultValue.copy()
         else:
@@ -207,20 +302,47 @@
         """
             Returns the value representing an empty field for this bone.
             This might be the empty string for str/text Bones, Zero for numeric bones etc.
         """
         return None
 
     def __setattr__(self, key, value):
+        """
+        Custom attribute setter for the BaseBone class.
+
+        This method is used to ensure that certain bone attributes, such as 'multiple', are only
+        set once during the bone's lifetime. Derived bone classes should not need to overwrite this
+        method unless they have additional attributes with similar constraints.
+
+        :param key: A string representing the attribute name.
+        :param value: The value to be assigned to the attribute.
+
+        :raises AttributeError: If a protected attribute is attempted to be modified after its initial
+            assignment.
+        """
         if not self.isClonedInstance and getSystemInitialized() and key != "isClonedInstance" and not key.startswith(
-            "_"):
+                "_"):
             raise AttributeError("You cannot modify this Skeleton. Grab a copy using .clone() first")
         super().__setattr__(key, value)
 
     def collectRawClientData(self, name, data, multiple, languages, collectSubfields):
+        """
+        Collects raw client data for the bone and returns it in a dictionary.
+
+        This method is called by the framework to gather raw data from the client, such as form data or data from a
+        request. Derived bone classes should overwrite this method to implement their own logic for collecting raw data.
+
+        :param name: A string representing the bone's name.
+        :param data: A dictionary containing the raw data from the client.
+        :param multiple: A boolean indicating whether the bone supports multiple values.
+        :param languages: An optional list of strings representing the supported languages (default: None).
+        :param collectSubfields: A boolean indicating whether to collect data for subfields (default: False).
+
+        :return: A dictionary containing the collected raw client data.
+        """
         fieldSubmitted = False
         if languages:
             res = {}
             for lang in languages:
                 if not collectSubfields:
                     if "%s.%s" % (name, lang) in data:
                         fieldSubmitted = True
@@ -263,15 +385,15 @@
                             fieldSubmitted = True
                             partKey = key.replace(prefix, "")
                             tmpDict[partKey] = value
                         res[lang] = tmpDict
             return res, fieldSubmitted
         else:  # No multi-lang
             if not collectSubfields:
-                if name not in data:  ## Empty!
+                if name not in data:  # Empty!
                     return None, False
                 val = data[name]
                 if multiple and not isinstance(val, list):
                     return [val], True
                 elif not multiple and isinstance(val, list):
                     if val:
                         return val[0], True
@@ -310,38 +432,47 @@
                         fieldSubmitted = True
                         subKey = key.replace(prefix, "")
                         res[subKey] = value
                     return res, fieldSubmitted
 
     def parseSubfieldsFromClient(self) -> bool:
         """
-            Whenever this request should try to parse subfields submitted from the client.
-            Set only to true if you expect a list of dicts to be transmitted
+            Determines whether the function should parse subfields submitted by the client.
+            Set to True only when expecting a list of dictionaries to be transmitted.
         """
         return False
 
     def singleValueFromClient(self, value, skel, name, origData):
-        # The BaseBone will not read any data in fromClient. Use rawValueBone if needed.
+        """
+        Prevents the BaseBone from reading data using the fromClient method.
+        If needed, use the RawBone instead.
+        Derived bones should overwrite this method for proper data processing.
+
+        :param value: The value to be processed.
+        :param skel: The skeleton containing the bone.
+        :param name: The name of the bone.
+        :param origData: The original data from the client.
+
+        :return: A tuple containing the empty value and a list with a ReadFromClientError.
+        """
         return self.getEmptyValue(), [
             ReadFromClientError(ReadFromClientErrorSeverity.Invalid, "Will not read a BaseBone fromClient!")]
 
     def fromClient(self, skel: 'SkeletonInstance', name: str, data: dict) -> Union[None, List[ReadFromClientError]]:
         """
-            Reads a value from the client.
+        Reads a value from the client and stores it in the skeleton instance if it is valid for the bone.
 
-            If this value is valid for this bone,
-            store this value and return None.
-            Otherwise our previous value is
-            left unchanged and an error-message
-            is returned.
-
-            :param skel: The skeleton instance where the values should be loaded.
-            :param name: Our name in the skeleton
-            :param data: User-supplied request-data
-            :returns: None or a list of errors
+        This function reads a value from the client and processes it according to the bone's configuration.
+        If the value is valid for the bone, it stores the value in the skeleton instance and returns None.
+        Otherwise, the previous value remains unchanged, and a list of ReadFromClientError objects is returned.
+
+        :param skel: A SkeletonInstance object where the values should be loaded.
+        :param name: A string representing the bone's name.
+        :param data: A dictionary containing the raw data from the client.
+        :return: None if no errors occurred, otherwise a list of ReadFromClientError objects.
         """
         subFields = self.parseSubfieldsFromClient()
         parsedData, fieldSubmitted = self.collectRawClientData(name, data, self.multiple, self.languages, subFields)
         if not fieldSubmitted:
             return [ReadFromClientError(ReadFromClientErrorSeverity.NotSet, "Field not submitted")]
         errors = []
         isEmpty = True
@@ -409,38 +540,51 @@
             return [ReadFromClientError(ReadFromClientErrorSeverity.Empty, "Field not set")]
         if self.multiple and isinstance(self.multiple, MultipleConstraints):
             errors.extend(self.validateMultipleConstraints(skel, name))
         return errors or None
 
     def validateMultipleConstraints(self, skel: 'SkeletonInstance', name: str) -> List[ReadFromClientError]:
         """
-            Validates our value against our multiple constrains.
-            Returns a ReadFromClientError for each violation (eg. too many items and duplicates)
+        Validates the value of a bone against its multiple constraints and returns a list of ReadFromClientError
+        objects for each violation, such as too many items or duplicates.
+
+        :param skel: A SkeletonInstance object where the values should be validated.
+        :param name: A string representing the bone's name.
+        :return: A list of ReadFromClientError objects for each constraint violation.
         """
         res = []
         value = skel[name]
         constraints = self.multiple
         if constraints.minAmount and len(value) < constraints.minAmount:
             res.append(ReadFromClientError(ReadFromClientErrorSeverity.Invalid, "Too few items"))
         if constraints.maxAmount and len(value) > constraints.maxAmount:
             res.append(ReadFromClientError(ReadFromClientErrorSeverity.Invalid, "Too many items"))
         if constraints.preventDuplicates:
             if len(set(value)) != len(value):
                 res.append(ReadFromClientError(ReadFromClientErrorSeverity.Invalid, "Duplicate items"))
         return res
 
     def singleValueSerialize(self, value, skel: 'SkeletonInstance', name: str, parentIndexed: bool):
+        """
+            Serializes a single value of the bone for storage in the database.
+
+            Derived bone classes should overwrite this method to implement their own logic for serializing single
+            values.
+            The serialized value should be suitable for storage in the database.
+        """
         return value
 
     def serialize(self, skel: 'SkeletonInstance', name: str, parentIndexed: bool) -> bool:
         """
-            Serializes this bone into something we
-            can write into the datastore.
+        Serializes this bone into a format that can be written into the datastore.
 
-            :param name: The property-name this bone has in its Skeleton (not the description!)
+        :param skel: A SkeletonInstance object containing the values to be serialized.
+        :param name: A string representing the property name of the bone in its Skeleton (not the description).
+        :param parentIndexed: A boolean indicating whether the parent bone is indexed.
+        :return: A boolean indicating whether the serialization was successful.
         """
         if name in skel.accessedValues:
             newVal = skel.accessedValues[name]
             if self.languages and self.multiple:
                 res = db.Entity()
                 res["_viurLanguageWrapper_"] = True
                 for language in self.languages:
@@ -477,28 +621,37 @@
                 skel.dbEntity.exclude_from_indexes.discard(name)
             elif not indexed and name not in skel.dbEntity.exclude_from_indexes:
                 skel.dbEntity.exclude_from_indexes.add(name)
             return True
         return False
 
     def singleValueUnserialize(self, val):
+        """
+            Unserializes a single value of the bone from the stored database value.
+
+            Derived bone classes should overwrite this method to implement their own logic for unserializing
+            single values. The unserialized value should be suitable for use in the application logic.
+        """
         return val
 
     def unserialize(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> bool:
         """
-            Inverse of serialize. Evaluates whats
-            read from the datastore and populates
-            this bone accordingly.
+        Deserialize bone data from the datastore and populate the bone with the deserialized values.
 
-            :param name: The property-name this bone has in its Skeleton (not the description!)
+        This function is the inverse of the serialize function. It converts data from the datastore
+        into a format that can be used by the bones in the skeleton.
+
+        :param skel: A SkeletonInstance object containing the values to be deserialized.
+        :param name: The property name of the bone in its Skeleton (not the description).
+        :returns: True if deserialization is successful, False otherwise.
         """
         if name in skel.dbEntity:
             loadVal = skel.dbEntity[name]
         elif conf.get("viur.viur2import.blobsource") and any(
-            [x.startswith("%s." % name) for x in skel.dbEntity.keys()]):
+                [x.startswith("%s." % name) for x in skel.dbEntity.keys()]):
             # We're importing from an old ViUR2 instance - there may only be keys prefixed with our name
             loadVal = None
         else:
             skel.accessedValues[name] = self.getDefaultValue(skel)
             return False
         if self.languages and self.multiple:
             res = {}
@@ -587,17 +740,16 @@
                       rawFilter: Dict,
                       prefix: Optional[str] = None) -> db.Query:
         """
             Parses the searchfilter a client specified in his Request into
             something understood by the datastore.
             This function must:
 
-                * Ignore all filters not targeting this bone
-                * Safely handle malformed data in rawFilter
-                    (this parameter is directly controlled by the client)
+                * - Ignore all filters not targeting this bone
+                * - Safely handle malformed data in rawFilter (this parameter is directly controlled by the client)
 
             :param name: The property-name this bone has in its Skeleton (not the description!)
             :param skel: The :class:`viur.core.db.Query` this bone is part of
             :param dbFilter: The current :class:`viur.core.db.Query` instance the filters should be applied to
             :param rawFilter: The dictionary of filters the client wants to have applied
             :returns: The modified :class:`viur.core.db.Query`
         """
@@ -637,20 +789,21 @@
                     name: str,
                     skel: 'viur.core.skeleton.SkeletonInstance',
                     dbFilter: db.Query,
                     rawFilter: Dict) -> Optional[db.Query]:
         """
             Same as buildDBFilter, but this time its not about filtering
             the results, but by sorting them.
-            Again: rawFilter is controlled by the client, so you *must* expect and safely hande
+            Again: rawFilter is controlled by the client, so you *must* expect and safely handle
             malformed data!
 
             :param name: The property-name this bone has in its Skeleton (not the description!)
             :param skel: The :class:`viur.core.skeleton.Skeleton` instance this bone is part of
-            :param dbFilter: The current :class:`viur.core.db.Query` instance the filters should be applied to
+            :param dbFilter: The current :class:`viur.core.db.Query` instance the filters should
+                be applied to
             :param rawFilter: The dictionary of filters the client wants to have applied
             :returns: The modified :class:`viur.core.db.Query`,
                 None if the query is unsatisfiable.
         """
         if "orderby" in rawFilter and rawFilter["orderby"] == name:
             if "orderdir" in rawFilter and rawFilter["orderdir"] == "1":
                 order = (rawFilter["orderby"], db.SortOrder.Descending)
@@ -682,14 +835,26 @@
                 else:
                     dbFilter.order(order)
             else:
                 dbFilter.order(order)
         return dbFilter
 
     def _hashValueForUniquePropertyIndex(self, value: Union[str, int]) -> List[str]:
+        """
+        Generates a hash of the given value for creating unique property indexes.
+
+        This method is called by the framework to create a consistent hash representation of a value
+        for constructing unique property indexes. Derived bone classes should overwrite this method to
+        implement their own logic for hashing values.
+
+        :param value: The value to be hashed, which can be a string, integer, or a float.
+
+        :return: A list containing a string representation of the hashed value. If the bone is multiple,
+                the list may contain more than one hashed value.
+        """
         def hashValue(value: Union[str, int]) -> str:
             h = hashlib.sha256()
             h.update(str(value).encode("UTF-8"))
             res = h.hexdigest()
             if isinstance(value, int) or isinstance(value, float):
                 return "I-%s" % res
             elif isinstance(value, str):
@@ -720,31 +885,40 @@
             # We should ignore the sort-order; so simply sort that List
             tmpList.sort()
         # Lock the value for that specific list
         return [hashValue(", ".join(tmpList))]
 
     def getUniquePropertyIndexValues(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> List[str]:
         """
-            Returns a list of hashes for our current value(s), used to store in the uniquePropertyValue index.
+        Returns a list of hashes for the current value(s) of a bone in the skeleton, used for storing in the
+        unique property value index.
+
+        :param skel: A SkeletonInstance object representing the current skeleton.
+        :param name: The property-name of the bone in the skeleton for which the unique property index values
+                    are required (not the description!).
+
+        :return: A list of strings representing the hashed values for the current bone value(s) in the skeleton.
+                If the bone has no value, an empty list is returned.
         """
         val = skel[name]
         if val is None:
             return []
         return self._hashValueForUniquePropertyIndex(val)
 
     def getReferencedBlobs(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> Set[str]:
         """
         Returns a set of blob keys referenced from this bone
         """
         return set()
 
     def performMagic(self, valuesCache: Dict, name: str, isAdd: bool):
         """
-            This function applies "magically" functionality which f.e. inserts the current Date or the current user.
-            :param isAdd: Signals whereever this is an add or edit operation.
+            This function applies "magically" functionality which f.e. inserts the current Date
+            or the current user.
+            :param isAdd: Signals wherever this is an add or edit operation.
         """
         pass  # We do nothing by default
 
     def postSavedHandler(self, skel: 'viur.core.skeleton.SkeletonInstance', boneName: str, key: str):
         """
             Can be overridden to perform further actions after the main entity has been written.
 
@@ -768,15 +942,25 @@
         """
             Refresh all values we might have cached from other entities.
         """
         pass
 
     def mergeFrom(self, valuesCache: Dict, boneName: str, otherSkel: 'viur.core.skeleton.SkeletonInstance'):
         """
-            Clones the values from other into this instance
+        Merges the values from another skeleton instance into the current instance, given that the bone types match.
+
+        :param valuesCache: A dictionary containing the cached values for each bone in the skeleton.
+        :param boneName: The property-name of the bone in the skeleton whose values are to be merged.
+        :param otherSkel: A SkeletonInstance object representing the other skeleton from which the values \
+            are to be merged.
+
+        This function clones the values from the specified bone in the other skeleton instance into the current
+        instance, provided that the bone types match. If the bone types do not match, a warning is logged, and the merge
+        is ignored. If the bone in the other skeleton has no value, the function returns without performing any merge
+        operation.
         """
         if getattr(otherSkel, boneName) is None:
             return
         if not isinstance(getattr(otherSkel, boneName), type(self)):
             logging.error("Ignoring values from conflicting boneType (%s is not a instance of %s)!" % (
                 getattr(otherSkel, boneName), type(self)))
             return
@@ -785,25 +969,30 @@
     def setBoneValue(self,
                      skel: 'SkeletonInstance',
                      boneName: str,
                      value: Any,
                      append: bool,
                      language: Union[None, str] = None) -> bool:
         """
-            Set our value to 'value'.
-            Santy-Checks are performed; if the value is invalid, no modification will happen.
-
-            :param skel: Dictionary with the current values from the skeleton we belong to
-            :param boneName: The Bone which should be modified
-            :param value: The value that should be assigned. It's type depends on the type of that bone
-            :param append: If true, the given value is appended to the values of that bone instead of
-                replacing it. Only supported on bones with multiple=True
-            :param language: Set/append which language
-            :return: Wherever that operation succeeded or not.
+        Sets the value of a bone in a skeleton instance, with optional support for appending and language-specific
+        values. Sanity checks are being performed.
 
+        :param skel: The SkeletonInstance object representing the skeleton to which the bone belongs.
+        :param boneName: The property-name of the bone in the skeleton whose value should be set or modified.
+        :param value: The value to be assigned. Its type depends on the type of the bone.
+        :param append: If True, the given value is appended to the bone's values instead of replacing it. \
+            Only supported for bones with multiple=True.
+        :param language: The language code for which the value should be set or appended, \
+            if the bone supports languages.
+
+        :return: A boolean indicating whether the operation was successful or not.
+
+        This function sets or modifies the value of a bone in a skeleton instance, performing sanity checks to ensure
+        the value is valid. If the value is invalid, no modification occurs. The function supports appending values to
+        bones with multiple=True and setting or appending language-specific values for bones that support languages.
         """
         assert not (bool(self.languages) ^ bool(language)), "Language is required or not supported"
         assert not append or self.multiple, "Can't append - bone is not multiple"
 
         if not append and self.multiple:
             # set multiple values at once
             val = []
@@ -833,39 +1022,54 @@
                 skel[boneName] = []
             skel[boneName].append(val)
         else:  # Just language
             skel[boneName][language] = val
         return True
 
     def getSearchTags(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> Set[str]:
-        """Returns a set of strings as search index for this bone.
+        """
+        Returns a set of strings as search index for this bone.
 
-        :param skel: The skeleton instance where the values should be loaded from.
-        :param name: The name of the bone.
-        :return: A list of strings, extracted from the bone value
+        This function extracts a set of search tags from the given bone's value in the skeleton
+        instance. The resulting set can be used for indexing or searching purposes.
+
+        :param skel: The skeleton instance where the values should be loaded from. This is an instance
+            of a class derived from `viur.core.skeleton.SkeletonInstance`.
+        :param name: The name of the bone, which is a string representing the key for the bone in
+            the skeleton. This should correspond to an existing bone in the skeleton instance.
+        :return: A set of strings, extracted from the bone value. If the bone value doesn't have
+            any searchable content, an empty set is returned.
         """
         return set()
 
     def iter_bone_value(
         self, skel: 'viur.core.skeleton.SkeletonInstance', name: str
     ) -> Iterator[Tuple[Optional[int], Optional[str], Any]]:
-        """Yield all values from the Skeleton related to this bone instance.
+        """
+        Yield all values from the Skeleton related to this bone instance.
 
-        This method handles the multiple/languages cases, which could save
-        a lot of if/elifs.
-        It yields always a triplet: index, language, value
+        This method handles multiple/languages cases, which could save a lot of if/elifs.
+        It always yields a triplet: index, language, value.
         Where index is the index (int) of a value inside a multiple bone,
-        language the language (str) of a multi-language-bone
-        and value the value inside this container.
+        language is the language (str) of a multi-language-bone,
+        and value is the value inside this container.
         index or language is None if the bone is single or not multi-lang.
 
-        :param skel: The skeleton instance where the values should be loaded from.
-        :param name: The name of the bone.
+        This function can be used to conveniently iterate through all the values of a specific bone
+        in a skeleton instance, taking into account multiple and multi-language bones.
 
-        :return: A generator which yields triplets.
+        :param skel: The skeleton instance where the values should be loaded from. This is an instance
+            of a class derived from `viur.core.skeleton.SkeletonInstance`.
+        :param name: The name of the bone, which is a string representing the key for the bone in
+            the skeleton. This should correspond to an existing bone in the skeleton instance.
+
+        :return: A generator which yields triplets (index, language, value), where index is the index
+            of a value inside a multiple bone, language is the language of a multi-language bone,
+            and value is the value inside this container. index or language is None if the bone is
+            single or not multi-lang.
         """
         value = skel[name]
         if not value:
             return None
 
         if self.languages and isinstance(value, dict):
             for idx, (lang, values) in enumerate(value.items()):
```

## viur/core/bones/boolean.py

```diff
@@ -1,13 +1,25 @@
+"""
+    The BooleanBone class represents a boolean data type, which can have two possible values: True or False.
+    It is a subclass of the BaseBone class and is used in the context of the ViUR web application framework.
+"""
 from viur.core.bones.base import BaseBone, ReadFromClientError, ReadFromClientErrorSeverity
 from viur.core import db, conf
 from typing import Dict, List, Optional, Any, Union
 
 
 class BooleanBone(BaseBone):
+    """
+    Represents a boolean data type, which can have two possible values: `True` or `False`.
+    BooleanBones cannot be defined as `multiple=True`.
+
+    :param defaultValue: The default value of the `BooleanBone` instance. Defaults to `False`.
+    :type defaultValue: bool
+    :raises ValueError: If the `defaultValue` is not a boolean value (`True` or `False`).
+    """
     type = "bool"
 
     def __init__(
         self,
         *,
         defaultValue: Union[
             bool,
@@ -27,24 +39,53 @@
             # We have given an explicit defaultValue and maybe a complex structure
             if not (kwargs.get("multiple") or kwargs.get("languages")) and not isinstance(defaultValue, bool):
                 raise TypeError("Only 'True' or 'False' can be provided as BooleanBone defaultValue")
             # TODO: missing validation for complex types, but in other bones too
 
         super().__init__(defaultValue=defaultValue, **kwargs)
 
+        # Disallow creation of BooleanBone(multiple=True)
+        if self.multiple:
+            raise ValueError("BooleanBone cannot be multiple")
+
     def singleValueFromClient(self, value, skel: 'viur.core.skeleton.SkeletonInstance', name: str, origData):
+        """
+        Converts a value received from a client into a boolean value.
+
+        :param value: The value received from the client.
+        :param skel: The `SkeletonInstance` object representing the data of the current entity.
+        :param name: The name of the `BooleanBone` instance.
+        :param origData: The original data received from the client.
+
+        :return: A tuple containing the boolean value and `None`.
+        :rtype: Tuple[bool, None]
+        """
         return str(value).strip().lower() in conf["viur.bone.boolean.str2true"], None
 
     def getEmptyValue(self):
+        """
+        Returns the empty value of the `BooleanBone` class, which is `False`.
+
+        :return: The empty value of the `BooleanBone` class (`False`).
+        :rtype: bool
+        """
         return False
 
-    def isEmpty(self, rawValue: Any):
-        if rawValue is self.getEmptyValue():
+    def isEmpty(self, value: Any):
+        """
+        Checks if the given boolean value is empty.
+
+        :param value: The boolean value to be checked.
+        :return: `True` if the boolean value is empty (i.e., equal to the empty value of the `BooleanBone` class), \
+            `False` otherwise.
+        :rtype: bool
+        """
+        if value is self.getEmptyValue():
             return True
-        return not bool(rawValue)
+        return not bool(value)
 
     def refresh(self, skel: 'viur.core.skeleton.SkeletonInstance', boneName: str) -> None:
         """
             Inverse of serialize. Evaluates whats
             read from the datastore and populates
             this bone accordingly.
 
@@ -57,12 +98,23 @@
         self,
         name: str,
         skel: 'viur.core.skeleton.SkeletonInstance',
         dbFilter: db.Query,
         rawFilter: Dict,
         prefix: Optional[str] = None
     ) -> db.Query:
+        """
+        Builds a database filter based on the boolean value.
+
+        :param name: The name of the `BooleanBone` instance.
+        :param skel: The `SkeletonInstance` object representing the data of the current entity.
+        :param dbFilter: The `Query` object representing the current database filter.
+        :param rawFilter: The dictionary representing the raw filter data received from the client.
+        :param prefix: A prefix to be added to the property name in the database filter.
+        :return: The updated `Query` object representing the updated database filter.
+        :rtype: google.cloud.ndb.query.Query
+        """
         if name in rawFilter:
             val = str(rawFilter[name]).strip().lower() in conf["viur.bone.boolean.str2true"]
             return super().buildDBFilter(name, skel, dbFilter, {name: val}, prefix=prefix)
 
         return dbFilter
```

## viur/core/bones/captcha.py

```diff
@@ -1,33 +1,56 @@
+"""
+The CaptchaBone is used to ensure that a user is not a bot. The Captcha bone uses the Google reCAPTCHA API
+to perform the Captcha validation and is derived from the BaseBone.
+"""
+
 import json
 import urllib.parse
 import urllib.request
 from typing import List, Union
 from viur.core import utils, conf, current
 from viur.core.bones.base import BaseBone, ReadFromClientError, ReadFromClientErrorSeverity
 
 
 class CaptchaBone(BaseBone):
+    """
+    The CaptchaBone uses the Google reCAPTCHA API to perform the Captcha validation.
+
+    :param publicKey: The public key for the Captcha validation.
+    :param privateKey: The private key for the Captcha validation.
+    :param **kwargs: Additional arguments to pass to the base class constructor.
+    """
     type = "captcha"
 
     def __init__(self, *, publicKey=None, privateKey=None, **kwargs):
         super().__init__(**kwargs)
         self.defaultValue = self.publicKey = publicKey
         self.privateKey = privateKey
         if not self.defaultValue and not self.privateKey:
             # Merge these values from the side-wide configuration if set
             if conf["viur.security.captcha.defaultCredentials"]:
                 self.defaultValue = self.publicKey = conf["viur.security.captcha.defaultCredentials"]["sitekey"]
                 self.privateKey = conf["viur.security.captcha.defaultCredentials"]["secret"]
         self.required = True
 
     def serialize(self, skel: 'SkeletonInstance', name: str, parentIndexed: bool) -> bool:
+        """
+        Serializing the Captcha bone is not possible so it return False
+        """
         return False
 
     def unserialize(self, skel, name) -> bool:
+        """
+        Unserialize the Captcha bone.
+
+        :param skel: The SkeletonInstance containing the Captcha bone.
+        :param name: The name of the Captcha bone.
+
+        :returns: boolean, that is true, as the Captcha bone is always unserialized successfully.
+        """
         skel.accessedValues[name] = self.publicKey
         return True
 
     def fromClient(self, skel: 'SkeletonInstance', name: str, data: dict) -> Union[None, List[ReadFromClientError]]:
         """
             Reads a value from the client.
             If this value is valid for this bone,
```

## viur/core/bones/color.py

```diff
@@ -1,21 +1,45 @@
+"""
+The class ColorBone is used to store color values. It inherits from the BaseBone class.
+"""
 from viur.core.bones.base import BaseBone, ReadFromClientError, ReadFromClientErrorSeverity
 from typing import List, Union
 import logging
 
 
 class ColorBone(BaseBone):
+    """
+    ColorBone is a custom bone class for storing color values in the ViUR framework.
+    It inherits from the BaseBone class in the viur.core.bones.base module.
+
+    :param type: A string representing the bone type, set to "color".
+    :param mode: A string specifying the color mode, either "rgb" or "rgba". Default is "rgb".
+    :param **kwargs: Additional keyword arguments passed to the BaseBone constructor.
+    """
     type = "color"
 
     def __init__(self, *, mode="rgb", **kwargs):  # mode rgb/rgba
         super().__init__(**kwargs)
         assert mode in {"rgb", "rgba"}
         self.mode = mode
 
     def singleValueFromClient(self, value, skel: 'viur.core.skeleton.SkeletonInstance', name: str, origData):
+        """
+        Processes a single value from the client, ensuring it is a valid color value,
+        and returns a tuple containing the processed value and any errors that occurred.
+
+        :param value: The value to be processed.
+        :param skel: The skeleton instance associated with the value.
+        :param name: The name of the bone.
+        :param origData: The original data for the bone.
+
+        :return tuple: A tuple containing the processed value if valid,
+            or the empty value if invalid, and a list of ReadFromClientError instances
+            if there were errors, or None if no errors occurred.
+        """
         value = value.lower()
         if value.count("#") > 1:
             return self.getEmptyValue(), [
                 ReadFromClientError(ReadFromClientErrorSeverity.Invalid, "Invalid value entered")]
         for char in value:
             if not char in "#0123456789abcdef":
                 return self.getEmptyValue(), [
```

## viur/core/bones/credential.py

```diff
@@ -1,53 +1,98 @@
+"""
+A bone for storing credentials.
+
+This bone is designed to store sensitive information like passwords, API keys, or other secret
+strings. It ensures that the stored value is always empty when read from the database. When saved,
+the value is only updated in the database if it is non-empty.
+"""
+
 from viur.core.bones.base import ReadFromClientError, ReadFromClientErrorSeverity
 from viur.core.bones.string import StringBone
 
 
 class CredentialBone(StringBone):
     """
-        A bone for storing credentials.
+        A bone for storing credentials. This bone is designed to store sensitive information like
+        passwords, API keys, or other secret strings.
         This is always empty if read from the database.
         If its saved, its ignored if its values is still empty.
         If its value is not empty, it will update the value in the database
+
+        :ivar str type: The type identifier of the bone, set to "str.credential".
+
     """
     type = "str.credential"
 
     def __init__(
         self,
         *,
         maxLength: int = None,  # Unlimited length
         **kwargs
     ):
         super().__init__(maxLength=maxLength, **kwargs)
         if self.multiple or self.languages:
-            raise ValueError("Credential-Bones cannot be multiple or translated!")
+            raise ValueError("CredentialBone cannot be multiple or translated")
 
     def isInvalid(self, value):
         """
             Returns None if the value would be valid for
             this bone, an error-message otherwise.
         """
         if value is None:
             return False
         if self.maxLength is not None and len(value) > self.maxLength:
             return "Maximum length exceeded"
 
     def serialize(self, skel: 'SkeletonInstance', name: str, parentIndexed: bool) -> bool:
         """
-            Update the value only if a new value is supplied.
+        Serializes the bone's value for storage.
+
+        Updates the value in the database only if a new value is supplied. Ensures the value is
+        never indexed.
+
+        :param skel: The skeleton instance that the bone is part of.
+        :type skel: SkeletonInstance
+        :param str name: The name of the bone attribute.
+        :param bool parentIndexed: Indicates whether the parent entity is indexed.
+        :return: True if the value was updated in the database, False otherwise.
+        :rtype: bool
         """
         skel.dbEntity.exclude_from_indexes.add(name)  # Ensure we are never indexed
         if name in skel.accessedValues and skel.accessedValues[name]:
             skel.dbEntity[name] = skel.accessedValues[name]
             return True
         return False
 
     def unserialize(self, valuesCache, name):
         """
-            We'll never read our value from the database.
+        Unserializes the bone's value from storage.
+
+        This method always returns an empty dictionary as the CredentialBone's value is always empty when read from
+        the database.
+
+        :param dict valuesCache: A dictionary containing the serialized values from the datastore.
+        :param str name: The name of the bone attribute.
+        :return: An empty dictionary, as the CredentialBone's value is always empty when read from the database.
+        :rtype: dict
         """
         return {}
 
     def singleValueFromClient(self, value, skel, name, origData):
+        """
+        Processes the value received from the client.
+
+        Returns the escaped value if it is valid, or the empty value and an error if the value is invalid.
+
+        :param value: The value received from the client.
+        :param skel: The skeleton instance that the bone is part of.
+        :type skel: SkeletonInstance
+        :param str name: The name of the bone attribute.
+        :param origData: The original data received from the client.
+        :return: A tuple containing the escaped value and None if the value is valid, or the empty value and a
+            ReadFromClientError if the value is invalid.
+        :rtype: tuple
+        """
         if not (err := self.isInvalid(value)):
             return value, None
+
         return self.getEmptyValue(), [ReadFromClientError(ReadFromClientErrorSeverity.Invalid, err)]
```

## viur/core/bones/date.py

```diff
@@ -1,19 +1,35 @@
+"""
+DateBone is a bone that can handle date and/or time information and is derived from the BaseBone class. It can
+store date and time information separately, as well as localize the time based on user's timezone.
+"""
 from datetime import datetime, timedelta, timezone
 from typing import Dict, Optional
 
 import pytz
 import tzlocal
 
 from viur.core import conf, current, db
 from viur.core.bones.base import BaseBone, ReadFromClientError, ReadFromClientErrorSeverity
 from viur.core.utils import utcNow
 
 
 class DateBone(BaseBone):
+    """
+    DateBone is a bone that can handle date and/or time information. It can store date and time information
+    separately, as well as localize the time based on the user's timezone.
+
+    :param bool creationMagic: Use the current time as value when creating an entity; ignoring this bone if the
+        entity gets updated.
+    :param bool updateMagic: Use the current time whenever this entity is saved.
+    :param bool date: If True, the bone will contain date information.
+    :param time: If True, the bone will contain time information.
+    :param localize: If True, the user's timezone is assumed for input and output. This is only valid if both 'date'
+          and 'time' are set to True. By default, UTC time is used.
+    """
     type = "date"
 
     def __init__(
         self,
         *,
         creationMagic: bool = False,
         date: bool = True,
@@ -63,48 +79,61 @@
         self.date = date
         self.time = time
         self.localize = localize
         self.naive = naive
 
     def singleValueFromClient(self, value: str, skel: 'viur.core.skeleton.SkeletonInstance', name: str, origData):
         """
-            Reads a value from the client.
-            If this value is valid for this bone,
-            store this value and return None.
-            Otherwise our previous value is
-            left unchanged and an error-message
-            is returned.
-
-            Value is assumed to be in local time zone only if both self.date and self.time are set to True
-            and self.localize is True.
-
-            Value is valid if, when converted into String, it complies following formats:\n
-            - is digit (may include one '-') and valid POSIX timestamp: converted from timestamp; assumes UTC timezone\n
-            - is digit (may include one '-') and NOT valid POSIX timestamp and not date and time: interpreted as seconds after epoch\n
-            - 'now': current time\n
-            - 'nowX', where X converted into String is added as seconds to current time\n
-            - '%H:%M:%S' if not date and time\n
-            - '%M:%S' if not date and time\n
-            - '%S' if not date and time\n
-            - '%Y-%m-%d %H:%M:%S' (ISO date format)\n
-            - '%Y-%m-%d %H:%M' (ISO date format)\n
-            - '%Y-%m-%d' (ISO date format)\n
-            - '%m/%d/%Y %H:%M:%S' (US date-format)\n
-            - '%m/%d/%Y %H:%M' (US date-format)\n
-            - '%m/%d/%Y' (US date-format)\n
-            - '%d.%m.%Y %H:%M:%S' (EU date-format)\n
-            - '%d.%m.%Y %H:%M' (EU date-format)\n
-            - '%d.%m.%Y' (EU date-format)\n
-            -  \n
-
-            The resulting year must be >= 1900.
-
-            :param name: Our name in the skeleton
-            :param value: *User-supplied* request-data, has to be of valid format
-            :returns: tuple[datetime or None, [Errors] or None]
+        Reads a value from the client. If the value is valid for this bone, it stores the value and returns None.
+        Otherwise, the previous value is left unchanged, and an error message is returned.
+
+        The value is assumed to be in the local time zone only if both self.date and self.time are set to True and
+        self.localize is True.
+
+            **Value is valid if, when converted into String, it complies following formats:**
+                is digit (may include one '-') and valid POSIX timestamp: converted from timestamp;
+                assumes UTC timezone
+
+                is digit (may include one '-') and NOT valid POSIX timestamp and not date and time: interpreted as
+                seconds after epoch
+
+                'now': current time
+
+                'nowX', where X converted into String is added as seconds to current time
+
+                '%H:%M:%S' if not date and time
+
+                '%M:%S' if not date and time
+
+                '%S' if not date and time
+
+                '%Y-%m-%d %H:%M:%S' (ISO date format)
+
+                '%Y-%m-%d %H:%M' (ISO date format)
+
+                '%Y-%m-%d' (ISO date format)
+
+                '%m/%d/%Y %H:%M:%S' (US date-format)
+
+                '%m/%d/%Y %H:%M' (US date-format)
+
+                '%m/%d/%Y' (US date-format)
+
+                '%d.%m.%Y %H:%M:%S' (EU date-format)
+
+                '%d.%m.%Y %H:%M' (EU date-format)
+
+                '%d.%m.%Y' (EU date-format)
+
+
+        The resulting year must be >= 1900.
+
+        :param str name: Our name in the skeleton
+        :param str value: *User-supplied* request-data, has to be of valid format
+        :returns: tuple[datetime or None, [Errors] or None]
         """
         time_zone = self.guessTimeZone()
         rawValue = value
         if str(rawValue).replace("-", "", 1).replace(".", "", 1).isdigit():
             if int(rawValue) < -1 * (2 ** 30) or int(rawValue) > (2 ** 31) - 2:
                 value = False  # its invalid
             else:
@@ -181,28 +210,41 @@
         if err := self.isInvalid(value):
             return self.getEmptyValue(), [ReadFromClientError(ReadFromClientErrorSeverity.Invalid, err)]
 
         return value, None
 
     def isInvalid(self, value):
         """
-            Ensure that year is >= 1900
-            Otherwise strftime will break later on.
+        Validates the input value to ensure that the year is greater than or equal to 1900. If the year is less
+        than 1900, it returns an error message. Otherwise, it calls the superclass's isInvalid method to perform
+        any additional validations.
+
+        This check is important because the strftime function, which is used to format dates in Python, will
+        break if the year is less than 1900.
+
+        :param datetime value: The input value to be validated, expected to be a datetime object.
+
+        :returns: An error message if the year is less than 1900, otherwise the result of calling
+            the superclass's isInvalid method.
+        :rtype: str or None
         """
         if isinstance(value, datetime):
             if value.year < 1900:
                 return "Year must be >= 1900"
 
         return super().isInvalid(value)
 
     def guessTimeZone(self):
         """
-        Guess the timezone the user is supposed to be in.
-        If not both date and time are set and the localize flag is set, then UTC is used.
-        If it cant be guessed, a safe default (UTC) is used
+        Tries to guess the user's time zone based on request headers. If the time zone cannot be guessed, it
+        falls back to using the UTC time zone. The guessed time zone is then cached for future use during the
+        current request.
+
+        :returns: The guessed time zone for the user or a default time zone (UTC) if the time zone cannot be guessed.
+        :rtype: pytz timezone object
         """
         if self.naive:
             return None
         if not (self.date and self.time and self.localize):
             return pytz.utc
 
         if conf["viur.instance.is_dev_server"]:
@@ -233,28 +275,49 @@
             timeZone = pytz.timezone("Australia/Canberra")  # Equivalent to NSW/Sydney :)
         else:  # The user is in a Country which has more than one timezone
             pass
         currReqData["timeZone"] = timeZone  # Cache the result
         return timeZone
 
     def singleValueSerialize(self, value, skel: 'SkeletonInstance', name: str, parentIndexed: bool):
+        """
+        Prepares a single value for storage by removing any unwanted parts of the datetime object, such as
+        microseconds or adjusting the date and time components depending on the configuration of the dateBone.
+        The method also ensures that the datetime object is timezone aware.
+
+        :param datetime value: The input datetime value to be serialized.
+        :param SkeletonInstance skel: The instance of the skeleton that contains this bone.
+        :param str name: The name of the bone in the skeleton.
+        :param bool parentIndexed: A boolean indicating if the parent bone is indexed.
+        :returns: The serialized datetime value with unwanted parts removed and timezone-aware.
+        :rtype: datetime
+        """
         if value:
             # Crop unwanted values to zero
             value = value.replace(microsecond=0)
             if not self.time:
                 value = value.replace(hour=0, minute=0, second=0)
             elif not self.date:
                 value = value.replace(year=1970, month=1, day=1)
             if self.naive:
                 value = value.replace(tzinfo=timezone.utc)
             # We should always deal with timezone aware datetimes
             assert value.tzinfo, "Encountered a naive Datetime object in %s - refusing to save." % name
         return value
 
     def singleValueUnserialize(self, value):
+        """
+        Converts the serialized datetime value back to its original form. If the datetime object is timezone aware,
+        it adjusts the timezone based on the configuration of the dateBone.
+
+        :param datetime value: The input serialized datetime value to be unserialized.
+        :returns: The unserialized datetime value with the appropriate timezone applied or None if the input
+            value is not a valid datetime object.
+        :rtype: datetime or None
+        """
         if isinstance(value, datetime):
             # Serialized value is timezone aware.
             if self.naive:
                 value = value.replace(tzinfo=None)
                 return value
             else:
                 # If local timezone is needed, set here, else force UTC.
@@ -266,22 +329,43 @@
 
     def buildDBFilter(self,
                       name: str,
                       skel: 'viur.core.skeleton.SkeletonInstance',
                       dbFilter: db.Query,
                       rawFilter: Dict,
                       prefix: Optional[str] = None) -> db.Query:
+        """
+        Constructs a datastore filter for date and/or time values based on the given raw filter. It parses the
+        raw filter and, if successful, applies it to the datastore query.
+
+        :param str name: The name of the dateBone in the skeleton.
+        :param SkeletonInstance skel: The skeleton instance containing the dateBone.
+        :param db.Query dbFilter: The datastore query to which the filter will be applied.
+        :param Dict rawFilter: The raw filter dictionary containing the filter values.
+        :param Optional[str] prefix: An optional prefix to use for the filter key, defaults to None.
+        :returns: The datastore query with the constructed filter applied.
+        :rtype: db.Query
+        """
         for key in [x for x in rawFilter.keys() if x.startswith(name)]:
             resDict = {}
             if not self.fromClient(resDict, key, rawFilter):  # Parsing succeeded
                 super().buildDBFilter(name, skel, dbFilter, {key: resDict[key]}, prefix=prefix)
 
         return dbFilter
 
     def performMagic(self, valuesCache, name, isAdd):
+        """
+        Automatically sets the current date and/or time for a dateBone when a new entry is created or an
+        existing entry is updated, depending on the configuration of creationMagic and updateMagic.
+
+        :param dict valuesCache: The cache of values to be stored in the datastore.
+        :param str name: The name of the dateBone in the skeleton.
+        :param bool isAdd: A flag indicating whether the operation is adding a new entry (True) or updating an
+            existing one (False).
+        """
         if (self.creationMagic and isAdd) or self.updateMagic:
             if self.naive:
                 valuesCache[name] = utcNow().replace(microsecond=0, tzinfo=None)
             else:
                 valuesCache[name] = utcNow().replace(microsecond=0).astimezone(self.guessTimeZone())
 
     def structure(self) -> dict:
```

## viur/core/bones/email.py

```diff
@@ -1,16 +1,44 @@
+"""
+The EmailBone class is a subclass of the StringBone class, designed for validating email addresses in the ViUR
+framework. This class provides an email validation method, ensuring that the given email address conforms to the
+required format and structure.
+"""
 from viur.core.bones.string import StringBone
 from encodings import idna
 import string
 
 
 class EmailBone(StringBone):
+    """
+    This Bone is responsible for validating email addresses. It' a subclass of the StringBone class.
+    """
     type = "str.email"
+    """
+      A string representing the type of the bone, in this case "str.email".
+    """
 
     def isInvalid(self, value):
+        """
+        Checks if the provided email address is valid or not.
+
+        :param str value: The email address to be validated.
+        :returns: An error message if the email address is invalid or None if it is valid.
+        :rtype: str, None
+
+        The method checks if the provided email address is valid according to the following criteria:
+
+        1. The email address must not be empty.
+        2. The email address must be shorter than 256 characters.
+        3. The local part (account) must be shorter than or equal to 64 characters.
+        4. The email address must contain an "@" symbol, separating the local part (account) and the domain part.
+        5. The domain part must be a valid IDNA-encoded string and should not contain any spaces.
+        6. The local part (account) should only contain valid characters.
+        7. The local part (account) can also contain Unicode characters within the range of U+0080 to U+10FFFF.
+        """
         if not value:
             return "No value entered"
         try:
             assert len(value) < 256
             account, domain = value.split(u"@")
             subDomain, tld = domain.rsplit(".", 1)
             assert account and subDomain and tld
```

## viur/core/bones/file.py

```diff
@@ -1,25 +1,43 @@
+"""
+The FileBone is a subclass of the TreeLeafBone class, which is a relational bone that can reference
+another entity's fields. FileBone provides additional file-specific properties and methods, such as
+managing file derivatives, handling file size and mime type restrictions, and refreshing file
+metadata.
+"""
+
 import logging
 from hashlib import sha256
 from time import time
 from typing import Any, Dict, List, Set, Union
 
 from viur.core import conf, db
 from viur.core.bones.treeleaf import TreeLeafBone
 from viur.core.tasks import CallDeferred
 
 
 @CallDeferred
 def ensureDerived(key: db.Key, srcKey, deriveMap: Dict[str, Any], refreshKey: db.Key = None):
     """
-    Ensure that pending thumbnails or other derived Files are build
-    :param key: DB-Key of the file-object on which we should update the derivemap
-    :param srcKey: Prefix for a (hopefully) stable key to prevent rebuilding derives over and over again
-    :param deriveMap: List of DeriveDicts we should build/update
-    :param refreshKey: If set, we'll fetch and refresh the skeleton after building new derives
+    The function is a deferred function that ensures all pending thumbnails or other derived files
+    are built. It takes the following parameters:
+
+    :param db.key key: The database key of the file-object that needs to have its derivation map
+        updated.
+    :param str srcKey: A prefix for a stable key to prevent rebuilding derived files repeatedly.
+    :param Dict[str,Any] deriveMap: A list of DeriveDicts that need to be built or updated.
+    :param db.Key refreshKey: If set, the function fetches and refreshes the skeleton after
+        building new derived files.
+
+    The function works by fetching the skeleton of the file-object, checking if it has any derived
+    files, and updating the derivation map accordingly. It iterates through the deriveMap items and
+    calls the appropriate deriver function. If the deriver function returns a result, the function
+    creates a new or updated resultDict and merges it into the file-object's metadata. Finally,
+    the updated results are written back to the database and the updateRelations function is called
+    to ensure proper relations are maintained.
     """
     from viur.core.skeleton import skeletonByKind, updateRelations
     deriveFuncMap = conf["viur.file.derivers"]
     skel = skeletonByKind("file")()
     if not skel.fromDB(key):
         logging.info("File-Entry went missing in ensureDerived")
         return
@@ -75,17 +93,47 @@
                 skel.refresh()
                 skel.toDB(update_relations=False)
 
             db.RunInTransaction(refreshTxn)
 
 
 class FileBone(TreeLeafBone):
+    """
+    A FileBone is a custom bone class that inherits from the TreeLeafBone class, and is used to store and manage
+    file references in a ViUR application.
+
+    :param format: Hint for the UI how to display a file entry (defaults to it's filename)
+    :param derive: A set of functions used to derive other files from the referenced ones. Used fe.
+        to create thumbnails / images for srcmaps from hires uploads. If set, must be a dictionary from string
+        (a key from conf["viur.file.derivers"]) to the parameters passed to that function. The parameters can be
+        any type (including None) that can be json-serialized.
+
+            Example:
+                >>> derive = {"thumbnail": [{"width": 111},
+                    {"width": 555, "height": 666}]}
+
+    :param validMimeTypes: A list of Mimetypes that can be selected in this bone (or None for any).
+        Wildcards ("image/*") are supported.
+
+            Example:
+                >>> validMimeTypes=["application/pdf", "image/*"]
+    :param maxFileSize: The maximum filesize accepted by this bone in bytes. None means no limit.
+        This will always be checked against the original file uploaded - not any of it's
+        derivatives.
+"""
+
     kind = "file"
+    """The kind of this bone is 'file'"""
     type = "relational.tree.leaf.file"
+    """The type of this bone is 'relational.tree.leaf.file'."""
     refKeys = ["name", "key", "mimetype", "dlkey", "size", "width", "height", "derived"]
+    """
+    The list of reference keys for this bone includes "name", "key", "mimetype", "dlkey", "size", "width",
+    "height", and "derived".
+    """
 
     def __init__(
         self,
         *,
         derive: Union[None, Dict[str, Any]] = None,
         maxFileSize: Union[None, int] = None,
         validMimeTypes: Union[None, List[str]] = None,
@@ -115,28 +163,49 @@
             self.refKeys.append("dlkey")
 
         self.derive = derive
         self.validMimeTypes = validMimeTypes
         self.maxFileSize = maxFileSize
 
     def isInvalid(self, value):
+        """
+        Checks if the provided value is invalid for this bone based on its MIME type and file size.
+
+        :param dict value: The value to check for validity.
+        :returns: None if the value is valid, or an error message if it is invalid.
+        """
         if self.validMimeTypes:
             mimeType = value["dest"]["mimetype"]
             for checkMT in self.validMimeTypes:
                 checkMT = checkMT.lower()
                 if checkMT == mimeType or checkMT.endswith("*") and mimeType.startswith(checkMT[:-1]):
                     break
             else:
                 return "Invalid filetype selected"
         if self.maxFileSize:
             if value["dest"]["size"] > self.maxFileSize:
                 return "File too large."
         return None
 
     def postSavedHandler(self, skel, boneName, key):
+        """
+        Handles post-save processing for the FileBone, including ensuring derived files are built.
+
+        :param SkeletonInstance skel: The skeleton instance this bone belongs to.
+        :param str boneName: The name of the bone.
+        :param db.Key key: The datastore key of the skeleton.
+
+        This method first calls the postSavedHandler of its superclass. Then, it checks if the
+        derive attribute is set and if there are any values in the skeleton for the given bone. If
+        so, it handles the creation of derived files based on the provided configuration.
+
+        If the values are stored as a dictionary without a "dest" key, it assumes a multi-language
+        setup and iterates over each language to handle the derived files. Otherwise, it handles
+        the derived files directly.
+        """
         super().postSavedHandler(skel, boneName, key)
 
         def handleDerives(values):
             if isinstance(values, dict):
                 values = [values]
             for val in values:  # Ensure derives getting build for each file referenced in this relation
                 ensureDerived(val["dest"]["key"], "%s_%s" % (skel.kindName, boneName), self.derive)
@@ -146,23 +215,53 @@
             if isinstance(values, dict) and "dest" not in values:  # multi lang
                 for lang in values:
                     handleDerives(values[lang])
             else:
                 handleDerives(values)
 
     def getReferencedBlobs(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> Set[str]:
+        """
+        Retrieves the referenced blobs in the FileBone.
+
+        :param SkeletonInstance skel: The skeleton instance this bone belongs to.
+        :param str name: The name of the bone.
+        :return: A set of download keys for the referenced blobs.
+        :rtype: Set[str]
+
+        This method iterates over the bone values for the given skeleton and bone name. It skips
+        values that are None. For each non-None value, it adds the download key of the referenced
+        blob to a set. Finally, it returns the set of unique download keys for the referenced blobs.
+        """
         result = set()
         for idx, lang, value in self.iter_bone_value(skel, name):
             if value is None:
                 continue
             result.add(value["dest"]["dlkey"])
         return result
 
     def refresh(self, skel, boneName):
+        """
+        Refreshes the FileBone by recreating file entries if needed and importing blobs from ViUR 2.
+
+        :param SkeletonInstance skel: The skeleton instance this bone belongs to.
+        :param str boneName: The name of the bone.
+
+        This method defines an inner function, recreateFileEntryIfNeeded(val), which is responsible
+        for recreating the weak file entry referenced by the relation in val if it doesn't exist
+        (e.g., if it was deleted by ViUR 2). It initializes a new skeleton for the "file" kind and
+        checks if the file object already exists. If not, it recreates the file entry with the
+        appropriate properties and saves it to the database.
+
+        The main part of the refresh method calls the superclass's refresh method and checks if the
+        configuration contains a ViUR 2 import blob source. If it does, it iterates through the file
+        references in the bone value, imports the blobs from ViUR 2, and recreates the file entries if
+        needed using the inner function.
+        """
         from viur.core.skeleton import skeletonByKind
+
         def recreateFileEntryIfNeeded(val):
             # Recreate the (weak) filenetry referenced by the relation *val*. (ViUR2 might have deleted them)
             skel = skeletonByKind("file")()
             if skel.fromDB(val["key"]):  # This file-object exist, no need to recreate it
                 return
             skel["key"] = val["key"]
             skel["name"] = val["name"]
```

## viur/core/bones/key.py

```diff
@@ -1,14 +1,30 @@
+"""
+The KeyBone is used for managing keys in the database. It provides various methods for validating,
+converting, and storing key values, as well as querying the database.
+Key management is crucial for maintaining relationships between entities in the database, and the
+KeyBone class helps ensure that keys are handled correctly and efficiently throughout the system.
+"""
 from viur.core.bones.base import BaseBone, ReadFromClientError, ReadFromClientErrorSeverity
 from viur.core import db, utils
 from typing import Dict, Optional, Union, List
-import logging, copy
+import logging
+import copy
 
 
 class KeyBone(BaseBone):
+    """
+    The KeyBone is used for managing keys in the database. It's based on the BoneBone
+
+    :param str descr: The description of the KeyBone.
+    :param bool readOnly: Whether the KeyBone is read-only.
+    :param bool visible: Whether the KeyBone is visible.
+    :param Union[None, List[str]] allowed_kinds: The allowed entity kinds for the KeyBone.
+    :param bool check: Whether to check for entity existence.
+    """
     type = "key"
 
     def __init__(
         self,
         *,
         descr: str = "Key",
         readOnly: bool = True,  # default is readonly
@@ -18,14 +34,28 @@
         **kwargs
     ):
         super().__init__(descr=descr, readOnly=readOnly, visible=visible, defaultValue=None, **kwargs)
         self.allowed_kinds = allowed_kinds
         self.check = check
 
     def singleValueFromClient(self, value, skel, name, origData):
+        """
+        This method validates and converts a key value received from the client. It checks if the
+        value is a valid key and, if necessary, converts it into an appropriate format for further
+        processing.
+
+        :param value: The key value received from the client.
+        :param skel: The Skeleton instance this bone is a part of.
+        :param name: The property name of this bone in the Skeleton (not the description).
+        :param origData: The original data received from the client.
+
+        :return: A tuple containing the validated and converted key, or an empty value if the key
+            is not valid. If there are any errors during validation, the second element of the tuple
+            will contain a list of :class:ReadFromClientError instances with error details.
+        """
         # check for correct key
         if isinstance(value, str):
             value = value.strip()
 
         if self.allowed_kinds:
             try:
                 key = db.keyHelper(value, self.allowed_kinds[0], self.allowed_kinds[1:])
@@ -56,35 +86,42 @@
                     )
                 ]
 
         return key, None
 
     def unserialize(self, skel: 'viur.core.skeleton.SkeletonValues', name: str) -> bool:
         """
-            Inverse of serialize. Evaluates whats
-            read from the datastore and populates
-            this bone accordingly.
-            :param name: The property-name this bone has in its Skeleton (not the description!)
-        """
+        This method is the inverse of :meth:serialize. It reads the key value from the datastore
+        and populates the corresponding KeyBone in the Skeleton. The method converts the value from
+        the datastore into an appropriate format for further use in the program.
+
+        :param skel: The SkeletonValues instance this bone is a part of.
+        :param name: The property name of this bone in the Skeleton (not the description).
+
+        :return: A boolean value indicating whether the operation was successful. Returns True if
+            the key value was successfully unserialized and added to the accessedValues of the
+            Skeleton, and False otherwise.
 
+        .. note:: The method contains an inner function, fixVals(val), which normalizes and
+            validates the key values before populating the bone.
+        """
         def fixVals(val):
             if isinstance(val, str):
                 try:
                     val = utils.normalizeKey(db.Key.from_legacy_urlsafe(val))
                 except:
                     val = None
             elif not isinstance(val, db.Key):
                 val = None
             return val
 
         if (name == "key"
             and isinstance(skel.dbEntity, db.Entity)
             and skel.dbEntity.key
-            and not skel.dbEntity.key.is_partial
-        ):
+                and not skel.dbEntity.key.is_partial):
             skel.accessedValues[name] = skel.dbEntity.key
             return True
         elif name in skel.dbEntity:
             val = skel.dbEntity[name]
             if isinstance(val, list):
                 val = [fixVals(x) for x in val if fixVals(x)]
             else:
@@ -98,51 +135,67 @@
                 val = val[0]
             skel.accessedValues[name] = val
             return True
         return False
 
     def serialize(self, skel: 'SkeletonInstance', name: str, parentIndexed: bool) -> bool:
         """
-            Serializes this bone into something we
-            can write into the datastore.
+        This method serializes the KeyBone into a format that can be written to the datastore. It
+        converts the key value from the Skeleton object into a format suitable for storage in the
+        datastore.
+
+        :param skel: The SkeletonInstance this bone is a part of.
+        :param name: The property name of this bone in the Skeleton (not the description).
+        :param parentIndexed: A boolean value indicating whether the parent entity is indexed or not.
+
+        :return: A boolean value indicating whether the operation was successful. Returns True if
+            the key value was successfully serialized and added to the datastore entity, and False
+            otherwise.
 
-            :param name: The property-name this bone has in its Skeleton (not the description!)
+        .. note:: Key values are always indexed, so the method discards any exclusion from indexing
+            for key values.
         """
         if name in skel.accessedValues:
             if name == "key":
                 skel.dbEntity.key = skel.accessedValues["key"]
             else:
                 skel.dbEntity[name] = skel.accessedValues[name]
                 skel.dbEntity.exclude_from_indexes.discard(name)  # Keys can never be not indexed
             return True
         return False
 
-
     def buildDBFilter(
         self,
-          name: str,
-          skel: 'viur.core.skeleton.SkeletonInstance',
-          dbFilter: db.Query,
-          rawFilter: Dict,
-          prefix: Optional[str] = None
+        name: str,
+        skel: 'viur.core.skeleton.SkeletonInstance',
+        dbFilter: db.Query,
+        rawFilter: Dict,
+        prefix: Optional[str] = None
     ) -> db.Query:
         """
-            Parses the searchfilter a client specified in his Request into
-            something understood by the datastore.
-            This function must:
-
-                * Ignore all filters not targeting this bone
-                * Safely handle malformed data in rawFilter
-                    (this parameter is directly controlled by the client)
-
-            :param name: The property-name this bone has in its Skeleton (not the description!)
-            :param skel: The :class:`viur.core.db.Query` this bone is part of
-            :param dbFilter: The current :class:`viur.core.db.Query` instance the filters should be applied to
-            :param rawFilter: The dictionary of filters the client wants to have applied
-            :returns: The modified :class:`viur.core.db.Query`
+        This method parses the search filter specified by the client in their request and converts
+        it into a format that can be understood by the datastore. It takes care of ignoring filters
+        that do not target this bone and safely handles malformed data in the raw filter.
+
+        :param name: The property name of this bone in the Skeleton (not the description).
+        :param skel: The :class:viur.core.skeleton.SkeletonInstance this bone is a part of.
+        :param dbFilter: The current :class:viur.core.db.Query instance the filters should be
+            applied to.
+        :param rawFilter: The dictionary of filters the client wants to have applied.
+        :param prefix: An optional string to prepend to the filter key. Defaults to None.
+
+        :return: The modified :class:viur.core.db.Query.
+
+        The method takes the following steps:
+
+        #. Decodes the provided key(s) from the raw filter.
+        #. If the filter contains a list of keys, it iterates through the list, creating a new
+            filter for each key and appending it to the list of queries.
+        #. If the filter contains a single key, it applies the filter directly to the query.
+        #. In case of any invalid key or other issues, it raises a RuntimeError.
         """
 
         def _decodeKey(key):
             if isinstance(key, db.Key):
                 return key
             else:
                 try:
```

## viur/core/bones/numeric.py

```diff
@@ -1,43 +1,46 @@
+"""A bone for storing numeric values, either integers or floats."""
 import logging
 import sys
 import warnings
 from typing import Any, Dict, Optional, Set, Union
 
 from viur.core import db
 from viur.core.bones.base import BaseBone, ReadFromClientError, ReadFromClientErrorSeverity
 
 # Constants for Mne (MIN/MAX-never-exceed)
 MIN = -(sys.maxsize - 1)
+""" Constant for the minimum """
 MAX = sys.maxsize
+""" Constant for the maximum """
 
 
 class NumericBone(BaseBone):
     """
-        Holds numeric values.
-        Can be used for ints and floats.
+        A bone for storing numeric values, either integers or floats.
         For floats, the precision can be specified in decimal-places.
+
+        :param precision: How may decimal places should be saved. Zero casts the value to int instead of
+            float.
+        :param min: Minimum accepted value (including).
+        :param max: Maximum accepted value (including).
     """
     type = "numeric"
 
     def __init__(
         self,
         *,
         max: Union[int, float] = MAX,
         min: Union[int, float] = MIN,
         mode=None,  # deprecated!
         precision: int = 0,
         **kwargs
     ):
         """
             Initializes a new NumericBone.
-
-            :param precision: How may decimal places should be saved. Zero casts the value to int instead of float.
-            :param min: Minimum accepted value (including).
-            :param max: Maximum accepted value (including).
         """
         super().__init__(**kwargs)
 
         if mode:
             logging.warning("mode-parameter to NumericBone is deprecated")
             warnings.warn(
                 "mode-parameter to NumericBone is deprecated", DeprecationWarning
@@ -51,51 +54,97 @@
             precision = 8
 
         self.precision = precision
         self.min = min
         self.max = max
 
     def __setattr__(self, key, value):
+        """
+        Sets the attribute with the specified key to the given value.
+
+        This method is overridden in the NumericBone class to handle the special case of setting
+        the 'multiple' attribute to True while the bone is of type float. In this case, an
+        AssertionError is raised to prevent creating a multiple float bone.
+
+        :param key: The name of the attribute to be set.
+        :param value: The value to set the attribute to.
+        :raises AssertionError: If the 'multiple' attribute is set to True for a float bone.
+        """
         if key in ("min", "max"):
             if value < MIN or value > MAX:
                 raise ValueError(f"{key} can only be set to something between {MIN} and {MAX}")
 
         return super().__setattr__(key, value)
 
     def isInvalid(self, value):
+        """
+        This method checks if a given value is invalid (e.g., NaN) for the NumericBone instance.
+
+        :param value: The value to be checked for validity.
+        :return: Returns a string "NaN not allowed" if the value is invalid (NaN), otherwise None.
+        """
         if value != value:  # NaN
             return "NaN not allowed"
 
     def getEmptyValue(self):
+        """
+        This method returns an empty value depending on the precision attribute of the NumericBone
+        instance.
+
+        :return: Returns 0 for integers (when precision is 0) or 0.0 for floating-point numbers (when
+            precision is non-zero).
+        """
         if self.precision:
             return 0.0
         else:
             return 0
 
-    def isEmpty(self, rawValue: Any):
-        if isinstance(rawValue, str) and not rawValue:
+    def isEmpty(self, value: Any):
+        """
+        This method checks if a given raw value is considered empty for the NumericBone instance.
+        It attempts to convert the raw value into a valid numeric value (integer or floating-point
+        number), depending on the precision attribute of the NumericBone instance.
+
+        :param value: The raw value to be checked for emptiness.
+        :return: Returns True if the raw value is considered empty, otherwise False.
+        """
+        if isinstance(value, str) and not value:
             return True
         try:
-            rawValue = self._convert_to_numeric(rawValue)
+            value = self._convert_to_numeric(value)
         except (ValueError, TypeError):
             return True
-        return rawValue == self.getEmptyValue()
+        return value == self.getEmptyValue()
 
     def singleValueFromClient(self, value, skel, name, origData):
+        """
+        This method converts the value received from the client into a valid numeric value
+        (integer or floating-point number) and checks if the value is within the minimum
+        and maximum limits defined for the NumericBone instance. If the value is valid,
+        it returns the converted value and None for errors. If the value is invalid, it
+        returns the empty value and a list containing a ReadFromClientError instance with
+        the error details.
+
+        :param value: The value received from the client.
+        :param skel: The skeleton instance containing the bone.
+        :param name: The name of the bone.
+        :param origData: The original data dictionary containing all values.
+        :return: A tuple containing the converted value and a list of errors (or None if no errors).
+        """
         try:
-            rawValue = str(value).replace(",", ".", 1)
+            value = str(value).replace(",", ".", 1)
         except:
             return self.getEmptyValue(), [ReadFromClientError(ReadFromClientErrorSeverity.Invalid, "Invalid Value")]
         else:
-            if self.precision and (str(rawValue).replace(".", "", 1).replace("-", "", 1).isdigit()) and float(
-                rawValue) >= self.min and float(rawValue) <= self.max:
-                value = round(float(rawValue), self.precision)
-            elif not self.precision and (str(rawValue).replace("-", "", 1).isdigit()) and int(
-                rawValue) >= self.min and int(rawValue) <= self.max:
-                value = int(rawValue)
+            if self.precision and (str(value).replace(".", "", 1).replace("-", "", 1).isdigit()) and float(
+                    value) >= self.min and float(value) <= self.max:
+                value = round(float(value), self.precision)
+            elif not self.precision and (str(value).replace("-", "", 1).isdigit()) and int(
+                    value) >= self.min and int(value) <= self.max:
+                value = int(value)
             else:
                 return self.getEmptyValue(), [ReadFromClientError(ReadFromClientErrorSeverity.Invalid, "Invalid Value")]
         err = self.isInvalid(value)
         if err:
             return self.getEmptyValue(), [ReadFromClientError(ReadFromClientErrorSeverity.Invalid, err)]
         return value, None
 
@@ -103,14 +152,27 @@
         self,
         name: str,
         skel: 'viur.core.skeleton.SkeletonInstance',
         dbFilter: db.Query,
         rawFilter: Dict,
         prefix: Optional[str] = None
     ) -> db.Query:
+        """
+        This method updates the database filter by converting the raw filter values into valid numeric
+        values (integer or floating-point numbers) for the NumericBone instance. It also ensures that
+        the filter values are not garbage, otherwise a RuntimeError is raised.
+
+        :param name: The name of the bone.
+        :param skel: The skeleton instance containing the bone.
+        :param dbFilter: The database query filter to be updated.
+        :param rawFilter: The raw filter dictionary containing the filter values.
+        :param prefix: An optional prefix for the filter parameters.
+        :return: Returns the updated database query filter.
+        :raises RuntimeError: If the filter value provided is not valid for the NumericBone.
+        """
         updatedFilter = {}
 
         for parmKey, paramValue in rawFilter.items():
             if parmKey.startswith(name):
                 if parmKey != name and not parmKey.startswith(name + "$"):
                     # It's just another bone which name start's with our's
                     continue
@@ -124,14 +186,23 @@
                     logging.warning("Invalid filtering! Unparsable int/float supplied to NumericBone %s" % name)
                     raise RuntimeError()
                 updatedFilter[parmKey] = paramValue
 
         return super().buildDBFilter(name, skel, dbFilter, updatedFilter, prefix)
 
     def getSearchTags(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> Set[str]:
+        """
+        This method generates a set of search tags based on the numeric values stored in the NumericBone
+        instance. It iterates through the bone values and adds the string representation of each value
+        to the result set.
+
+        :param skel: The skeleton instance containing the bone.
+        :param name: The name of the bone.
+        :return: Returns a set of search tags as strings.
+        """
         result = set()
         for idx, lang, value in self.iter_bone_value(skel, name):
             if value is None:
                 continue
             result.add(str(value))
         return result
```

## viur/core/bones/password.py

```diff
@@ -1,7 +1,13 @@
+"""
+The PasswordBone class is a specialized version of the StringBone class designed to handle password
+data. It hashes the password data before saving it to the database and prevents it from being read
+directly. The class also includes various tests to determine the strength of the entered password.
+"""
+
 import hashlib
 import re
 from typing import List, Tuple, Union
 
 from viur.core import conf, utils
 from viur.core.bones.string import StringBone
 from viur.core.i18n import translate
@@ -27,35 +33,36 @@
         "iterations": iterations,
         "dklen": dklen,
     }
 
 
 class PasswordBone(StringBone):
     """
-        A bone holding passwords.
-        This is always empty if read from the database.
-        If its saved, its ignored if its values is still empty.
-        If its value is not empty, its hashed (with salt) and only the resulting hash
-        will be written to the database
+    A specialized subclass of the StringBone class designed to handle password data. The
+    PasswordBone class hashes the password before saving it to the database and prevents it from
+    being read directly. It also includes various tests to determine the strength of the entered
+    password.
     """
     type = "password"
+    """A string representing the bone type, which is "password" in this case."""
     saltLength = 13
 
     tests: tuple[tuple[str, str, bool]] = (
         (r"^.*[A-Z].*$", translate("core.bones.password.no_capital_letters",
                                    defaultText="The password entered has no capital letters."), False),
         (r"^.*[a-z].*$", translate("core.bones.password.no_lowercase_letters",
                                    defaultText="The password entered has no lowercase letters."), False),
         (r"^.*\d.*$", translate("core.bones.password.no_digits",
                                 defaultText="The password entered has no digits."), False),
         (r"^.*\W.*$", translate("core.bones.password.no_special_characters",
                                 defaultText="The password entered has no special characters."), False),
         (r"^.{8,}$", translate("core.bones.password.too_short",
                                defaultText="The password is too short. It requires for at least 8 characters."), True),
     )
+    """Provides tests based on regular expressions to test the password stength."""
 
     def __init__(
         self,
         *,
         test_threshold: int = 3,
         tests: List[Tuple] = tests,
         **kwargs
@@ -69,14 +76,23 @@
         """
         super().__init__(**kwargs)
         self.test_threshold = test_threshold
         if tests is not None:
             self.tests = tests
 
     def isInvalid(self, value):
+        """
+        Determines if the entered password is invalid based on the length and strength requirements.
+        It checks if the password is empty, too short, or too weak according to the password tests
+        specified in the class.
+
+        :param str value: The password to be checked.
+        :return: True if the password is invalid, otherwise False.
+        :rtype: bool
+        """
         if not value:
             return False
 
         # Run our password test suite
         tests_errors = []
         tests_passed = 0
         required_test_failed = False
@@ -89,14 +105,27 @@
                     required_test_failed = True
         if tests_passed < self.test_threshold or required_test_failed:
             return tests_errors
 
         return False
 
     def fromClient(self, skel: 'SkeletonInstance', name: str, data: dict) -> Union[None, List[ReadFromClientError]]:
+        """
+        Processes the password field from the client data, validates it, and stores it in the
+        skeleton instance after hashing. This method performs several checks, such as ensuring that
+        the password field is present in the data, that the password is not empty, and that it meets
+        the length and strength requirements. If any of these checks fail, a ReadFromClientError is
+        returned.
+
+        :param SkeletonInstance skel: The skeleton instance to store the password in.
+        :param str name: The name of the password field.
+        :param dict data: The data dictionary containing the password field value.
+        :return: None if the password is valid, otherwise a list of ReadFromClientErrors.
+        :rtype: Union[None, List[ReadFromClientError]]
+        """
         if not name in data:
             return [ReadFromClientError(ReadFromClientErrorSeverity.NotSet, "Field not submitted")]
         value = data.get(name)
         if not value:
             # Password-Bone is special: As it cannot be read don't set back no None if no value is given
             # This means an once set password can only be changed - but never deleted.
             return [ReadFromClientError(ReadFromClientErrorSeverity.Empty, "No value entered")]
@@ -104,14 +133,34 @@
         if err:
             return [ReadFromClientError(ReadFromClientErrorSeverity.Invalid, err)]
         # As we don't escape passwords and allow most special characters we'll hash it early on so we don't open
         # an XSS attack vector if a password is echoed back to the client (which should not happen)
         skel[name] = encode_password(value, utils.generateRandomString(self.saltLength))
 
     def serialize(self, skel: 'SkeletonInstance', name: str, parentIndexed: bool) -> bool:
+        """
+        Processes and stores the password field from the client data into the skeleton instance after
+        hashing and validating it. This method carries out various checks, such as:
+
+        * Ensuring that the password field is present in the data.
+        * Verifying that the password is not empty.
+        * Confirming that the password meets the length and strength requirements.
+
+        If any of these checks fail, a ReadFromClientError is returned.
+
+        :param SkeletonInstance skel: The skeleton instance where the password will be stored as a
+            hashed value along with its salt.
+        :param str name: The name of the password field used to access the password value in the
+            data dictionary.
+        :param dict data: The data dictionary containing the password field value, typically
+            submitted by the client.
+        :return: None if the password is valid and successfully stored in the skeleton instance;
+            otherwise, a list of ReadFromClientErrors containing detailed information about the errors.
+        :rtype: Union[None, List[ReadFromClientError]]
+        """
         if name in skel.accessedValues and skel.accessedValues[name]:
             value = skel.accessedValues[name]
             if isinstance(value, dict):  # It is a pre-hashed value (probably fromClient)
                 skel.dbEntity[name] = value
             else:  # This has been set by skel["password"] = "secret", we'll still have to hash it
                 skel.dbEntity[name] = encode_password(value, utils.generateRandomString(self.saltLength))
 
@@ -121,11 +170,20 @@
                 skel.dbEntity.exclude_from_indexes.discard(name)
             elif not indexed and name not in skel.dbEntity.exclude_from_indexes:
                 skel.dbEntity.exclude_from_indexes.add(name)
             return True
         return False
 
     def unserialize(self, skeletonValues, name):
+        """
+        This method does not unserialize password values from the datastore. It always returns False,
+        indicating that no password value will be unserialized.
+
+        :param dict skeletonValues: The dictionary containing the values from the datastore.
+        :param str name: The name of the password field.
+        :return: False, as no password value will be unserialized.
+        :rtype: bool
+        """
         return False
 
     def structure(self) -> dict:
         return super().structure() | {"tests": self.tests}
```

## viur/core/bones/randomslice.py

```diff
@@ -1,19 +1,36 @@
+"""
+The RandomSliceBone is particularly useful when you want to retrieve a random sample of elements from a
+larger dataset without needing to fetch all the data from the database. By performing multiple
+subqueries and processing the results, RandomSliceBone provides an efficient way to get a
+randomized selection of elements from the database query.
+Simulates the orderby=random from SQL.
+"""
 from viur.core.bones.base import BaseBone
 from viur.core import db
 from typing import Dict, List, Optional
 from random import random, sample, shuffle
 from itertools import chain
 from math import ceil
 
 
 class RandomSliceBone(BaseBone):
     """
-        Simulates the orderby=random from SQL.
-        If you sort by this bone, the query will return a random set of elements from that query.
+    This class is particularly useful when you want to retrieve a random sample of elements from a
+    larger dataset without needing to fetch all the data from the database. By performing multiple
+    subqueries and processing the results, RandomSliceBone provides an efficient way to get a
+    randomized selection of elements from the database query.
+    Simulates the orderby=random from SQL.
+    If you sort by this bone, the query will return a random set of elements from that query.
+
+    :param visible: Indicates if the bone is visible, defaults to False.
+    :param readOnly: Indicates if the bone is read-only, defaults to True.
+    :param slices: The number of slices to use, defaults to 2.
+    :param sliceSize: The size of each slice, defaults to 0.5.
+    :param kwargs: Additional keyword arguments.
     """
 
     type = "randomslice"
 
     def __init__(self, *, visible=False, readOnly=True, slices=2, sliceSize=0.5, **kwargs):
         """
             Initializes a new RandomSliceBone.
@@ -24,48 +41,53 @@
             raise NotImplemented("A RandomSliceBone must not visible and readonly!")
         super().__init__(indexed=True, visible=False, readOnly=True, **kwargs)
         self.slices = slices
         self.sliceSize = sliceSize
 
     def serialize(self, skel: 'SkeletonInstance', name: str, parentIndexed: bool) -> bool:
         """
-            Serializes this bone into something we
-            can write into the datastore.
-
-            This time, we just ignore whatever is set on this bone and write a randomly chosen
-            float [0..1) as value for this bone.
-
-            :param name: The property-name this bone has in its Skeleton (not the description!)
+        Serializes the bone into a format that can be written into the datastore. Instead of using
+        the existing value, it writes a randomly chosen float in the range [0, 1) as the value for
+        this bone.
+
+        :param SkeletonInstance skel: The SkeletonInstance this bone is part of.
+        :param str name: The property name this bone has in its Skeleton (not the description).
+        :param bool parentIndexed: Indicates if the parent bone is indexed.
+        :return: Returns True if the serialization is successful.
+        :rtype: bool
         """
         skel.dbEntity[name] = random()
         skel.dbEntity.exclude_from_indexes.discard(name)  # Random bones can never be not indexed
         return True
 
     def buildDBSort(
         self,
         name: str,
         skel: 'viur.core.skeleton.SkeletonInstance',
         dbFilter: db.Query,
         rawFilter: Dict
     ) -> Optional[db.Query]:
         """
-            Same as buildDBFilter, but this time its not about filtering
-            the results, but by sorting them.
-            Again: rawFilter is controlled by the client, so you *must* expect and safely handle
-            malformed data!
-
-            This function is somewhat special as it doesn't just change in which order the selected
-            Elements are being returned - but also changes *which* Elements are beeing returned (=>
-            a random selection)
-
-            :param name: The property-name this bone has in its Skeleton (not the description!)
-            :param skel: The :class:`viur.core.skeleton.Skeleton` instance this bone is part of
-            :param dbFilter: The current :class:`viur.core.db.Query` instance the filters should be applied to
-            :param rawFilter: The dictionary of filters the client wants to have applied
-            :returns: The modified :class:`viur.core.db.Query`
+        Modifies the database query to return a random selection of elements by creating multiple
+        subqueries, each covering a slice of the data. This method doesn't just change the order of
+        the selected elements, but also changes which elements are returned.
+
+        :param str name: The property name this bone has in its Skeleton (not the description).
+        :param SkeletonInstance skel: The :class:viur.core.skeleton.Skeleton instance this bone is part of.
+        :param db.Query dbFilter: The current :class:viur.core.db.Query instance the filters should be applied to.
+        :param Dict rawFilter: The dictionary of filters the client wants to have applied.
+        :return: The modified :class:viur.core.db.Query instance.
+        :rtype: Optional[db.Query]
+
+        .. note:: The rawFilter is controlled by the client, so you must expect and safely handle
+            malformed data.
+
+        The method also contains an inner function, applyFilterHook, that applies the filter hook to
+        the given filter if set, or returns the unmodified filter. This allows the orderby=random
+        functionality to be used in relational queries as well.
         """
 
         def applyFilterHook(dbfilter, property, value):
             """
                 Applies dbfilter._filterHook to the given filter if set,
                 else return the unmodified filter.
                 Allows orderby=random also be used in relational-queries.
@@ -108,29 +130,33 @@
             for k, v in origFilter.items():
                 dbFilter.filter(k, v)
             dbFilter._customMultiQueryMerge = self.customMultiQueryMerge
             dbFilter._calculateInternalMultiQueryLimit = self.calculateInternalMultiQueryLimit
 
     def calculateInternalMultiQueryLimit(self, query: db.Query, targetAmount: int) -> int:
         """
-            Tells :class:`viur.core.db.Query` How much entries should be fetched in each subquery.
+        Calculates the number of entries to be fetched in each subquery.
 
-            :param targetAmount: How many entries shall be returned from db.Query
-            :returns: The amount of elements db.Query should fetch on each subquery
+        :param db.Query query: The :class:viur.core.db.Query instance.
+        :param int targetAmount: The number of entries to be returned from the db.Query.
+        :return: The number of elements the db.Query should fetch on each subquery.
+        :rtype: int
         """
         return ceil(targetAmount * self.sliceSize)
 
     def customMultiQueryMerge(self, dbFilter: db.Query, result: List[db.Entity], targetAmount: int) -> List[db.Entity]:
         """
-            Randomly returns 'targetAmount' elements from 'result'
+        Merges the results of multiple subqueries by randomly selecting 'targetAmount' elements
+        from the combined 'result' list.
 
-            :param dbFilter: The db.Query calling this function
-            :param result: The list of results for each subquery we've run
-            :param targetAmount: How many results should be returned from db.Query
-            :return: list of elements which should be returned from db.Query
+        :param db.Query dbFilter: The db.Query instance calling this function.
+        :param List[db.Entity] result: The list of results for each subquery that has been run.
+        :param int targetAmount: The number of results to be returned from the db.Query.
+        :return: A list of elements to be returned from the db.Query.
+        :rtype: List[db.Entity]
         """
         # res is a list of iterators at this point, chain them together
         res = chain(*[list(x) for x in result])
         # Remove duplicates
         tmpDict = {}
         for item in res:
             tmpDict[str(item.key)] = item
```

## viur/core/bones/raw.py

```diff
@@ -1,20 +1,35 @@
+"""
+The RawBone stores it's data without applying any pre/post-processing or filtering. Can be used to
+store non-html content.
+"""
 from viur.core.bones.base import BaseBone, ReadFromClientError, ReadFromClientErrorSeverity
 
 
 class RawBone(BaseBone):
     """
-        Stores it's data without applying any pre/post-processing or filtering. Can be used to store non-html content.
-        Use the dot-notation like "raw.markdown" or similar to describe subsequent types.
-
-        ..Warning: Using this bone will lead to security vulnerabilities like reflected XSS unless the data is either
-            otherwise validated/stripped or from a trusted source! Don't use this unless you fully understand it's
-            implications!
+    Stores it's data without applying any pre/post-processing or filtering. Can be used to store
+    non-html content.
+    Use the dot-notation like "raw.markdown" or similar to describe subsequent types.
 
+    ..Warning: Using this bone will lead to security vulnerabilities like reflected XSS unless the
+        data is either otherwise validated/stripped or from a trusted source! Don't use this unless
+        you fully understand it's implications!
     """
     type = "raw"
 
     def singleValueFromClient(self, value, skel, name, origData):
+        """
+        Takes a value from the client, checks if it's invalid, and returns either the value with no
+        errors or an empty value with an error.
+
+        :param value: The value to be checked.
+        :param skel: The :class:viur.core.skeleton.Skeleton instance this bone is part of.
+        :param name: The property-name this bone has in its Skeleton (not the description!).
+        :param origData: The original data received from the client.
+        :returns: A tuple containing the value and either an error or None. If the value is invalid,
+            returns an empty value and a ReadFromClientError. Otherwise, returns the value and None.
+        """
         err = self.isInvalid(value)
         if err:
             return self.getEmptyValue(), [ReadFromClientError(ReadFromClientErrorSeverity.Invalid, err)]
         return value, None
```

## viur/core/bones/record.py

```diff
@@ -1,19 +1,38 @@
+"""
+The RecordBone class is a specialized bone type used to store structured data. It inherits from the
+BaseBone class. The RecordBone class is designed to store complex data structures, such as nested
+dictionaries or objects, by using a related skeleton class (the using parameter) to manage the
+internal structure of the data.
+"""
 from typing import List, Set
 
 from viur.core.bones.base import BaseBone, ReadFromClientError, ReadFromClientErrorSeverity
 
 try:
     import extjson
 except ImportError:
     # FIXME: That json will not read datetime objects
     import json as extjson
 
 
 class RecordBone(BaseBone):
+    """
+    The RecordBone class is a specialized bone type used to store structured data. It inherits from
+    the BaseBone class. The RecordBone class is designed to store complex data structures, such as
+    nested dictionaries or objects, by using a related skeleton class (the using parameter) to manage
+    the internal structure of the data.
+
+    :param format: Optional string parameter to specify the format of the record bone.
+    :param indexed: Optional boolean parameter to indicate if the record bone is indexed.
+        Defaults to False.
+    :param using: A class that inherits from 'viur.core.skeleton.RelSkel' to be used with the
+        RecordBone.
+    :param kwargs: Additional keyword arguments to be passed to the BaseBone constructor.
+    """
     type = "record"
 
     def __init__(
         self,
         *,
         format: str = None,
         indexed: bool = False,
@@ -27,14 +46,22 @@
         super().__init__(indexed=indexed, **kwargs)
         self.using = using
         self.format = format
         if not format or indexed:
             raise NotImplementedError("A RecordBone must not be indexed and must have a format set")
 
     def singleValueUnserialize(self, val):
+        """
+        Unserializes a single value, creating an instance of the 'using' class and unserializing
+        the value into it.
+
+        :param val: The value to unserialize.
+        :return: An instance of the 'using' class with the unserialized data.
+        :raises AssertionError: If the unserialized value is not a dictionary.
+        """
         if isinstance(val, str):
             try:
                 value = extjson.loads(val)
             except:
                 value = None
         else:
             value = val
@@ -44,35 +71,60 @@
             value = value[0]
         assert isinstance(value, dict), "Read something from the datastore thats not a dict: %s" % str(type(value))
         usingSkel = self.using()
         usingSkel.unserialize(value)
         return usingSkel
 
     def singleValueSerialize(self, value, skel: 'SkeletonInstance', name: str, parentIndexed: bool):
+        """
+        Serializes a single value by calling the serialize method of the 'using' skeleton instance.
+
+        :param value: The value to be serialized, which should be an instance of the 'using' skeleton.
+        :param skel: The parent skeleton instance.
+        :param name: The name of the bone.
+        :param parentIndexed: A boolean indicating if the parent bone is indexed.
+        :return: The serialized value.
+        """
         if not value:
             return value
 
         return value.serialize(parentIndexed=False)
 
     def parseSubfieldsFromClient(self) -> bool:
         """
-        Whenever this request should try to parse subfields submitted from the client.
-        Set only to true if you expect a list of dicts to be transmitted
+        Determines if the current request should attempt to parse subfields received from the client.
+        This should only be set to True if a list of dictionaries is expected to be transmitted.
         """
         return True
 
     def singleValueFromClient(self, value, skel, name, origData):
+        """
+        Serializes a single value by calling the serialize method of the 'using' skeleton instance.
+
+        :param value: The value to be serialized, which should be an instance of the 'using' skeleton.
+        :param skel: The parent skeleton instance.
+        :param name: The name of the bone.
+        :param parentIndexed: A boolean indicating if the parent bone is indexed.
+        :return: The serialized value.
+        """
         usingSkel = self.using()
         if not usingSkel.fromClient(value, not (self.required or self.multiple)):
             usingSkel.errors.append(
                 ReadFromClientError(ReadFromClientErrorSeverity.Invalid, "Incomplete data")
             )
         return usingSkel, usingSkel.errors
 
     def getSearchTags(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> Set[str]:
+        """
+        Collects search tags from the 'using' skeleton instance for the given bone.
+
+        :param skel: The parent skeleton instance.
+        :param name: The name of the bone.
+        :return: A set of search tags generated from the 'using' skeleton instance.
+        """
         result = set()
 
         using_skel_cache = self.using()
         for idx, lang, value in self.iter_bone_value(skel, name):
             if value is None:
                 continue
             for key, bone in using_skel_cache.items():
@@ -80,14 +132,23 @@
                     continue
                 for tag in bone.getSearchTags(value, key):
                     result.add(tag)
 
         return result
 
     def getSearchDocumentFields(self, valuesCache, name, prefix=""):
+        """
+        Generates a list of search document fields for the given values cache, name, and optional prefix.
+
+        :param dict valuesCache: A dictionary containing the cached values.
+        :param str name: The name of the bone to process.
+        :param str prefix: An optional prefix to use for the search document fields, defaults to an empty string.
+        :return: A list of search document fields.
+        :rtype: list
+        """
         def getValues(res, skel, valuesCache, searchPrefix):
             for key, bone in skel.items():
                 if bone.searchable:
                     res.extend(bone.getSearchDocumentFields(valuesCache, key, prefix=searchPrefix))
 
         value = valuesCache.get(name)
         res = []
@@ -97,14 +158,22 @@
         uskel = self.using()
         for idx, val in enumerate(value):
             getValues(res, uskel, val, "%s%s_%s" % (prefix, name, str(idx)))
 
         return res
 
     def getReferencedBlobs(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> Set[str]:
+        """
+        Retrieves a set of referenced blobs for the given skeleton instance and name.
+
+        :param SkeletonInstance skel: The skeleton instance to process.
+        :param str name: The name of the bone to process.
+        :return: A set of referenced blobs.
+        :rtype: set[str]
+        """
         result = set()
 
         using_skel_cache = self.using()
         for idx, lang, value in self.iter_bone_value(skel, name):
             if value is None:
                 continue
             for key, bone in using_skel_cache.items():
@@ -113,17 +182,17 @@
                 for tag in bone.getReferencedBlobs(value, key):
                     result.add(tag)
 
         return result
 
     def getUniquePropertyIndexValues(self, valuesCache: dict, name: str) -> List[str]:
         """
-            This is intentionally not defined as we don't now how to derive a key from the relskel
-            being using (ie. which Fields to include and how).
+        This method is intentionally not implemented as it's not possible to determine how to derive
+        a key from the related skeleton being used (i.e., which fields to include and how).
 
         """
-        raise NotImplementedError
+        raise NotImplementedError()
 
     def structure(self) -> dict:
         return super().structure() | {
             "format": self.format,
             "using": self.using().structure()}
```

## viur/core/bones/relational.py

```diff
@@ -1,7 +1,12 @@
+"""
+RelationalBone is used to create and manage relationships between database entities. This class provides basic
+functionality and attributes that can be extended by other specialized relational bone classes, such as N1Relation,
+N2NRelation, and Hierarchy.
+"""
 import logging
 import warnings
 from enum import Enum
 from itertools import chain
 from time import time
 from typing import Any, Dict, List, Optional, Set, Union
 
@@ -12,56 +17,137 @@
     import extjson
 except ImportError:
     # FIXME: That json will not read datetime objects
     import json as extjson
 
 
 class RelationalConsistency(Enum):
+    """
+    An enumeration representing the different consistency strategies for handling stale relations in
+    the RelationalBone class.
+    """
     Ignore = 1  # Ignore stale relations (old behaviour)
+    """Ignore stale relations, which represents the old behavior."""
     PreventDeletion = 2  # Lock target object so it cannot be deleted
+    """Lock the target object so that it cannot be deleted."""
     SetNull = 3  # Drop Relation if target object is deleted
+    """Drop the relation if the target object is deleted."""
     CascadeDeletion = 4  # Delete this object also if the referenced entry is deleted (Dangerous!)
+    """
+    .. warning:: Delete this object also if the referenced entry is deleted (Dangerous!)
+    """
 
 
 class RelationalUpdateLevel(Enum):
+    """
+    An enumeration representing the different update levels for the RelationalBone class.
+    """
     Always = 0
+    """Always update the relational information, regardless of the context."""
     OnRebuildSearchIndex = 1
+    """Update the relational information only when rebuilding the search index."""
     OnValueAssignment = 2
+    """Update the relational information only when a new value is assigned to the bone."""
 
 
 class RelationalBone(BaseBone):
     """
-        This is our magic class implementing relations.
+    The base class for all relational bones in the ViUR framework.
 
-        This implementation is read-efficient, e.g. filtering by relational-properties only costs an additional
-        small-op for each entity returned.
-        However, it costs several more write-ops for writing an entity to the db.
-        (These costs are somewhat around additional (4+len(refKeys)+len(parentKeys)) write-ops for each referenced
-        property) for multiple=True RelationalBones and (4+len(refKeys)) for n:1 relations)
-
-        So don't use this if you expect data being read less frequently than written! (Sorry, we don't have a
-        write-efficient method yet)
-        To speedup writes to (maybe) referenced entities, information in these relations isn't updated instantly.
-        Once a skeleton is updated, a deferred task is kicked off which updates the references to
-        that skeleton (if any).
-        As a result, you might see stale data until this task has been finished.
-
-        Example:
-
-            * Entity A references Entity B.
-            * Both have a property "name".
-            * Entity B gets updated (it name changes).
-            * As "A" has a copy of entity "B"s values, you'll see "B"s old name inside the values of the
-              RelationalBone when fetching entity A.
+    RelationalBone is used to create and manage relationships between database entities. This class provides
+    basic functionality and attributes that can be extended by other specialized relational bone classes,
+    such as N1Relation, N2NRelation, and Hierarchy.
+
+    This is our magic class implementing relations.
+
+    This implementation prioritizes read efficiency and is suitable for situations where data is read more
+    frequently than written. However, it comes with increased write operations when writing an entity to the
+    database. The additional write operations depend on the type of relationship: multiple=True RelationalBones
+    or 1:N relations.
+
+    The implementation does not instantly update relational information when a skeleton is updated; instead,
+    it triggers a deferred task to update references. This may result in outdated data until the task is completed.
+
+    Note: Filtering a list by relational properties uses the outdated data.
+
+    Example:
+    - Entity A references Entity B.
+    - Both have a property "name."
+    - Entity B is updated (its name changes).
+    - Entity A's RelationalBone values still show Entity B's old name.
+
+    It is not recommended for cases where data is read less frequently than written, as there is no
+    write-efficient method available yet.
+
+    :param kind: KindName of the referenced property.
+    :param module: Name of the module which should be used to select entities of kind "type". If not set,
+        the value of "type" will be used (the kindName must match the moduleName)
+    :param refKeys: A list of properties to include from the referenced property. These properties will be
+        available in the template without having to fetch the referenced property. Filtering is also only possible
+        by properties named here!
+    :param parentKeys: A list of properties from the current skeleton to include. If mixing filtering by
+        relational properties and properties of the class itself, these must be named here.
+    :param multiple: If True, allow referencing multiple Elements of the given class. (Eg. n:n-relation).
+        Otherwise its n:1, (you can only select exactly one). It's possible to use a unique constraint on this
+        bone, allowing for at-most-1:1 or at-most-1:n relations. Instead of true, it's also possible to use
+        a :class:MultipleConstraints instead.
+    :param format: Hint for the frontend how to display such an relation. This is now a python expression
+        evaluated by safeeval on the client side. The following values will be passed to the expression:
+            - value: dict:
+                The value to display. This will be always a dict (= a single value) - even if the relation is
+                multiple (in which case the expression is evaluated once per referenced entity)
+            - structure: dict:
+                The structure of the skeleton this bone is part of as a dictionary as it's transferred to the
+                fronted by the admin/vi-render.
+            - language: str:
+                The current language used by the frontend in ISO2 code (eg. "de"). This will be always set, even if
+                the project did not enable the multi-language feature.
+    :param updateLevel: Indicates how ViUR should keep the values copied from the referenced entity into our
+        entity up to date. If this bone is indexed, it's recommended to leave this set to
+        RelationalUpdateLevel.Always, as filtering/sorting by this bone will produce stale results.
+        Possible values are:
+            - RelationalUpdateLevel.Always:
+                always update refkeys (old behavior). If the referenced entity is edited, ViUR will update this
+                entity also (after a small delay, as these updates happen deferred)
+            - RelationalUpdateLevel.OnRebuildSearchIndex:
+                update refKeys only on rebuildSearchIndex. If the referenced entity changes, this entity will
+                remain unchanged (this RelationalBone will still have the old values), but it can be updated
+                by either by editing this entity or running a rebuildSearchIndex over our kind.
+            - RelationalUpdateLevel.OnValueAssignment:
+                update only if explicitly set. A rebuildSearchIndex will not trigger an update, this bone has to be
+                explicitly modified (in an edit) to have it's values updated
+    :param consistency: Can be used to implement SQL-like constrains on this relation. Possible values are:
+        - RelationalConsistency.Ignore:
+            If the referenced entity gets deleted, this bone will not change. It will still reflect the old
+            values. This will be even be preserved over edits, however if that referenced value is once
+            deleted by the user (assigning a different value to this bone or removing that value of the list
+            of relations if we are multiple) there's no way of restoring it
+        - RelationalConsistency.PreventDeletion:
+            Will prevent deleting the referenced entity as long as it's selected in this bone (calling
+            skel.delete() on the referenced entity will raise errors.Locked). It's still (technically)
+            possible to remove the underlying datastore entity using db.Delete manually, but this *must not*
+            be used on a skeleton object as it will leave a whole bunch of references in a stale state.
+        - RelationalConsistency.SetNull: Will set this bone to None (or remove the relation from the list in
+            case we are multiple) when the referenced entity is deleted.
+        - RelationalConsistency.CascadeDeletion:
+            (Dangerous!) Will delete this entity when the referenced entity is deleted. Warning: Unlike
+            relational updates this will cascade. If Entity A references B with CascadeDeletion set, and
+            B references C also with CascadeDeletion; if C gets deleted, both B and A will be deleted as well.
 
-        If you filter a list by relational properties, this will also use the old data! (Eg. filtering A's list by
-        B's new name won't return any result)
     """
     refKeys = ["key", "name"]  # todo: turn into a tuple, as it should not be mutable.
+    """
+    A list of properties to include from the referenced property. These properties will be available in the template
+    without having to fetch the referenced property. Filtering is also only possible by properties named here!
+    """
     parentKeys = ["key", "name"]  # todo: turn into a tuple, as it should not be mutable.
+    """
+    A list of properties from the current skeleton to include. If mixing filtering by relational properties and
+    properties of the class itself, these must be named here.
+    """
     type = "relational"
     kind = None
 
     def __init__(
         self,
         *,
         consistency: RelationalConsistency = RelationalConsistency.Ignore,
@@ -168,36 +254,70 @@
 
         if getSystemInitialized():
             from viur.core.skeleton import RefSkel, SkeletonInstance
             self._refSkelCache = RefSkel.fromSkel(self.kind, *self.refKeys)
             self._skeletonInstanceClassRef = SkeletonInstance
 
     def setSystemInitialized(self):
+        """
+        Set the system initialized for the current class and cache the RefSkel and SkeletonInstance.
+
+        This method calls the superclass's setSystemInitialized method and initializes the RefSkel
+        and SkeletonInstance classes. The RefSkel is created from the current kind and refKeys,
+        while the SkeletonInstance class is stored as a reference.
+
+        :rtype: None
+        """
         super().setSystemInitialized()
         from viur.core.skeleton import RefSkel, SkeletonInstance
         self._refSkelCache = RefSkel.fromSkel(self.kind, *self.refKeys)
         self._skeletonInstanceClassRef = SkeletonInstance
 
     # from viur.core.skeleton import RefSkel, skeletonByKind
     # self._refSkelCache = RefSkel.fromSkel(skeletonByKind(self.kind), *self.refKeys)
     # self._usingSkelCache = self.using() if self.using else None
 
     def _getSkels(self):
+        """
+        Retrieve the reference skeleton and the 'using' skeleton for the current RelationalBone instance.
+
+        This method returns a tuple containing the reference skeleton (RefSkel) and the 'using' skeleton
+        (UsingSkel) associated with the current RelationalBone instance. The 'using' skeleton is only
+        retrieved if the 'using' attribute is defined.
+
+        :return: A tuple containing the reference skeleton and the 'using' skeleton.
+        :rtype: tuple
+        """
         refSkel = self._refSkelCache()
         usingSkel = self.using() if self.using else None
         return refSkel, usingSkel
 
     def singleValueUnserialize(self, val):
         """
-            Restores one of our values (including the Rel- and Using-Skel) from the serialized data read from the datastore
-            :param value: Json-Encoded datastore property
-            :return: Our Value (with restored RelSkel and using-Skel)
+        Restore a value, including the Rel- and Using-Skeleton, from the serialized data read from the datastore.
+
+        This method takes a serialized value from the datastore, deserializes it, and returns the corresponding
+        value with restored RelSkel and Using-Skel. It also handles ViUR 2 compatibility by handling string values.
+
+        :param val: A JSON-encoded datastore property.
+        :type val: str or dict
+        :return: The deserialized value with restored RelSkel and Using-Skel.
+        :rtype: dict
+
+        :raises AssertionError: If the deserialized value is not a dictionary.
         """
 
         def fixFromDictToEntry(inDict):
+            """
+            Convert a dictionary to an entry with properly restored keys and values.
+
+            :param dict inDict: The input dictionary to convert.
+        :   return: The resulting entry.
+            :rtype: dict
+            """
             if not isinstance(inDict, dict):
                 return None
             res = {}
             if "dest" in inDict:
                 res["dest"] = db.Entity()
                 for k, v in inDict["dest"].items():
                     res["dest"][k] = v
@@ -237,14 +357,29 @@
             usingSkel.unserialize(value["rel"] or db.Entity())
             usingData = usingSkel
         else:
             usingData = None
         return {"dest": relSkel, "rel": usingData}
 
     def serialize(self, skel: 'SkeletonInstance', name: str, parentIndexed: bool) -> bool:
+        """
+        Serialize the RelationalBone for the given skeleton, updating relational locks as necessary.
+
+        This method serializes the RelationalBone values for a given skeleton and stores the serialized
+        values in the skeleton's dbEntity. It also updates the relational locks, adding new locks and
+        removing old ones as needed.
+
+        :param SkeletonInstance skel: The skeleton instance containing the values to be serialized.
+        :param str name: The name of the bone to be serialized.
+        :param bool parentIndexed: A flag indicating whether the parent bone is indexed.
+        :return: True if the serialization is successful, False otherwise.
+        :rtype: bool
+
+        :raises AssertionError: If a programming error is detected.
+        """
         oldRelationalLocks = set(skel.dbEntity.get("%s_outgoingRelationalLocks" % name) or [])
         newRelationalLocks = set()
         # Clean old properties from entry (prevent name collision)
         for k in list(skel.dbEntity.keys()):
             if k.startswith("%s." % name):
                 del skel.dbEntity[k]
         indexed = self.indexed and parentIndexed
@@ -342,31 +477,47 @@
             assert skel["key"] in referencedObj["viur_incomming_relational_locks"], "Programming error detected?"
             referencedObj["viur_incomming_relational_locks"].remove(skel["key"])
             db.Put(referencedObj)
         return True
 
     def delete(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str):
         """
-            Ensure any outgoing relational lock is cleared
-        :param skel:
-        :param name:
-        :return:
+        Clear any outgoing relational locks when deleting a skeleton.
+
+        This method ensures that any outgoing relational locks are cleared when deleting a skeleton.
+
+        :param SkeletonInstance skel: The skeleton instance being deleted.
+        :param str name: The name of the bone being deleted.
+
+        :raises Warning: If a referenced entry is missing despite the lock.
         """
         if skel.dbEntity.get("%s_outgoingRelationalLocks" % name):
             for refKey in skel.dbEntity["%s_outgoingRelationalLocks" % name]:
                 referencedEntry = db.Get(refKey)
                 if not referencedEntry:
                     logging.warning("Programming error detected: Entry %s is gone despite lock" % refKey)
                     continue
                 incommingLocks = referencedEntry.get("viur_incomming_relational_locks", [])
                 # We remove any reference to ourself as multiple bones may hold Locks to the same entry
                 referencedEntry["viur_incomming_relational_locks"] = [x for x in incommingLocks if x != skel["key"]]
                 db.Put(referencedEntry)
 
     def postSavedHandler(self, skel, boneName, key):
+        """
+        Handle relational updates after a skeleton is saved.
+
+        This method updates, removes, or adds relations between the saved skeleton and the referenced entities.
+        It also takes care of updating the relational properties and consistency levels.
+
+        :param SkeletonInstance skel: The saved skeleton instance.
+        :param str boneName: The name of the relational bone.
+        :param google.cloud.datastore.key.Key key: The key of the saved skeleton instance.
+
+        :raises Warning: If a relation entry is corrupt and cannot be updated.
+        """
         if not skel[boneName]:
             values = []
         elif self.multiple and self.languages:
             values = chain(*skel[boneName].values())
         elif self.languages:
             values = list(skel[boneName].values())
         elif self.multiple:
@@ -426,28 +577,73 @@
             dbObj["viur_dest_kind"] = self.kind
             dbObj["viur_relational_updateLevel"] = self.updateLevel.value
             dbObj["viur_relational_consistency"] = self.consistency.value
             dbObj["viur_foreign_keys"] = self.refKeys
             db.Put(dbObj)
 
     def postDeletedHandler(self, skel, boneName, key):
+        """
+        Handle relational updates after a skeleton is deleted.
+
+        This method deletes all relations associated with the deleted skeleton and the referenced entities
+        for the given relational bone.
+
+        :param SkeletonInstance skel: The deleted skeleton instance.
+        :param str boneName: The name of the relational bone.
+        :param google.cloud.datastore.key.Key key: The key of the deleted skeleton instance.
+        """
         dbVals = db.Query("viur-relations")  # skel.kindName+"_"+self.kind+"_"+key
         dbVals.filter("viur_src_kind =", skel.kindName)
         dbVals.filter("viur_dest_kind =", self.kind)
         dbVals.filter("viur_src_property =", boneName)
         dbVals.filter("src.__key__ =", key)
         db.Delete([x for x in dbVals.run()])
 
     def isInvalid(self, key):
+        """
+        Check if the given key is invalid for this relational bone.
+
+        This method always returns None, as the actual validation of the key
+        is performed in other methods of the RelationalBone class.
+
+        :param key: The key to be checked for validity.
+        :return: None, as the actual validation is performed elsewhere.
+        """
         return None
 
     def parseSubfieldsFromClient(self):
+        """
+        Determine if the RelationalBone should parse subfields from the client.
+
+        This method returns True if the `using` attribute is not None, indicating
+        that this RelationalBone has a using-skeleton, and its subfields should
+        be parsed. Otherwise, it returns False.
+
+        :return: True if the using-skeleton is not None and subfields should be parsed, False otherwise.
+        :rtype: bool
+        """
         return self.using is not None
 
     def singleValueFromClient(self, value, skel, name, origData):
+        """
+        Deserialize a single value from the client and validate its integrity.
+
+        This method takes a value submitted from the client and attempts to deserialize and validate it. The value
+        is expected to be a key pointing to a referenced entry in the datastore.
+
+        :param value: The value submitted from the client.
+        :type value: str or dict
+        :param SkeletonInstance skel: The skeleton instance the bone is a part of.
+        :param str name: The name of the bone.
+        :param dict origData: The original data submitted from the client.
+
+        :return: A tuple containing the deserialized and validated value, and a list of errors if any.
+             Errors are instances of `ReadFromClientError`.
+        :rtype: Tuple[Union[dict, None], List[viur.core.bones.ReadFromClientError]]
+        """
         oldValues = skel[name]
 
         def restoreSkels(key, usingData, index=None):
             refSkel, usingSkel = self._getSkels()
             isEntryFromBackup = False  # If the referenced entry has been deleted, restore information from backup
             entry = None
             dbKey = None
@@ -512,16 +708,30 @@
                 return self.getEmptyValue(), [ReadFromClientError(ReadFromClientErrorSeverity.Invalid, err)]
             return resVal, errors
         else:
             return self.getEmptyValue(), errors
 
     def _rewriteQuery(self, name, skel, dbFilter, rawFilter):
         """
-            Rewrites a datastore query to operate on "viur-relations" instead of the original kind.
-            This is needed to perform relational queries on n:m relations.
+        Rewrites a datastore query to operate on "viur-relations" instead of the original kind.
+
+        This method is needed to perform relational queries on n:m relations. It takes the original datastore query
+        and rewrites it to target the "viur-relations" kind. It also adjusts filters and sort orders accordingly.
+
+        :param str name: The name of the bone.
+        :param SkeletonInstance skel: The skeleton instance the bone is a part of.
+        :param viur.core.db.Query dbFilter: The original datastore query to be rewritten.
+        :param dict rawFilter: The raw filter applied to the original datastore query.
+
+        :return: A tuple containing the name, skeleton, rewritten query, and raw filter.
+        :rtype: Tuple[str, 'viur.core.skeleton.SkeletonInstance', 'viur.core.db.Query', dict]
+
+        :raises NotImplementedError: If the original query contains multiple filters with "IN" or "!=" operators.
+        :raises RuntimeError: If the filtering is invalid, e.g., using multiple key filters or querying
+            properties not in parentKeys.
         """
         origQueries = dbFilter.queries
         if isinstance(origQueries, list):
             raise NotImplementedError(
                 "Doing a relational Query with multiple=True and \"IN or !=\"-filters is currently unsupported!")
         dbFilter.queries = db.QueryDefinition("viur-relations", {
             "viur_src_kind =": skel.kindName,
@@ -565,14 +775,32 @@
         self,
         name: str,
         skel: 'viur.core.skeleton.SkeletonInstance',
         dbFilter: db.Query,
         rawFilter: Dict,
         prefix: Optional[str] = None
     ) -> db.Query:
+        """
+        Builds a datastore query by modifying the given filter based on the RelationalBone's properties.
+
+        This method takes a datastore query and modifies it according to the relational bone properties.
+        It also merges any related filters based on the 'refKeys' and 'using' attributes of the bone.
+
+        :param str name: The name of the bone.
+        :param SkeletonInstance skel: The skeleton instance the bone is a part of.
+        :param db.Query dbFilter: The original datastore query to be modified.
+        :param dict rawFilter: The raw filter applied to the original datastore query.
+        :param str prefix: Optional prefix to be applied to filter keys.
+
+        :return: The modified datastore query.
+        :rtype: db.Query
+
+        :raises RuntimeError: If the filtering is invalid, e.g., querying properties not in 'refKeys'
+                          or not a bone in 'using'.
+        """
         relSkel, _usingSkelCache = self._getSkels()
         origQueries = dbFilter.queries
 
         if origQueries is None:  # This query is unsatisfiable
             return dbFilter
 
         myKeys = [x for x in rawFilter.keys() if x.startswith("%s." % name)]
@@ -652,19 +880,36 @@
     def buildDBSort(
         self,
         name: str,
         skel: 'viur.core.skeleton.SkeletonInstance',
         dbFilter: db.Query,
         rawFilter: Dict
     ) -> Optional[db.Query]:
+        """
+        Builds a datastore query by modifying the given filter based on the RelationalBone's properties for sorting.
+
+        This method takes a datastore query and modifies its sorting behavior according to the relational bone
+        properties. It also checks if the sorting is valid based on the 'refKeys' and 'using' attributes of the bone.
+
+        :param str name: The name of the bone.
+        :param SkeletonInstance skel: The skeleton instance the bone is a part of.
+        :param db.Query dbFilter: The original datastore query to be modified.
+        :param dict rawFilter: The raw filter applied to the original datastore query.
+
+        :return: The modified datastore query with updated sorting behavior.
+        :rtype: Optional[db.Query]
+
+        :raises RuntimeError: If the sorting is invalid, e.g., using properties not in 'refKeys'
+            or not a bone in 'using'.
+        """
         origFilter = dbFilter.queries
         if origFilter is None or not "orderby" in rawFilter:  # This query is unsatisfiable or not sorted
             return dbFilter
         if "orderby" in rawFilter and isinstance(rawFilter["orderby"], str) and rawFilter["orderby"].startswith(
-            "%s." % name):
+                "%s." % name):
             if not dbFilter.getKind() == "viur-relations" and self.multiple:  # This query has not been rewritten (yet)
                 name, skel, dbFilter, rawFilter = self._rewriteQuery(name, skel, dbFilter, rawFilter)
             key = rawFilter["orderby"]
             try:
                 unused, _type, param = key.split(".")
                 assert _type in ["dest", "rel"]
             except:
@@ -692,18 +937,31 @@
             if self.multiple:
                 dbFilter.setFilterHook(lambda s, filter, value: self.filterHook(name, s, filter, value))
                 dbFilter.setOrderHook(lambda s, orderings: self.orderHook(name, s, orderings))
         return dbFilter
 
     def filterHook(self, name, query, param, value):  # FIXME
         """
-            Hook installed by buildDbFilter.
-            This rewrites all filters added to the query after buildDbFilter has been run to match the
-            layout of our viur-relations index.
-            Also performs sanity checks wherever this query is possible at all.
+        Hook installed by buildDbFilter that rewrites filters added to the query to match the layout of the
+        viur-relations index and performs sanity checks on the query.
+
+        This method rewrites and validates filters added to a datastore query after the `buildDbFilter` method
+        has been executed. It ensures that the filters are compatible with the structure of the viur-relations
+        index and checks if the query is possible.
+
+        :param str name: The name of the bone.
+        :param db.Query query: The datastore query to be modified.
+        :param str param: The filter parameter to be checked and potentially modified.
+        :param value: The value associated with the filter parameter.
+
+        :return: A tuple containing the modified filter parameter and its associated value, or None if
+             the filter parameter is a key special property.
+        :rtype: Tuple[str, Any] or None
+
+        :raises RuntimeError: If the filtering is invalid, e.g., using properties not in 'refKeys' or 'parentKeys'.
         """
         if param.startswith("src.") or param.startswith("dest.") or param.startswith("viur_"):
             # This filter is already valid in our relation
             return param, value
         if param.startswith("%s." % name):
             # We add a constrain filtering by properties of the referenced entity
             refKey = param.replace("%s." % name, "")
@@ -738,18 +996,30 @@
             if srcKey not in self.parentKeys:
                 logging.warning("Invalid filtering! %s is not in parentKeys of RelationalBone %s!" % (srcKey, name))
                 raise RuntimeError()
             return "src.%s" % param, value
 
     def orderHook(self, name, query, orderings):  # FIXME
         """
-            Hook installed by buildDbFilter.
-            This rewrites all orderings added to the query after buildDbFilter has been run to match the
-            layout of our viur-relations index.
-            Also performs sanity checks wherever this query is possible at all.
+        Hook installed by buildDbFilter that rewrites orderings added to the query to match the layout of the
+        viur-relations index and performs sanity checks on the query.
+
+        This method rewrites and validates orderings added to a datastore query after the `buildDbFilter` method
+        has been executed. It ensures that the orderings are compatible with the structure of the viur-relations
+        index and checks if the query is possible.
+
+        :param str name: The name of the bone.
+        :param db.Query query: The datastore query to be modified.
+        :param orderings: A list or tuple of orderings to be checked and potentially modified.
+        :type orderings: List[Union[str, Tuple[str, db.SortOrder]]] or Tuple[Union[str, Tuple[str, db.SortOrder]]]
+
+        :return: A list of modified orderings that are compatible with the viur-relations index.
+        :rtype: List[Union[str, Tuple[str, db.SortOrder]]]
+
+        :raises RuntimeError: If the ordering is invalid, e.g., using properties not in 'refKeys' or 'parentKeys'.
         """
         res = []
         if not isinstance(orderings, list) and not isinstance(orderings, tuple):
             orderings = [orderings]
         for order in orderings:
             if isinstance(order, tuple):
                 orderKey = order[0]
@@ -785,17 +1055,23 @@
                         res.append(("src.%s" % orderKey, order[1]))
                     else:
                         res.append("src.%s" % orderKey)
         return res
 
     def refresh(self, skel, boneName):
         """
-            Refresh all values we might have cached from other entities.
-        """
+        Refreshes all values that might be cached from other entities in the provided skeleton.
+
+        This method updates the cached values for relational bones in the provided skeleton, which
+        correspond to other entities. It fetches the updated values for the relational bone's
+        reference keys and replaces the cached values in the skeleton with the fetched values.
 
+        :param SkeletonInstance skel: The skeleton containing the bone to be refreshed.
+        :param str boneName: The name of the bone to be refreshed.
+        """
         def updateInplace(relDict):
             """
                 Fetches the entity referenced by valDict["dest.key"] and updates all dest.* keys
                 accordingly
             """
             if not (isinstance(relDict, dict) and "dest" in relDict):
                 logging.error("Invalid dictionary in updateInplace: %s" % relDict)
@@ -823,14 +1099,26 @@
             if isinstance(skel[boneName], dict):
                 updateInplace(skel[boneName])
             elif isinstance(skel[boneName], list):
                 for k in skel[boneName]:
                     updateInplace(k)
 
     def getSearchTags(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> Set[str]:
+        """
+        Retrieves the search tags for the given RelationalBone in the provided skeleton.
+
+        This method iterates over the values of the relational bone and gathers search tags from the
+        reference and using skeletons. It combines all the tags into a set to avoid duplicates.
+
+        :param SkeletonInstance skel: The skeleton containing the bone for which search tags are to be retrieved.
+        :param str name: The name of the bone for which search tags are to be retrieved.
+
+        :return: A set of search tags for the specified relational bone.
+        :rtype: Set[str]
+        """
         result = set()
 
         def get_values(skel_, values_cache):
             for key, bone in skel_.items():
                 if not bone.searchable:
                     continue
                 for tag in bone.getSearchTags(values_cache, key):
@@ -845,16 +1133,27 @@
             if value["rel"]:
                 get_values(using_skel_cache, value["rel"])
 
         return result
 
     def createRelSkelFromKey(self, key: Union[str, db.Key], rel: Union[dict, None] = None):
         """
-            Creates a relSkel instance valid for this bone from the given database key.
+        Creates a relSkel instance valid for this bone from the given database key.
+
+        This method retrieves the entity corresponding to the provided key from the database, unserializes it
+        into a reference skeleton, and returns a dictionary containing the reference skeleton and optional
+        relation data.
+
+        :param Union[str, db.Key] key: The database key of the entity for which a relSkel instance is to be created.
+        :param Union[dict, None]rel: Optional relation data to be included in the resulting dictionary. Default is None.
+
+        :return: A dictionary containing a reference skeleton and optional relation data.
+        :rtype: dict
         """
+
         key = db.keyHelper(key, self.kind)
         entity = db.Get(key)
         if not entity:
             logging.error("Key %s not found" % str(key))
             return None
         relSkel = self._refSkelCache()
         relSkel.unserialize(entity)
@@ -872,42 +1171,45 @@
         skel: 'SkeletonInstance',
         boneName: str,
         value: Any,
         append: bool,
         language: Union[None, str] = None
     ) -> bool:
         """
-            Set our value to 'value'.
-            Santy-Checks are performed; if the value is invalid, no modification will happen.
+        Sets the value of the specified bone in the given skeleton. Sanity checks are performed to ensure the
+        value is valid. If the value is invalid, no modifications are made.
+
+        :param SkeletonInstance skel: Dictionary with the current values from the skeleton we belong to.
+        :param str boneName: The name of the bone to be modified.
+        :param value: The value to be assigned. The type depends on the bone type.
+        :param bool append: If true, the given value is appended to the values of the bone instead of replacing it.
+                   Only supported on bones with multiple=True.
+        :param Union[None, str] language: Set/append for a specific language (optional). Required if the bone
+            supports languages.
 
-            :param skel: Dictionary with the current values from the skeleton we belong to
-            :param boneName: The Bone which should be modified
-            :param value: The value that should be assigned. It's type depends on the type of that bone
-            :param append: If true, the given value is appended to the values of that bone instead of
-                replacing it. Only supported on bones with multiple=True
-            :param language: Set/append which language
-            :return: Wherever that operation succeeded or not.
+        :return: True if the operation succeeded, False otherwise.
+        :rtype: bool
         """
         assert not (bool(self.languages) ^ bool(language)), "Language is required or not supported"
         assert not append or self.multiple, "Can't append - bone is not multiple"
         if not self.multiple and not self.using:
             if not (isinstance(value, str) or isinstance(value, db.Key)):
                 logging.error(value)
                 logging.error(type(value))
                 raise ValueError("You must supply exactly one Database-Key to %s" % boneName)
             realValue = (value, None)
         elif not self.multiple and self.using:
             if not isinstance(value, tuple) or len(value) != 2 or \
-                not (isinstance(value[0], str) or isinstance(value[0], db.Key)) or \
-                not isinstance(value[1], self._skeletonInstanceClassRef):
+                    not (isinstance(value[0], str) or isinstance(value[0], db.Key)) or \
+                    not isinstance(value[1], self._skeletonInstanceClassRef):
                 raise ValueError("You must supply a tuple of (Database-Key, relSkel) to %s" % boneName)
             realValue = value
         elif self.multiple and not self.using:
             if not (isinstance(value, str) or isinstance(value, db.Key)) and not (isinstance(value, list)) \
-                and all([isinstance(x, str) or isinstance(x, db.Key) for x in value]):
+                    and all([isinstance(x, str) or isinstance(x, db.Key) for x in value]):
                 raise ValueError("You must supply a Database-Key or a list hereof to %s" % boneName)
             if isinstance(value, list):
                 realValue = [(x, None) for x in value]
             else:
                 realValue = [(value, None)]
         else:  # which means (self.multiple and self.using)
             if not (isinstance(value, tuple) and len(value) == 2 and
@@ -956,30 +1258,45 @@
                         skel[boneName] = {}
                     skel[boneName][language] = tmpRes
                 else:
                     skel[boneName] = tmpRes
         return True
 
     def getReferencedBlobs(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> Set[str]:
+        """
+        Retrieves the set of referenced blobs from the specified bone in the given skeleton instance.
+
+        :param SkeletonInstance skel: The skeleton instance to extract the referenced blobs from.
+        :param str name: The name of the bone to retrieve the referenced blobs from.
+
+        :return: A set containing the unique blob keys referenced by the specified bone.
+        :rtype: Set[str]
+        """
         result = set()
         for idx, lang, value in self.iter_bone_value(skel, name):
             if value is None:
                 continue
             logging.debug((idx, lang, value, name))
             for key, bone_ in value["dest"].items():
                 result.update(bone_.getReferencedBlobs(value["dest"], key))
             if value["rel"]:
                 for key, bone_ in value["rel"].items():
                     result.update(bone_.getReferencedBlobs(value["rel"], key))
         return result
 
     def getUniquePropertyIndexValues(self, valuesCache: dict, name: str) -> List[str]:
         """
-            By default, RelationalBones distinct by referenced keys. Should be overridden if a different
-            behaviour is required (eg. examine values from `prop:usingSkel`)
+        Generates unique property index values for the RelationalBone based on the referenced keys.
+        Can be overridden if different behavior is required (e.g., examining values from `prop:usingSkel`).
+
+        :param dict valuesCache: The cache containing the current values of the bone.
+        :param str name: The name of the bone for which to generate unique property index values.
+
+        :return: A list containing the unique property index values for the specified bone.
+        :rtype: List[str]
         """
         value = valuesCache.get(name)
         if not value:  # We don't have a value to lock
             return []
         if isinstance(value, dict):
             return self._hashValueForUniquePropertyIndex(value["dest"]["key"])
         elif isinstance(value, list):
```

## viur/core/bones/select.py

```diff
@@ -1,49 +1,71 @@
+"""
+    A SelectBone represents a dropdown list or selection menu allowing users to choose one or multiple options.
+    Inherits from the BaseBone class.
+"""
+
 import enum
 from collections import OrderedDict
 from numbers import Number
 from typing import Callable, Dict, List, Tuple, Union
 
 from viur.core.bones.base import BaseBone, ReadFromClientError, ReadFromClientErrorSeverity
 from viur.core.i18n import translate
 
 SelectBoneValue = Union[str, Number, enum.Enum]
+"""
+Type alias of possible values in a SelectBone. SelectBoneValue can be either a string (str) or a number (Number)
+"""
+
 SelectBoneMultiple = List[SelectBoneValue]
+""" SelectBoneMultiple is a list of SelectBoneValue elements."""
 
 
 class SelectBone(BaseBone):
+    """
+    A SelectBone represents a dropdown list or selection menu allowing users to choose one or multiple options.
+    Inherits from the BaseBone class. The `type` attribute is set to "select".
+
+    :param defaultValue: key(s) which will be checked by default
+    :param values: dict of key->value pairs from which the user can choose from.
+    :param kwargs: Additional keyword arguments that will be passed to the superclass' __init__ method.
+    """
     type = "select"
 
     def __init__(
         self,
         *,
         defaultValue: Union[
             SelectBoneValue,
             SelectBoneMultiple,
             Dict[str, Union[SelectBoneMultiple, SelectBoneValue]],
         ] = None,
         values: Union[Dict, List, Tuple, Callable, enum.EnumMeta] = (),
         **kwargs
     ):
-        """
-            Creates a new SelectBone.
 
-            :param defaultValue: key(s) which will be checked by default
-            :param values: dict of key->value pairs from which the user can choose from.
-        """
         super().__init__(defaultValue=defaultValue, **kwargs)
 
         # handle list/tuple as dicts
         if isinstance(values, (list, tuple)):
             values = {i: translate(i) for i in values}
 
         assert isinstance(values, (dict, OrderedDict)) or callable(values)
         self._values = values
 
     def __getattribute__(self, item):
+        """
+        Overrides the default __getattribute__ method to handle the 'values' attribute dynamically. If the '_values'
+        attribute is callable, it will be called and the result will be stored in the 'values' attribute.
+
+        :param str item: The attribute name.
+        :return: The value of the specified attribute.
+
+        :raises AssertionError: If the resulting values are not of type dict or OrderedDict.
+        """
         if item == "values":
             values = self._values
             if isinstance(values, enum.EnumMeta):
                 values = {value.value: translate(value.name) for value in values}
             elif callable(values):
                 values = values()
 
@@ -66,14 +88,29 @@
 
     def singleValueSerialize(self, val, skel: 'SkeletonInstance', name: str, parentIndexed: bool):
         if isinstance(self._values, enum.EnumMeta) and isinstance(val, self._values):
             return val.value
         return val
 
     def singleValueFromClient(self, value, skel, name, origData):
+        """
+        Processes the value received from the client and checks its validity. Returns the value if valid,
+        otherwise generates an error.
+
+        :param Union[str, Number] value: The value received from the client.
+        :param SkeletonInstance skel: A skeleton object that represents the data structure. Not utilized in this
+            implementation.
+        :param str name: The name of the bone. Not utilized in this implementation.
+        :param Dict[str, Any] origData: The original data dictionary containing all the data sent by the client.
+            Not utilized in this implementation.
+        :return: A tuple containing the processed value (if valid) or the empty value (if invalid), and a list of
+            ReadFromClientError objects (either empty if the value is valid or containing an error if the value is
+            invalid).
+        :rtype: Tuple[Union[str, Number, None], List[ReadFromClientError]]
+        """
         if not str(value):
             return self.getEmptyValue(), [ReadFromClientError(ReadFromClientErrorSeverity.Empty, "No value selected")]
         for key in self.values.keys():
             if str(key) == str(value):
                 if isinstance(self._values, enum.EnumMeta):
                     return self._values(key), None
                 return key, None
```

## viur/core/bones/selectcountry.py

```diff
@@ -1,7 +1,14 @@
+"""
+A bone representing a country selection input field in a web application or form.
+
+The SelectCountryBone is designed to provide a user-friendly way to select a country from a predefined list of
+countries. It inherits from the BaseBone class and extends it to support country-specific functionalities,
+such as displaying country names and handling country codes (e.g., ISO 3166-1 alpha-2 or alpha-3).
+"""
 from collections import OrderedDict
 from viur.core.bones.select import SelectBone
 
 
 ISO3CODES = {
     "abw": "Aruba",
     "afg": "Afghanistan",
@@ -239,14 +246,18 @@
     "wlf": "Wallis and Futuna",
     "wsm": "Samoa",
     "yem": "Yemen",
     "zaf": "South Africa",
     "zmb": "Zambia",
     "zwe": "Zimbabwe"
 }
+"""
+ISO 3166-1 alpha-3 (commonly referred to as ISO3) is a part of the ISO 3166 standard, which defines three-letter
+codes to represent countries.
+"""
 
 ISO2CODES = {
     "aw": "Aruba",
     "af": "Afghanistan",
     "ao": "Angola",
     "ai": "Anguilla",
     "al": "Albania",
@@ -481,15 +492,18 @@
     "wf": "Wallis and Futuna",
     "ws": "Samoa",
     "ye": "Yemen",
     "za": "South Africa",
     "zm": "Zambia",
     "zw": "Zimbabwe"
 }
-
+"""
+The ISO 2 country code (also known as ISO 3166-1 alpha-2) is an international standard consisting of two-letter
+codes used to identify countries.
+"""
 ISO3TOISO2 = {  # Convert iso3 to iso2 codes
     'yem': 'ye',
     'bvt': 'bv',
     'mnp': 'mp',
     'lso': 'ls',
     'uga': 'ug',
     'tkm': 'tm',
@@ -723,19 +737,30 @@
     'kna': 'kn',
     'gha': 'gh',
     'cck': 'cc',
     'chl': 'cl',
     'ury': 'uy',
     'tha': 'th'
 }
+"""A Map of ISO3 to ISO2 country codes"""
 
 ISO2TOISO3 = {v: k for k, v in ISO3TOISO2.items()}  # Build the invert map
+"""A built Map of ISO2 to ISO3 country codes"""
 
 
 class SelectCountryBone(SelectBone):
+    """
+    A bone representing a country selection input field in a web application or form.
+
+    The SelectCountryBone is designed to provide a user-friendly way to select a country from a predefined list of
+    countries. It inherits from the BaseBone class and extends it to support country-specific functionalities,
+    such as displaying country names and handling country codes (e.g., ISO 3166-1 alpha-2 or alpha-3).
+
+    :params List[str] countries: A list of countries supported by the bone, typically represented by their codes.
+    """
     type = "select.country"
     ISO2 = 2
     ISO3 = 3
 
     def __init__(self, *, codes=ISO2, values=None, **kwargs):
         global ISO2CODES, ISO3CODES
         assert codes in [self.ISO2, self.ISO3]
@@ -745,14 +770,26 @@
             values=OrderedDict(sorted((ISO2CODES if codes == self.ISO2 else ISO3CODES).items(), key=lambda i: i[1])),
             **kwargs
         )
 
         self.codes = codes
 
     def singleValueUnserialize(self, val):
+        """
+        Unserializes a single value, converting ISO country codes between ISO 3166-1 alpha-2 and alpha-3 if necessary.
+
+        This method takes a country code string (either ISO 3166-1 alpha-2 or alpha-3) and checks if a conversion is
+        needed based on the `self.codes` attribute. If a conversion is required, it attempts to perform the conversion
+        using the `ISO3TOISO2` or `ISO2TOISO3` dictionaries. If the conversion is successful, the converted code is
+        returned; otherwise, the original value is returned.
+
+        :params val: The value to be unserialized, typically a string representing an ISO country code.
+
+        :returns: The unserialized value, either the original or converted ISO country code.
+        """
         if isinstance(val, str) and len(val) == 3 and self.codes == self.ISO2:
             # We got an ISO3 code from the db, but are using ISO2
             try:
                 return ISO3TOISO2[val]
             except KeyError:
                 pass
         elif isinstance(val, str) and len(val) == 2 and self.codes == self.ISO3:
```

## viur/core/bones/sortindex.py

```diff
@@ -1,12 +1,28 @@
+"""
+The SortIndexBone class is specifically designed to handle sorting indexes for data elements, which are numeric
+values that determine the order of these elements. It inherits from the NumericBone.
+"""
 from viur.core.bones.numeric import NumericBone
-import time, typing
+import time
+import typing
 
 
 class SortIndexBone(NumericBone):
+    """
+    The SortIndexBone class is specifically designed to handle sorting indexes for data elements, which are
+    numeric values that determine the order of these elements. It inherits from the NumericBone.
+
+    :param typing.Union[int, float] defaultValue: A default value for the bone, which is a function that returns
+        the current time by default. This parameter accepts either an integer or a floating-point number.
+    :param str descr: A short description of the bone, set to "SortIndex" by default.
+    :param int precision: The precision of the numeric value, determining the number of decimal places allowed.
+        The default value is 8.
+    :param dict kwargs: Additional keyword arguments that can be passed to the parent NumericBone class.
+    """
     type = "numeric.sortindex"
 
     def __init__(
         self,
         *,
         defaultValue: typing.Union[int, float] = lambda *args, **kwargs: time.time(),
         descr: str = "SortIndex",
```

## viur/core/bones/spatial.py

```diff
@@ -1,60 +1,82 @@
+"""
+The "SpatialBone" is a specific type of data structure designed to handle spatial data, such as geographical
+coordinates or geometries. This bone would typically be used for representing and storing location-based data,
+like the coordinates of a point of interest on a map or the boundaries of a geographic region.
+"""
+
 from viur.core.bones.base import BaseBone, ReadFromClientError, ReadFromClientErrorSeverity
 from viur.core import db
-import logging, math
+import logging
+import math
 from math import pow, floor, ceil
 from copy import deepcopy
 from math import floor
 from typing import Any, Dict, List, Optional, Tuple, Union
 
 
 def haversine(lat1, lng1, lat2, lng2):
     """
-        Calculates the distance between two points on Earth given by (lat1,lng1) and (lat2, lng2) in Meter.
-        See https://en.wikipedia.org/wiki/Haversine_formula
+    Calculate the distance between two points on Earth's surface in meters.
 
-        :return: Distance in Meter
+    This function uses the haversine formula to compute the great-circle distance between
+    two points on Earth's surface, specified by their latitude and longitude coordinates.
+    The haversine formula is particularly useful for small distances on the Earth's surface,
+    as it provides accurate results with good performance.
+
+    For more details on the haversine formula, see
+    `Haversine formula <https://en.wikipedia.org/wiki/Haversine_formula>`_.
+
+    :param float lat1: Latitude of the first point in decimal degrees.
+    :param float lng1: Longitude of the first point in decimal degrees.
+    :param float lat2: Latitude of the second point in decimal degrees.
+    :param float lng2: Longitude of the second point in decimal degrees.
+    :return: Distance between the two points in meters.
+    :rtype: float
     """
     lat1 = math.radians(lat1)
     lng1 = math.radians(lng1)
     lat2 = math.radians(lat2)
     lng2 = math.radians(lng2)
     distLat = lat2 - lat1
     distlng = lng2 - lng1
     d = math.sin(distLat / 2.0) ** 2.0 + math.cos(lat1) * math.cos(lat2) * math.sin(distlng / 2.0) ** 2.0
     return math.atan2(math.sqrt(d), math.sqrt(1 - d)) * 12742000  # 12742000 = Avg. Earth size (6371km) in meters*2
 
 
 class SpatialBone(BaseBone):
     """
-        Allows to query by Elements close to a given position.
-        Prior to use, you must specify for which region of the map the index should be build.
-        This region should be as small as possible for best accuracy. You cannot use the whole world, as
-        no boundary wraps are been performed.
-        GridDimensions specifies into how many sub-regions the map will be split. Results further away than the
-        size of these sub-regions won't be considered within a search by this algorithm.
-
-        Example:
-            If you use this bone to query your data for the nearest pubs, you might want to this algorithm
-            to consider results up to 100km distance, but not results that are 500km away.
-            Setting the size of these sub-regions to roughly 100km width/height allows this algorithm
-            to exclude results further than 200km away on database-query-level, therefore drastically
-            improving performance and reducing costs per query.
+    This feature allows querying elements near a specific location. Before using, designate the map region for
+    which the index should be constructed. To ensure the best accuracy, minimize the region size; using the entire
+    world is not feasible since boundary wraps are not executed. GridDimensions indicates the number of sub-regions
+    the map will be partitioned into. Results beyond the size of these sub-regions will not be considered during
+    searches by this algorithm.
+
+    .. note:: Example:
+        When using this feature to find the nearest pubs, the algorithm could be set to consider
+        results within 100km but not those 500km away. Setting the sub-region size to roughly
+        100km in width and height allows the algorithm to exclude results further than 200km away
+        at the database-query-level, significantly enhancing performance and reducing query costs.
 
         Example region: Germany: boundsLat=(46.988, 55.022), boundsLng=(4.997, 15.148)
+
+    :param Tuple[float, float] boundsLat: The outer bounds (Latitude) of the region we will search in
+    :param Tuple[float, float] boundsLng: The outer bounds (Longitude) of the region we will search in
+    :param gridDimensions: (Tuple[int, int]) The number of sub-regions the map will be divided in
     """
 
     type = "spatial"
 
-    def __init__(self, *, boundsLat: Tuple[float, float], boundsLng: Tuple[float, float], gridDimensions: Tuple[int, int], **kwargs):
+    def __init__(self, *, boundsLat: Tuple[float, float], boundsLng: Tuple[float, float],
+                 gridDimensions: Tuple[int, int], **kwargs):
         """
             Initializes a new SpatialBone.
 
             :param boundsLat: Outer bounds (Latitude) of the region we will search in.
-            :param boundsLng: Outer bounds (Latitude) of the region we will search in.
+            :param boundsLng: Outer bounds (Longitude) of the region we will search in.
             :param gridDimensions: Number of sub-regions the map will be divided in
         """
         super().__init__(**kwargs)
         assert isinstance(boundsLat, tuple) and len(boundsLat) == 2, "boundsLat must be a tuple of (float, float)"
         assert isinstance(boundsLng, tuple) and len(boundsLng) == 2, "boundsLng must be a tuple of (float, float)"
         assert isinstance(gridDimensions, tuple) and len(
             gridDimensions) == 2, "gridDimensions must be a tuple of (int, int)"
@@ -71,41 +93,55 @@
         assert not (self.indexed and self.multiple), "Spatial-Bone cannot be indexed when multiple"
         self.boundsLat = boundsLat
         self.boundsLng = boundsLng
         self.gridDimensions = gridDimensions
 
     def getGridSize(self):
         """
-            :return: the size of our sub-regions in (fractions-of-latitude, fractions-of-longitude)
-            :rtype: (float, float)
+        Calculate and return the size of the sub-regions in terms of fractions of latitude and longitude.
+
+        :return: A tuple containing the size of the sub-regions as (fractions-of-latitude, fractions-of-longitude)
+        :rtype: (float, float)
         """
         latDelta = float(self.boundsLat[1] - self.boundsLat[0])
         lngDelta = float(self.boundsLng[1] - self.boundsLng[0])
         return latDelta / float(self.gridDimensions[0]), lngDelta / float(self.gridDimensions[1])
 
     def isInvalid(self, value: Tuple[float, float]) -> Union[str, bool]:
         """
-            Tests, if the point given by 'value' is inside our boundaries.
-            We'll reject all values outside that region.
-            :param value: (latitude, longitude) of the location of this entry.
-            :return: An error-description or False if the value is valid
-            :rtype: str | False
+        Validate if the given point (latitude, longitude) falls within the specified boundaries.
+        Rejects all values outside the defined region.
+
+        :param value: A tuple containing the location of the entry as (latitude, longitude)
+        :return: An error description if the value is invalid or False if the value is valid
+        :rtype: str | bool
         """
         try:
             lat, lng = value
         except:
             return "Invalid value entered"
         if lat < self.boundsLat[0] or lat > self.boundsLat[1]:
             return "Latitude out of range"
         elif lng < self.boundsLng[0] or lng > self.boundsLng[1]:
             return "Longitude out of range"
         else:
             return False
 
     def singleValueSerialize(self, value, skel: 'SkeletonInstance', name: str, parentIndexed: bool):
+        """
+        Serialize a single value (latitude, longitude) for storage. If the bone is indexed, calculate
+        and add tile information for efficient querying.
+
+        :param value: A tuple containing the location of the entry as (latitude, longitude)
+        :param SkeletonInstance skel: The instance of the Skeleton this bone is attached to
+        :param str name: The name of this bone
+        :param bool parentIndexed: A boolean indicating if the parent bone is indexed
+        :return: A dictionary containing the serialized data, including coordinates and tile information (if indexed)
+        :rtype: dict | None
+        """
         if not value:
             return None
         lat, lng = value
         res = {
             "coordinates": {
                 "lat": lat,
                 "lng": lng,
@@ -119,52 +155,76 @@
             res["tiles"] = {
                 "lat": [tileLat - 1, tileLat, tileLat + 1],
                 "lng": [tileLng - 1, tileLng, tileLng + 1],
             }
         return res
 
     def singleValueUnserialize(self, val):
+        """
+        Deserialize a single value (latitude, longitude) from the stored data.
+
+        :param val: A dictionary containing the serialized data, including coordinates
+        :return: A tuple containing the location of the entry as (latitude, longitude)
+        :rtype: Tuple[float, float] | None
+        """
         if not val:
             return None
         return val["coordinates"]["lat"], val["coordinates"]["lng"]
 
     def parseSubfieldsFromClient(self):
+        """
+        Determines if subfields (latitude and longitude) should be parsed from the client.
+
+        :return: Always returns True, as latitude and longitude are required
+        :rtype: bool
+        """
         return True  # We'll always get .lat and .lng
 
-    def isEmpty(self, rawValue: Any):
-        if not rawValue:
+    def isEmpty(self, value: Any):
+        """
+        Check if the given raw value is considered empty (either not present or equal to the empty value).
+
+        :param value: The raw value to be checked
+        :return: True if the raw value is considered empty, False otherwise
+        :rtype: bool
+        """
+        if not value:
             return True
-        if isinstance(rawValue, dict):
+        if isinstance(value, dict):
             try:
-                rawLat = float(rawValue["lat"])
-                rawLng = float(rawValue["lng"])
+                rawLat = float(value["lat"])
+                rawLng = float(value["lng"])
                 return (rawLat, rawLng) == self.getEmptyValue()
             except:
                 return True
-        return rawValue == self.getEmptyValue()
+        return value == self.getEmptyValue()
 
     def getEmptyValue(self) -> Tuple[float, float]:
         """
-            If you need a special marker for empty, use 91.0, 181.0.
-            These are both out of range for Latitude (-90, +90) and Longitude (-180, 180) but will be accepted
-            by Vi and Admin
+        Returns an empty value for the bone, which represents an invalid position. Use 91.0, 181.0 as a special
+        marker for empty, as they are both out of range for Latitude (-90, +90) and Longitude (-180, 180), but will
+        be accepted by Vi and Admin.
+
+        :return: A tuple representing an empty value for this bone (91.0, 181.0)
+        :rtype: Tuple[float, float]
         """
         return 0.0, 0.0
 
     def singleValueFromClient(self, value: Dict, skel: str, name: str, origData: Dict):
         """
-            Reads a value from the client.
-            If this value is valid for this bone,
-            store this value and return None.
-            Otherwise our previous value is
-            left unchanged and an error-message
-            is returned.
-
-            :param name: Our name in the skeleton
-            :param value: *User-supplied* request-data
+        Processes a value received from the client. If the value is valid for this bone, it is stored,
+        and None is returned. If the value is not valid, the previous value remains unchanged, and an
+        error message is returned.
+
+        :param dict value: User-supplied request data
+        :param skel: The skeleton instance
+        :param str name: The name of the bone in the skeleton
+        :param dict origData: The original data from the client request
+        :return: A tuple containing the processed value and a list of errors, if any
+        :rtype: Tuple[Union[Tuple[float, float], None], List[ReadFromClientError]]
         """
         rawLat = value.get("lat", None)
         rawLng = value.get("lng", None)
         if rawLat is None and rawLng is None:
             return self.getEmptyValue(), [
                 ReadFromClientError(ReadFromClientErrorSeverity.NotSet, "Field not submitted")]
         elif rawLat is None or rawLng is None:
@@ -179,39 +239,37 @@
             return self.getEmptyValue(), [
                 ReadFromClientError(ReadFromClientErrorSeverity.Invalid, "Invalid value entered")]
         err = self.isInvalid((rawLat, rawLng))
         if err:
             return self.getEmptyValue(), [ReadFromClientError(ReadFromClientErrorSeverity.Invalid, err)]
         return (rawLat, rawLng), None
 
-
     def buildDBFilter(
         self,
         name: str,
         skel: 'viur.core.skeleton.SkeletonInstance',
         dbFilter: db.Query,
         rawFilter: Dict,
         prefix: Optional[str] = None
     ) -> db.Query:
         """
-            Parses the searchfilter a client specified in his Request into
-            something understood by the datastore.
-            This function must:
-
-                * Ignore all filters not targeting this bone
-                * Safely handle malformed data in rawFilter
-                    (this parameter is directly controlled by the client)
-
-            For detailed information, how this geo-spatial search works, see the ViUR documentation.
-
-            :param name: The property-name this bone has in its Skeleton (not the description!)
-            :param skel: The :class:`viur.core.db.Query` this bone is part of
-            :param dbFilter: The current :class:`viur.core.db.Query` instance the filters should be applied to
-            :param rawFilter: The dictionary of filters the client wants to have applied
-            :returns: The modified :class:`viur.core.db.Query`
+        Parses the client's search filter specified in their request and converts it into a format
+        understood by the datastore. This function should:
+            - Ignore filters that do not target this bone.
+            - Safely handle malformed data in rawFilter (this parameter is directly controlled by the client).
+
+        For detailed information on how this geo-spatial search works, see the ViUR documentation.
+
+        :param str name: The property name this bone has in its Skeleton (not the description!)
+        :param SkeletonInstance skel: The skeleton this bone is part of
+        :param db.Query dbFilter: The current `viur.core.db.Query` instance to which the filters should be applied
+        :param dict rawFilter: The dictionary of filters the client wants to have applied
+        :param prefix: Optional string, specifying a prefix for the bone's name (default is None)
+        :return: The modified `viur.core.db.Query` instance
+        :rtype: db.Query
         """
         assert prefix is None, "You cannot use spatial data in a relation for now"
         if name + ".lat" in rawFilter and name + ".lng" in rawFilter:
             try:
                 lat = float(rawFilter[name + ".lat"])
                 lng = float(rawFilter[name + ".lng"])
             except:
@@ -252,34 +310,37 @@
                                                                                                  **kwargs)
             dbFilter._calculateInternalMultiQueryLimit = self.calculateInternalMultiQueryLimit
 
     # return super().buildDBFilter(name, skel, dbFilter, rawFilter)
 
     def calculateInternalMultiQueryLimit(self, dbQuery: db.Query, targetAmount: int):
         """
-            Tells :class:`viur.core.db.Query` How much entries should be fetched in each subquery.
+        Provides guidance to viur.core.db.Query on the number of entries that should be fetched in each subquery.
 
-            :param targetAmount: How many entries shall be returned from db.Query
-            :returns: The amount of elements db.Query should fetch on each subquery
+        :param dbQuery: The `viur.core.db.Query` instance
+        :param targetAmount: The desired number of entries to be returned from the db.Query
+        :return: The number of elements db.Query should fetch for each subquery
+        :rtype: int
         """
         return targetAmount * 2
 
     def customMultiQueryMerge(self, name, lat, lng, dbFilter: db.Query,
                               result: List[db.Entity], targetAmount: int
                               ) -> List[db.Entity]:
         """
-            Randomly returns 'targetAmount' elements from 'result'
+        Randomly returns 'targetAmount' elements from 'result'.
 
-            :param name:
-            :param lat:
-            :param lng:
-            :param dbFilter: The db.Query calling this function
-            :param result: The list of results for each subquery we've run
-            :param targetAmount: How many results should be returned from db.Query
-            :return: List of elements which should be returned from db.Query
+        :param str name: The property-name this bone has in its Skeleton (not the description!)
+        :param lat: Latitude of the reference point
+        :param lng: Longitude of the reference point
+        :param dbFilter: The db.Query instance calling this function
+        :param result: The list of results for each subquery that was executed
+        :param int targetAmount: The desired number of results to be returned from db.Query
+        :return: List of elements to be returned from db.Query
+        :rtype: List[db.Entity]
         """
         assert len(result) == 4  # There should be exactly one result for each direction
         result = [list(x) for x in result]  # Remove the iterators
         latRight, latLeft, lngBottom, lngTop = result
         gridSizeLat, gridSizeLng = self.getGridSize()
         # Calculate the outer bounds we've reached - used to tell to which distance we can
         # prove the result to be correct.
@@ -317,24 +378,26 @@
         skel: 'SkeletonInstance',
         boneName: str,
         value: Any,
         append: bool,
         language: Union[None, str] = None
     ) -> bool:
         """
-            Set our value to 'value'.
-            Santy-Checks are performed; if the value is invalid, we flip our value back to its original
-            (default) value and return false.
-
-            :param skel: Dictionary with the current values from the skeleton we belong to
-            :param boneName: The Bone which should be modified
-            :param value: The value that should be assigned. It's type depends on the type of that bone
-            :param append: If true, the given value is appended to the values of that bone instead of
-                replacing it. Only supported on bones with multiple=True
-            :return: Wherever that operation succeeded or not.
+        Sets the value of the bone to the provided 'value'.
+        Sanity checks are performed; if the value is invalid, the bone value will revert to its original
+        (default) value and the function will return False.
+
+        :param skel: Dictionary with the current values from the skeleton the bone belongs to
+        :param boneName: The name of the bone that should be modified
+        :param value: The value that should be assigned. Its type depends on the type of the bone
+        :param append: If True, the given value will be appended to the existing bone values instead of
+            replacing them. Only supported on bones with multiple=True
+        :param language: Optional, the language of the value if the bone is language-aware
+        :return: A boolean indicating whether the operation succeeded or not
+        :rtype: bool
         """
         if append:
             raise ValueError("append is not possible on %s bones" % self.type)
         assert isinstance(value, tuple) and len(value) == 2, "Value must be a tuple of (lat, lng)"
         skel[boneName] = value
 
     def structure(self) -> dict:
```

## viur/core/bones/string.py

```diff
@@ -1,66 +1,142 @@
+"""
+The "StringBone" class is a subclass of the "BaseBone" class and represents a data field that
+contains text values. It overrides some of the base class methods to provide specific functionality
+for text fields.
+"""
+
 import logging
 from typing import Dict, List, Optional, Set
 
-from viur.core import db, utils, current
+from viur.core import current, db, utils
 from viur.core.bones.base import BaseBone, ReadFromClientError, ReadFromClientErrorSeverity
 
 
-
 class StringBone(BaseBone):
-    type = "str"
+    """
+    The "StringBone" represents a data field that contains text values.
 
+    :param caseSensitive: A boolean value indicating whether the text values in this field are
+        case-sensitive or not.
+    :param maxLength: The maximum length of the text values in this field.
+    :param kwargs: Additional keyword arguments to pass to the base class constructor.
+    """
+    type = "str"
     def __init__(
         self,
         *,
         caseSensitive: bool = True,
-        maxLength: int = 254,
+        maxLength: int | None = 254,
         **kwargs
     ):
+        """
+        Initializes a new StringBone.
+
+        :param caseSensitive: When filtering for values in this bone, should it be case-sensitive?
+        :param maxLength: The maximum length allowed for values of this bone. Set to None for no limitation.
+        :param kwargs: Inherited arguments from the BaseBone.
+        """
         super().__init__(**kwargs)
+        if maxLength is not None and maxLength <= 0:
+            raise ValueError("maxLength must be a positive integer or None")
         self.caseSensitive = caseSensitive
         self.maxLength = maxLength
 
     def singleValueSerialize(self, value, skel: 'SkeletonInstance', name: str, parentIndexed: bool):
+        """
+        Serializes a single value of this data field for storage in the database.
+
+        :param value: The value to serialize.
+        :param skel: The skeleton instance that this data field belongs to.
+        :param name: The name of this data field.
+        :param parentIndexed: A boolean value indicating whether the parent object has an index on
+            this data field or not.
+        :return: The serialized value.
+        """
         if not self.caseSensitive and parentIndexed:
             return {"val": value, "idx": value.lower() if isinstance(value, str) else None}
         return value
 
     def singleValueUnserialize(self, value):
+        """
+        Unserializes a single value of this data field from the database.
+
+        :param value: The serialized value to unserialize.
+        :return: The unserialized value.
+        """
         if isinstance(value, dict) and "val" in value:
             return value["val"]
         elif value:
             return str(value)
         else:
             return ""
 
     def getEmptyValue(self):
+        """
+        Returns the empty value for this data field.
+
+        :return: An empty string.
+        """
         return ""
 
     def isEmpty(self, value):
+        """
+        Determines whether a value for this data field is empty or not.
+
+        :param value: The value to check for emptiness.
+        :return: A boolean value indicating whether the value is empty or not.
+        """
         if not value:
             return True
 
         return not bool(str(value).strip())
 
+    def isInvalid(self, value):
+        """
+        Returns None if the value would be valid for
+        this bone, an error-message otherwise.
+        """
+        if self.maxLength is not None and len(value) > self.maxLength:
+            return "Maximum length exceeded"
+        return None
+
     def singleValueFromClient(self, value, skel, name, origData):
+        """
+        Converts a value for this data field from a client-provided representation to an internal
+        representation.
+
+        :param value: The value to convert from the client-provided representation.
+        :param skel: The skeleton instance that this data field belongs to.
+        :param name: The name of this data field.
+        :param origData: The original data of the skeleton instance.
+        :return: A tuple containing the converted value and a list of any validation errors encountered.
+        """
         value = utils.escapeString(value, self.maxLength)
-        err = self.isInvalid(value)
-        if not err:
-            return utils.escapeString(value, self.maxLength), None
+        if not (err := self.isInvalid(value)):
+            return value, None
         return self.getEmptyValue(), [ReadFromClientError(ReadFromClientErrorSeverity.Invalid, err)]
 
     def buildDBFilter(
         self,
         name: str,
         skel: 'viur.core.skeleton.SkeletonInstance',
         dbFilter: db.Query,
         rawFilter: Dict,
         prefix: Optional[str] = None
     ) -> db.Query:
+        """
+        Builds and returns a database filter for this data field based on the provided raw filter data.
+
+        :param name: The name of this data field.
+        :param skel: The skeleton instance that this data field belongs to.
+        :param dbFilter: The database filter to add query clauses to.
+        :param rawFilter: A dictionary containing the raw filter data for this data field.
+        :param prefix: An optional prefix to add to the query clause.
+        :return: The database filter with the added query clauses.
+        """
         if name not in rawFilter and not any(
             [(x.startswith(name + "$") or x.startswith(name + ".")) for x in rawFilter.keys()]
         ):
             return super().buildDBFilter(name, skel, dbFilter, rawFilter, prefix)
 
         if not self.languages:
             namefilter = name
@@ -110,26 +186,36 @@
     def buildDBSort(
         self,
         name: str,
         skel: 'viur.core.skeleton.SkeletonInstance',
         dbFilter: db.Query,
         rawFilter: Dict
     ) -> Optional[db.Query]:
-        if "orderby" in rawFilter and (rawFilter["orderby"] == name or (
-            isinstance(rawFilter["orderby"], str) and rawFilter["orderby"].startswith(
-            "%s." % name) and self.languages)):
+        """
+        Build a DB sort based on the specified name and a raw filter.
+
+        :param name: The name of the attribute to sort by.
+        :param skel: A SkeletonInstance object.
+        :param dbFilter: A Query object representing the current DB filter.
+        :param rawFilter: A dictionary containing the raw filter.
+        :return: The Query object with the specified sort applied.
+        :rtype: Optional[google.cloud.ndb.query.Query]
+        """
+        if ((orderby := rawFilter.get("orderby"))
+            and (orderby == name
+                 or (isinstance(orderby, str) and orderby.startswith(f"{name}.") and self.languages))):
             if self.languages:
                 lang = None
-                if rawFilter["orderby"].startswith("%s." % name):
-                    lng = rawFilter["orderby"].replace("%s." % name, "")
+                if orderby.startswith(f"{name}."):
+                    lng = orderby.replace(f"{name}.", "")
                     if lng in self.languages:
                         lang = lng
                 if lang is None:
                     lang = current.language.get()  # currentSession.getLanguage()
-                    if not lang or not lang in self.languages:
+                    if not lang or lang not in self.languages:
                         lang = self.languages[0]
                 if self.caseSensitive:
                     prop = "%s.%s" % (name, lang)
                 else:
                     prop = "%s.%s.idx" % (name, lang)
             else:
                 if self.caseSensitive:
@@ -154,24 +240,43 @@
                 else:
                     dbFilter.order(order)
             else:
                 dbFilter.order(order)
         return dbFilter
 
     def getSearchTags(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> Set[str]:
+        """
+        Returns a set of lowercased words that represent searchable tags for the given bone.
+
+        :param skel: The skeleton instance being searched.
+        :param name: The name of the bone to generate tags for.
+
+        :return: A set of lowercased words representing searchable tags.
+        :rtype: set
+        """
         result = set()
         for idx, lang, value in self.iter_bone_value(skel, name):
             if value is None:
                 continue
             for line in str(value).splitlines():  # TODO: Can a StringBone be multiline?
                 for word in line.split(" "):
                     result.add(word.lower())
         return result
 
     def getUniquePropertyIndexValues(self, skel, name: str) -> List[str]:
+        """
+        Returns a list of unique index values for a given property name.
+
+        :param skel: The skeleton instance.
+        :param name: The name of the property.
+        :return: A list of unique index values for the property.
+        :rtype: List[str]
+        :raises NotImplementedError: If the StringBone has languages and the implementation
+            for this case is not yet defined.
+        """
         if self.languages:
             # Not yet implemented as it's unclear if we should keep each language distinct or not
             raise NotImplementedError()
 
         return super().getUniquePropertyIndexValues(skel, name)
 
     def structure(self) -> dict:
```

## viur/core/bones/text.py

```diff
@@ -1,7 +1,11 @@
+"""
+The TextBone is specifically designed to handle text input fields. TextBone is a subclass of the BaseBone class,
+inheriting its core functionality and extending it to support text-specific data manipulation.
+"""
 import string
 from base64 import urlsafe_b64decode
 from datetime import datetime
 from html import entities as htmlentitydefs
 from html.parser import HTMLParser
 from typing import Dict, List, Optional, Set, Tuple, Union
 
@@ -24,21 +28,39 @@
     },
     "validStyles": [
         "color"
     ],  # List of CSS-Directives we allow
     "validClasses": ["vitxt-*", "viur-txt-*"],  # List of valid class-names that are valid
     "singleTags": ["br", "img", "hr"]  # List of tags, which don't have a corresponding end tag
 }
+"""
+A dictionary containing default configurations for handling HTML content in TextBone instances.
+
+- validTags (list[str]):
+    A list of valid HTML tags allowed in TextBone instances.
+- validAttrs (dict[str, list[str]]):
+    A dictionary mapping valid attributes for each tag. If a tag is not listed, no attributes are allowed for that tag.
+- validStyles (list[str]):
+   A list of allowed CSS directives for the TextBone instances.
+- validClasses (list[str]):
+    A list of valid CSS class names allowed in TextBone instances.
+- singleTags (list[str]):
+   A list of self-closing HTML tags that don't have corresponding end tags.
+"""
 
 
 def parseDownloadUrl(urlStr: str) -> Tuple[Optional[str], Optional[bool], Optional[str]]:
     """
-        Parses a file download-url (/file/download/xxxx?sig=yyyy) into it's components
-        blobKey, derived (yes/no) and filename. Will return None for each component if the url
-        could not be parsed.
+    Parses a file download URL in the format `/file/download/xxxx?sig=yyyy` into its components: blobKey, derived,
+    and filename. If the URL cannot be parsed, the function returns None for each component.
+
+    :param str urlStr: The file download URL to be parsed.
+    :return: A tuple containing the parsed components: (blobKey, derived, filename).
+            Each component will be None if the URL could not be parsed.
+    :rtype: Tuple[Optional[str], Optional[bool], Optional[str]]
     """
     if not urlStr.startswith("/file/download/") or "?" not in urlStr:
         return None, None, None
     dataStr, sig = urlStr[15:].split("?")  # Strip /file/download/ and split on ?
     sig = sig[4:]  # Strip sig=
     if not utils.hmacVerify(dataStr.encode("ASCII"), sig):
         # Invalid signature, bail out
@@ -53,68 +75,111 @@
         return None, None, None
     blobkey, derived, fileName = dlPath.split("/")
     derived = derived != "source"
     return blobkey, derived, fileName
 
 
 class CollectBlobKeys(HTMLParser):
+    """
+    A custom HTML parser that extends the HTMLParser class to collect blob keys found in the "src" attribute
+    of <a> and <img> tags.
+    """
+
     def __init__(self):
         super(CollectBlobKeys, self).__init__()
         self.blobs = set()
 
     def handle_starttag(self, tag, attrs):
+        """
+        Handles the start tag in the HTML content being parsed. If the tag is an <a> or <img> element, the method
+        extracts the blob key from the "src" attribute and adds it to the "blobs" set.
+
+        :param str tag: The current start tag encountered by the parser.
+        :param List[Tuple[str, str]] attrs: A list of tuples containing the attribute name and value of the current tag.
+        """
         if tag in ["a", "img"]:
             for k, v in attrs:
                 if k == "src":
                     blobKey, _, _ = parseDownloadUrl(v)
                     if blobKey:
                         self.blobs.add(blobKey)
 
 
 class HtmlSerializer(HTMLParser):  # html.parser.HTMLParser
+    """
+    A custom HTML parser that extends the HTMLParser class to sanitize and serialize HTML content
+    by removing invalid tags and attributes while retaining the valid ones.
+
+    :param dict validHtml: A dictionary containing valid HTML tags, attributes, styles, and classes.
+    :param dict srcSet: A dictionary containing width and height for srcset attribute processing.
+    """
+
     def __init__(self, validHtml=None, srcSet=None):
         global _defaultTags
         super(HtmlSerializer, self).__init__()
         self.result = ""  # The final result that will be returned
         self.openTagsList = []  # List of tags that still need to be closed
         self.tagCache = []  # Tuple of tags that have been processed but not written yet
         self.validHtml = validHtml
         self.srcSet = srcSet
 
     def handle_data(self, data):
+        """
+        Handles the data encountered in the HTML content being parsed. Escapes special characters
+        and appends the data to the result if it is not only whitespace characters.
+
+        :param str data: The data encountered by the parser.
+        """
         data = str(data) \
             .replace("<", "&lt;") \
             .replace(">", "&gt;") \
             .replace("\"", "&quot;") \
             .replace("'", "&#39;") \
             .replace("\0", "")
         if data.strip():
             self.flushCache()
             self.result += data
 
     def handle_charref(self, name):
+        """
+        Handles character references in the HTML content being parsed and appends the character reference to the
+        result.
+
+        :param str name: The name of the character reference.
+        """
         self.flushCache()
         self.result += "&#%s;" % (name)
 
     def handle_entityref(self, name):  # FIXME
+        """
+        Handles entity references in the HTML content being parsed and appends the entity reference to the result.
+
+        :param str name: The name of the entity reference.
+        """
         if name in htmlentitydefs.entitydefs.keys():
             self.flushCache()
             self.result += "&%s;" % (name)
 
     def flushCache(self):
         """
-            Flush pending tags into the result and push their corresponding end-tags onto the stack
+        Flush pending tags into the result and push their corresponding end-tags onto the stack
         """
         for start, end in self.tagCache:
             self.result += start
             self.openTagsList.insert(0, end)
         self.tagCache = []
 
     def handle_starttag(self, tag, attrs):
-        """ Delete all tags except for legal ones """
+        """
+        Handles start tags in the HTML content being parsed. Filters out invalid tags and attributes and
+        processes valid ones.
+
+        :param str tag: The current start tag encountered by the parser.
+        :param List[Tuple[str, str]] attrs: A list of tuples containing the attribute name and value of the current tag.
+        """
         filterChars = "\"'\\\0\r\n@()"
         if self.validHtml and tag in self.validHtml["validTags"]:
             cacheTagStart = '<' + tag
             isBlankTarget = False
             styles = None
             classes = None
             for k, v in attrs:
@@ -159,22 +224,22 @@
                     isBlankTarget = True
             if styles:
                 syleRes = {}
                 for s in styles:
                     style = s[: s.find(":")].strip()
                     value = s[s.find(":") + 1:].strip()
                     if any([c in style for c in filterChars]) or any(
-                        [c in value for c in filterChars]):
+                            [c in value for c in filterChars]):
                         # Either the key or the value contains a character that's not supposed to be there
                         continue
                     if value.lower().startswith("expression") or value.lower().startswith("import"):
                         # IE evaluates JS inside styles if the keyword expression is present
                         continue
                     if style in self.validHtml["validStyles"] and not any(
-                        [(x in value) for x in ["\"", ":", ";"]]):
+                            [(x in value) for x in ["\"", ":", ";"]]):
                         syleRes[style] = value
                 if len(syleRes.keys()):
                     cacheTagStart += " style=\"%s\"" % "; ".join(
                         [("%s: %s" % (k, v)) for (k, v) in syleRes.items()])
             if classes:
                 validClasses = []
                 for currentClass in classes:
@@ -209,14 +274,19 @@
                 # we detect it has no content
                 cacheTagStart += '>'
                 self.tagCache.append((cacheTagStart, tag))
         else:
             self.result += " "
 
     def handle_endtag(self, tag):
+        """
+        Handles end tags in the HTML content being parsed. Closes open tags and discards invalid ones.
+
+        :param str tag: The current end tag encountered by the parser.
+        """
         if self.validHtml:
             if self.tagCache:
                 # Check if that element is still on the cache
                 # and just silently drop the cache up to that point
                 if tag in [x[1] for x in self.tagCache] + self.openTagsList:
                     for tagCache in self.tagCache[::-1]:
                         self.tagCache.remove(tagCache)
@@ -228,30 +298,51 @@
                 for endTag in self.openTagsList[:]:
                     self.result += "</%s>" % endTag
                     self.openTagsList.remove(endTag)
                     if endTag == tag:
                         break
 
     def cleanup(self):  # FIXME: vertauschte tags
-        """ Append missing closing tags """
+        """ Append missing closing tags to the result."""
         self.flushCache()
         for tag in self.openTagsList:
             endTag = '</%s>' % tag
             self.result += endTag
 
     def sanitize(self, instr):
+        """
+        Sanitizes the input HTML string by removing invalid tags and attributes while retaining valid ones.
+
+        :param str instr: The input HTML string to be sanitized.
+        :return: The sanitized HTML string.
+        :rtype: str
+        """
         self.result = ""
         self.openTagsList = []
         self.feed(instr)
         self.close()
         self.cleanup()
         return self.result
 
 
 class TextBone(BaseBone):
+    """
+    A bone for storing and validating HTML or plain text content. Can be configured to allow
+    only specific HTML tags and attributes, and enforce a maximum length. Supports the use of
+    srcset for embedded images.
+
+    :param Union[None, Dict] validHtml: A dictionary containing allowed HTML tags and their attributes. Defaults
+        to _defaultTags. Must be a structured like :prop:_defaultTags
+    :param int maxLength: The maximum allowed length for the content. Defaults to 200000.
+    :param languages: If set, this bone can store a different content for each language
+    :param Dict[str, List] srcSet: An optional dictionary containing width and height for srcset generation.
+        Must be a dict of "width": [List of Ints], "height": [List of Ints], eg {"height": [720, 1080]}
+    :param bool indexed: Whether the content should be indexed for searching. Defaults to False.
+    :param kwargs: Additional keyword arguments to be passed to the base class constructor.
+    """
     class __undefinedC__:
         pass
 
     type = "text"
 
     def __init__(
         self,
@@ -277,42 +368,85 @@
             validHtml = _defaultTags
 
         self.validHtml = validHtml
         self.maxLength = maxLength
         self.srcSet = srcSet
 
     def singleValueSerialize(self, value, skel: 'SkeletonInstance', name: str, parentIndexed: bool):
+        """
+        Serializes a single value of the TextBone instance for storage.
+
+        This method takes the value as-is without any additional processing, since it's already stored in a format
+        suitable for serialization.
+        """
         return value
 
     def singleValueFromClient(self, value, skel, name, origData):
+        """
+        Processes a single value received from the client for the TextBone instance.
+
+        Validates the value and sanitizes it using the HtmlSerializer if it's valid. If the value is invalid,
+        an error message is returned along with an empty value.
+
+        :param value: The value received from the client.
+        :param SkeletonInstance skel: The skeleton instance that will contain the value.
+        :param str name: The name of the bone containing the value.
+        :param origData: The original data received from the client.
+        :return: A tuple containing the sanitized value and an error message (if any).
+             If there's no error, the second element of the tuple is None.
+        :rtype: Tuple[Any, Optional[List[ReadFromClientError]]]
+        """
         err = self.isInvalid(value)  # Returns None on success, error-str otherwise
         if not err:
             return HtmlSerializer(self.validHtml, self.srcSet).sanitize(value), None
         else:
             return self.getEmptyValue(), [ReadFromClientError(ReadFromClientErrorSeverity.Invalid, err)]
 
     def getEmptyValue(self):
+        """
+        Returns an empty value for the TextBone instance.
+
+        This method is used to represent an empty or unset value for the TextBone.
+
+        return: An empty string.
+        :rtype: str
+        """
         return ""
 
     def isInvalid(self, value):
         """
-            Returns None if the value would be valid for
-            this bone, an error-message otherwise.
+        Checks if the given value is valid for this TextBone instance.
+
+        This method checks whether the given value is valid according to the TextBone's constraints (e.g., not
+        None and within the maximum length).
+
+        :param value: The value to be checked for validity.
+        :return: Returns None if the value is valid, or an error message string otherwise.
+        :rtype: Optional[str]
         """
+
         if value == None:
             return "No value entered"
         if len(value) > self.maxLength:
             return "Maximum length exceeded"
 
     def getReferencedBlobs(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> Set[str]:
         """
-            Parse our html for embedded img or hrefs pointing to files. These will be locked,
-            so even if they are deleted from the file browser, we'll still keep that blob alive
-            so we don't have broken links/images in this bone.
+        Extracts and returns the blob keys of referenced files in the HTML content of the TextBone instance.
+
+        This method parses the HTML content of the TextBone to identify embedded images or file hrefs,
+        collects their blob keys, and ensures that they are not deleted even if removed from the file browser,
+        preventing broken links or images in the TextBone content.
+
+        :param SkeletonInstance skel: A SkeletonInstance object containing the data of an entry.
+        :param str name: The name of the TextBone for which to find referenced blobs.
+        :return: A set containing the blob keys of the referenced files in the TextBone's HTML content.
+        :rtype: Set[str]
         """
+
         collector = CollectBlobKeys()
 
         for idx, lang, value in self.iter_bone_value(skel, name):
             if value:
                 collector.feed(value)
 
         blob_keys = collector.blobs
@@ -332,34 +466,64 @@
                 if file_obj:
                     ensureDerived(file_obj.key, "%s_%s" % (skel.kindName, name), derive_dict, skel["key"])
 
         return blob_keys
 
     def refresh(self, skel, boneName) -> None:
         """
-            Re-parse our text. This will cause our src-set to rebuild.
+        Re-parses the text content of the TextBone instance to rebuild the src-set if necessary.
+
+        This method is useful when the src-set configuration has changed and needs to be applied
+        to the existing HTML content. It re-parses the content and updates the src-set attributes
+        accordingly.
+
+        :param SkeletonInstance skel: A SkeletonInstance object containing the data of an entry.
+        :param str boneName: The name of the TextBone for which to refresh the src-set.
         """
         if self.srcSet:
             val = skel[boneName]
             if self.languages and isinstance(val, dict):
                 skel[boneName] = {k: self.singleValueFromClient(v, skel, boneName, None)[0] for k, v in val.items()}
             elif not self.languages and isinstance(val, str):
                 skel[boneName] = self.singleValueFromClient(val, skel, boneName, None)[0]
 
     def getSearchTags(self, skel: 'viur.core.skeleton.SkeletonInstance', name: str) -> Set[str]:
+        """
+        Extracts search tags from the text content of a TextBone.
+
+        This method iterates over the values of the TextBone in the given skeleton, and for each non-empty value,
+        it tokenizes the text by lines and words. Then, it adds the lowercase version of each word to a set of
+        search tags, which is returned at the end.
+
+        :param skel: A SkeletonInstance containing the TextBone.
+        :param name: The name of the TextBone in the skeleton.
+        :return: A set of unique search tags (lowercase words) extracted from the text content of the TextBone.
+        """
         result = set()
         for idx, lang, value in self.iter_bone_value(skel, name):
             if value is None:
                 continue
             for line in str(value).splitlines():
                 for word in line.split(" "):
                     result.add(word.lower())
         return result
 
     def getUniquePropertyIndexValues(self, valuesCache: dict, name: str) -> List[str]:
+        """
+        Retrieves the unique property index values for the TextBone.
+
+        If the TextBone supports multiple languages, this method raises a NotImplementedError, as it's unclear
+        whether each language should be kept distinct or not. Otherwise, it calls the superclass's
+        getUniquePropertyIndexValues method to retrieve the unique property index values.
+
+        :param valuesCache: A dictionary containing the cached values for the TextBone.
+        :param name: The name of the TextBone.
+        :return: A list of unique property index values for the TextBone.
+        :raises NotImplementedError: If the TextBone supports multiple languages.
+        """
         if self.languages:
             # Not yet implemented as it's unclear if we should keep each language distinct or not
             raise NotImplementedError()
 
         return super().getUniquePropertyIndexValues(valuesCache, name)
 
     def structure(self) -> dict:
```

## viur/core/bones/treeleaf.py

```diff
@@ -1,8 +1,16 @@
+"""
+TreeLeafBone is a subclass of RelationalBone specifically designed to represent a leaf node in a tree-like data
+structure. It provides an additional level of hierarchy and organization for relational data in ViUR applications.
+"""
 from viur.core.bones.relational import RelationalBone
 
 
 class TreeLeafBone(RelationalBone):
+    """
+    TreeLeafBone is a subclass of RelationalBone specifically designed to represent a leaf node in a tree-like data
+    structure. It provides an additional level of hierarchy and organization for relational data in ViUR applications.
+    """
     type = "relational.tree.leaf"
 
     def __init__(self, **kwargs):
         super(TreeLeafBone, self).__init__(**kwargs)
```

## viur/core/bones/treenode.py

```diff
@@ -1,5 +1,17 @@
+"""
+TreeNodeBone is a subclass of RelationalBone specifically designed to represent an intermediate node in a tree-like
+data structure. It provides a way to define hierarchical relationships between entities in a ViUR application.
+
+The TreeNodeBone is of type "relational.tree.node", which distinguishes it from other RelationalBone subclasses.
+"""
 from viur.core.bones.relational import RelationalBone
 
 
 class TreeNodeBone(RelationalBone):
+    """
+    TreeNodeBone is a subclass of RelationalBone specifically designed to represent an intermediate node in a tree-like
+    data structure. It provides a way to define hierarchical relationships between entities in a ViUR application.
+
+    The TreeNodeBone is of type "relational.tree.node", which distinguishes it from other RelationalBone subclasses.
+    """
     type = "relational.tree.node"
```

## viur/core/bones/user.py

```diff
@@ -1,12 +1,27 @@
+"""
+A specialized relational bone for handling user references. Extends the functionality of
+:class:`viur.core.bones.relational.RelationalBone` to include support for creation and update magic.
+"""
 from viur.core.bones.relational import RelationalBone
 from viur.core import current
 
 
 class UserBone(RelationalBone):
+    """
+    A specialized relational bone for handling user references. Extends the functionality of
+    :class:`viur.core.bones.relational.RelationalBone` to include support for creation and update magic.
+
+    :param bool creationMagic: If True, the bone will automatically store the creating user when a new entry is added.
+    :param bool updateMagic: If True, the bone will automatically store the last user who updated the entry.
+    :param bool visible: If True, the bone will be visible in the skeleton.
+    :param bool readOnly: If True, the bone will be read-only and its value cannot be changed through user input.
+    :param dict kwargs: Additional keyword arguments passed to the parent class constructor.
+    :raises ValueError: If the bone has multiple set to True and a creation/update magic is set.
+    """
     kind = "user"
     datafields = ["name"]
 
     def __init__(self, *, creationMagic=False, updateMagic=False, visible=None, readOnly=False, **kwargs):
         if creationMagic or updateMagic:
             readOnly = False
             if visible is None:
@@ -19,12 +34,26 @@
         self.creationMagic = creationMagic
         self.updateMagic = updateMagic
 
         if self.multiple and (creationMagic or updateMagic):
             raise ValueError("Cannot be multiple and have a creation/update-magic set!")
 
     def performMagic(self, skel, key, isAdd, *args, **kwargs):
+        """
+        Perform the magic operation on the bone value.
+
+        If updateMagic is enabled or creationMagic is enabled and the operation is an addition,
+        the bone will store the current user's key.
+
+        :param SkeletonInstance skel: The skeleton instance to operate on.
+        :param str key: The key of the bone in the skeleton.
+        :param bool isAdd: If True, the operation is an addition. Otherwise, it is an update.
+        :param args: Additional positional arguments.
+        :param kwargs: Additional keyword arguments.
+        :return: True if the magic operation was successful, False otherwise.
+        :rtype: bool
+        """
         if self.updateMagic or (self.creationMagic and isAdd):
             if user := current.user.get():
                 return self.setBoneValue(skel, key, user["key"], False)
             skel[key] = None
             return True
```

## viur/core/languages/de.py

```diff
@@ -58,19 +58,24 @@
     "not shipped": "Nicht versendet",
     "ready to ship": "Versandbereit",
     "shipped": "Versendet",
     "unpaid": "Unbezahlt",
     "created at": "Erstellt am",
     "updated at": "Aktualisiert am",
 
+    # User module
     "waiting for email verification": "wartet auf Bestätigung der E-Mailadresse",
     "waiting for verification through admin": "warte auf Freischaltung durch Administrator",
     "account disabled": "deaktiviert",
     "active": "aktiv",
 
+    "viur.user.bone.roles": "Rollen",
+    "viur.user.bone.roles.invalid": "Die Rolle 'Benutzerdefiniert' kann nur einzeln gesetzt werden!",
+    "viur.user.bone.access": "Zugriffsrechte",
+
     # Titles
     "mr.": "Herr",
     "mrs.": "Frau",
 
     # Country-Names
     "afghanistan": "Afghanistan",
     "albania": "Albanien",
```

## viur/core/modules/file.py

```diff
@@ -1,30 +1,32 @@
 import base64
 import email.header
-import google.auth
+import html
 import json
 import logging
 import string
-import html
-from PIL import Image, ImageCms
 from base64 import urlsafe_b64decode
 from datetime import datetime, timedelta
-from google.auth import compute_engine
-from google.auth.transport import requests
-from google.cloud import iam_credentials_v1, storage
-from google.oauth2.service_account import Credentials as ServiceAccountCredentials
 from io import BytesIO
 from quopri import decodestring
 from typing import Any, List, Tuple, Union
 from urllib.request import urlopen
-from viur.core import db, conf, errors, exposed, forcePost, forceSSL, securitykey, utils, current
+
+import google.auth
+from PIL import Image, ImageCms
+from google.auth import compute_engine
+from google.auth.transport import requests
+from google.cloud import iam_credentials_v1, storage
+from google.oauth2.service_account import Credentials as ServiceAccountCredentials
+
+from viur.core import conf, current, db, errors, exposed, forcePost, forceSSL, securitykey, utils
 from viur.core.bones import BaseBone, BooleanBone, KeyBone, NumericBone, StringBone
 from viur.core.prototypes.tree import SkelType, Tree, TreeSkel
 from viur.core.skeleton import SkeletonInstance, skeletonByKind
-from viur.core.tasks import PeriodicTask, CallDeferred
+from viur.core.tasks import CallDeferred, DeleteEntitiesIter, PeriodicTask
 from viur.core.utils import sanitizeFileName
 
 credentials, project = google.auth.default()
 client = storage.Client(project, credentials)
 bucket = client.lookup_bucket(f"""{conf["viur.instance.project_id"]}.appspot.com""")
 iamClient = iam_credentials_v1.IAMCredentialsClient()
 
@@ -395,14 +397,20 @@
 
     handler = "tree.simple.file"
     adminInfo = {
         "icon": "icon-file-system",
         "handler": handler,  # fixme: Use static handler; Remove with VIUR4!
     }
 
+    roles = {
+        "*": "view",
+        "editor": ("add", "edit"),
+        "admin": "*",
+    }
+
     blobCacheTime = 60 * 60 * 24  # Requests to file/download will be served with cache-control: public, max-age=blobCacheTime if set
 
     def write(self, filename: str, content: Any, mimetype: str = "text/plain", width: int = None,
               height: int = None) -> db.Key:
         """
         Write a file from any buffer into the file module.
 
@@ -508,74 +516,86 @@
         fileSkel["height"] = 0
         fileSkel.toDB()
         # Mark that entry dirty as we might never receive an add
         utils.markFileForDeletion(targetKey)
         return db.encodeKey(fileSkel["key"]), uploadUrl
 
     @exposed
-    def getUploadURL(self, fileName, mimeType, size=None, skey=None, *args, **kwargs):
+    def getUploadURL(self, fileName: str, mimeType: str, size: int = None, skey: str = None, *args, **kwargs):
         node = kwargs.get("node")
         authData = kwargs.get("authData")
         authSig = kwargs.get("authSig")
-        # Validate the the contentType from the client seems legit
-        mimeType = mimeType.lower()
-        assert len(mimeType.split("/")) == 2, "Invalid Mime-Type"
-        assert all([x in string.ascii_letters + string.digits + "/-.+" for x in mimeType]), "Invalid Mime-Type"
+
+        # Validate the contentType from the client seems legit
+        mimeType = mimeType.strip().lower()
+        if not (
+            mimeType
+            and mimeType.count("/") == 1
+            and all(ch in string.ascii_letters + string.digits + "/-.+" for ch in mimeType)
+        ):
+            raise errors.UnprocessableEntity(f"Invalid mime-type {mimeType} provided")
+
         if authData and authSig:
-            # First, validate the signature, otherwise we don't need to proceed any further
+            # First, validate the signature, otherwise we don't need to proceed further
             if not utils.hmacVerify(authData.encode("ASCII"), authSig):
-                raise errors.Forbidden()
+                raise errors.Unauthorized()
+
             authData = json.loads(base64.b64decode(authData.encode("ASCII")).decode("UTF-8"))
+
             if datetime.strptime(authData["validUntil"], "%Y%m%d%H%M") < datetime.now():
-                raise errors.Gone()
+                raise errors.Gone("The upload URL has expired")
+
             if authData["validMimeTypes"]:
                 for validMimeType in authData["validMimeTypes"]:
                     if validMimeType == mimeType or (
                         validMimeType.endswith("*") and mimeType.startswith(validMimeType[:-1])):
                         break
                 else:
-                    raise errors.NotAcceptable()
+                    raise errors.UnprocessableEntity(f"Invalid mime-type {mimeType} provided")
+
             node = authData["node"]
             maxSize = authData["maxSize"]
+
         else:
             if node:
                 rootNode = self.getRootNode(node)
                 if not self.canAdd("leaf", rootNode):
                     raise errors.Forbidden()
             else:
                 if not self.canAdd("leaf", None):
                     raise errors.Forbidden()
+
             maxSize = None  # The user has some file/add permissions, don't restrict fileSize
+
         if maxSize:
-            try:
-                size = int(size)
-                assert size <= maxSize
-            except:  # We have a size-limit set - but no size supplied
-                raise errors.PreconditionFailed()
+            if size > maxSize:
+                raise errors.UnprocessableEntity(f"Size {size} exceeds maximum size {maxSize}")
         else:
             size = None
 
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
 
-        targetKey, uploadUrl = self.initializeUpload(fileName, mimeType.lower(), node, size)
+        targetKey, uploadUrl = self.initializeUpload(fileName, mimeType, node, size)
 
         resDict = {
             "uploadUrl": uploadUrl,
             "uploadKey": targetKey,
         }
+
         if authData and authSig:
             # In this case, we'd have to store the key in the users session so he can call add() later on
             session = current.session.get()
             if not "pendingFileUploadKeys" in session:
                 session["pendingFileUploadKeys"] = []
             session["pendingFileUploadKeys"].append(targetKey)
             # Clamp to the latest 50 pending uploads
             session["pendingFileUploadKeys"] = session["pendingFileUploadKeys"][-50:]
             session.markChanged()
+
         return self.render.view(resDict)
 
     @exposed
     def download(self, blobKey: str, fileName: str = "", download: str = "", sig: str = "", *args, **kwargs):
         """
         Download a file.
         :param blobKey: The unique blob key of the file.
@@ -653,15 +673,15 @@
     def add(self, skelType: SkelType, node=None, *args, **kwargs):
         ## We can't add files directly (they need to be uploaded
         # if skelType != "node":
         #    raise errors.NotAcceptable()
         if skelType == "leaf":  # We need to handle leafs separately here
             skey = kwargs.get("skey")
             targetKey = kwargs.get("key")
-            if not skey or not securitykey.validate(skey, useSessionKey=True) or not targetKey:
+            if not skey or not securitykey.validate(skey) or not targetKey:
                 raise errors.PreconditionFailed()
             skel = self.addSkel("leaf")
             if not skel.fromDB(targetKey):
                 raise errors.NotFound()
             if not skel["pending"]:
                 raise errors.PreconditionFailed()
             skel["pending"] = False
@@ -799,7 +819,19 @@
             else:
                 logging.debug("Increasing count, %s" % file["dlkey"])
                 file["itercount"] += 1
                 db.Put(file)
     newCursor = query.getCursor()
     if newCursor:
         doCleanupDeletedFiles(newCursor)
+
+
+@PeriodicTask(60 * 4)
+def start_delete_pending_files():
+    """
+    Start deletion of pending FileSkels that are older than 7 days.
+    """
+    DeleteEntitiesIter.startIterOnQuery(
+        FileBaseSkel().all()
+        .filter("pending =", True)
+        .filter("creationdate <", utils.utcNow() - timedelta(days=7))
+    )
```

## viur/core/modules/formmailer.py

```diff
@@ -20,15 +20,15 @@
 
         if len(kwargs) == 0:
             return self.render.add(skel=skel, failed=False)
 
         if not skel.fromClient(kwargs) or not "skey" in kwargs:
             return self.render.add(skel=skel, failed=True)
 
-        if not securitykey.validate(kwargs["skey"], useSessionKey=True):
+        if not securitykey.validate(kwargs["skey"]):
             raise errors.PreconditionFailed()
 
         # Allow bones to perform outstanding "magic" operations before sending the mail
         for key, _bone in skel.items():
             if isinstance(_bone, BaseBone):
                 _bone.performMagic(skel, key, isAdd=True)
```

## viur/core/modules/script.py

```diff
@@ -71,14 +71,18 @@
     )
 
 
 class Script(Tree):
     leafSkelCls = ScriptLeafSkel
     nodeSkelCls = ScriptNodeSkel
 
+    roles = {
+        "admin": "*",
+    }
+
     def adminInfo(self):
         return conf.get("viur.script.admin_info") or {}
 
     def getAvailableRootNodes(self):
         if not utils.getCurrentUser():
             return []
```

## viur/core/modules/user.py

```diff
@@ -11,15 +11,15 @@
 
 import time
 from google.auth.transport import requests
 from google.oauth2 import id_token
 
 from viur.core import (
     conf, current, db, email, errors, exposed, forceSSL, i18n,
-    securitykey, session, skeleton, tasks, utils
+    securitykey, session, skeleton, tasks, utils, Module
 )
 from viur.core.bones import *
 from viur.core.bones.password import PBKDF2_DEFAULT_ITERATIONS, encode_password
 from viur.core.prototypes.list import List
 from viur.core.ratelimit import RateLimit
 from viur.core.securityheaders import extendCsp
 
@@ -100,21 +100,39 @@
     gaeadmin = BooleanBone(
         descr="Is GAE Admin",
         defaultValue=False,
         readOnly=True,
     )
 
     # Generic properties
+
+    roles = SelectBone(
+        descr=i18n.translate("viur.user.bone.roles", defaultText="Roles"),
+        values=conf["viur.user.roles"],
+        required=True,
+        multiple=True,
+        # fixme: This is generally broken in VIUR! See #776 for details.
+        # vfunc=lambda values:
+        #     i18n.translate(
+        #         "user.bone.roles.invalid",
+        #         defaultText="Invalid role setting: 'custom' can only be set alone.")
+        #     if "custom" in values and len(values) > 1 else None,
+        defaultValue=list(conf["viur.user.roles"].keys())[:1],
+    )
+
     access = SelectBone(
-        descr="Access rights",
+        descr=i18n.translate("viur.user.bone.access", defaultText="Access rights"),
         values=lambda: {
             right: i18n.translate("server.modules.user.accessright.%s" % right, defaultText=right)
             for right in sorted(conf["viur.accessRights"])
         },
         multiple=True,
+        params={
+            "readonlyIf": "'custom' not in role"  # if role is not "custom", access is managed by the role system
+        }
     )
 
     status = SelectBone(
         descr="Account status",
         values=Status,
         defaultValue=Status.ACTIVE,
         required=True,
@@ -144,14 +162,53 @@
     )
 
     admin_config = JsonBone(  # This bone stores settings from the vi
         descr="Config for the User",
         visible=False
     )
 
+    @classmethod
+    def toDB(cls, skel, *args, **kwargs):
+        # Roles
+        if skel["roles"] and "custom" not in skel["roles"]:
+            # Collect access rights through rules
+            access = set()
+
+            for role in skel["roles"]:
+                # Get default access for this role
+                access |= conf["viur.mainApp"].vi.user.get_role_defaults(role)
+
+                # Go through all modules and evaluate available role-settings
+                for name in dir(conf["viur.mainApp"].vi):
+                    if name.startswith("_"):
+                        continue
+
+                    module = getattr(conf["viur.mainApp"].vi, name)
+                    if not isinstance(module, Module):
+                        continue
+
+                    roles = getattr(module, "roles", None) or {}
+                    rights = roles.get(role, roles.get("*", ()))
+
+                    # Convert role into tuple if it's not
+                    if not isinstance(rights, (tuple, list)):
+                        rights = (rights, )
+
+                    if "*" in rights:
+                        for right in module.accessRights:
+                            access.add(f"{name}-{right}")
+                    else:
+                        for right in rights:
+                            if right in module.accessRights:
+                                access.add(f"{name}-{right}")
+
+            skel["access"] = list(access)
+
+        return super().toDB(skel, *args, **kwargs)
+
 
 class UserPassword:
     registrationEnabled = False
     registrationEmailVerificationRequired = True
     registrationAdminVerificationRequired = True
 
     verifySuccessTemplate = "user_verify_success"
@@ -217,15 +274,15 @@
 
     @exposed
     @forceSSL
     def login(self, name=None, password=None, skey="", *args, **kwargs):
         if current.user.get():  # User is already logged in, nothing to do.
             return self.userModule.render.loginSucceeded()
 
-        if not name or not password or not securitykey.validate(skey, useSessionKey=True):
+        if not name or not password or not securitykey.validate(skey):
             return self.userModule.render.login(self.LoginSkel())
 
         self.loginRateLimit.assertQuotaIsAvailable()
 
         name = name.lower().strip()
         query = db.Query(self.userModule.viewSkel().kindName)
         user_entry = query.filter("name.idx >=", name).getEntry() or {}  # might find another user; always keep a dict
@@ -289,30 +346,29 @@
         request = current.request.get()
         recoverStep = session.get("user.auth_userpassword.pwrecover")
         if not recoverStep:
             # This is the first step, where we ask for the username of the account we'll going to reset the password on
             skel = self.LostPasswordStep1Skel()
             if not request.isPostRequest or not skel.fromClient(kwargs):
                 return self.userModule.render.edit(skel, tpl=self.passwordRecoveryStep1Template)
-            if not securitykey.validate(kwargs.get("skey"), useSessionKey=True):
+            if not securitykey.validate(kwargs.get("skey")):
                 raise errors.PreconditionFailed()
             self.passwordRecoveryRateLimit.decrementQuota()
             recoveryKey = utils.generateRandomString(13)  # This is the key the user will have to Copy&Paste
             self.sendUserPasswordRecoveryCode(skel["name"].lower(), recoveryKey)  # Send the code in the background
             session["user.auth_userpassword.pwrecover"] = {
                 "name": skel["name"].lower(),
                 "recoveryKey": recoveryKey,
                 "creationdate": utils.utcNow(),
                 "errorCount": 0
             }
             del recoveryKey
             return self.pwrecover()  # Fall through to the second step as that key in the session is now set
         else:
-            if request.isPostRequest and kwargs.get("abort") == "1" \
-                and securitykey.validate(kwargs.get("skey"), useSessionKey=True):
+            if request.isPostRequest and kwargs.get("abort") == "1" and securitykey.validate(kwargs.get("skey")):
                 # Allow a user to abort the process if a wrong email has been used
                 session["user.auth_userpassword.pwrecover"] = None
                 return self.pwrecover()
             # We're in the second step - the code has been send and is waiting for confirmation from the user
             if utils.utcNow() - session["user.auth_userpassword.pwrecover"]["creationdate"] \
                     > datetime.timedelta(minutes=15):
                 # This recovery-process is expired; reset the session and start over
@@ -320,15 +376,15 @@
                 return self.userModule.render.view(
                     skel=None,
                     tpl=self.passwordRecoveryFailedTemplate,
                     reason=self.passwordRecoveryKeyExpired)
             skel = self.LostPasswordStep2Skel()
             if not skel.fromClient(kwargs) or not request.isPostRequest:
                 return self.userModule.render.edit(skel, tpl=self.passwordRecoveryStep2Template)
-            if not securitykey.validate(kwargs.get("skey"), useSessionKey=True):
+            if not securitykey.validate(kwargs.get("skey")):
                 raise errors.PreconditionFailed()
             self.passwordRecoveryRateLimit.decrementQuota()
             if not hmac.compare_digest(session["user.auth_userpassword.pwrecover"]["recoveryKey"], skel["recoveryKey"]):
                 # The key was invalid, increase error-count or abort this recovery process altogether
                 session["user.auth_userpassword.pwrecover"]["errorCount"] += 1
                 if session["user.auth_userpassword.pwrecover"]["errorCount"] > 3:
                     session["user.auth_userpassword.pwrecover"] = None
@@ -388,15 +444,15 @@
                 return
             # Update the changedate so no more than one email is send per 4 hours
             db.RunInTransaction(updateChangeDateTxn, user.key)
             email.sendEMail(tpl=self.passwordRecoveryMail, skel={"recoveryKey": recoveryKey}, dests=[userName])
 
     @exposed
     def verify(self, skey, *args, **kwargs):
-        data = securitykey.validate(skey, useSessionKey=False)
+        data = securitykey.validate(skey, session_bound=False)
         skel = self.userModule.editSkel()
         if not data or not isinstance(data, dict) or "userKey" not in data or not skel.fromDB(
             data["userKey"].id_or_name):
             return self.userModule.render.view(None, tpl=self.verifyFailedTemplate)
         if self.registrationAdminVerificationRequired:
             skel["status"] = Status.WAITING_FOR_ADMIN_VERIFICATION
         else:
@@ -450,15 +506,15 @@
         skel = self.addSkel()
         if (len(kwargs) == 0  # no data supplied
             or not current.request.get().isPostRequest  # bail out if not using POST-method
             or not skel.fromClient(kwargs)  # failure on reading into the bones
             or ("bounce" in kwargs and kwargs["bounce"] == "1")):  # review before adding
             # render the skeleton in the version it could as far as it could be read.
             return self.userModule.render.add(skel)
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
         skel.toDB()
         if self.registrationEmailVerificationRequired and skel["status"] == Status.WAITING_FOR_EMAIL_VERIFICATION:
             # The user will have to verify his email-address. Create a skey and send it to his address
             skey = securitykey.create(duration=60 * 60 * 24 * 7, userKey=utils.normalizeKey(skel["key"]),
                                       name=skel["name"])
             skel.skey = BaseBone(descr="Skey")
@@ -497,15 +553,15 @@
                   .joinpath("viur/core/template/vi_user_google_login.html")
                   .open() as tpl_file):
                 tplStr = tpl_file.read()
             tplStr = tplStr.replace("{{ clientID }}", conf["viur.user.google.clientID"])
             extendCsp({"script-src": ["sha256-JpzaUIxV/gVOQhKoDLerccwqDDIVsdn1JclA6kRNkLw="],
                        "style-src": ["sha256-FQpGSicYMVC5jxKGS5sIEzrRjSJmkxKPaetUc7eamqc="]})
             return tplStr
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
         userInfo = id_token.verify_oauth2_token(token, requests.Request(), conf["viur.user.google.clientID"])
         if userInfo['iss'] not in {'accounts.google.com', 'https://accounts.google.com'}:
             raise ValueError('Wrong issuer.')
         # Token looks valid :)
         uid = userInfo['sub']
         email = userInfo['email']
@@ -632,15 +688,15 @@
     def otp(self, otptoken=None, skey=None, *args, **kwargs):
         session = current.session.get()
         token = session.get("_otp_user")
         if not token:
             raise errors.Forbidden()
         if otptoken is None:
             self.userModule.render.edit(self.OtpSkel())
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
         if token["failures"] > 3:
             raise errors.Forbidden("Maximum amount of authentication retries exceeded")
         if len(token["otpkey"]) % 2 == 1:
             raise errors.PreconditionFailed("The otp secret stored for this user is invalid (uneven length)")
         validTokens = self.generateOtps(token["otpkey"], token["otptimedrift"])
         try:
@@ -704,14 +760,18 @@
 
     secondFactorTimeWindow = datetime.timedelta(minutes=10)
 
     adminInfo = {
         "icon": "icon-users"
     }
 
+    roles = {
+        "admin": "*",
+    }
+
     def __init__(self, moduleName, modulePath, *args, **kwargs):
         super().__init__(moduleName, modulePath, *args, **kwargs)
 
         # Initialize the login-providers
         self.initializedAuthenticationProviders = {}
         self.initializedSecondFactorProviders = {}
         self._viurMapSubmodules = []
@@ -728,14 +788,23 @@
             pInstance = p(self, modulePath + "/f2_%s" % p.__name__.lower())
             self.initializedAuthenticationProviders[pInstance.__class__.__name__.lower()] = pInstance
 
             # Also put it as an object into self, so that any exposed function is reachable
             setattr(self, "f2_%s" % pInstance.__class__.__name__.lower(), pInstance)
             self._viurMapSubmodules.append("f2_%s" % pInstance.__class__.__name__.lower())
 
+    def get_role_defaults(self, role: str) -> set[str]:
+        """
+        Returns a set of default access rights for a given role.
+        """
+        if role in ("viewer", "editor", "admin"):
+            return {"admin"}
+
+        return set()
+
     def addSkel(self):
         skel = super(User, self).addSkel().clone()
         user = current.user.get()
         if not (user and user["access"] and ("%s-add" % self.moduleName in user["access"] or "root" in user["access"])):
             skel.status.readOnly = True
             skel["status"] = Status.UNSET
             skel.status.visible = False
@@ -843,30 +912,30 @@
         session.reset()
         # and copy them over to the new session
         session |= take_over
 
         # Update session, user and request
         session["user"] = skel.dbEntity
 
-        current.request.get().response.headers["Sec-X-ViUR-StaticSKey"] = session.staticSecurityKey
+        current.request.get().response.headers[securitykey.SECURITYKEY_STATIC] = session.static_security_key
         current.user.set(self.getCurrentUser())
 
         self.onLogin(skel)
 
         return self.render.loginSucceeded(**kwargs)
 
     @exposed
     def logout(self, skey="", *args, **kwargs):
         """
             Implements the logout action. It also terminates the current session (all keys not listed
             in viur.session.persistentFieldsOnLogout will be lost).
         """
         if not (user := current.user.get()):
             raise errors.Unauthorized()
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
 
         self.onLogout(user)
 
         session = current.session.get()
         take_over = {k: v for k, v in session.items() if k in conf["viur.session.persistentFieldsOnLogout"]}
         session.reset()
```

## viur/core/prototypes/list.py

```diff
@@ -82,20 +82,20 @@
             Renders data for an entry, without reading from the database.
             This function allows to preview an entry without writing it to the database.
 
             Any entity values are provided via *kwargs*.
 
             The function uses the viewTemplate of the application.
 
-            :returns: The rendered representation of the the supplied data.
+            :returns: The rendered representation of the supplied data.
         """
         if not self.canPreview():
             raise errors.Unauthorized()
 
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
 
         skel = self.viewSkel()
         skel.fromClient(kwargs)
 
         return self.render.view(skel)
 
@@ -207,15 +207,15 @@
         if (len(kwargs) == 0  # no data supplied
             or not current.request.get().isPostRequest  # failure if not using POST-method
             or not skel.fromClient(kwargs)  # failure on reading into the bones
             or ("bounce" in kwargs and kwargs["bounce"] == "1")  # review before changing
         ):
             # render the skeleton in the version it could as far as it could be read.
             return self.render.edit(skel)
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
 
         self.onEdit(skel)
         skel.toDB()  # write it!
         self.onEdited(skel)
 
         return self.render.editSuccess(skel)
@@ -243,15 +243,15 @@
         if (len(kwargs) == 0  # no data supplied
             or not current.request.get().isPostRequest  # failure if not using POST-method
             or not skel.fromClient(kwargs)  # failure on reading into the bones
             or ("bounce" in kwargs and kwargs["bounce"] == "1")  # review before adding
         ):
             # render the skeleton in the version it could as far as it could be read.
             return self.render.add(skel)
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
 
         self.onAdd(skel)
         skel.toDB()
         self.onAdded(skel)
 
         return self.render.addSuccess(skel)
@@ -277,15 +277,15 @@
         skel = self.editSkel()
         if not skel.fromDB(key):
             raise errors.NotFound()
 
         if not self.canDelete(skel):
             raise errors.Unauthorized()
 
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
 
         self.onDelete(skel)
         skel.delete()
         self.onDeleted(skel)
 
         return self.render.deleteSuccess(skel)
```

## viur/core/prototypes/singleton.py

```diff
@@ -65,15 +65,15 @@
         The function uses the viewTemplate of the application.
 
         :returns: The rendered representation of the supplied data.
         """
         if not self.canPreview():
             raise errors.Unauthorized()
 
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
 
         skel = self.viewSkel()
         skel.fromClient(kwargs)
 
         return self.render.view(skel)
 
@@ -147,15 +147,15 @@
         if not skel.fromDB(key):  # Its not there yet; we need to set the key again
             skel["key"] = key
         if (len(kwargs) == 0  # no data supplied
             or not skel.fromClient(kwargs)  # failure on reading into the bones
             or ("bounce" in kwargs and kwargs["bounce"] == "1")):  # review before changing
             return self.render.edit(skel)
 
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
 
         self.onEdit(skel)
         skel.toDB()
         self.onEdited(skel)
         return self.render.editSuccess(skel)
```

## viur/core/prototypes/skelmodule.py

```diff
@@ -17,33 +17,14 @@
         This information is used to bind a specific :class:`viur.core.skeleton.Skeleton`-class to this
         prototype. By default, it is automatically determined from the module's class name, so a module named
         `Animal` refers to a Skeleton named `AnimalSkel` and its kindName is `animal`.
 
         For more information, refer to the function :func:`~_resolveSkelCls`.
     """
 
-    accessRights: Tuple[str] = None
-    """
-        If set, a tuple of access rights (like add, edit, delete) that this module supports.
-
-        These will be prefixed on instance startup with the actual module name (becoming file-add, file-edit etc)
-        and registered in ``conf["viur.accessRights"]`` so these will be available on the access bone in user/add
-        or user/edit.
-    """
-
-    def __init__(self, *args, **kwargs):
-        super().__init__(*args, **kwargs)
-
-        if self.handler and self.accessRights:
-            for r in self.accessRights:
-                rightName = "%s-%s" % (self.moduleName, r)
-
-                if rightName not in conf["viur.accessRights"]:
-                    conf["viur.accessRights"].append(rightName)
-
     def _resolveSkelCls(self, *args, **kwargs) -> Type[Skeleton]:
         """
         Retrieve the generally associated :class:`viur.core.skeleton.Skeleton` that is used by
         the application.
 
         This is either be defined by the member variable *kindName* or by a Skeleton named like the
         application class in lower-case order.
```

## viur/core/prototypes/tree.py

```diff
@@ -362,15 +362,15 @@
 
         if (len(kwargs) == 0  # no data supplied
             or not skel.fromClient(kwargs)  # failure on reading into the bones
             or not current.request.get().isPostRequest
             or ("bounce" in kwargs and kwargs["bounce"] == "1")  # review before adding
         ):
             return self.render.add(skel)
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
 
         self.onAdd(skelType, skel)
         skel.toDB()
         self.onAdded(skelType, skel)
         return self.render.addSuccess(skel)
 
@@ -407,15 +407,15 @@
             raise errors.Unauthorized()
         if (len(kwargs) == 0  # no data supplied
             or not skel.fromClient(kwargs)  # failure on reading into the bones
             or not current.request.get().isPostRequest
             or ("bounce" in kwargs and kwargs["bounce"] == "1")  # review before adding
         ):
             return self.render.edit(skel)
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
         self.onEdit(skelType, skel)
         skel.toDB()
         self.onEdited(skelType, skel)
         return self.render.editSuccess(skel)
 
     @exposed
@@ -442,15 +442,15 @@
         if not (skelType := self._checkSkelType(skelType)):
             raise errors.NotAcceptable(f"Invalid skelType provided.")
         skel = self.editSkel(skelType)
         if not skel.fromDB(key):
             raise errors.NotFound()
         if not self.canDelete(skelType, skel):
             raise errors.Unauthorized()
-        if not securitykey.validate(skey, useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
         if skelType == "node":
             self.deleteRecursive(skel["key"])
         self.onDelete(skelType, skel)
         skel.delete()
         self.onDeleted(skelType, skel)
         return self.render.deleteSuccess(skel, skelType=skelType)
@@ -477,23 +477,24 @@
             if not nodeSkel.fromDB(node.key):
                 continue
             nodeSkel.delete()
 
     @exposed
     @forceSSL
     @forcePost
-    def move(self, skelType: SkelType, key: str, parentNode: str, *args, **kwargs) -> str:
+    def move(self, skelType: SkelType, key: str, parentNode: str, skey: str, *args, **kwargs) -> str:
         """
         Move a node (including its contents) or a leaf to another node.
 
         .. seealso:: :func:`canMove`
 
         :param skelType: Defines the type of the entry that should be moved and may either be "node" or "leaf".
         :param key: URL-safe key of the item to be moved.
         :param parentNode: URL-safe key of the destination node, which must be a node.
+        :param skey: The CSRF security key.
 
         :returns: The rendered, edited object of the entry.
 
         :raises: :exc:`viur.core.errors.NotFound`, when no entry with the given *key* was found.
         :raises: :exc:`viur.core.errors.Unauthorized`, if the current user does not have the required permissions.
         :raises: :exc:`viur.core.errors.PreconditionFailed`, if the *skey* could not be verified.
         """
@@ -535,15 +536,15 @@
             raise errors.NotAcceptable("Unable to find a root node in recursion?")
 
         # Test if we try to move a rootNode
         tmp = skel.dbEntity
         if "rootNode" in tmp and tmp["rootNode"] == 1:
             raise errors.NotAcceptable("Can't move a rootNode to somewhere else")
 
-        if not securitykey.validate(kwargs.get("skey", ""), useSessionKey=True):
+        if not securitykey.validate(skey):
             raise errors.PreconditionFailed()
 
         currentParentRepo = skel["parentrepo"]
         skel["parententry"] = parentNodeSkel["key"]
         skel["parentrepo"] = parentNodeSkel["parentrepo"]  # Fixme: Need to recursive fixing to parentrepo?
         if "sortindex" in kwargs:
             try:
```

## viur/core/render/html/default.py

```diff
@@ -1,24 +1,25 @@
 import codecs
+import collections
 import enum
 import functools
 import logging
 import os
-from collections import namedtuple
 from typing import Any, Dict, List, Literal, Tuple, Union
 
 from jinja2 import ChoiceLoader, Environment, FileSystemLoader, Template
 
 from viur.core import conf, current, db, errors, securitykey
 from viur.core.bones import *
 from viur.core.i18n import LanguageWrapper, TranslationExtension
 from viur.core.skeleton import SkelList, SkeletonInstance
 from . import utils as jinjaUtils
+from ..json.default import CustomJsonEncoder
 
-KeyValueWrapper = namedtuple("KeyValueWrapper", ["key", "descr"])
+KeyValueWrapper = collections.namedtuple("KeyValueWrapper", ["key", "descr"])
 
 
 class Render(object):
     """
         The core jinja2 render.
 
         This is the bridge between your ViUR modules and your templates.
@@ -59,74 +60,99 @@
         if not Render.__haveEnvImported_:
             # We defer loading our plugins to this point to avoid circular imports
             # noinspection PyUnresolvedReferences
             from . import env
             Render.__haveEnvImported_ = True
         self.parent = parent
 
-    def getTemplateFileName(self, template: str, ignoreStyle: bool = False) -> str:
+    def getTemplateFileName(
+        self,
+        template: str | List[str] | Tuple[str],
+        ignoreStyle: bool = False,
+        raise_exception: bool = True,
+    ) -> str | None:
         """
             Returns the filename of the template.
 
             This function decides in which language and which style a given template is rendered.
             The style is provided as get-parameters for special-case templates that differ from
             their usual way.
 
             It is advised to override this function in case that
             :func:`viur.core.render.jinja2.default.Render.getLoaders` is redefined.
 
-            :param template: The basename of the template to use.
+            :param template: The basename of the template to use. This can optionally be also a sequence of names.
             :param ignoreStyle: Ignore any maybe given style hints.
+            :param raise_exception: Defaults to raise an exception when not found, otherwise returns None.
 
             :returns: Filename of the template
         """
         validChars = "abcdefghijklmnopqrstuvwxyz1234567890-"
-        if "htmlpath" in dir(self):
-            htmlpath = self.htmlpath
-        else:
-            htmlpath = "html"
-        currReq = current.request.get()
-        if not ignoreStyle \
-            and "style" in currReq.kwargs \
-            and all([x in validChars for x in currReq.kwargs["style"].lower()]):
-            stylePostfix = "_" + currReq.kwargs["style"]
+        htmlpath = getattr(self, "htmlpath", "html")
+
+        if (
+            not ignoreStyle
+            and (style := current.request.get().kwargs.get("style"))
+            and all([x in validChars for x in style.lower()])
+        ):
+            style_postfix = f"_{style}"
         else:
-            stylePostfix = ""
-        lang = current.language.get()  # session.current.getLanguage()
-        fnames = [template + stylePostfix + ".html", template + ".html"]
-        if lang:
-            fnames = [os.path.join(lang, template + stylePostfix + ".html"),
-                      template + stylePostfix + ".html",
-                      os.path.join(lang, template + ".html"),
-                      template + ".html"]
-        for fn in fnames:  # check subfolders
-            prefix = template.split("_")[0]
-            if conf["viur.instance.project_base_path"].joinpath(htmlpath, prefix, fn).is_file():
-                return "%s/%s" % (prefix, fn)
-        for fn in fnames:  # Check the templatefolder of the application
-            if conf["viur.instance.project_base_path"].joinpath(htmlpath, fn).is_file():
-                return fn
-        for fn in fnames:  # Check the fallback
-            if conf["viur.instance.core_base_path"].joinpath("template", fn).is_file():
-                return fn
-        raise errors.NotFound("Template %s not found." % template)
+            style_postfix = ""
+
+        lang = current.language.get()
+
+        if not isinstance(template, (tuple, list)):
+            template = (template,)
+
+        for tpl in template:
+            filenames = [
+                tpl,
+                tpl + style_postfix,
+            ]
+
+            if lang:
+                filenames += [
+                    os.path.join(lang, tpl + style_postfix),
+                    os.path.join(lang, tpl),
+                ]
+
+            for filename in set(reversed(filenames)):
+                filename += ".html"
+
+                if "_" in filename:
+                    dirname, tail = filename.split("_", 1)
+                    if tail:
+                        if conf["viur.instance.project_base_path"].joinpath(htmlpath, dirname, filename).is_file():
+                            return os.path.join(dirname, filename)
+
+                if conf["viur.instance.project_base_path"].joinpath(htmlpath, filename).is_file():
+                    return filename
+
+                if conf["viur.instance.core_base_path"].joinpath("viur", "core", "template", filename).is_file():
+                    return filename
+
+        msg = f"""Template {" or ".join((repr(tpl) for tpl in template))} not found."""
+        if raise_exception:
+            raise errors.NotFound(msg)
+
+        logging.error(msg)
+        return None
 
     def getLoaders(self) -> ChoiceLoader:
         """
             Return the list of Jinja2 loaders which should be used.
 
             May be overridden to provide an alternative loader
             (e.g. for fetching templates from the datastore).
         """
-        if "htmlpath" in dir(self):
-            htmlpath = self.htmlpath
-        else:
-            htmlpath = "html/"
-
-        return ChoiceLoader([FileSystemLoader(htmlpath), FileSystemLoader("viur/core/template/")])
+        # fixme: Why not use ChoiceLoader directly for template loading?
+        return ChoiceLoader((
+            FileSystemLoader(getattr(self, "htmlpath", "html")),
+            FileSystemLoader(conf["viur.instance.core_base_path"] / "viur" / "core" / "template"),
+        ))
 
     def renderBoneValue(self,
                         bone: BaseBone,
                         skel: SkeletonInstance,
                         key: Any,  # TODO: unused
                         boneValue: Any,
                         isLanguageWrapped: bool = False
@@ -472,14 +498,15 @@
             :return: Extended Jinja2 environment.
         """
         if "env" not in dir(self):
             loaders = self.getLoaders()
             self.env = Environment(loader=loaders,
                                    extensions=["jinja2.ext.do", "jinja2.ext.loopcontrols", TranslationExtension])
             self.env.trCache = {}
+            self.env.policies["json.dumps_kwargs"]["cls"] = CustomJsonEncoder
 
             # Import functions.
             for name, func in jinjaUtils.getGlobalFunctions().items():
                 self.env.globals[name] = functools.partial(func, self)
 
             # Import filters.
             for name, func in jinjaUtils.getGlobalFilters().items():
```

## viur/core/render/json/__init__.py

```diff
@@ -1,35 +1,38 @@
 from .default import DefaultRender as default
 from .user import UserRender as user
 from viur.core import securitykey, current, errors, exposed
 import json
-import typing
 
 __all__ = [default]
 
 
 @exposed
-def skey(duration: typing.Optional[int] = None, *args, **kwargs) -> str:
+def skey(amount: int = 1, *args, **kwargs) -> str:
     """
-    Creates or returns a valid skey.
+    Creates CSRF-security-keys for transactions.
 
-    When a user is authenticated, a duration can be provided,
-    which returns a fresh, session-agnostic skey.
-    Otherwise, a session-based skey is returned.
+    All returned keys are associated with the session, therefore they cannot be used across sessions.
+    The keys get a maximum lifetime of the session lifetime, afterward they become invalid.
+
+    :param amount: Optional amount of securitykeys to create in a batch.
+        `amount > 1` can only be used by authenticated users, for a maximum of 100 keys.
 
     See module securitykey for details.
     """
     current.request.get().response.headers["Content-Type"] = "application/json"
 
-    if duration is not None:
-        if not current.user.get():
-            raise errors.Unauthorized("Durations can only be used by authenticated users")
+    if amount == 1:
+        return json.dumps(securitykey.create())
+
+    if not 0 < amount <= 100:
+        raise errors.Forbidden("Invalid amount provided")
 
-        if not 0 < duration <= 60:
-            raise errors.Forbidden("Invalid duration provided")
+    if not current.user.get():
+        raise errors.Forbidden("Batch securitykey creation is only available to authenticated users")
 
-    return json.dumps(securitykey.create(duration=duration))
+    return json.dumps([securitykey.create() for _ in range(amount)])
 
 
 def _postProcessAppObj(obj):  # Register our SKey function
     obj["skey"] = skey
     return obj
```

## viur/core/render/json/default.py

```diff
@@ -136,64 +136,75 @@
             res[key] = self.renderBoneValue(bone, skel, key)
         if injectDownloadURL and "dlkey" in skel and "name" in skel:
             res["downloadUrl"] = utils.downloadUrlFor(skel["dlkey"], skel["name"], derived=False,
                                                       expires=conf["viur.render.json.downloadUrlExpiration"])
         return res
 
     def renderEntry(self, skel: SkeletonInstance, actionName, params=None):
+        structure = None
+        errors = None
+
         if isinstance(skel, list):
             vals = [self.renderSkelValues(x) for x in skel]
             if isinstance(skel[0], SkeletonInstance):
-                struct = DefaultRender.render_structure(skel[0].structure())
-            errors = None
+                structure = DefaultRender.render_structure(skel[0].structure())
 
         elif isinstance(skel, SkeletonInstance):
             vals = self.renderSkelValues(skel)
-            struct = DefaultRender.render_structure(skel.structure())
+            structure = DefaultRender.render_structure(skel.structure())
             errors = [{"severity": x.severity.value, "fieldPath": x.fieldPath, "errorMessage": x.errorMessage,
                        "invalidatedFields": x.invalidatedFields} for x in skel.errors]
 
         else:  # Hopefully we can pass it directly...
             vals = skel
-            struct = None
-            errors = None
 
         res = {
-            "values": vals,
-            "structure": struct,
-            "errors": errors,
             "action": actionName,
-            "params": params
+            "errors": errors,
+            "params": params,
+            "structure": structure,
+            "values": vals,
         }
 
         current.request.get().response.headers["Content-Type"] = "application/json"
         return json.dumps(res, cls=CustomJsonEncoder)
 
     def view(self, skel: SkeletonInstance, action: str = "view", params=None, **kwargs):
         return self.renderEntry(skel, action, params)
 
     def list(self, skellist, action: str = "list", params=None, **kwargs):
-        res = {}
-        skels = []
+        # Rendering the structure in lists is flagged as deprecated
+        structure = None
+        cursor = None
+        orders = None
 
         if skellist:
-            for skel in skellist:
-                skels.append(self.renderSkelValues(skel))
-
-            res["cursor"] = skellist.getCursor()
             if isinstance(skellist[0], SkeletonInstance):
-                res["structure"] = DefaultRender.render_structure(skellist[0].structure())
+                if "json.bone.structure.inlists" in conf["viur.compatibility"]:
+                    structure = DefaultRender.render_structure(skellist[0].structure())
+
+                cursor = skellist.getCursor()
+                orders = skellist.get_orders()
+
+            skellist = [self.renderSkelValues(skel) for skel in skellist]
         else:
-            res["structure"] = None
-            res["cursor"] = None
+            skellist = []
+
+        # VIUR4 ;-)
+        # loc = locals()
+        # res = {k: loc[k] for k in ("action", "cursor", "params", "skellist", "structure", "orders") if loc[k]}
 
-        res["skellist"] = skels
-        res["action"] = action
-        res["params"] = params
-        res["orders"] = skellist.get_orders()
+        res = {
+            "action": action,
+            "cursor": cursor,
+            "params": params,
+            "skellist": skellist,
+            "structure": structure,
+            "orders": orders
+        }
 
         current.request.get().response.headers["Content-Type"] = "application/json"
         return json.dumps(res, cls=CustomJsonEncoder)
 
     def add(self, skel: SkeletonInstance, action: str = "add", params=None, **kwargs):
         return self.renderEntry(skel, action, params)
```

## viur/core/template/error.html

```diff
@@ -1,12 +1,12 @@
 <!DOCTYPE html>
 <html>
 <head>
 	<meta charset="UTF-8">
-    <title>$error_code - $error_name</title>
+    <title>{{status}} - {{reason}}</title>
 
     <style>
         html, body, div, span, applet, object, iframe,
         h1, h2, h3, h4, h5, h6, p, blockquote, pre,
         a, abbr, acronym, address, big, cite, code,
         del, dfn, em, font, img, ins, kbd, q, s, samp,
         small, strike, strong, sub, sup, tt, var,
@@ -212,23 +212,23 @@
 </head>
 
 <body>
     <div id="wrapper">
         <div id="error">
             <div id="content">
 
-                <h1>$error_code</h1>
+                <h1>{{ status }}</h1>
 
                 <a class="logo" href="https://www.viur.dev">&nbsp;</a>
 
                 <div class="clear">&nbsp;</div>
 
-                <h2>$error_name</h2>
+                <h2>{{ title }}</h2>
 
-                <p>$error_descr</p>
+                <p>{{ descr }}</p>
 
 				<div class="wrapper-buttons">
                     <a href="/" class="button-red shadow">Home</a>
                     <div class="clear">&nbsp;</div>
                 </div>
             </div>
         </div>
```

### html2text {}

```diff
@@ -1,7 +1,7 @@
-****** $error_code ******
+****** {{ status }} ******
  
  
-***** $error_name *****
-$error_descr
+***** {{ title }} *****
+{{ descr }}
 Home
```

## Comparing `viur_core-3.4.4.dist-info/LICENSE` & `viur_core-3.5.0b1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `viur_core-3.4.4.dist-info/METADATA` & `viur_core-3.5.0b1.dist-info/METADATA`

 * *Files 26% similar despite different names*

```diff
@@ -1,69 +1,65 @@
 Metadata-Version: 2.1
 Name: viur-core
-Version: 3.4.4
+Version: 3.5.0b1
 Summary: The core component of ViUR, a development framework for Google App Engine
 Home-page: https://github.com/viur-framework/viur-core
 Author: Mausbrand Informationssysteme GmbH
 Author-email: devs@viur.dev
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: Topic :: Internet
 Classifier: Topic :: Software Development :: Libraries :: Application Frameworks
 Requires-Python: >=3.10
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: attrs (==22.2.0)
-Requires-Dist: cachetools (==5.0.0)
-Requires-Dist: certifi (==2022.12.7)
-Requires-Dist: charset-normalizer (==2.0.12)
-Requires-Dist: google-api-core[grpc] (==2.7.2)
-Requires-Dist: google-auth (==2.6.3)
-Requires-Dist: google-cloud-appengine-logging (==1.1.1)
-Requires-Dist: google-cloud-audit-log (==0.2.0)
-Requires-Dist: google-cloud-core (==2.3.0)
-Requires-Dist: google-cloud-datastore (==2.5.1)
-Requires-Dist: google-cloud-iam (==2.6.1)
-Requires-Dist: google-cloud-logging (==3.0.0)
-Requires-Dist: google-cloud-storage (==2.2.1)
-Requires-Dist: google-cloud-tasks (==2.8.1)
-Requires-Dist: google-crc32c (==1.3.0)
-Requires-Dist: google-resumable-media (==2.3.2)
-Requires-Dist: googleapis-common-protos[grpc] (==1.56.0)
-Requires-Dist: grpc-google-iam-v1 (==0.12.4)
-Requires-Dist: grpcio (==1.44.0)
-Requires-Dist: grpcio-status (==1.44.0)
+Requires-Dist: google-auth (==2.20.0)
+Requires-Dist: google-cloud-datastore (==2.16.0)
+Requires-Dist: google-cloud-iam (==2.12.0)
+Requires-Dist: google-cloud-logging (==3.5.0)
+Requires-Dist: google-cloud-storage (==2.9.0)
+Requires-Dist: google-cloud-tasks (==2.13.1)
+Requires-Dist: google-resumable-media (==2.5.0)
+Requires-Dist: grpcio (==1.56.0)
+Requires-Dist: grpcio-status (==1.56.0)
 Requires-Dist: gunicorn (==20.1.0)
-Requires-Dist: idna (==3.3)
-Requires-Dist: jinja2 (==3.1.1)
+Requires-Dist: jinja2 (==3.1.2)
 Requires-Dist: jsonschema (==4.17.3)
-Requires-Dist: MarkupSafe (==2.1.1)
-Requires-Dist: packaging (==21.3)
-Requires-Dist: pillow (==9.3.0)
-Requires-Dist: proto-plus (==1.20.6)
-Requires-Dist: protobuf (==3.20.2)
-Requires-Dist: pyasn1 (==0.4.8)
-Requires-Dist: pyasn1-modules (==0.2.8)
-Requires-Dist: pyparsing (==3.0.8)
-Requires-Dist: pyrsistent (==0.19.3)
-Requires-Dist: pytz (==2022.1)
-Requires-Dist: pytz-deprecation-shim (==0.1.0.post0)
-Requires-Dist: PyYAML (==6.0)
+Requires-Dist: pillow (==9.5.0)
+Requires-Dist: pytz (==2023.3)
 Requires-Dist: requests (==2.31.0)
-Requires-Dist: rsa (==4.8)
-Requires-Dist: setuptools (==65.5.1)
-Requires-Dist: six (==1.16.0)
-Requires-Dist: tzdata (==2022.1)
-Requires-Dist: tzlocal (==4.2)
-Requires-Dist: urllib3 (==1.26.9)
+Requires-Dist: tzlocal (==5.0.1)
 Requires-Dist: viur-datastore (==1.3.9)
 Requires-Dist: webob (==1.8.7)
+Requires-Dist: charset-normalizer (==3.1.0) ; python_full_version >= "3.7.0"
+Requires-Dist: six (==1.16.0) ; python_version >= "2.7" and python_version not in "3.0, 3.1, 3.2, 3.3"
+Requires-Dist: pyasn1 (==0.5.0) ; python_version >= "2.7" and python_version not in "3.0, 3.1, 3.2, 3.3, 3.4, 3.5"
+Requires-Dist: pyasn1-modules (==0.3.0) ; python_version >= "2.7" and python_version not in "3.0, 3.1, 3.2, 3.3, 3.4, 3.5"
+Requires-Dist: urllib3 (==1.26.16) ; python_version >= "2.7" and python_version not in "3.0, 3.1, 3.2, 3.3, 3.4, 3.5"
+Requires-Dist: idna (==3.4) ; python_version >= "3.5"
+Requires-Dist: certifi (==2023.5.7) ; python_version >= "3.6"
+Requires-Dist: proto-plus (==1.22.3) ; python_version >= "3.6"
+Requires-Dist: rsa (==4.9) ; python_version >= "3.6" and python_version < "4"
+Requires-Dist: attrs (==23.1.0) ; python_version >= "3.7"
+Requires-Dist: cachetools (==5.3.1) ; python_version >= "3.7"
+Requires-Dist: google-api-core[grpc] (==2.11.1) ; python_version >= "3.7"
+Requires-Dist: google-cloud-appengine-logging (==1.3.0) ; python_version >= "3.7"
+Requires-Dist: google-cloud-audit-log (==0.2.5) ; python_version >= "3.7"
+Requires-Dist: google-cloud-core (==2.3.2) ; python_version >= "3.7"
+Requires-Dist: google-crc32c (==1.5.0) ; python_version >= "3.7"
+Requires-Dist: googleapis-common-protos (==1.59.1) ; python_version >= "3.7"
+Requires-Dist: grpc-google-iam-v1 (==0.12.6) ; python_version >= "3.7"
+Requires-Dist: markupsafe (==2.1.3) ; python_version >= "3.7"
+Requires-Dist: protobuf (==4.23.3) ; python_version >= "3.7"
+Requires-Dist: pyrsistent (==0.19.3) ; python_version >= "3.7"
+Requires-Dist: setuptools (==68.0.0) ; python_version >= "3.7"
 
 <div align="center">
     <img src="https://github.com/viur-framework/viur-artwork/raw/main/icons/icon-core.svg" height="196" alt="A hexagonal logo of the viur-core" title="viur-core">
     <h1>viur-core</h1>
     <a href="https://github.com/viur-framework/viur-core/actions/workflows/python-test.yaml">
         <img src="https://github.com/viur-framework/viur-core/actions/workflows/python-test.yaml/badge.svg" alt="Badge for Python test suite" title="Python test suite">
     </a>
```

### html2text {}

```diff
@@ -1,40 +1,49 @@
-Metadata-Version: 2.1 Name: viur-core Version: 3.4.4 Summary: The core
+Metadata-Version: 2.1 Name: viur-core Version: 3.5.0b1 Summary: The core
 component of ViUR, a development framework for Google App Engine Home-page:
 https://github.com/viur-framework/viur-core Author: Mausbrand
 Informationssysteme GmbH Author-email: devs@viur.dev Classifier: Development
 Status :: 5 - Production/Stable Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: GNU Lesser General Public License v3
 (LGPLv3) Classifier: Operating System :: OS Independent Classifier: Programming
-Language :: Python :: 3.10 Classifier: Topic :: Internet Classifier: Topic ::
-Software Development :: Libraries :: Application Frameworks Requires-Python:
->=3.10 Description-Content-Type: text/markdown License-File: LICENSE Requires-
-Dist: attrs (==22.2.0) Requires-Dist: cachetools (==5.0.0) Requires-Dist:
-certifi (==2022.12.7) Requires-Dist: charset-normalizer (==2.0.12) Requires-
-Dist: google-api-core[grpc] (==2.7.2) Requires-Dist: google-auth (==2.6.3)
-Requires-Dist: google-cloud-appengine-logging (==1.1.1) Requires-Dist: google-
-cloud-audit-log (==0.2.0) Requires-Dist: google-cloud-core (==2.3.0) Requires-
-Dist: google-cloud-datastore (==2.5.1) Requires-Dist: google-cloud-iam
-(==2.6.1) Requires-Dist: google-cloud-logging (==3.0.0) Requires-Dist: google-
-cloud-storage (==2.2.1) Requires-Dist: google-cloud-tasks (==2.8.1) Requires-
-Dist: google-crc32c (==1.3.0) Requires-Dist: google-resumable-media (==2.3.2)
-Requires-Dist: googleapis-common-protos[grpc] (==1.56.0) Requires-Dist: grpc-
-google-iam-v1 (==0.12.4) Requires-Dist: grpcio (==1.44.0) Requires-Dist:
-grpcio-status (==1.44.0) Requires-Dist: gunicorn (==20.1.0) Requires-Dist: idna
-(==3.3) Requires-Dist: jinja2 (==3.1.1) Requires-Dist: jsonschema (==4.17.3)
-Requires-Dist: MarkupSafe (==2.1.1) Requires-Dist: packaging (==21.3) Requires-
-Dist: pillow (==9.3.0) Requires-Dist: proto-plus (==1.20.6) Requires-Dist:
-protobuf (==3.20.2) Requires-Dist: pyasn1 (==0.4.8) Requires-Dist: pyasn1-
-modules (==0.2.8) Requires-Dist: pyparsing (==3.0.8) Requires-Dist: pyrsistent
-(==0.19.3) Requires-Dist: pytz (==2022.1) Requires-Dist: pytz-deprecation-shim
-(==0.1.0.post0) Requires-Dist: PyYAML (==6.0) Requires-Dist: requests
-(==2.31.0) Requires-Dist: rsa (==4.8) Requires-Dist: setuptools (==65.5.1)
-Requires-Dist: six (==1.16.0) Requires-Dist: tzdata (==2022.1) Requires-Dist:
-tzlocal (==4.2) Requires-Dist: urllib3 (==1.26.9) Requires-Dist: viur-datastore
-(==1.3.9) Requires-Dist: webob (==1.8.7)
+Language :: Python :: 3.10 Classifier: Programming Language :: Python :: 3.11
+Classifier: Topic :: Internet Classifier: Topic :: Software Development ::
+Libraries :: Application Frameworks Requires-Python: >=3.10 Description-
+Content-Type: text/markdown License-File: LICENSE Requires-Dist: google-auth
+(==2.20.0) Requires-Dist: google-cloud-datastore (==2.16.0) Requires-Dist:
+google-cloud-iam (==2.12.0) Requires-Dist: google-cloud-logging (==3.5.0)
+Requires-Dist: google-cloud-storage (==2.9.0) Requires-Dist: google-cloud-tasks
+(==2.13.1) Requires-Dist: google-resumable-media (==2.5.0) Requires-Dist:
+grpcio (==1.56.0) Requires-Dist: grpcio-status (==1.56.0) Requires-Dist:
+gunicorn (==20.1.0) Requires-Dist: jinja2 (==3.1.2) Requires-Dist: jsonschema
+(==4.17.3) Requires-Dist: pillow (==9.5.0) Requires-Dist: pytz (==2023.3)
+Requires-Dist: requests (==2.31.0) Requires-Dist: tzlocal (==5.0.1) Requires-
+Dist: viur-datastore (==1.3.9) Requires-Dist: webob (==1.8.7) Requires-Dist:
+charset-normalizer (==3.1.0) ; python_full_version >= "3.7.0" Requires-Dist:
+six (==1.16.0) ; python_version >= "2.7" and python_version not in "3.0, 3.1,
+3.2, 3.3" Requires-Dist: pyasn1 (==0.5.0) ; python_version >= "2.7" and
+python_version not in "3.0, 3.1, 3.2, 3.3, 3.4, 3.5" Requires-Dist: pyasn1-
+modules (==0.3.0) ; python_version >= "2.7" and python_version not in "3.0,
+3.1, 3.2, 3.3, 3.4, 3.5" Requires-Dist: urllib3 (==1.26.16) ; python_version >=
+"2.7" and python_version not in "3.0, 3.1, 3.2, 3.3, 3.4, 3.5" Requires-Dist:
+idna (==3.4) ; python_version >= "3.5" Requires-Dist: certifi (==2023.5.7) ;
+python_version >= "3.6" Requires-Dist: proto-plus (==1.22.3) ; python_version
+>= "3.6" Requires-Dist: rsa (==4.9) ; python_version >= "3.6" and
+python_version < "4" Requires-Dist: attrs (==23.1.0) ; python_version >= "3.7"
+Requires-Dist: cachetools (==5.3.1) ; python_version >= "3.7" Requires-Dist:
+google-api-core[grpc] (==2.11.1) ; python_version >= "3.7" Requires-Dist:
+google-cloud-appengine-logging (==1.3.0) ; python_version >= "3.7" Requires-
+Dist: google-cloud-audit-log (==0.2.5) ; python_version >= "3.7" Requires-Dist:
+google-cloud-core (==2.3.2) ; python_version >= "3.7" Requires-Dist: google-
+crc32c (==1.5.0) ; python_version >= "3.7" Requires-Dist: googleapis-common-
+protos (==1.59.1) ; python_version >= "3.7" Requires-Dist: grpc-google-iam-v1
+(==0.12.6) ; python_version >= "3.7" Requires-Dist: markupsafe (==2.1.3) ;
+python_version >= "3.7" Requires-Dist: protobuf (==4.23.3) ; python_version >=
+"3.7" Requires-Dist: pyrsistent (==0.19.3) ; python_version >= "3.7" Requires-
+Dist: setuptools (==68.0.0) ; python_version >= "3.7"
                       [A hexagonal logo of the viur-core]
                             ****** viur-core ******
  [Badge_for_Python_test_suite] [Badge_for_readthedocs.org_build_status] [Badge
          showing_current_PyPI_version] [Badge_displaying_the_license]
            This is the core library component of the ViUR_framework.
 ## About ViUR is an application development toolkit for the Google App
 Engineâ¢. ViUR is an open source software development framework that was
```

## Comparing `viur_core-3.4.4.dist-info/RECORD` & `viur_core-3.5.0b1.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,92 +1,92 @@
-viur/requirements.txt,sha256=N6a6zjgoP-F51GjWrSQkGtL2zDMbDG9v3Tt5q0nqrdE,18870
+viur/requirements.txt,sha256=-3fFWAfaxCsR2QFkh4hkbKGTXhK5D3sGiLOmwt6FUCU,33986
 viur/tox.ini,sha256=sweRPrajZcO1YaJ9KrJsdn0tVqIkuWf2Eaf7BsptiFg,304
 viur/core/__init__.py,sha256=-HX7o51v7Vmpz8HOXdIiMgNOuHr7n1fxmoT4iSA5REA,16000
 viur/core/cache.py,sha256=w12PdFEll-SHntZt9huU-ycw0elC0gI7dQtCNR0DpkE,13627
-viur/core/config.py,sha256=XaDW8GiZNrCAQvCH88u4FebBYdujmmg-GU7PeBF0Nt0,12369
+viur/core/config.py,sha256=Hfb63rLrCSFjOiX_a_0sDvBvDJCIBkjbdCD1ApTXs6c,12723
 viur/core/current.py,sha256=7o-TDQZ7NVlIvZFtp00tKHCkVA2bagqXhKTE8OzxQok,272
 viur/core/db.py,sha256=qVTMq4SNBibCiFGMPnshauKD2PJt1FdV0CzMWMK5lEw,579
 viur/core/email.py,sha256=J2Ton5Sx6QxIO-6g9IxhBtEUoTBs2-VFm_P-Gpa-FE8,17528
-viur/core/errors.py,sha256=c4i6hiBSBduhb10DkcAFlWZEgIR7WhR8hEyICY4nPd8,7048
+viur/core/errors.py,sha256=xksdTEmehTy5mNIb0Q5E-rcMSd2PKqTSOLa43F2UDp0,8267
 viur/core/i18n.py,sha256=mCpryf1OpR5HV3rbSxBD_N4lvJHWXwkTqSpv6jjnHFU,12654
 viur/core/logging.py,sha256=UXhFLwb9Y2K52VS-f0lEkAruw_CXIT0giH5ppwAL1bw,6360
-viur/core/module.py,sha256=jeswlTLpSmCvKqKlOmlsyzbHQ0rmTymbDPx75vuqAd8,7185
+viur/core/module.py,sha256=ZdfsjgZD0XQRBJK3LTIY3nDHS5yU6f9Mk_gteb6wnSE,8487
 viur/core/pagination.py,sha256=OmTE4gHCThpc9O0di1SbD7FtbwIDMQuABAZ0rIv2L0w,6141
 viur/core/ratelimit.py,sha256=bcoYeMjtoisK6YReQz51EFY-7F2BSwAW24qPRZg9IQc,5647
-viur/core/request.py,sha256=S0itd7lGXfQfYDL9fOnXv8BlEhruAupz-D9ArxtPQS8,32734
+viur/core/request.py,sha256=0YIdnnqu_04Tfce8BHyvCB4GFOCiNWUdmWxU2YBsUNw,32628
 viur/core/securityheaders.py,sha256=dJh6-VnOgpNNFEuYanDRK9mz_ctaMJEax_mX5O3uQNA,14954
-viur/core/securitykey.py,sha256=-1n2_UjsGeS6KROhVTOUyMBPgd3_tb8y6wKiFjB_pvE,4651
-viur/core/session.py,sha256=1qSRDuDlwoL15oTrNrGGNMU6NCuFchBFhzNXk3xkr1E,10338
-viur/core/skeleton.py,sha256=zH4cwSYTdpmF86rd-Tk8vaBw2vdk2fVRKpKDw3Y9F4c,71253
-viur/core/tasks.py,sha256=c6jVoUQYAzOjLGEJEp7KUfemzRZdmZq8wlJ6zGdIOIg,33528
+viur/core/securitykey.py,sha256=-PwSmzuqYEMcI9qqTZuRjoX1-kmJYIQaCkHsdYJMpm0,4543
+viur/core/session.py,sha256=dSVxZIE5g7uq2X6cixl2veHuTkcoNAg3wf-jYQBAdyo,8647
+viur/core/skeleton.py,sha256=ys4mREyhi1NeXLRCKvAzc3neWvppK9O1LI3GRti51to,71202
+viur/core/tasks.py,sha256=xXhLwtw2dWfDAsfIlRvFn1M4v5LuEbYSViKovOZbZIM,33741
 viur/core/utils.py,sha256=wUMu98DDNCyEmW1BqkB9jTuAYEr_d8ZUbDQupodM4g0,12355
-viur/core/version.py,sha256=0hMIwr85EjyncKsZdN-ui7jzY88NQRjqV5_lvvLH43g,429
+viur/core/version.py,sha256=MFXotmYxfVqEXpXc5SZi3vibSNLUWoux_3R-aZNC5f4,435
 viur/core/bones/__init__.py,sha256=VOVFTzFk_izcOAtBmXUnIzAE2QcMJPgYZgvhWqvyj-k,2765
-viur/core/bones/base.py,sha256=F0VzTjTXJ3MZ1ahECQuTncbqwjd32mt8BnFnLbm53yc,42403
-viur/core/bones/boolean.py,sha256=N-_blVCXbYfISGzAFtVNf-7iH-2jrvkqyzD8Kfzi7og,2554
-viur/core/bones/captcha.py,sha256=Ei0XevzU6_eXzN8Fla2D6GcNMvc7tML_GiNKm2w86f0,2742
-viur/core/bones/color.py,sha256=aI3oPPSx33fFBDklpXVwuJS5Q0GWD_DmkBdSavb5PfE,1910
-viur/core/bones/credential.py,sha256=5r1JubIntazVhZfwBAcbiU20PKSoj8xD7DL-uEJRj18,1908
-viur/core/bones/date.py,sha256=y_ebcJ8SrR6Bs4gIbW3-GlWQ3PLvP_07KGhAAwTUN_0,12901
-viur/core/bones/email.py,sha256=YmYtC3kwqFc4GkbkYmgPI9YZmZKJex_A82jjsSzjxsM,1211
-viur/core/bones/file.py,sha256=SZtdT2sEiSSBO9FEI_-fzgzaqy8JMwXhOA2lq8UrJF4,8870
+viur/core/bones/base.py,sha256=trqKGzH-PQEnb0Zf4tXUmGY_JWCdaK-sDl_wvpN8vFA,54117
+viur/core/bones/boolean.py,sha256=Whe_opsD_hQ7uA3_m8qR_Ll9BOUgE0-tYOCbmnf4FRA,4921
+viur/core/bones/captcha.py,sha256=Q9AbZ9TDBKjpTRjkf8Aemfkx6t29AO3OfvdsV29DrWA,3621
+viur/core/bones/color.py,sha256=mXO5GQaBGzkTuvGLmIKQgNLd5t_dh93mx7lgd5GV_dY,3079
+viur/core/bones/credential.py,sha256=Vl7TSrP03aLPl9tCHAElgNDDOoN7RCEo4cZXjJcilDg,3947
+viur/core/bones/date.py,sha256=LLp9-UUUYG9bjsHrPhrXcQLtlXfHhZH8GWuNlXCTlpM,17144
+viur/core/bones/email.py,sha256=KtR4IYkc6jsesPtTSe9AUHxl_4rCNVpmRi2Ovya4G2c,2648
+viur/core/bones/file.py,sha256=cRRsGmuO5xdlOLTQg6lcBIxAEaIO-jnV_1hL5upiKec,14136
 viur/core/bones/json.py,sha256=fs83Wxt9twtzvspYmj6j7vcmg8fUC66XYHtci5XGrH0,3268
-viur/core/bones/key.py,sha256=ykrm56C78FSCGH40pU0TX5-xn1PcYsKlNHTBwK7DrrI,7115
-viur/core/bones/numeric.py,sha256=gBpky7X7p_7Z0f6T9eEKowyN8uc7jf2Wyo6f1pMnZYc,6703
-viur/core/bones/password.py,sha256=94KubvRjk4cso1spmjc8Kk9-8AW7tZr0__5ysGRSToE,5806
-viur/core/bones/randomslice.py,sha256=A4zZj0dOYLbpiWzQ_37Fm32qHWOISUDkEAS6_7qmvlc,6453
-viur/core/bones/raw.py,sha256=MYUZbhoFVlp0ksxtl9mRn9NaBHnl5J9nIOoKb8HCWu8,873
-viur/core/bones/record.py,sha256=uj76K9H0SnC0_ujXpDsGBzGIJPuP9MUSOolaEwS4qfU,4415
-viur/core/bones/relational.py,sha256=s2kIMZD14f_icaEGMLlr9lip5tqu9R6w8eyHCpnDt_0,48776
-viur/core/bones/select.py,sha256=TvgQriIn1CdWLxo8ZaaEGpMXk4se4EqguKcXKmMtgw8,3034
-viur/core/bones/selectcountry.py,sha256=1kbjerk_dwilbRO7yQuTWdv21p5fBkEeRskBbxyr5yY,16814
-viur/core/bones/sortindex.py,sha256=F7Xw57tLVe7oo24WyAHGTWrtZ10JKbTcfhGJ1aEnwhE,505
-viur/core/bones/spatial.py,sha256=sRkXwXEICxlLC1imEf0WjIDMIjVnyy_uDMjArKgCjkM,16500
-viur/core/bones/string.py,sha256=pgaK76FCdv7BcCxtCNDLprolkA8t3fjIXsR7PsfAyQs,7374
-viur/core/bones/text.py,sha256=DDVqNuyoS4wIGFodXbfsSsfyoe3ivn183y3lRulIJPI,16275
-viur/core/bones/treeleaf.py,sha256=LjLO7uY43MN81ogIoubYfam_1fh5QYfGVQmJC7ccZkk,214
-viur/core/bones/treenode.py,sha256=MfvZXFBzeN3jyPmkX6HQN7BNc-k9P-JIHPRtUPMGhlY,126
-viur/core/bones/user.py,sha256=87Jys3Tc_iS9w7YKaY8L-zturLKa9kB-f_ToIB4IuMo,1074
+viur/core/bones/key.py,sha256=37X_XsPU3jPQFijtwd1dOHH0g4bK5YTbyblwgO520sM,10452
+viur/core/bones/numeric.py,sha256=fzPPNcbQY2JQn0LSXzMgI5FCwiUTByorhmEtfR1Lo7A,10434
+viur/core/bones/password.py,sha256=Fm3pNt_E0VFFqbldUTAspKm1mOZ8zgjco_gbxoGaOws,9076
+viur/core/bones/randomslice.py,sha256=3tccyzzmi4T-N35udKrA0765YO2mwMPTf0GGQ-HBy2Q,8194
+viur/core/bones/raw.py,sha256=YYL8mZJoxSI8G_6PfgY2xAMK5ny3jSayrjyoRnLsOy0,1662
+viur/core/bones/record.py,sha256=-N7Cz2O09MTPtjfr9qrqTdtKRjADKNRiTU1V7MpnPbI,7872
+viur/core/bones/relational.py,sha256=DubuLdfaW9pQG4LpVKsde7pc8f1J01wE_GQlIJckq2c,67067
+viur/core/bones/select.py,sha256=PNd2LC0lGn1QtMAIYqAe_PqgNY7uENe8CXWU9blr1J8,5015
+viur/core/bones/selectcountry.py,sha256=JSgspE8BeP342--24p1xlKXEXrARtCoZzv1Koq1WEoA,18919
+viur/core/bones/sortindex.py,sha256=V-9KiSGxv4IBMtAfcBkxHKMNgodJD5wsb9rVvh6W0kg,1492
+viur/core/bones/spatial.py,sha256=-sR8Nyt6qtmpOfZSG-xRpu6uJ2XKkH_46BIwXBgvL5c,20334
+viur/core/bones/string.py,sha256=nnAU8_iuL6ChbUVCvWOL1M2GrDvBG1gmhCt3zKb1c9I,11935
+viur/core/bones/text.py,sha256=a4dBBB47PfZqvxw-SRzmHASX9rqkVW7_0npYLiW3r9w,24571
+viur/core/bones/treeleaf.py,sha256=efwax8MQxdFP5_wKbPwSMfhH0hZF4-hLjo6qW8FfgTY,700
+viur/core/bones/treenode.py,sha256=8Vsw-WaBy2PFbkK9JgUFviv04fQXyrkdjVrtpfppfxg,844
+viur/core/bones/user.py,sha256=YwXlmi1aKVOVA_Zs-gw-gIHcN_qt072PYEGNMicS2JY,2760
 viur/core/languages/__init__.py,sha256=NpyUzlGt3ZFRClF_ZZ3vuE6whv7Xw4HY_QRS_Ilww2Q,38
-viur/core/languages/de.py,sha256=kv_5vDnhaFySsj_zI0bBS15pH9W-33aap9jjctHvDAY,12778
+viur/core/languages/de.py,sha256=BpUtpMnKAei7Ns0FizjQi7pEWv8DMZqe1LzQBSX0HP0,12984
 viur/core/languages/en.py,sha256=Gf-ieI4xKq2NH2SfpjtQqdRX6R7XEIym75mlhT6Lsrw,1660
 viur/core/modules/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-viur/core/modules/file.py,sha256=SB4JbsQcMc-CSQUn1lWA-F5n7BF1Q31pAs4bpCuYMBY,33556
-viur/core/modules/formmailer.py,sha256=I2V0GQ1_jG1BWsJ3vkNhvLBL9009Zhom2IlmHmYK2mI,1916
+viur/core/modules/file.py,sha256=2RB6-SbtRQews3NnV8j8h0wOdcszo4xJL1OslgXanaA,34072
+viur/core/modules/formmailer.py,sha256=STqTWHJwyCaudcPmaBgmb9eCCdjZPSg2b9Hy8UDB8VA,1896
 viur/core/modules/moduleconf.py,sha256=zE8l3D8OFZLm2rpwJYs-qMu3doluk6Z-lTWHybMRPqM,2502
 viur/core/modules/page.py,sha256=3VSisgv3aMHZeZBZIpbtAvCrtuLSFRJwkB0bH3QkgJQ,973
-viur/core/modules/script.py,sha256=YhJH-F1pimGXJNXnA1VQo2Fv1loqIg_wtuGsxO4TJnU,4071
+viur/core/modules/script.py,sha256=2c5xEh9rnoB4T8WfU-OOe0K6joW78xBD-k6Sm0GNeFY,4114
 viur/core/modules/site.py,sha256=5MKaFAmYyVZC9pxYtsHFofyRS_DHYvs_HvSkhTbynHw,556
-viur/core/modules/user.py,sha256=Q9IEfK2pE-pqeteKI0DHhpyXhfS2Ti6OFk1eS_JhvuU,42063
+viur/core/modules/user.py,sha256=rhDU-yEE1Qegk6RBChxVn7cuX5klAVbM2VFdZxLk6K8,44470
 viur/core/prototypes/__init__.py,sha256=qU6GQfQDDvUJugNmagumTp0GfP5jneepddgeXs8myLg,816
-viur/core/prototypes/list.py,sha256=Ar-ezuqXoXMb1K7yXnxBxwrKPT-zzW2eQEQm48vPexU,22782
-viur/core/prototypes/singleton.py,sha256=XdgIh93wS0C9_D9MTKT4nXyAsywJR2FOv90EjjFW1aI,10123
-viur/core/prototypes/skelmodule.py,sha256=71cMNejQjTF4ntG3VG5CVp1aB2hPLHQFLjhYW3EaaQA,2897
-viur/core/prototypes/tree.py,sha256=v2IwV8HenzHVYFgfd80rqbqsdt4zH6Yt0idMDfSFksU,34002
+viur/core/prototypes/list.py,sha256=j6CGLGP-B23cS8yHaTj8MC0XGX50IDRP6ZtQfuQT6Mk,22698
+viur/core/prototypes/singleton.py,sha256=MVwFAuub1q7yP1Jnz42TQBfpXtdvJWI0IIEVYwhSccQ,10083
+viur/core/prototypes/skelmodule.py,sha256=2beolv1vzoaDmAAW0SvQaDsLvCtcbY1x6gnUmCMGMho,2141
+viur/core/prototypes/tree.py,sha256=kKZ8lAyRc_jodkxrys7BDOk46_iJz01s3PRQHwfkejk,33959
 viur/core/render/__init__.py,sha256=WnbFrpDhZDnZ6iwQOcIZEyM-NcO0ZXjaMko3CeIKrTo,204
 viur/core/render/html/__init__.py,sha256=VPzcYq1d52WRQXdn3HeTugM6iZlUs1k7INbYmCUuxQ0,169
-viur/core/render/html/default.py,sha256=_gmeVbZdl0g1c4njJdBw3UfzidtZhWg-hmcQvGUw0fk,19851
+viur/core/render/html/default.py,sha256=05iuWfVYtqvU28pR4l_yKLzaD7Bl_QY-muxQxBEy2TQ,20470
 viur/core/render/html/user.py,sha256=yBVHoIKrIxVCG-1s4afzy3IZKda2vFafJvhF8lTabaE,3584
 viur/core/render/html/utils.py,sha256=tWSL0PveXkHkkOiC3CSwTSTnXwwEGm2rAOT_bzOdRek,1949
 viur/core/render/html/env/__init__.py,sha256=Yu0H1AvRe_Q7_WLMvP3wLyXsilWZ29Lmjq-SHzDu5fw,142
 viur/core/render/html/env/date.py,sha256=0yc_Qur0QFBbbt3G73Gfgl8boNyJqIzdQ-pVph2dJ7s,942
 viur/core/render/html/env/debug.py,sha256=2fFWkku56cy05xSLfYh2m46GgiAiQgxrWWDViLsapYE,1353
 viur/core/render/html/env/regex.py,sha256=bZn9HS-ELmRRNpGxSMkXit720Gy7oNo6dT5yrGaQi5E,1753
 viur/core/render/html/env/session.py,sha256=Y9tOE1GH4C3TdkNaMLKlD1hufnHJsd9tjgVt5zQu8cg,1161
 viur/core/render/html/env/strings.py,sha256=9by8IFF7gDWIbFOOUfZ5NxSbNctquGTdHU-I68vWs7I,540
 viur/core/render/html/env/tests.py,sha256=dBQ5pk1dDuqlzkIDxkhtfiMVLNOFcVJgaf4A4ssxLCc,435
 viur/core/render/html/env/viur.py,sha256=CuvPihAwdcO81zrxrzfuLeOX3bhC0ngOtcHjjS-769I,25465
-viur/core/render/json/__init__.py,sha256=9B3IY10xaBrLE3r924mlsGVmdsGd0nTeumX16Kxg-6o,1027
-viur/core/render/json/default.py,sha256=652Q_-jl88ePkBuZPpjkF2RLCo7stCpqKl-8QGfQyyU,8699
+viur/core/render/json/__init__.py,sha256=myMO_6fqxkzFKyZt0mqBlB1cg4iAMVk3pvNtY7ul-KU,1243
+viur/core/render/json/default.py,sha256=LZfESA2mXgtRmMe_prNMbYJGkAE4exmyuh1RQnp0aCQ,9075
 viur/core/render/json/user.py,sha256=Wawazxes13Vli74wT3U03KRyHIg2_GkfsokHShVpcIA,963
 viur/core/render/vi/__init__.py,sha256=5xaJYiNJPoxNu7bcx2zHUTpQc3AkN4t2cQNxyEzOvOg,5703
 viur/core/render/vi/user.py,sha256=ZRGrfbN-bs1X5RV5KYKtiHTgVY9J1W7u0Hvo6NXltXk,899
 viur/core/render/xml/__init__.py,sha256=O5VhJ_-NTIIGyVhAYaB7osFZLpVE_pe5JbJW-39dkbo,1046
 viur/core/render/xml/default.py,sha256=FIJaaegpUbCYBCWaBS3HiFfY1CK8VuiWmPPiJa9kAog,7319
 viur/core/render/xml/user.py,sha256=HU5e21IlNh_Ev0BCEF_rguBG13P0cK2drxK53HHv5OM,957
-viur/core/template/error.html,sha256=CCDX7EduoLVBLu641ZO4Dwcv5QsJsJxnMA1E_p30ajY,7644
+viur/core/template/error.html,sha256=Dx9oM0hhJEslOM9Ls-UzWuoTOS41Z_LH3jWuhHxTRHE,7642
 viur/core/template/vi_user_google_login.html,sha256=yzFit0gQBAIy5-feRabZQZM2R3bfD-Wkk67MiUNdrcY,1083
-viur_core-3.4.4.dist-info/LICENSE,sha256=2n6rt7r999OuXp8iOqW9we7ORaxWncIbOwN1ILRGR2g,7651
-viur_core-3.4.4.dist-info/METADATA,sha256=SGoSQgouwuThjMPFIwPi7WmzsbkOSixbTwJ_O-I3ebY,5023
-viur_core-3.4.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-viur_core-3.4.4.dist-info/top_level.txt,sha256=UpXSoS_clIJYncMZKAppy3WNRScHSjarTabKBOa8OeI,5
-viur_core-3.4.4.dist-info/RECORD,,
+viur_core-3.5.0b1.dist-info/LICENSE,sha256=2n6rt7r999OuXp8iOqW9we7ORaxWncIbOwN1ILRGR2g,7651
+viur_core-3.5.0b1.dist-info/METADATA,sha256=FRVy58y8c-VuRKZgYm6JmjxRN4Jr1ZBdrgHmFFKtuxY,5713
+viur_core-3.5.0b1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+viur_core-3.5.0b1.dist-info/top_level.txt,sha256=UpXSoS_clIJYncMZKAppy3WNRScHSjarTabKBOa8OeI,5
+viur_core-3.5.0b1.dist-info/RECORD,,
```

