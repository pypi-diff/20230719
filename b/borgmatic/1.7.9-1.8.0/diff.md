# Comparing `tmp/borgmatic-1.7.9.tar.gz` & `tmp/borgmatic-1.8.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "borgmatic-1.7.9.tar", last modified: Thu Mar 16 20:46:45 2023, max compression
+gzip compressed data, was "borgmatic-1.8.0.tar", last modified: Wed Jul 19 05:50:44 2023, max compression
```

## Comparing `borgmatic-1.7.9.tar` & `borgmatic-1.8.0.tar`

### file list

```diff
@@ -1,288 +1,319 @@
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.573053 borgmatic-1.7.9/
--rw-r--r--   0 witten    (1000) witten    (1000)       10 2021-06-08 17:56:15.000000 borgmatic-1.7.9/.dockerignore
--rw-r--r--   0 witten    (1000) witten    (1000)     1023 2023-03-16 20:28:40.000000 borgmatic-1.7.9/.drone.yml
--rw-r--r--   0 witten    (1000) witten    (1000)     1461 2023-01-27 00:18:02.000000 borgmatic-1.7.9/.eleventy.js
--rw-r--r--   0 witten    (1000) witten    (1000)       12 2023-03-07 22:01:46.000000 borgmatic-1.7.9/.flake8
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.543052 borgmatic-1.7.9/.gitea/
--rw-r--r--   0 witten    (1000) witten    (1000)      808 2021-06-08 17:56:15.000000 borgmatic-1.7.9/.gitea/issue_template.md
--rw-r--r--   0 witten    (1000) witten    (1000)      105 2022-03-05 23:40:50.000000 borgmatic-1.7.9/.gitignore
--rw-r--r--   0 witten    (1000) witten    (1000)      631 2021-06-08 17:56:15.000000 borgmatic-1.7.9/AUTHORS
--rw-r--r--   0 witten    (1000) witten    (1000)    35122 2021-06-08 17:56:15.000000 borgmatic-1.7.9/LICENSE
--rw-r--r--   0 witten    (1000) witten    (1000)       58 2021-06-08 17:56:15.000000 borgmatic-1.7.9/MANIFEST.in
--rw-r--r--   0 witten    (1000) witten    (1000)    53738 2023-03-16 20:42:05.000000 borgmatic-1.7.9/NEWS
--rw-r--r--   0 witten    (1000) witten    (1000)      682 2023-03-16 20:46:45.573053 borgmatic-1.7.9/PKG-INFO
--rw-r--r--   0 witten    (1000) witten    (1000)     7227 2023-03-16 20:24:06.000000 borgmatic-1.7.9/README.md
--rw-r--r--   0 witten    (1000) witten    (1000)      665 2022-03-05 23:40:50.000000 borgmatic-1.7.9/SECURITY.md
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.543052 borgmatic-1.7.9/borgmatic/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:15.000000 borgmatic-1.7.9/borgmatic/__init__.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.546386 borgmatic-1.7.9/borgmatic/actions/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1058 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/borg.py
--rw-r--r--   0 witten    (1000) witten    (1000)      697 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/break_lock.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1478 2023-03-16 20:24:06.000000 borgmatic-1.7.9/borgmatic/actions/check.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1808 2023-03-16 20:24:06.000000 borgmatic-1.7.9/borgmatic/actions/compact.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2615 2023-03-16 20:24:06.000000 borgmatic-1.7.9/borgmatic/actions/create.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1446 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/export_tar.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1883 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/extract.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1310 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/info.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1404 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/list.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1312 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/mount.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1431 2023-03-16 20:24:06.000000 borgmatic-1.7.9/borgmatic/actions/prune.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1034 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/rcreate.py
--rw-r--r--   0 witten    (1000) witten    (1000)    12293 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/restore.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1049 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/rinfo.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1013 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/rlist.py
--rw-r--r--   0 witten    (1000) witten    (1000)      626 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/actions/transfer.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.546386 borgmatic-1.7.9/borgmatic/borg/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2022-06-30 18:18:03.000000 borgmatic-1.7.9/borgmatic/borg/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2334 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/borg/borg.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1232 2022-12-12 19:25:31.000000 borgmatic-1.7.9/borgmatic/borg/break_lock.py
--rw-r--r--   0 witten    (1000) witten    (1000)    11327 2023-03-07 22:07:02.000000 borgmatic-1.7.9/borgmatic/borg/check.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1739 2022-08-19 06:07:33.000000 borgmatic-1.7.9/borgmatic/borg/compact.py
--rw-r--r--   0 witten    (1000) witten    (1000)    19042 2023-03-02 23:23:00.000000 borgmatic-1.7.9/borgmatic/borg/create.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1346 2022-06-30 18:00:59.000000 borgmatic-1.7.9/borgmatic/borg/environment.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2583 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/borg/export_tar.py
--rw-r--r--   0 witten    (1000) witten    (1000)     5197 2023-03-09 18:07:20.000000 borgmatic-1.7.9/borgmatic/borg/extract.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1468 2023-03-02 18:53:58.000000 borgmatic-1.7.9/borgmatic/borg/feature.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1793 2022-08-19 06:07:33.000000 borgmatic-1.7.9/borgmatic/borg/flags.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2421 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/borg/info.py
--rw-r--r--   0 witten    (1000) witten    (1000)     7963 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/borg/list.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2551 2022-12-12 19:25:31.000000 borgmatic-1.7.9/borgmatic/borg/mount.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2905 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/borg/prune.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2849 2022-08-19 06:07:33.000000 borgmatic-1.7.9/borgmatic/borg/rcreate.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1887 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/borg/rinfo.py
--rw-r--r--   0 witten    (1000) witten    (1000)     4278 2023-03-07 22:07:16.000000 borgmatic-1.7.9/borgmatic/borg/rlist.py
--rw-r--r--   0 witten    (1000) witten    (1000)       52 2022-06-30 18:22:30.000000 borgmatic-1.7.9/borgmatic/borg/state.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1852 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/borg/transfer.py
--rw-r--r--   0 witten    (1000) witten    (1000)      576 2022-08-16 03:08:11.000000 borgmatic-1.7.9/borgmatic/borg/umount.py
--rw-r--r--   0 witten    (1000) witten    (1000)      971 2022-12-12 19:25:31.000000 borgmatic-1.7.9/borgmatic/borg/version.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.546386 borgmatic-1.7.9/borgmatic/commands/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:15.000000 borgmatic-1.7.9/borgmatic/commands/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)    34430 2023-03-16 20:24:06.000000 borgmatic-1.7.9/borgmatic/commands/arguments.py
--rw-r--r--   0 witten    (1000) witten    (1000)    26598 2023-03-08 21:47:48.000000 borgmatic-1.7.9/borgmatic/commands/borgmatic.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2082 2022-06-09 23:26:49.000000 borgmatic-1.7.9/borgmatic/commands/completion.py
--rw-r--r--   0 witten    (1000) witten    (1000)     3421 2021-12-06 19:57:31.000000 borgmatic-1.7.9/borgmatic/commands/convert_config.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2388 2022-08-24 16:53:36.000000 borgmatic-1.7.9/borgmatic/commands/generate_config.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1705 2021-06-08 17:56:16.000000 borgmatic-1.7.9/borgmatic/commands/validate_config.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.549719 borgmatic-1.7.9/borgmatic/config/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/borgmatic/config/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)      349 2021-06-08 17:56:16.000000 borgmatic-1.7.9/borgmatic/config/checks.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2147 2021-12-06 19:54:03.000000 borgmatic-1.7.9/borgmatic/config/collect.py
--rw-r--r--   0 witten    (1000) witten    (1000)     3805 2022-03-05 23:40:50.000000 borgmatic-1.7.9/borgmatic/config/convert.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1557 2022-10-03 18:27:04.000000 borgmatic-1.7.9/borgmatic/config/environment.py
--rw-r--r--   0 witten    (1000) witten    (1000)    11020 2022-08-19 06:07:33.000000 borgmatic-1.7.9/borgmatic/config/generate.py
--rw-r--r--   0 witten    (1000) witten    (1000)     5432 2021-06-08 17:56:16.000000 borgmatic-1.7.9/borgmatic/config/legacy.py
--rw-r--r--   0 witten    (1000) witten    (1000)     9063 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/config/load.py
--rw-r--r--   0 witten    (1000) witten    (1000)     3707 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/config/normalize.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2401 2022-12-12 19:25:31.000000 borgmatic-1.7.9/borgmatic/config/override.py
--rw-r--r--   0 witten    (1000) witten    (1000)    61715 2023-03-08 21:49:46.000000 borgmatic-1.7.9/borgmatic/config/schema.yaml
--rw-r--r--   0 witten    (1000) witten    (1000)     6712 2023-03-07 22:04:39.000000 borgmatic-1.7.9/borgmatic/config/validate.py
--rw-r--r--   0 witten    (1000) witten    (1000)    12717 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/execute.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.549719 borgmatic-1.7.9/borgmatic/hooks/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/borgmatic/hooks/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)     3412 2022-08-21 21:51:50.000000 borgmatic-1.7.9/borgmatic/hooks/command.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1949 2023-03-07 22:22:17.000000 borgmatic-1.7.9/borgmatic/hooks/cronhub.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1832 2023-03-07 22:22:17.000000 borgmatic-1.7.9/borgmatic/hooks/cronitor.py
--rw-r--r--   0 witten    (1000) witten    (1000)     3226 2023-03-04 17:47:51.000000 borgmatic-1.7.9/borgmatic/hooks/dispatch.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2429 2023-03-04 17:47:51.000000 borgmatic-1.7.9/borgmatic/hooks/dump.py
--rw-r--r--   0 witten    (1000) witten    (1000)     4926 2023-03-07 22:22:17.000000 borgmatic-1.7.9/borgmatic/hooks/healthchecks.py
--rw-r--r--   0 witten    (1000) witten    (1000)     6796 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/hooks/mongodb.py
--rw-r--r--   0 witten    (1000) witten    (1000)      180 2023-03-07 22:22:17.000000 borgmatic-1.7.9/borgmatic/hooks/monitor.py
--rw-r--r--   0 witten    (1000) witten    (1000)     9087 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/hooks/mysql.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2828 2023-03-07 23:34:13.000000 borgmatic-1.7.9/borgmatic/hooks/ntfy.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2649 2022-06-30 03:50:56.000000 borgmatic-1.7.9/borgmatic/hooks/pagerduty.py
--rw-r--r--   0 witten    (1000) witten    (1000)    10603 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/hooks/postgresql.py
--rw-r--r--   0 witten    (1000) witten    (1000)     4780 2023-03-04 17:48:09.000000 borgmatic-1.7.9/borgmatic/hooks/sqlite.py
--rw-r--r--   0 witten    (1000) witten    (1000)     6838 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/logger.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1048 2022-04-28 23:35:37.000000 borgmatic-1.7.9/borgmatic/signals.py
--rw-r--r--   0 witten    (1000) witten    (1000)      516 2023-02-28 17:37:40.000000 borgmatic-1.7.9/borgmatic/verbosity.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.543052 borgmatic-1.7.9/borgmatic.egg-info/
--rw-r--r--   0 witten    (1000) witten    (1000)      682 2023-03-16 20:46:45.000000 borgmatic-1.7.9/borgmatic.egg-info/PKG-INFO
--rw-r--r--   0 witten    (1000) witten    (1000)     7575 2023-03-16 20:46:45.000000 borgmatic-1.7.9/borgmatic.egg-info/SOURCES.txt
--rw-r--r--   0 witten    (1000) witten    (1000)        1 2023-03-16 20:46:45.000000 borgmatic-1.7.9/borgmatic.egg-info/dependency_links.txt
--rw-r--r--   0 witten    (1000) witten    (1000)      266 2023-03-16 20:46:45.000000 borgmatic-1.7.9/borgmatic.egg-info/entry_points.txt
--rw-r--r--   0 witten    (1000) witten    (1000)       79 2023-03-16 20:46:45.000000 borgmatic-1.7.9/borgmatic.egg-info/requires.txt
--rw-r--r--   0 witten    (1000) witten    (1000)       10 2023-03-16 20:46:45.000000 borgmatic-1.7.9/borgmatic.egg-info/top_level.txt
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.553053 borgmatic-1.7.9/docs/
--rw-r--r--   0 witten    (1000) witten    (1000)     1417 2023-03-08 22:11:32.000000 borgmatic-1.7.9/docs/Dockerfile
--rw-r--r--   0 witten    (1000) witten    (1000)     7227 2023-03-16 20:24:06.000000 borgmatic-1.7.9/docs/README.md
--rw-r--r--   0 witten    (1000) witten    (1000)      673 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/SECURITY.md
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.553053 borgmatic-1.7.9/docs/_data/
--rw-r--r--   0 witten    (1000) witten    (1000)       19 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/_data/layout.json
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.553053 borgmatic-1.7.9/docs/_includes/
--rw-r--r--   0 witten    (1000) witten    (1000)       52 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/_includes/asciinema.css
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.553053 borgmatic-1.7.9/docs/_includes/components/
--rw-r--r--   0 witten    (1000) witten    (1000)      492 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/_includes/components/external-links.css
--rw-r--r--   0 witten    (1000) witten    (1000)      636 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/_includes/components/info-blocks.css
--rw-r--r--   0 witten    (1000) witten    (1000)     5125 2023-03-05 00:18:28.000000 borgmatic-1.7.9/docs/_includes/components/lists.css
--rw-r--r--   0 witten    (1000) witten    (1000)     1788 2023-03-05 00:18:28.000000 borgmatic-1.7.9/docs/_includes/components/minilink.css
--rw-r--r--   0 witten    (1000) witten    (1000)      230 2022-03-05 23:40:50.000000 borgmatic-1.7.9/docs/_includes/components/suggestion-link.html
--rw-r--r--   0 witten    (1000) witten    (1000)     1861 2023-03-05 00:18:28.000000 borgmatic-1.7.9/docs/_includes/components/toc.css
--rw-r--r--   0 witten    (1000) witten    (1000)      265 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/_includes/header.njk
--rw-r--r--   0 witten    (1000) witten    (1000)    25783 2023-03-05 00:18:28.000000 borgmatic-1.7.9/docs/_includes/index.css
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.553053 borgmatic-1.7.9/docs/_includes/layouts/
--rw-r--r--   0 witten    (1000) witten    (1000)      813 2022-03-05 23:40:50.000000 borgmatic-1.7.9/docs/_includes/layouts/base.njk
--rw-r--r--   0 witten    (1000) witten    (1000)     1091 2022-03-05 23:40:50.000000 borgmatic-1.7.9/docs/_includes/layouts/main.njk
--rw-r--r--   0 witten    (1000) witten    (1000)     3039 2021-12-06 19:54:03.000000 borgmatic-1.7.9/docs/_includes/prism-theme.css
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.556386 borgmatic-1.7.9/docs/how-to/
--rw-r--r--   0 witten    (1000) witten    (1000)     4522 2022-08-22 03:42:17.000000 borgmatic-1.7.9/docs/how-to/add-preparation-and-cleanup-steps-to-backups.md
--rw-r--r--   0 witten    (1000) witten    (1000)     5082 2023-02-28 17:37:40.000000 borgmatic-1.7.9/docs/how-to/backup-to-a-removable-drive-or-an-intermittent-server.md
--rw-r--r--   0 witten    (1000) witten    (1000)    12509 2023-03-09 00:09:27.000000 borgmatic-1.7.9/docs/how-to/backup-your-databases.md
--rw-r--r--   0 witten    (1000) witten    (1000)     6760 2023-03-08 22:04:20.000000 borgmatic-1.7.9/docs/how-to/deal-with-very-large-backups.md
--rw-r--r--   0 witten    (1000) witten    (1000)     4667 2023-03-16 20:24:06.000000 borgmatic-1.7.9/docs/how-to/develop-on-borgmatic.md
--rw-r--r--   0 witten    (1000) witten    (1000)     4263 2023-03-07 06:45:31.000000 borgmatic-1.7.9/docs/how-to/extract-a-backup.md
--rw-r--r--   0 witten    (1000) witten    (1000)       66 2021-12-06 19:54:03.000000 borgmatic-1.7.9/docs/how-to/index.md
--rw-r--r--   0 witten    (1000) witten    (1000)     4823 2023-03-09 00:09:35.000000 borgmatic-1.7.9/docs/how-to/inspect-your-backups.md
--rw-r--r--   0 witten    (1000) witten    (1000)     2057 2023-02-28 17:37:40.000000 borgmatic-1.7.9/docs/how-to/make-backups-redundant.md
--rw-r--r--   0 witten    (1000) witten    (1000)     8860 2023-02-28 17:37:40.000000 borgmatic-1.7.9/docs/how-to/make-per-application-backups.md
--rw-r--r--   0 witten    (1000) witten    (1000)    14065 2023-03-08 21:56:29.000000 borgmatic-1.7.9/docs/how-to/monitor-your-backups.md
--rw-r--r--   0 witten    (1000) witten    (1000)     3110 2022-08-22 04:14:10.000000 borgmatic-1.7.9/docs/how-to/provide-your-passwords.md
--rw-r--r--   0 witten    (1000) witten    (1000)      124 2022-06-16 18:55:15.000000 borgmatic-1.7.9/docs/how-to/restore-a-backup.md
--rw-r--r--   0 witten    (1000) witten    (1000)     3924 2022-12-12 19:25:31.000000 borgmatic-1.7.9/docs/how-to/run-arbitrary-borg-commands.md
--rw-r--r--   0 witten    (1000) witten    (1000)      152 2022-06-16 18:55:21.000000 borgmatic-1.7.9/docs/how-to/run-preparation-steps-before-backups.md
--rw-r--r--   0 witten    (1000) witten    (1000)    14869 2023-02-28 17:37:40.000000 borgmatic-1.7.9/docs/how-to/set-up-backups.md
--rw-r--r--   0 witten    (1000) witten    (1000)     7785 2023-02-28 17:37:40.000000 borgmatic-1.7.9/docs/how-to/upgrade.md
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.556386 borgmatic-1.7.9/docs/reference/
--rw-r--r--   0 witten    (1000) witten    (1000)      331 2023-02-28 17:37:40.000000 borgmatic-1.7.9/docs/reference/command-line.md
--rw-r--r--   0 witten    (1000) witten    (1000)      426 2023-02-28 17:37:40.000000 borgmatic-1.7.9/docs/reference/configuration.md
--rw-r--r--   0 witten    (1000) witten    (1000)       69 2021-12-06 19:54:03.000000 borgmatic-1.7.9/docs/reference/index.md
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.559719 borgmatic-1.7.9/docs/static/
--rw-r--r--   0 witten    (1000) witten    (1000)     5822 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/static/borgbase.png
--rw-r--r--   0 witten    (1000) witten    (1000)     3593 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/static/borgmatic.png
--rw-r--r--   0 witten    (1000) witten    (1000)     1674 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/static/borgmatic.svg
--rw-r--r--   0 witten    (1000) witten    (1000)    23536 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/static/cronhub.png
--rw-r--r--   0 witten    (1000) witten    (1000)    10364 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/static/cronitor.png
--rw-r--r--   0 witten    (1000) witten    (1000)     4556 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/static/healthchecks.png
--rw-r--r--   0 witten    (1000) witten    (1000)     9474 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/static/mariadb.png
--rw-r--r--   0 witten    (1000) witten    (1000)    12839 2022-03-05 23:40:50.000000 borgmatic-1.7.9/docs/static/mongodb.png
--rw-r--r--   0 witten    (1000) witten    (1000)     3761 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/static/mysql.png
--rw-r--r--   0 witten    (1000) witten    (1000)    10266 2022-06-09 20:35:18.000000 borgmatic-1.7.9/docs/static/ntfy.png
--rw-r--r--   0 witten    (1000) witten    (1000)    20107 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/static/pagerduty.png
--rw-r--r--   0 witten    (1000) witten    (1000)    31528 2021-06-08 17:56:16.000000 borgmatic-1.7.9/docs/static/postgresql.png
--rw-r--r--   0 witten    (1000) witten    (1000)     4668 2023-03-04 17:53:36.000000 borgmatic-1.7.9/docs/static/sqlite.png
--rw-r--r--   0 witten    (1000) witten    (1000)       64 2021-06-08 17:56:16.000000 borgmatic-1.7.9/pyproject.toml
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.539719 borgmatic-1.7.9/sample/
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.559719 borgmatic-1.7.9/sample/cron/
--rw-r--r--   0 witten    (1000) witten    (1000)      183 2022-03-05 23:40:50.000000 borgmatic-1.7.9/sample/cron/borgmatic
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.559719 borgmatic-1.7.9/sample/systemd/
--rw-r--r--   0 witten    (1000) witten    (1000)     2612 2022-12-12 19:25:31.000000 borgmatic-1.7.9/sample/systemd/borgmatic.service
--rw-r--r--   0 witten    (1000) witten    (1000)      138 2022-05-08 06:08:53.000000 borgmatic-1.7.9/sample/systemd/borgmatic.timer
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.559719 borgmatic-1.7.9/scripts/
--rwxr-xr-x   0 witten    (1000) witten    (1000)      241 2023-01-27 02:00:56.000000 borgmatic-1.7.9/scripts/dev-docs
--rwxr-xr-x   0 witten    (1000) witten    (1000)     3108 2022-12-12 19:25:31.000000 borgmatic-1.7.9/scripts/find-unsupported-borg-options
--rwxr-xr-x   0 witten    (1000) witten    (1000)      137 2021-06-08 17:56:16.000000 borgmatic-1.7.9/scripts/push
--rwxr-xr-x   0 witten    (1000) witten    (1000)     1838 2023-03-04 17:49:38.000000 borgmatic-1.7.9/scripts/release
--rwxr-xr-x   0 witten    (1000) witten    (1000)      517 2021-06-08 17:56:16.000000 borgmatic-1.7.9/scripts/run-full-dev-tests
--rwxr-xr-x   0 witten    (1000) witten    (1000)      991 2023-03-04 17:47:51.000000 borgmatic-1.7.9/scripts/run-full-tests
--rw-r--r--   0 witten    (1000) witten    (1000)      513 2023-03-16 20:46:45.573053 borgmatic-1.7.9/setup.cfg
--rw-r--r--   0 witten    (1000) witten    (1000)     1372 2023-03-16 20:42:11.000000 borgmatic-1.7.9/setup.py
--rw-r--r--   0 witten    (1000) witten    (1000)      566 2023-03-07 22:02:22.000000 borgmatic-1.7.9/test_requirements.txt
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.559719 borgmatic-1.7.9/tests/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/__init__.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.563053 borgmatic-1.7.9/tests/end-to-end/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/end-to-end/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)      626 2022-03-05 23:40:50.000000 borgmatic-1.7.9/tests/end-to-end/docker-compose.yaml
--rw-r--r--   0 witten    (1000) witten    (1000)     3180 2022-08-22 05:57:33.000000 borgmatic-1.7.9/tests/end-to-end/test_borgmatic.py
--rw-r--r--   0 witten    (1000) witten    (1000)      143 2022-05-26 18:07:14.000000 borgmatic-1.7.9/tests/end-to-end/test_completion.py
--rw-r--r--   0 witten    (1000) witten    (1000)     6274 2023-03-04 17:47:51.000000 borgmatic-1.7.9/tests/end-to-end/test_database.py
--rw-r--r--   0 witten    (1000) witten    (1000)      588 2022-08-19 06:07:33.000000 borgmatic-1.7.9/tests/end-to-end/test_generate_config.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2006 2022-08-22 06:22:23.000000 borgmatic-1.7.9/tests/end-to-end/test_override.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1227 2022-08-18 03:47:17.000000 borgmatic-1.7.9/tests/end-to-end/test_validate_config.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.563053 borgmatic-1.7.9/tests/integration/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/integration/__init__.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.563053 borgmatic-1.7.9/tests/integration/borg/
--rw-r--r--   0 witten    (1000) witten    (1000)      546 2022-03-05 23:40:50.000000 borgmatic-1.7.9/tests/integration/borg/test_feature.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.563053 borgmatic-1.7.9/tests/integration/commands/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/integration/commands/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)    18673 2023-03-16 20:24:06.000000 borgmatic-1.7.9/tests/integration/commands/test_arguments.py
--rw-r--r--   0 witten    (1000) witten    (1000)      432 2022-08-21 21:13:43.000000 borgmatic-1.7.9/tests/integration/commands/test_borgmatic.py
--rw-r--r--   0 witten    (1000) witten    (1000)      133 2022-05-26 16:53:24.000000 borgmatic-1.7.9/tests/integration/commands/test_completion.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1671 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/integration/commands/test_convert_config.py
--rw-r--r--   0 witten    (1000) witten    (1000)      803 2022-05-29 23:00:10.000000 borgmatic-1.7.9/tests/integration/commands/test_generate_config.py
--rw-r--r--   0 witten    (1000) witten    (1000)      672 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/integration/commands/test_validate_config.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.563053 borgmatic-1.7.9/tests/integration/config/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/integration/config/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)     7927 2022-06-30 20:10:10.000000 borgmatic-1.7.9/tests/integration/config/test_generate.py
--rw-r--r--   0 witten    (1000) witten    (1000)      578 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/integration/config/test_legacy.py
--rw-r--r--   0 witten    (1000) witten    (1000)    15187 2022-05-20 22:15:07.000000 borgmatic-1.7.9/tests/integration/config/test_load.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1039 2021-11-29 20:38:51.000000 borgmatic-1.7.9/tests/integration/config/test_override.py
--rw-r--r--   0 witten    (1000) witten    (1000)      234 2021-12-06 19:54:03.000000 borgmatic-1.7.9/tests/integration/config/test_schema.py
--rw-r--r--   0 witten    (1000) witten    (1000)     7699 2023-03-07 22:03:24.000000 borgmatic-1.7.9/tests/integration/config/test_validate.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.563053 borgmatic-1.7.9/tests/integration/hooks/
--rw-r--r--   0 witten    (1000) witten    (1000)      729 2021-12-06 19:54:03.000000 borgmatic-1.7.9/tests/integration/hooks/test_healthchecks.py
--rw-r--r--   0 witten    (1000) witten    (1000)    11263 2022-08-28 16:03:46.000000 borgmatic-1.7.9/tests/integration/test_execute.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.563053 borgmatic-1.7.9/tests/unit/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/unit/__init__.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.566386 borgmatic-1.7.9/tests/unit/actions/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)      760 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_borg.py
--rw-r--r--   0 witten    (1000) witten    (1000)      636 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_break_lock.py
--rw-r--r--   0 witten    (1000) witten    (1000)     3105 2023-03-16 20:24:53.000000 borgmatic-1.7.9/tests/unit/actions/test_check.py
--rw-r--r--   0 witten    (1000) witten    (1000)     3142 2023-03-16 20:25:01.000000 borgmatic-1.7.9/tests/unit/actions/test_compact.py
--rw-r--r--   0 witten    (1000) witten    (1000)     3418 2023-03-16 20:24:57.000000 borgmatic-1.7.9/tests/unit/actions/test_create.py
--rw-r--r--   0 witten    (1000) witten    (1000)      958 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_export_tar.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1104 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_extract.py
--rw-r--r--   0 witten    (1000) witten    (1000)      808 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_info.py
--rw-r--r--   0 witten    (1000) witten    (1000)      799 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_list.py
--rw-r--r--   0 witten    (1000) witten    (1000)      764 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_mount.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2712 2023-03-16 20:24:48.000000 borgmatic-1.7.9/tests/unit/actions/test_prune.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1730 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_rcreate.py
--rw-r--r--   0 witten    (1000) witten    (1000)    18426 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_restore.py
--rw-r--r--   0 witten    (1000) witten    (1000)      679 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_rinfo.py
--rw-r--r--   0 witten    (1000) witten    (1000)      671 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_rlist.py
--rw-r--r--   0 witten    (1000) witten    (1000)      621 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/actions/test_transfer.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.569719 borgmatic-1.7.9/tests/unit/borg/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/unit/borg/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)    12347 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/borg/test_borg.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2534 2022-12-12 19:25:31.000000 borgmatic-1.7.9/tests/unit/borg/test_break_lock.py
--rw-r--r--   0 witten    (1000) witten    (1000)    25781 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/borg/test_check.py
--rw-r--r--   0 witten    (1000) witten    (1000)     5527 2022-08-19 06:07:33.000000 borgmatic-1.7.9/tests/unit/borg/test_compact.py
--rw-r--r--   0 witten    (1000) witten    (1000)   116577 2023-03-07 22:08:00.000000 borgmatic-1.7.9/tests/unit/borg/test_create.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1174 2022-06-30 19:15:33.000000 borgmatic-1.7.9/tests/unit/borg/test_environment.py
--rw-r--r--   0 witten    (1000) witten    (1000)    10755 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/borg/test_export_tar.py
--rw-r--r--   0 witten    (1000) witten    (1000)    15997 2023-03-09 18:07:00.000000 borgmatic-1.7.9/tests/unit/borg/test_extract.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2846 2022-08-19 06:07:33.000000 borgmatic-1.7.9/tests/unit/borg/test_flags.py
--rw-r--r--   0 witten    (1000) witten    (1000)    13294 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/borg/test_info.py
--rw-r--r--   0 witten    (1000) witten    (1000)    23301 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/borg/test_list.py
--rw-r--r--   0 witten    (1000) witten    (1000)     7359 2022-12-12 19:25:31.000000 borgmatic-1.7.9/tests/unit/borg/test_mount.py
--rw-r--r--   0 witten    (1000) witten    (1000)    10592 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/borg/test_prune.py
--rw-r--r--   0 witten    (1000) witten    (1000)     9791 2022-08-19 16:27:22.000000 borgmatic-1.7.9/tests/unit/borg/test_rcreate.py
--rw-r--r--   0 witten    (1000) witten    (1000)     9342 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/borg/test_rinfo.py
--rw-r--r--   0 witten    (1000) witten    (1000)    14072 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/borg/test_rlist.py
--rw-r--r--   0 witten    (1000) witten    (1000)    14768 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/borg/test_transfer.py
--rw-r--r--   0 witten    (1000) witten    (1000)      920 2022-06-30 19:06:41.000000 borgmatic-1.7.9/tests/unit/borg/test_umount.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2063 2022-12-12 19:25:31.000000 borgmatic-1.7.9/tests/unit/borg/test_version.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.569719 borgmatic-1.7.9/tests/unit/commands/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/unit/commands/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)     5746 2023-03-08 20:11:06.000000 borgmatic-1.7.9/tests/unit/commands/test_arguments.py
--rw-r--r--   0 witten    (1000) witten    (1000)    44909 2023-03-08 21:50:23.000000 borgmatic-1.7.9/tests/unit/commands/test_borgmatic.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.569719 borgmatic-1.7.9/tests/unit/config/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/unit/config/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)      709 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/unit/config/test_checks.py
--rw-r--r--   0 witten    (1000) witten    (1000)     7576 2021-12-06 19:54:03.000000 borgmatic-1.7.9/tests/unit/config/test_collect.py
--rw-r--r--   0 witten    (1000) witten    (1000)     5380 2022-03-05 23:40:50.000000 borgmatic-1.7.9/tests/unit/config/test_convert.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2880 2022-06-23 17:40:47.000000 borgmatic-1.7.9/tests/unit/config/test_environment.py
--rw-r--r--   0 witten    (1000) witten    (1000)     5549 2022-03-05 23:40:50.000000 borgmatic-1.7.9/tests/unit/config/test_generate.py
--rw-r--r--   0 witten    (1000) witten    (1000)     7470 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/unit/config/test_legacy.py
--rw-r--r--   0 witten    (1000) witten    (1000)     3381 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/config/test_normalize.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2827 2022-03-05 23:40:50.000000 borgmatic-1.7.9/tests/unit/config/test_override.py
--rw-r--r--   0 witten    (1000) witten    (1000)     6214 2022-08-17 16:56:29.000000 borgmatic-1.7.9/tests/unit/config/test_validate.py
-drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-03-16 20:46:45.573053 borgmatic-1.7.9/tests/unit/hooks/
--rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.7.9/tests/unit/hooks/__init__.py
--rw-r--r--   0 witten    (1000) witten    (1000)     4092 2022-05-23 22:26:48.000000 borgmatic-1.7.9/tests/unit/hooks/test_command.py
--rw-r--r--   0 witten    (1000) witten    (1000)     3525 2023-03-07 22:22:17.000000 borgmatic-1.7.9/tests/unit/hooks/test_cronhub.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2973 2023-03-07 22:22:17.000000 borgmatic-1.7.9/tests/unit/hooks/test_cronitor.py
--rw-r--r--   0 witten    (1000) witten    (1000)     4402 2022-12-12 19:25:31.000000 borgmatic-1.7.9/tests/unit/hooks/test_dispatch.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2938 2021-12-06 19:54:03.000000 borgmatic-1.7.9/tests/unit/hooks/test_dump.py
--rw-r--r--   0 witten    (1000) witten    (1000)    11575 2023-03-07 22:22:17.000000 borgmatic-1.7.9/tests/unit/hooks/test_healthchecks.py
--rw-r--r--   0 witten    (1000) witten    (1000)    11590 2023-03-07 22:08:11.000000 borgmatic-1.7.9/tests/unit/hooks/test_mongodb.py
--rw-r--r--   0 witten    (1000) witten    (1000)    15616 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/hooks/test_mysql.py
--rw-r--r--   0 witten    (1000) witten    (1000)     7267 2023-03-07 23:37:04.000000 borgmatic-1.7.9/tests/unit/hooks/test_ntfy.py
--rw-r--r--   0 witten    (1000) witten    (1000)     2231 2022-06-30 04:15:15.000000 borgmatic-1.7.9/tests/unit/hooks/test_pagerduty.py
--rw-r--r--   0 witten    (1000) witten    (1000)    26214 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/hooks/test_postgresql.py
--rw-r--r--   0 witten    (1000) witten    (1000)     5020 2023-03-04 17:47:51.000000 borgmatic-1.7.9/tests/unit/hooks/test_sqlite.py
--rw-r--r--   0 witten    (1000) witten    (1000)    16090 2022-12-12 19:25:31.000000 borgmatic-1.7.9/tests/unit/test_execute.py
--rw-r--r--   0 witten    (1000) witten    (1000)    13531 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/test_logger.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1405 2022-04-28 23:35:37.000000 borgmatic-1.7.9/tests/unit/test_signals.py
--rw-r--r--   0 witten    (1000) witten    (1000)     1265 2023-02-28 17:37:40.000000 borgmatic-1.7.9/tests/unit/test_verbosity.py
--rw-r--r--   0 witten    (1000) witten    (1000)      711 2023-03-16 20:28:32.000000 borgmatic-1.7.9/tox.ini
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:44.012133 borgmatic-1.8.0/
+-rw-r--r--   0 witten    (1000) witten    (1000)       10 2021-06-08 17:56:15.000000 borgmatic-1.8.0/.dockerignore
+-rw-r--r--   0 witten    (1000) witten    (1000)     1923 2023-07-10 16:39:03.000000 borgmatic-1.8.0/.drone.yml
+-rw-r--r--   0 witten    (1000) witten    (1000)     1624 2023-06-27 21:37:40.000000 borgmatic-1.8.0/.eleventy.js
+-rw-r--r--   0 witten    (1000) witten    (1000)       12 2023-06-27 21:37:40.000000 borgmatic-1.8.0/.flake8
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.962132 borgmatic-1.8.0/.gitea/
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.972132 borgmatic-1.8.0/.gitea/issue_template/
+-rw-r--r--   0 witten    (1000) witten    (1000)     2113 2023-07-15 05:25:42.000000 borgmatic-1.8.0/.gitea/issue_template/bug_template.yaml
+-rw-r--r--   0 witten    (1000) witten    (1000)       28 2023-07-15 05:17:31.000000 borgmatic-1.8.0/.gitea/issue_template/config.yaml
+-rw-r--r--   0 witten    (1000) witten    (1000)      334 2023-07-15 05:24:16.000000 borgmatic-1.8.0/.gitea/issue_template/feature_template.yaml
+-rw-r--r--   0 witten    (1000) witten    (1000)      105 2023-05-12 23:35:39.000000 borgmatic-1.8.0/.gitignore
+-rw-r--r--   0 witten    (1000) witten    (1000)      631 2021-06-08 17:56:15.000000 borgmatic-1.8.0/AUTHORS
+-rw-r--r--   0 witten    (1000) witten    (1000)    35122 2021-06-08 17:56:15.000000 borgmatic-1.8.0/LICENSE
+-rw-r--r--   0 witten    (1000) witten    (1000)       58 2021-06-08 17:56:15.000000 borgmatic-1.8.0/MANIFEST.in
+-rw-r--r--   0 witten    (1000) witten    (1000)    63363 2023-07-19 05:49:54.000000 borgmatic-1.8.0/NEWS
+-rw-r--r--   0 witten    (1000) witten    (1000)      682 2023-07-19 05:50:44.012133 borgmatic-1.8.0/PKG-INFO
+-rw-r--r--   0 witten    (1000) witten    (1000)     6650 2023-07-14 03:21:38.000000 borgmatic-1.8.0/README.md
+-rw-r--r--   0 witten    (1000) witten    (1000)      658 2023-07-10 16:39:03.000000 borgmatic-1.8.0/SECURITY.md
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.972132 borgmatic-1.8.0/borgmatic/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:15.000000 borgmatic-1.8.0/borgmatic/__init__.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.975466 borgmatic-1.8.0/borgmatic/actions/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2023-05-12 23:35:39.000000 borgmatic-1.8.0/borgmatic/actions/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      327 2023-07-10 16:39:03.000000 borgmatic-1.8.0/borgmatic/actions/arguments.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1190 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/borg.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      878 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/break_lock.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1458 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/check.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1914 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/compact.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.975466 borgmatic-1.8.0/borgmatic/actions/config/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2023-07-10 16:39:03.000000 borgmatic-1.8.0/borgmatic/actions/config/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3525 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/config/bootstrap.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1622 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/config/generate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      858 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/config/validate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3785 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/create.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1521 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/export_tar.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1962 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/extract.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1543 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/info.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1641 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/list.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1385 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/mount.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1380 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/prune.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1091 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/rcreate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    13089 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/restore.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1200 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/rinfo.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1134 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/rlist.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      705 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/actions/transfer.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.978799 borgmatic-1.8.0/borgmatic/borg/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2022-06-30 18:18:03.000000 borgmatic-1.8.0/borgmatic/borg/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2360 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/borg.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1348 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/break_lock.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    15244 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/check.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1800 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/compact.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    19716 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/create.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1783 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/environment.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2573 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/export_tar.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     5530 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/extract.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1368 2023-07-12 16:12:01.000000 borgmatic-1.8.0/borgmatic/borg/feature.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2870 2023-07-07 05:26:07.000000 borgmatic-1.8.0/borgmatic/borg/flags.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2670 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/info.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     8470 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/list.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2851 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/mount.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3274 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/prune.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3056 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/rcreate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2055 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/rinfo.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     4998 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/rlist.py
+-rw-r--r--   0 witten    (1000) witten    (1000)       52 2023-07-07 05:36:58.000000 borgmatic-1.8.0/borgmatic/borg/state.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2136 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/transfer.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      576 2023-07-07 05:37:41.000000 borgmatic-1.8.0/borgmatic/borg/umount.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      991 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/borg/version.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.978799 borgmatic-1.8.0/borgmatic/commands/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:15.000000 borgmatic-1.8.0/borgmatic/commands/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    51275 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/commands/arguments.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    31188 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/commands/borgmatic.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.982133 borgmatic-1.8.0/borgmatic/commands/completion/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2023-07-10 16:39:03.000000 borgmatic-1.8.0/borgmatic/commands/completion/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1382 2023-07-10 16:39:03.000000 borgmatic-1.8.0/borgmatic/commands/completion/actions.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2390 2023-07-10 16:39:03.000000 borgmatic-1.8.0/borgmatic/commands/completion/bash.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     6785 2023-07-10 16:39:03.000000 borgmatic-1.8.0/borgmatic/commands/completion/fish.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      488 2023-07-10 16:39:03.000000 borgmatic-1.8.0/borgmatic/commands/generate_config.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      488 2023-07-10 16:39:03.000000 borgmatic-1.8.0/borgmatic/commands/validate_config.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.982133 borgmatic-1.8.0/borgmatic/config/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.8.0/borgmatic/config/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      349 2023-07-01 05:36:11.000000 borgmatic-1.8.0/borgmatic/config/checks.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2210 2023-07-10 16:39:03.000000 borgmatic-1.8.0/borgmatic/config/collect.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1542 2023-06-27 21:37:40.000000 borgmatic-1.8.0/borgmatic/config/environment.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    10882 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/config/generate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    12749 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/config/load.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    11064 2023-07-19 05:45:57.000000 borgmatic-1.8.0/borgmatic/config/normalize.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2984 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/config/override.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    54538 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/config/schema.yaml
+-rw-r--r--   0 witten    (1000) witten    (1000)     7260 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/config/validate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    13958 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/execute.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.985466 borgmatic-1.8.0/borgmatic/hooks/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2023-07-10 00:33:30.000000 borgmatic-1.8.0/borgmatic/hooks/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3276 2023-06-27 21:37:40.000000 borgmatic-1.8.0/borgmatic/hooks/command.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1929 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/hooks/cronhub.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1810 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/hooks/cronitor.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3203 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/hooks/dispatch.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2387 2023-07-10 00:33:27.000000 borgmatic-1.8.0/borgmatic/hooks/dump.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     4896 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/hooks/healthchecks.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     7495 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/hooks/mongodb.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      180 2023-07-10 00:33:34.000000 borgmatic-1.8.0/borgmatic/hooks/monitor.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     9391 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/hooks/mysql.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2852 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/hooks/ntfy.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2606 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/hooks/pagerduty.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    12327 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/hooks/postgresql.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     5075 2023-07-14 03:21:38.000000 borgmatic-1.8.0/borgmatic/hooks/sqlite.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     7242 2023-07-10 16:39:03.000000 borgmatic-1.8.0/borgmatic/logger.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1048 2023-05-12 23:35:39.000000 borgmatic-1.8.0/borgmatic/signals.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      586 2023-07-10 16:39:03.000000 borgmatic-1.8.0/borgmatic/verbosity.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.972132 borgmatic-1.8.0/borgmatic.egg-info/
+-rw-r--r--   0 witten    (1000) witten    (1000)      682 2023-07-19 05:50:43.000000 borgmatic-1.8.0/borgmatic.egg-info/PKG-INFO
+-rw-r--r--   0 witten    (1000) witten    (1000)     8586 2023-07-19 05:50:43.000000 borgmatic-1.8.0/borgmatic.egg-info/SOURCES.txt
+-rw-r--r--   0 witten    (1000) witten    (1000)        1 2023-07-19 05:50:43.000000 borgmatic-1.8.0/borgmatic.egg-info/dependency_links.txt
+-rw-r--r--   0 witten    (1000) witten    (1000)      200 2023-07-19 05:50:43.000000 borgmatic-1.8.0/borgmatic.egg-info/entry_points.txt
+-rw-r--r--   0 witten    (1000) witten    (1000)       89 2023-07-19 05:50:43.000000 borgmatic-1.8.0/borgmatic.egg-info/requires.txt
+-rw-r--r--   0 witten    (1000) witten    (1000)       10 2023-07-19 05:50:43.000000 borgmatic-1.8.0/borgmatic.egg-info/top_level.txt
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.985466 borgmatic-1.8.0/docs/
+-rw-r--r--   0 witten    (1000) witten    (1000)     1544 2023-07-10 16:39:03.000000 borgmatic-1.8.0/docs/Dockerfile
+-rw-r--r--   0 witten    (1000) witten    (1000)     6650 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/README.md
+-rw-r--r--   0 witten    (1000) witten    (1000)      673 2023-05-12 23:35:39.000000 borgmatic-1.8.0/docs/SECURITY.md
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.985466 borgmatic-1.8.0/docs/_data/
+-rw-r--r--   0 witten    (1000) witten    (1000)      112 2023-07-12 03:00:10.000000 borgmatic-1.8.0/docs/_data/borgmatic.js
+-rw-r--r--   0 witten    (1000) witten    (1000)       19 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/_data/layout.json
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.985466 borgmatic-1.8.0/docs/_includes/
+-rw-r--r--   0 witten    (1000) witten    (1000)       52 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/_includes/asciinema.css
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.985466 borgmatic-1.8.0/docs/_includes/components/
+-rw-r--r--   0 witten    (1000) witten    (1000)      492 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/_includes/components/external-links.css
+-rw-r--r--   0 witten    (1000) witten    (1000)      636 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/_includes/components/info-blocks.css
+-rw-r--r--   0 witten    (1000) witten    (1000)     5125 2023-06-27 21:37:40.000000 borgmatic-1.8.0/docs/_includes/components/lists.css
+-rw-r--r--   0 witten    (1000) witten    (1000)     1788 2023-06-27 21:37:40.000000 borgmatic-1.8.0/docs/_includes/components/minilink.css
+-rw-r--r--   0 witten    (1000) witten    (1000)      219 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/_includes/components/suggestion-link.html
+-rw-r--r--   0 witten    (1000) witten    (1000)     1862 2023-06-27 21:37:40.000000 borgmatic-1.8.0/docs/_includes/components/toc.css
+-rw-r--r--   0 witten    (1000) witten    (1000)      265 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/_includes/header.njk
+-rw-r--r--   0 witten    (1000) witten    (1000)    26340 2023-06-27 21:37:40.000000 borgmatic-1.8.0/docs/_includes/index.css
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.985466 borgmatic-1.8.0/docs/_includes/layouts/
+-rw-r--r--   0 witten    (1000) witten    (1000)      909 2023-06-27 21:37:40.000000 borgmatic-1.8.0/docs/_includes/layouts/base.njk
+-rw-r--r--   0 witten    (1000) witten    (1000)     1184 2023-07-12 03:00:10.000000 borgmatic-1.8.0/docs/_includes/layouts/main.njk
+-rw-r--r--   0 witten    (1000) witten    (1000)     3039 2023-05-12 23:35:39.000000 borgmatic-1.8.0/docs/_includes/prism-theme.css
+-rw-r--r--   0 witten    (1000) witten    (1000)      422 2023-07-12 03:00:10.000000 borgmatic-1.8.0/docs/docker-compose.yaml
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.988799 borgmatic-1.8.0/docs/how-to/
+-rw-r--r--   0 witten    (1000) witten    (1000)     5278 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/add-preparation-and-cleanup-steps-to-backups.md
+-rw-r--r--   0 witten    (1000) witten    (1000)     5401 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/backup-to-a-removable-drive-or-an-intermittent-server.md
+-rw-r--r--   0 witten    (1000) witten    (1000)    15709 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/backup-your-databases.md
+-rw-r--r--   0 witten    (1000) witten    (1000)     7909 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/deal-with-very-large-backups.md
+-rw-r--r--   0 witten    (1000) witten    (1000)     6240 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/develop-on-borgmatic.md
+-rw-r--r--   0 witten    (1000) witten    (1000)     4363 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/extract-a-backup.md
+-rw-r--r--   0 witten    (1000) witten    (1000)       77 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/index.md
+-rw-r--r--   0 witten    (1000) witten    (1000)     6424 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/inspect-your-backups.md
+-rw-r--r--   0 witten    (1000) witten    (1000)     2165 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/make-backups-redundant.md
+-rw-r--r--   0 witten    (1000) witten    (1000)    19367 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/make-per-application-backups.md
+-rw-r--r--   0 witten    (1000) witten    (1000)    14685 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/monitor-your-backups.md
+-rw-r--r--   0 witten    (1000) witten    (1000)     3322 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/provide-your-passwords.md
+-rw-r--r--   0 witten    (1000) witten    (1000)      124 2022-06-16 18:55:15.000000 borgmatic-1.8.0/docs/how-to/restore-a-backup.md
+-rw-r--r--   0 witten    (1000) witten    (1000)     5925 2023-07-10 16:39:03.000000 borgmatic-1.8.0/docs/how-to/run-arbitrary-borg-commands.md
+-rw-r--r--   0 witten    (1000) witten    (1000)      152 2022-06-16 18:55:21.000000 borgmatic-1.8.0/docs/how-to/run-preparation-steps-before-backups.md
+-rw-r--r--   0 witten    (1000) witten    (1000)    15841 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/set-up-backups.md
+-rw-r--r--   0 witten    (1000) witten    (1000)     7637 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/how-to/upgrade.md
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.988799 borgmatic-1.8.0/docs/reference/
+-rw-r--r--   0 witten    (1000) witten    (1000)      853 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/reference/command-line.md
+-rw-r--r--   0 witten    (1000) witten    (1000)      810 2023-07-10 16:39:03.000000 borgmatic-1.8.0/docs/reference/configuration.md
+-rw-r--r--   0 witten    (1000) witten    (1000)       80 2023-07-14 03:21:38.000000 borgmatic-1.8.0/docs/reference/index.md
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.992133 borgmatic-1.8.0/docs/static/
+-rw-r--r--   0 witten    (1000) witten    (1000)     5822 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/static/borgbase.png
+-rw-r--r--   0 witten    (1000) witten    (1000)     3593 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/static/borgmatic.png
+-rw-r--r--   0 witten    (1000) witten    (1000)     1674 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/static/borgmatic.svg
+-rw-r--r--   0 witten    (1000) witten    (1000)    23536 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/static/cronhub.png
+-rw-r--r--   0 witten    (1000) witten    (1000)    10364 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/static/cronitor.png
+-rw-r--r--   0 witten    (1000) witten    (1000)     4556 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/static/healthchecks.png
+-rw-r--r--   0 witten    (1000) witten    (1000)     9474 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/static/mariadb.png
+-rw-r--r--   0 witten    (1000) witten    (1000)    12839 2023-05-12 23:35:39.000000 borgmatic-1.8.0/docs/static/mongodb.png
+-rw-r--r--   0 witten    (1000) witten    (1000)     3761 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/static/mysql.png
+-rw-r--r--   0 witten    (1000) witten    (1000)    10266 2023-05-12 23:35:39.000000 borgmatic-1.8.0/docs/static/ntfy.png
+-rw-r--r--   0 witten    (1000) witten    (1000)    20107 2023-05-12 23:35:39.000000 borgmatic-1.8.0/docs/static/pagerduty.png
+-rw-r--r--   0 witten    (1000) witten    (1000)    31528 2021-06-08 17:56:16.000000 borgmatic-1.8.0/docs/static/postgresql.png
+-rw-r--r--   0 witten    (1000) witten    (1000)     4668 2023-06-27 21:37:40.000000 borgmatic-1.8.0/docs/static/sqlite.png
+-rw-r--r--   0 witten    (1000) witten    (1000)       64 2023-04-15 02:33:57.000000 borgmatic-1.8.0/pyproject.toml
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.965466 borgmatic-1.8.0/sample/
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.992133 borgmatic-1.8.0/sample/cron/
+-rw-r--r--   0 witten    (1000) witten    (1000)      183 2023-05-12 23:35:39.000000 borgmatic-1.8.0/sample/cron/borgmatic
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.992133 borgmatic-1.8.0/sample/systemd/
+-rw-r--r--   0 witten    (1000) witten    (1000)      499 2023-07-10 16:39:03.000000 borgmatic-1.8.0/sample/systemd/borgmatic-user.service
+-rw-r--r--   0 witten    (1000) witten    (1000)      138 2023-06-14 21:55:41.000000 borgmatic-1.8.0/sample/systemd/borgmatic-user.timer
+-rw-r--r--   0 witten    (1000) witten    (1000)     2612 2023-07-10 16:39:03.000000 borgmatic-1.8.0/sample/systemd/borgmatic.service
+-rw-r--r--   0 witten    (1000) witten    (1000)      138 2023-06-14 21:55:41.000000 borgmatic-1.8.0/sample/systemd/borgmatic.timer
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.992133 borgmatic-1.8.0/scripts/
+-rwxr-xr-x   0 witten    (1000) witten    (1000)      259 2023-07-10 16:39:03.000000 borgmatic-1.8.0/scripts/dev-docs
+-rwxr-xr-x   0 witten    (1000) witten    (1000)     3108 2023-05-12 23:35:39.000000 borgmatic-1.8.0/scripts/find-unsupported-borg-options
+-rwxr-xr-x   0 witten    (1000) witten    (1000)      137 2021-06-08 17:56:16.000000 borgmatic-1.8.0/scripts/push
+-rwxr-xr-x   0 witten    (1000) witten    (1000)     1685 2023-07-10 16:39:03.000000 borgmatic-1.8.0/scripts/release
+-rwxr-xr-x   0 witten    (1000) witten    (1000)      658 2023-06-27 21:37:40.000000 borgmatic-1.8.0/scripts/run-end-to-end-dev-tests
+-rwxr-xr-x   0 witten    (1000) witten    (1000)     1334 2023-07-10 16:39:03.000000 borgmatic-1.8.0/scripts/run-full-tests
+-rw-r--r--   0 witten    (1000) witten    (1000)      505 2023-07-19 05:50:44.012133 borgmatic-1.8.0/setup.cfg
+-rw-r--r--   0 witten    (1000) witten    (1000)     1312 2023-07-19 05:50:00.000000 borgmatic-1.8.0/setup.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      818 2023-07-10 16:39:03.000000 borgmatic-1.8.0/test_requirements.txt
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.992133 borgmatic-1.8.0/tests/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.8.0/tests/__init__.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.995466 borgmatic-1.8.0/tests/end-to-end/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.8.0/tests/end-to-end/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1383 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/end-to-end/docker-compose.yaml
+-rw-r--r--   0 witten    (1000) witten    (1000)     2981 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/end-to-end/test_borgmatic.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      268 2023-07-14 02:24:28.000000 borgmatic-1.8.0/tests/end-to-end/test_completion.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    12221 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/end-to-end/test_database.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1711 2023-07-14 02:24:16.000000 borgmatic-1.8.0/tests/end-to-end/test_dev_parity_with_build_server.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      588 2023-07-14 02:24:23.000000 borgmatic-1.8.0/tests/end-to-end/test_generate_config.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1980 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/end-to-end/test_override.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1630 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/end-to-end/test_validate_config.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.995466 borgmatic-1.8.0/tests/integration/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.8.0/tests/integration/__init__.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.995466 borgmatic-1.8.0/tests/integration/actions/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/integration/actions/__init__.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.995466 borgmatic-1.8.0/tests/integration/actions/config/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/integration/actions/config/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1088 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/integration/actions/config/test_validate.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.995466 borgmatic-1.8.0/tests/integration/borg/
+-rw-r--r--   0 witten    (1000) witten    (1000)     5352 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/integration/borg/test_commands.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      546 2023-05-12 23:35:39.000000 borgmatic-1.8.0/tests/integration/borg/test_feature.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.995466 borgmatic-1.8.0/tests/integration/commands/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.8.0/tests/integration/commands/__init__.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.998800 borgmatic-1.8.0/tests/integration/commands/completion/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/integration/commands/completion/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      811 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/integration/commands/completion/test_actions.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      138 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/integration/commands/completion/test_bash.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      138 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/integration/commands/completion/test_fish.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    23211 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/integration/commands/test_arguments.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      432 2023-04-15 02:32:17.000000 borgmatic-1.8.0/tests/integration/commands/test_borgmatic.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      214 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/integration/commands/test_generate_config.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      214 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/integration/commands/test_validate_config.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.998800 borgmatic-1.8.0/tests/integration/config/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.8.0/tests/integration/config/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     8563 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/integration/config/test_generate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    35294 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/integration/config/test_load.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1039 2023-05-12 23:35:39.000000 borgmatic-1.8.0/tests/integration/config/test_override.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      234 2023-05-12 23:35:39.000000 borgmatic-1.8.0/tests/integration/config/test_schema.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     7158 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/integration/config/test_validate.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.998800 borgmatic-1.8.0/tests/integration/hooks/
+-rw-r--r--   0 witten    (1000) witten    (1000)      753 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/integration/hooks/test_healthchecks.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    11256 2023-06-27 21:37:40.000000 borgmatic-1.8.0/tests/integration/test_execute.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:43.998800 borgmatic-1.8.0/tests/unit/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.8.0/tests/unit/__init__.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:44.002133 borgmatic-1.8.0/tests/unit/actions/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2023-05-12 23:35:39.000000 borgmatic-1.8.0/tests/unit/actions/__init__.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:44.002133 borgmatic-1.8.0/tests/unit/actions/config/
+-rw-r--r--   0 witten    (1000) witten    (1000)     4024 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/actions/config/test_bootstrap.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1305 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/actions/config/test_generate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      599 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/actions/config/test_validate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      390 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/actions/test_arguments.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      821 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_borg.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      682 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_break_lock.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2847 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_check.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3049 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_compact.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     6076 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_create.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      967 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_export_tar.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1074 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_extract.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      993 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_info.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      984 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_list.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      824 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_mount.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2609 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_prune.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1748 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_rcreate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    19198 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_restore.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      743 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_rinfo.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      721 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_rlist.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      630 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/actions/test_transfer.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:44.005466 borgmatic-1.8.0/tests/unit/borg/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.8.0/tests/unit/borg/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    10406 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_borg.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3332 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_break_lock.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    39722 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_check.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     6675 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_compact.py
+-rw-r--r--   0 witten    (1000) witten    (1000)   126262 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_create.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1655 2023-07-12 05:16:01.000000 borgmatic-1.8.0/tests/unit/borg/test_environment.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    11144 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_export_tar.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    19818 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_extract.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     4866 2023-07-07 05:57:27.000000 borgmatic-1.8.0/tests/unit/borg/test_flags.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    24164 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_info.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    25878 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_list.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    10756 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_mount.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    15245 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_prune.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    12524 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_rcreate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    11325 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_rinfo.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    23462 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_rlist.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    20749 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_transfer.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      920 2023-07-07 06:06:19.000000 borgmatic-1.8.0/tests/unit/borg/test_umount.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2112 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/borg/test_version.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:44.005466 borgmatic-1.8.0/tests/unit/commands/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.8.0/tests/unit/commands/__init__.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:44.008800 borgmatic-1.8.0/tests/unit/commands/completion/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/commands/completion/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      226 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/commands/completion/test_actions.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      431 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/commands/completion/test_bash.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     4616 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/commands/completion/test_fish.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    17204 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/commands/test_arguments.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    49716 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/commands/test_borgmatic.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:44.008800 borgmatic-1.8.0/tests/unit/config/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.8.0/tests/unit/config/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      709 2023-04-15 02:32:17.000000 borgmatic-1.8.0/tests/unit/config/test_checks.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     8085 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/config/test_collect.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3090 2023-06-27 21:37:40.000000 borgmatic-1.8.0/tests/unit/config/test_environment.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     4980 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/config/test_generate.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     7006 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/config/test_normalize.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3804 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/config/test_override.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     7837 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/config/test_validate.py
+drwxr-xr-x   0 witten    (1000) witten    (1000)        0 2023-07-19 05:50:44.012133 borgmatic-1.8.0/tests/unit/hooks/
+-rw-r--r--   0 witten    (1000) witten    (1000)        0 2021-06-08 17:56:16.000000 borgmatic-1.8.0/tests/unit/hooks/__init__.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3920 2023-07-01 23:41:53.000000 borgmatic-1.8.0/tests/unit/hooks/test_command.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3726 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/hooks/test_cronhub.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     3162 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/hooks/test_cronitor.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     4490 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/hooks/test_dispatch.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2938 2023-05-12 23:35:39.000000 borgmatic-1.8.0/tests/unit/hooks/test_dump.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    11731 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/hooks/test_healthchecks.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    17940 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/hooks/test_mongodb.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    20116 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/hooks/test_mysql.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     7411 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/hooks/test_ntfy.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     2303 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/hooks/test_pagerduty.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    38402 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/hooks/test_postgresql.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     7431 2023-07-14 03:21:38.000000 borgmatic-1.8.0/tests/unit/hooks/test_sqlite.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    18294 2023-06-27 21:37:40.000000 borgmatic-1.8.0/tests/unit/test_execute.py
+-rw-r--r--   0 witten    (1000) witten    (1000)    16634 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/test_logger.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1405 2023-05-12 23:35:39.000000 borgmatic-1.8.0/tests/unit/test_signals.py
+-rw-r--r--   0 witten    (1000) witten    (1000)     1426 2023-07-10 16:39:03.000000 borgmatic-1.8.0/tests/unit/test_verbosity.py
+-rw-r--r--   0 witten    (1000) witten    (1000)      838 2023-06-27 21:37:40.000000 borgmatic-1.8.0/tox.ini
```

### Comparing `borgmatic-1.7.9/.eleventy.js` & `borgmatic-1.8.0/.eleventy.js`

 * *Files 10% similar despite different names*

#### js-beautify {}

```diff
@@ -1,15 +1,17 @@
 const pluginSyntaxHighlight = require("@11ty/eleventy-plugin-syntaxhighlight");
+const codeClipboard = require("eleventy-plugin-code-clipboard");
 const inclusiveLangPlugin = require("@11ty/eleventy-plugin-inclusive-language");
 const navigationPlugin = require("@11ty/eleventy-navigation");
 
 module.exports = function(eleventyConfig) {
     eleventyConfig.addPlugin(pluginSyntaxHighlight);
     eleventyConfig.addPlugin(inclusiveLangPlugin);
     eleventyConfig.addPlugin(navigationPlugin);
+    eleventyConfig.addPlugin(codeClipboard);
 
     let markdownIt = require("markdown-it");
     let markdownItAnchor = require("markdown-it-anchor");
     let markdownItReplaceLink = require("markdown-it-replace-link");
 
     let markdownItOptions = {
         html: true,
@@ -27,14 +29,15 @@
     };
 
     eleventyConfig.setLibrary(
         "md",
         markdownIt(markdownItOptions)
         .use(markdownItAnchor, markdownItAnchorOptions)
         .use(markdownItReplaceLink)
+        .use(codeClipboard.markdownItCopyButton)
     );
 
     eleventyConfig.addPassthroughCopy({
         "docs/static": "static"
     });
 
     eleventyConfig.setLiquidOptions({
```

### Comparing `borgmatic-1.7.9/AUTHORS` & `borgmatic-1.8.0/AUTHORS`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/LICENSE` & `borgmatic-1.8.0/LICENSE`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/NEWS` & `borgmatic-1.8.0/NEWS`

 * *Files 10% similar despite different names*

```diff
@@ -1,7 +1,148 @@
+1.8.0
+ * #575: BREAKING: For the "borgmatic borg" action, instead of implicitly injecting
+   repository/archive into the resulting Borg command-line, pass repository to Borg via an
+   environment variable and make archive available for explicit use in your commands. See the
+   documentation for more information:
+   https://torsion.org/borgmatic/docs/how-to/run-arbitrary-borg-commands/
+ * #719: Fix an error when running "borg key export" through borgmatic.
+ * #720: Fix an error when dumping a database and the "exclude_nodump" option is set.
+ * #724: Add "check_i_know_what_i_am_doing" option to bypass Borg confirmation prompt when running
+   "check --repair".
+ * When merging two configuration files, error gracefully if the two files do not adhere to the same
+   format.
+ * #721: Remove configuration sections ("location:", "storage:", "hooks:" etc.), while still keeping
+   deprecated support for them. Now, all options are at the same level, and you don't need to worry
+   about commenting/uncommenting section headers when you change an option (if you remove your
+   sections first).
+ * #721: BREAKING: The retention prefix and the consistency prefix can no longer have different
+   values (unless one is not set).
+ * #721: BREAKING: The storage umask and the hooks umask can no longer have different values (unless
+   one is not set).
+ * BREAKING: Flags like "--config" that previously took multiple values now need to be given once
+   per value, e.g. "--config first.yaml --config second.yaml" instead of "--config first.yaml
+   second.yaml". This prevents argument parsing errors on ambiguous commands.
+ * BREAKING: Remove the deprecated (and silently ignored) "--successful" flag on the "list" action,
+   as newer versions of Borg list successful (non-checkpoint) archives by default.
+ * All deprecated configuration option values now generate warning logs.
+ * Remove the deprecated (and non-functional) "--excludes" flag in favor of excludes within
+   configuration.
+ * Fix an error when logging too-long command output during error handling. Now, long command output
+   is truncated before logging.
+
+1.7.15
+ * #326: Add configuration options and command-line flags for backing up a database from one
+   location while restoring it somewhere else.
+ * #399: Add a documentation troubleshooting note for MySQL/MariaDB authentication errors.
+ * #529: Remove upgrade-borgmatic-config command for upgrading borgmatic 1.1.0 INI-style
+   configuration.
+ * #529: Deprecate generate-borgmatic-config in favor of new "config generate" action.
+ * #529: Deprecate validate-borgmatic-config in favor of new "config validate" action.
+ * #697, #712, #716: Extract borgmatic configuration from backup via new "config bootstrap"
+   actioneven when borgmatic has no configuration yet!
+ * #669: Add sample systemd user service for running borgmatic as a non-root user.
+ * #711, #713: Fix an error when "data" check time files are accessed without getting upgraded
+   first.
+
+1.7.14
+ * #484: Add a new verbosity level (-2) to disable output entirely (for console, syslog, log file,
+   or monitoring), so not even errors are shown.
+ * #688: Tweak archive check probing logic to use the newest timestamp found when multiple exist.
+ * #659: Add Borg 2 date-based matching flags to various actions for archive selection.
+ * #703: Fix an error when loading the configuration schema on Fedora Linux.
+ * #704: Fix "check" action error when repository and archive checks are configured but the archive
+   check gets skipped due to the configured frequency.
+ * #706: Fix "--archive latest" on "list" and "info" actions that only worked on the first of
+   multiple configured repositories.
+
+1.7.13
+ * #375: Restore particular PostgreSQL schemas from a database dump via "borgmatic restore --schema"
+   flag. See the documentation for more information:
+   https://torsion.org/borgmatic/docs/how-to/backup-your-databases/#restore-particular-schemas
+ * #678: Fix error from PostgreSQL when dumping a database with a "format" of "plain".
+ * #678: Fix PostgreSQL hook to support "psql_command" and "pg_restore_command" options containing
+   commands with arguments.
+ * #678: Fix calls to psql in PostgreSQL hook to ignore "~/.psqlrc", whose settings can break
+   database dumping.
+ * #680: Add support for logging each log line as a JSON object via global "--log-json" flag.
+ * #682: Fix "source_directories_must_exist" option to expand globs and tildes in source directories.
+ * #684: Rename "master" development branch to "main" to use more inclusive language. You'll need to
+   update your development checkouts accordingly.
+ * #686: Add fish shell completion script so you can tab-complete on the borgmatic command-line. See
+   the documentation for more information:
+   https://torsion.org/borgmatic/docs/how-to/set-up-backups/#shell-completion
+ * #687: Fix borgmatic error when not finding the configuration schema for certain "pip install
+   --editable" development installs.
+ * #688: Fix archive checks being skipped even when particular archives haven't been checked
+   recently. This occurred when using multiple borgmatic configuration files with different
+   "archive_name_format"s, for instance.
+ * #691: Fix error in "borgmatic restore" action when the configured repository path is relative
+   instead of absolute.
+ * #694: Run "borgmatic borg" action without capturing output so interactive prompts and flags like
+   "--progress" still work.
+
+1.7.12
+ * #413: Add "log_file" context to command hooks so your scripts can consume the borgmatic log file.
+   See the documentation for more information:
+   https://torsion.org/borgmatic/docs/how-to/add-preparation-and-cleanup-steps-to-backups/
+ * #666, #670: Fix error when running the "info" action with the "--match-archives" or "--archive"
+   flags. Also fix the "--match-archives"/"--archive" flags to correctly override the
+   "match_archives" configuration option for the "transfer", "list", "rlist", and "info" actions.
+ * #668: Fix error when running the "prune" action with both "archive_name_format" and "prefix"
+   options set.
+ * #672: Selectively shallow merge certain mappings or sequences when including configuration files.
+   See the documentation for more information:
+   https://torsion.org/borgmatic/docs/how-to/make-per-application-backups/#shallow-merge
+ * #672: Selectively omit list values when including configuration files. See the documentation for
+   more information:
+   https://torsion.org/borgmatic/docs/how-to/make-per-application-backups/#list-merge
+ * #673: View the results of configuration file merging via "validate-borgmatic-config --show" flag.
+   See the documentation for more information:
+   https://torsion.org/borgmatic/docs/how-to/make-per-application-backups/#debugging-includes
+ * Add optional support for running end-to-end tests and building documentation with rootless Podman
+   instead of Docker.
+
+1.7.11
+ * #479, #588: BREAKING: Automatically use the "archive_name_format" option to filter which archives
+   get used for borgmatic actions that operate on multiple archives. Override this behavior with the
+   new "match_archives" option in the storage section. This change is "breaking" in that it silently
+   changes which archives get considered for "rlist", "prune", "check", etc. See the documentation
+   for more information:
+   https://torsion.org/borgmatic/docs/how-to/make-per-application-backups/#archive-naming
+ * #479, #588: The "prefix" options have been deprecated in favor of the new "archive_name_format"
+   auto-matching behavior and the "match_archives" option.
+ * #658: Add "--log-file-format" flag for customizing the log message format. See the documentation
+   for more information:
+   https://torsion.org/borgmatic/docs/how-to/inspect-your-backups/#logging-to-file
+ * #662: Fix regression in which the "check_repositories" option failed to match repositories.
+ * #663: Fix regression in which the "transfer" action produced a traceback.
+ * Add spellchecking of source code during test runs.
+
+1.7.10
+ * #396: When a database command errors, display and log the error message instead of swallowing it.
+ * #501: Optionally error if a source directory does not exist via "source_directories_must_exist"
+   option in borgmatic's location configuration.
+ * #576: Add support for "file://" paths within "repositories" option.
+ * #612: Define and use custom constants in borgmatic configuration files. See the documentation for
+   more information:
+   https://torsion.org/borgmatic/docs/how-to/make-per-application-backups/#constant-interpolation
+ * #618: Add support for BORG_FILES_CACHE_TTL environment variable via "borg_files_cache_ttl" option
+   in borgmatic's storage configuration.
+ * #623: Fix confusing message when an error occurs running actions for a configuration file.
+ * #635: Add optional repository labels so you can select a repository via "--repository yourlabel"
+   at the command-line. See the configuration reference for more information:
+   https://torsion.org/borgmatic/docs/reference/configuration/
+ * #649: Add documentation on backing up a database running in a container:
+   https://torsion.org/borgmatic/docs/how-to/backup-your-databases/#containers
+ * #655: Fix error when databases are configured and a source directory doesn't exist.
+ * Add code style plugins to enforce use of Python f-strings and prevent single-letter variables.
+   To join in the pedantry, refresh your test environment with "tox --recreate".
+ * Rename scripts/run-full-dev-tests to scripts/run-end-to-end-dev-tests and make it run end-to-end
+   tests only. Continue using tox to run unit and integration tests.
+
 1.7.9
  * #295: Add a SQLite database dump/restore hook.
  * #304: Change the default action order when no actions are specified on the command-line to:
    "create", "prune", "compact", "check". If you'd like to retain the old ordering ("prune" and
    "compact" first), then specify actions explicitly on the command-line.
  * #304: Run any command-line actions in the order specified instead of using a fixed ordering.
  * #564: Add "--repository" flag to all actions where it makes sense, so you can run borgmatic on
@@ -299,15 +440,15 @@
    more information: https://torsion.org/borgmatic/docs/how-to/run-arbitrary-borg-commands/
 
 1.5.14
  * #390: Add link to Hetzner storage offering from the documentation.
  * #398: Clarify canonical home of borgmatic in documentation.
  * #406: Clarify that spaces in path names should not be backslashed in path names.
  * #423: Fix error handling to error loudly when Borg gets killed due to running out of memory!
- * Fix build so as not to attempt to build and push documentation for a non-master branch.
+ * Fix build so as not to attempt to build and push documentation for a non-main branch.
  * "Fix" build failure with Alpine Edge by switching from Edge to Alpine 3.13.
  * Move #borgmatic IRC channel from Freenode to Libera Chat due to Freenode takeover drama.
    IRC connection info: https://torsion.org/borgmatic/#issues
 
 1.5.13
  * #373: Document that passphrase is used for Borg keyfile encryption, not just repokey encryption.
  * #404: Add support for ruamel.yaml 0.17.x YAML parsing library.
@@ -362,15 +503,15 @@
    on different filesystems were related by parentage (e.g. "/foo" and "/foo/bar/baz") and the
    one_file_system option was enabled.
  * Update documentation code fragments theme to better match the rest of the page.
  * Improve configuration reference documentation readability via more aggressive word-wrapping in
    configuration schema descriptions.
 
 1.5.6
- * #292: Allow before_backup and similiar hooks to exit with a soft failure without altering the
+ * #292: Allow before_backup and similar hooks to exit with a soft failure without altering the
    monitoring status on Healthchecks or other providers. Support this by waiting to ping monitoring
    services with a "start" status until after before_* hooks finish. Failures in before_* hooks
    still trigger a monitoring "fail" status.
  * #316: Fix hang when a stale database dump named pipe from an aborted borgmatic run remains on
    disk.
  * #323: Fix for certain configuration options like ssh_command impacting Borg invocations for
    separate configuration files.
@@ -431,15 +572,15 @@
    https://torsion.org/borgmatic/docs/how-to/backup-to-a-removable-drive-or-an-intermittent-server/
  * #287: View consistency check progress via "--progress" flag for "check" action.
  * For "create" and "prune" actions, no longer list files or show detailed stats at any verbosities
    by default. You can opt back in with "--files" or "--stats" flags.
  * For "list" and "info" actions, show repository names even at verbosity 0.
 
 1.4.22
- * #276, #285: Disable colored output when "--json" flag is used, so as to produce valid JSON ouput.
+ * #276, #285: Disable colored output when "--json" flag is used, so as to produce valid JSON output.
  * After a backup of a database dump in directory format, properly remove the dump directory.
  * In "borgmatic --help", don't expand $HOME in listing of default "--config" paths.
 
 1.4.21
  * #268: Override particular configuration options from the command-line via "--override" flag. See
    the documentation for more information:
    https://torsion.org/borgmatic/docs/how-to/make-per-application-backups/#configuration-overrides
@@ -803,15 +944,15 @@
    path.
  * #74, #83: Support for Borg --json option via borgmatic command-line to --list archives or show
    archive --info in JSON format, ideal for programmatic consumption.
  * #38, #76: Upgrade ruamel.yaml compatibility version range and fix support for Python 3.7.
  * #77: Skip non-"*.yaml" config filenames in /etc/borgmatic.d/ so as not to parse backup files,
    editor swap files, etc.
  * #81: Document user-defined hooks run before/after backup, or on error.
- * Add code style guidelines to the documention.
+ * Add code style guidelines to the documentation.
 
 1.2.0
  * #61: Support for Borg --list option via borgmatic command-line to list all archives.
  * #61: Support for Borg --info option via borgmatic command-line to display summary information.
  * #62: Update README to mention other ways of installing borgmatic.
  * Support for Borg --prefix option for consistency checks via "prefix" option in borgmatic's
    consistency configuration.
```

### Comparing `borgmatic-1.7.9/PKG-INFO` & `borgmatic-1.8.0/PKG-INFO`

 * *Files 24% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: borgmatic
-Version: 1.7.9
+Version: 1.8.0
 Summary: Simple, configuration-driven backup software for servers and workstations
 Home-page: https://torsion.org/borgmatic
 Author: Dan Helfman
 Author-email: witten@torsion.org
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Environment :: Console
 Classifier: Intended Audience :: System Administrators
```

### Comparing `borgmatic-1.7.9/README.md` & `borgmatic-1.8.0/README.md`

 * *Files 5% similar despite different names*

```diff
@@ -7,62 +7,54 @@
 
 <img src="docs/static/borgmatic.png" alt="borgmatic logo" width="150px" style="float: right; padding-left: 1em;">
 
 borgmatic is simple, configuration-driven backup software for servers and
 workstations. Protect your files with client-side encryption. Backup your
 databases too. Monitor it all with integrated third-party services.
 
-The canonical home of borgmatic is at <a href="https://torsion.org/borgmatic">https://torsion.org/borgmatic</a>.
+The canonical home of borgmatic is at <a href="https://torsion.org/borgmatic">https://torsion.org/borgmatic/</a>
 
 Here's an example configuration file:
 
 ```yaml
-location:
-    # List of source directories to backup.
-    source_directories:
-        - /home
-        - /etc
-
-    # Paths of local or remote repositories to backup to.
-    repositories:
-        - ssh://1234@usw-s001.rsync.net/./backups.borg
-        - ssh://k8pDxu32@k8pDxu32.repo.borgbase.com/./repo
-        - /var/lib/backups/local.borg
-
-retention:
-    # Retention policy for how many backups to keep.
-    keep_daily: 7
-    keep_weekly: 4
-    keep_monthly: 6
-
-consistency:
-    # List of checks to run to validate your backups.
-    checks:
-        - name: repository
-        - name: archives
-          frequency: 2 weeks
-
-hooks:
-    # Custom preparation scripts to run.
-    before_backup:
-        - prepare-for-backup.sh
-
-    # Databases to dump and include in backups.
-    postgresql_databases:
-        - name: users
+# List of source directories to backup.
+source_directories:
+    - /home
+    - /etc
+
+# Paths of local or remote repositories to backup to.
+repositories:
+    - path: ssh://k8pDxu32@k8pDxu32.repo.borgbase.com/./repo
+      label: borgbase
+    - path: /var/lib/backups/local.borg
+      label: local
+
+# Retention policy for how many backups to keep.
+keep_daily: 7
+keep_weekly: 4
+keep_monthly: 6
+
+# List of checks to run to validate your backups.
+checks:
+    - name: repository
+    - name: archives
+      frequency: 2 weeks
+
+# Custom preparation scripts to run.
+before_backup:
+    - prepare-for-backup.sh
+
+# Databases to dump and include in backups.
+postgresql_databases:
+    - name: users
 
-    # Third-party services to notify you if backups aren't happening.
-    healthchecks: https://hc-ping.com/be067061-cf96-4412-8eae-62b0c50d6a8c
+# Third-party services to notify you if backups aren't happening.
+healthchecks: https://hc-ping.com/be067061-cf96-4412-8eae-62b0c50d6a8c
 ```
 
-Want to see borgmatic in action? Check out the <a
-href="https://asciinema.org/a/203761?autoplay=1" target="_blank">screencast</a>.
-
-<a href="https://asciinema.org/a/203761?autoplay=1" target="_blank"><img src="https://asciinema.org/a/203761.png" width="480"></a>
-
 borgmatic is powered by [Borg Backup](https://www.borgbackup.org/).
 
 ## Integrations
 
 <a href="https://www.postgresql.org/"><img src="docs/static/postgresql.png" alt="PostgreSQL" height="60px" style="margin-bottom:20px;"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <a href="https://www.mysql.com/"><img src="docs/static/mysql.png" alt="MySQL" height="60px" style="margin-bottom:20px;"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <a href="https://mariadb.com/"><img src="docs/static/mariadb.png" alt="MariaDB" height="60px" style="margin-bottom:20px;"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
@@ -86,24 +78,23 @@
 reference guides</a>.
 
 
 ## Hosting providers
 
 Need somewhere to store your encrypted off-site backups? The following hosting
 providers include specific support for Borg/borgmaticand fund borgmatic
-development and hosting when you use these links to sign up. (These are
-referral links, but without any tracking scripts or cookies.)
+development and hosting when you use these referral links to sign up:
 
 <ul>
  <li class="referral"><a href="https://www.borgbase.com/?utm_source=borgmatic">BorgBase</a>: Borg hosting service with support for monitoring, 2FA, and append-only repos</li>
+ <li class="referral"><a href="https://hetzner.cloud/?ref=v9dOJ98Ic9I8">Hetzner</a>: A "storage box" that includes support for Borg</li>
 </ul>
 
-Additionally, [rsync.net](https://www.rsync.net/products/borg.html) and
-[Hetzner](https://www.hetzner.com/storage/storage-box) have compatible storage
-offerings, but do not currently fund borgmatic development or hosting.
+Additionally, rsync.net has a compatible storage offering, but does not fund
+borgmatic development or hosting.
 
 ## Support and contributing
 
 ### Issues
 
 Are you experiencing an issue with borgmatic? Or do you have an idea for a
 feature enhancement? Head on over to our [issue
@@ -116,18 +107,15 @@
 Also see the [security
 policy](https://torsion.org/borgmatic/docs/security-policy/) for any security
 issues.
 
 
 ### Social
 
-Check out the [Borg subreddit](https://www.reddit.com/r/BorgBackup/) for
-general Borg and borgmatic discussion and support.
-
-Also follow [borgmatic on Mastodon](https://fosstodon.org/@borgmatic).
+Follow [borgmatic on Mastodon](https://fosstodon.org/@borgmatic).
 
 
 ### Chat
 
 To chat with borgmatic developers or users, check out the `#borgmatic`
 IRC channel on Libera Chat, either via <a
 href="https://web.libera.chat/#borgmatic">web chat</a> or a native <a
@@ -160,9 +148,9 @@
 first. We also accept Pull Requests on GitHub, if that's more your thing. In
 general, contributions are very welcome. We don't bite!
 
 Also, please check out the [borgmatic development
 how-to](https://torsion.org/borgmatic/docs/how-to/develop-on-borgmatic/) for
 info on cloning source code, running tests, etc.
 
-<a href="https://build.torsion.org/borgmatic-collective/borgmatic" alt="build status">![Build Status](https://build.torsion.org/api/badges/borgmatic-collective/borgmatic/status.svg?ref=refs/heads/master)</a>
+<a href="https://build.torsion.org/borgmatic-collective/borgmatic" alt="build status">![Build Status](https://build.torsion.org/api/badges/borgmatic-collective/borgmatic/status.svg?ref=refs/heads/main)</a>
```

#### html2text {}

```diff
@@ -1,54 +1,49 @@
 --- title: borgmatic permalink: index.html --- ## It's your data. Keep it that
 way. [borgmatic logo] borgmatic is simple, configuration-driven backup software
 for servers and workstations. Protect your files with client-side encryption.
 Backup your databases too. Monitor it all with integrated third-party services.
-The canonical home of borgmatic is at https://torsion.org/borgmatic. Here's an
-example configuration file: ```yaml location: # List of source directories to
-backup. source_directories: - /home - /etc # Paths of local or remote
-repositories to backup to. repositories: - ssh://1234@usw-s001.rsync.net/./
-backups.borg - ssh://k8pDxu32@k8pDxu32.repo.borgbase.com/./repo - /var/lib/
-backups/local.borg retention: # Retention policy for how many backups to keep.
-keep_daily: 7 keep_weekly: 4 keep_monthly: 6 consistency: # List of checks to
-run to validate your backups. checks: - name: repository - name: archives
-frequency: 2 weeks hooks: # Custom preparation scripts to run. before_backup: -
-prepare-for-backup.sh # Databases to dump and include in backups.
-postgresql_databases: - name: users # Third-party services to notify you if
-backups aren't happening. healthchecks: https://hc-ping.com/be067061-cf96-4412-
-8eae-62b0c50d6a8c ``` Want to see borgmatic in action? Check out the
-screencast. [https://asciinema.org/a/203761.png] borgmatic is powered by [Borg
-Backup](https://www.borgbackup.org/). ## Integrations [PostgreSQL]
-[MySQL] [MariaDB] [MongoDB] [SQLite] [Healthchecks]
-[Cronitor] [Cronhub] [PagerDuty] [ntfy] [BorgBase] ##
-Getting started Your first step is to [install and configure borgmatic](https:/
-/torsion.org/borgmatic/docs/how-to/set-up-backups/). For additional
-documentation, check out the links above (left panel on wide screens) for
-borgmatic_how-to_and_reference_guides. ## Hosting providers Need somewhere to
-store your encrypted off-site backups? The following hosting providers include
-specific support for Borg/borgmaticand fund borgmatic development and
-hosting when you use these links to sign up. (These are referral links, but
-without any tracking scripts or cookies.)
+The canonical home of borgmatic is at https://torsion.org/borgmatic/ Here's an
+example configuration file: ```yaml # List of source directories to backup.
+source_directories: - /home - /etc # Paths of local or remote repositories to
+backup to. repositories: - path: ssh://k8pDxu32@k8pDxu32.repo.borgbase.com/./
+repo label: borgbase - path: /var/lib/backups/local.borg label: local #
+Retention policy for how many backups to keep. keep_daily: 7 keep_weekly: 4
+keep_monthly: 6 # List of checks to run to validate your backups. checks: -
+name: repository - name: archives frequency: 2 weeks # Custom preparation
+scripts to run. before_backup: - prepare-for-backup.sh # Databases to dump and
+include in backups. postgresql_databases: - name: users # Third-party services
+to notify you if backups aren't happening. healthchecks: https://hc-ping.com/
+be067061-cf96-4412-8eae-62b0c50d6a8c ``` borgmatic is powered by [Borg Backup]
+(https://www.borgbackup.org/). ## Integrations [PostgreSQL] [MySQL]
+[MariaDB] [MongoDB] [SQLite] [Healthchecks] [Cronitor]
+[Cronhub] [PagerDuty] [ntfy] [BorgBase] ## Getting started
+Your first step is to [install and configure borgmatic](https://torsion.org/
+borgmatic/docs/how-to/set-up-backups/). For additional documentation, check out
+the links above (left panel on wide screens) for borgmatic_how-to_and_reference
+guides. ## Hosting providers Need somewhere to store your encrypted off-site
+backups? The following hosting providers include specific support for Borg/
+borgmaticand fund borgmatic development and hosting when you use these
+referral links to sign up:
     * BorgBase: Borg hosting service with support for monitoring, 2FA, and
       append-only repos
-Additionally, [rsync.net](https://www.rsync.net/products/borg.html) and
-[Hetzner](https://www.hetzner.com/storage/storage-box) have compatible storage
-offerings, but do not currently fund borgmatic development or hosting. ##
-Support and contributing ### Issues Are you experiencing an issue with
-borgmatic? Or do you have an idea for a feature enhancement? Head on over to
-our [issue tracker](https://projects.torsion.org/borgmatic-collective/
-borgmatic/issues). In order to create a new issue or add a comment, you'll need
-to [register](https://projects.torsion.org/user/sign_up?invite_code=borgmatic)
-first. If you prefer to use an existing GitHub account, you can skip account
-creation and [login directly](https://projects.torsion.org/user/login). Also
-see the [security policy](https://torsion.org/borgmatic/docs/security-policy/
-) for any security issues. ### Social Check out the [Borg subreddit](https://
-www.reddit.com/r/BorgBackup/) for general Borg and borgmatic discussion and
-support. Also follow [borgmatic on Mastodon](https://fosstodon.org/@borgmatic).
-### Chat To chat with borgmatic developers or users, check out the `#borgmatic`
-IRC channel on Libera Chat, either via web_chat or a native IRC_client. If you
+    * Hetzner: A "storage box" that includes support for Borg
+Additionally, rsync.net has a compatible storage offering, but does not fund
+borgmatic development or hosting. ## Support and contributing ### Issues Are
+you experiencing an issue with borgmatic? Or do you have an idea for a feature
+enhancement? Head on over to our [issue tracker](https://projects.torsion.org/
+borgmatic-collective/borgmatic/issues). In order to create a new issue or add a
+comment, you'll need to [register](https://projects.torsion.org/user/
+sign_up?invite_code=borgmatic) first. If you prefer to use an existing GitHub
+account, you can skip account creation and [login directly](https://
+projects.torsion.org/user/login). Also see the [security policy](https://
+torsion.org/borgmatic/docs/security-policy/) for any security issues. ###
+Social Follow [borgmatic on Mastodon](https://fosstodon.org/@borgmatic). ###
+Chat To chat with borgmatic developers or users, check out the `#borgmatic` IRC
+channel on Libera Chat, either via web_chat or a native IRC_client. If you
 don't get a response right away, please hang around a whileor file a ticket
 instead. ### Other Other questions or comments? Contact [witten@torsion.org]
 (mailto:witten@torsion.org). ### Contributing borgmatic [source code is
 available](https://projects.torsion.org/borgmatic-collective/borgmatic) and is
 also mirrored on [GitHub](https://github.com/borgmatic-collective/borgmatic)
 for convenience. borgmatic is licensed under the GNU General Public License
 version 3 or any later version. If you'd like to contribute to borgmatic
@@ -57,8 +52,8 @@
 (https://projects.torsion.org/borgmatic-collective/borgmatic/issues) to discuss
 your idea. Note that you'll need to [register](https://projects.torsion.org/
 user/sign_up?invite_code=borgmatic) first. We also accept Pull Requests on
 GitHub, if that's more your thing. In general, contributions are very welcome.
 We don't bite! Also, please check out the [borgmatic development how-to](https:
 //torsion.org/borgmatic/docs/how-to/develop-on-borgmatic/) for info on cloning
 source code, running tests, etc. ![Build_Status](https://build.torsion.org/api/
-badges/borgmatic-collective/borgmatic/status.svg?ref=refs/heads/master)
+badges/borgmatic-collective/borgmatic/status.svg?ref=refs/heads/main)
```

### Comparing `borgmatic-1.7.9/SECURITY.md` & `borgmatic-1.8.0/docs/SECURITY.md`

 * *Files 8% similar despite different names*

```diff
@@ -2,17 +2,18 @@
 title: Security policy
 permalink: security-policy/index.html
 ---
 
 ## Supported versions
 
 While we want to hear about security vulnerabilities in all versions of
-borgmatic, security fixes are only made to the most recently released version.
-It's simply not practical for our small volunteer effort to maintain multiple
-release branches and put out separate security patches for each.
+borgmatic, security fixes will only be made to the most recently released
+version. It's not practical for our small volunteer effort to maintain
+multiple different release branches and put out separate security patches for
+each.
 
 ## Reporting a vulnerability
 
 If you find a security vulnerability, please [file a
 ticket](https://torsion.org/borgmatic/#issues) or [send email
 directly](mailto:witten@torsion.org) as appropriate. You should expect to hear
-back within a few days at most and generally sooner.
+back within a few days at most, and generally sooner.
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/borg.py` & `borgmatic-1.8.0/borgmatic/actions/borg.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,33 +4,42 @@
 import borgmatic.borg.rlist
 import borgmatic.config.validate
 
 logger = logging.getLogger(__name__)
 
 
 def run_borg(
-    repository, storage, local_borg_version, borg_arguments, local_path, remote_path,
+    repository,
+    config,
+    local_borg_version,
+    borg_arguments,
+    global_arguments,
+    local_path,
+    remote_path,
 ):
     '''
     Run the "borg" action for the given repository.
     '''
     if borg_arguments.repository is None or borgmatic.config.validate.repositories_match(
         repository, borg_arguments.repository
     ):
-        logger.info('{}: Running arbitrary Borg command'.format(repository))
+        logger.info(
+            f'{repository.get("label", repository["path"])}: Running arbitrary Borg command'
+        )
         archive_name = borgmatic.borg.rlist.resolve_archive_name(
-            repository,
+            repository['path'],
             borg_arguments.archive,
-            storage,
+            config,
             local_borg_version,
+            global_arguments,
             local_path,
             remote_path,
         )
         borgmatic.borg.borg.run_arbitrary_borg(
-            repository,
-            storage,
+            repository['path'],
+            config,
             local_borg_version,
             options=borg_arguments.options,
             archive=archive_name,
             local_path=local_path,
             remote_path=remote_path,
         )
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/check.py` & `borgmatic-1.8.0/borgmatic/actions/check.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,18 +6,15 @@
 
 logger = logging.getLogger(__name__)
 
 
 def run_check(
     config_filename,
     repository,
-    location,
-    storage,
-    consistency,
-    hooks,
+    config,
     hook_context,
     local_borg_version,
     check_arguments,
     global_arguments,
     local_path,
     remote_path,
 ):
@@ -26,36 +23,35 @@
     '''
     if check_arguments.repository and not borgmatic.config.validate.repositories_match(
         repository, check_arguments.repository
     ):
         return
 
     borgmatic.hooks.command.execute_hook(
-        hooks.get('before_check'),
-        hooks.get('umask'),
+        config.get('before_check'),
+        config.get('umask'),
         config_filename,
         'pre-check',
         global_arguments.dry_run,
         **hook_context,
     )
-    logger.info('{}: Running consistency checks'.format(repository))
+    logger.info(f'{repository.get("label", repository["path"])}: Running consistency checks')
     borgmatic.borg.check.check_archives(
-        repository,
-        location,
-        storage,
-        consistency,
+        repository['path'],
+        config,
         local_borg_version,
+        global_arguments,
         local_path=local_path,
         remote_path=remote_path,
         progress=check_arguments.progress,
         repair=check_arguments.repair,
         only_checks=check_arguments.only,
         force=check_arguments.force,
     )
     borgmatic.hooks.command.execute_hook(
-        hooks.get('after_check'),
-        hooks.get('umask'),
+        config.get('after_check'),
+        config.get('umask'),
         config_filename,
         'post-check',
         global_arguments.dry_run,
         **hook_context,
     )
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/compact.py` & `borgmatic-1.8.0/borgmatic/actions/compact.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,17 +7,15 @@
 
 logger = logging.getLogger(__name__)
 
 
 def run_compact(
     config_filename,
     repository,
-    storage,
-    retention,
-    hooks,
+    config,
     hook_context,
     local_borg_version,
     compact_arguments,
     global_arguments,
     dry_run_label,
     local_path,
     remote_path,
@@ -27,37 +25,42 @@
     '''
     if compact_arguments.repository and not borgmatic.config.validate.repositories_match(
         repository, compact_arguments.repository
     ):
         return
 
     borgmatic.hooks.command.execute_hook(
-        hooks.get('before_compact'),
-        hooks.get('umask'),
+        config.get('before_compact'),
+        config.get('umask'),
         config_filename,
         'pre-compact',
         global_arguments.dry_run,
         **hook_context,
     )
     if borgmatic.borg.feature.available(borgmatic.borg.feature.Feature.COMPACT, local_borg_version):
-        logger.info('{}: Compacting segments{}'.format(repository, dry_run_label))
+        logger.info(
+            f'{repository.get("label", repository["path"])}: Compacting segments{dry_run_label}'
+        )
         borgmatic.borg.compact.compact_segments(
             global_arguments.dry_run,
-            repository,
-            storage,
+            repository['path'],
+            config,
             local_borg_version,
+            global_arguments,
             local_path=local_path,
             remote_path=remote_path,
             progress=compact_arguments.progress,
             cleanup_commits=compact_arguments.cleanup_commits,
             threshold=compact_arguments.threshold,
         )
     else:  # pragma: nocover
-        logger.info('{}: Skipping compact (only available/needed in Borg 1.2+)'.format(repository))
+        logger.info(
+            f'{repository.get("label", repository["path"])}: Skipping compact (only available/needed in Borg 1.2+)'
+        )
     borgmatic.hooks.command.execute_hook(
-        hooks.get('after_compact'),
-        hooks.get('umask'),
+        config.get('after_compact'),
+        config.get('umask'),
         config_filename,
         'post-compact',
         global_arguments.dry_run,
         **hook_context,
     )
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/export_tar.py` & `borgmatic-1.8.0/borgmatic/actions/export_tar.py`

 * *Files 24% similar despite different names*

```diff
@@ -5,44 +5,46 @@
 import borgmatic.config.validate
 
 logger = logging.getLogger(__name__)
 
 
 def run_export_tar(
     repository,
-    storage,
+    config,
     local_borg_version,
     export_tar_arguments,
     global_arguments,
     local_path,
     remote_path,
 ):
     '''
     Run the "export-tar" action for the given repository.
     '''
     if export_tar_arguments.repository is None or borgmatic.config.validate.repositories_match(
         repository, export_tar_arguments.repository
     ):
         logger.info(
-            '{}: Exporting archive {} as tar file'.format(repository, export_tar_arguments.archive)
+            f'{repository["path"]}: Exporting archive {export_tar_arguments.archive} as tar file'
         )
         borgmatic.borg.export_tar.export_tar_archive(
             global_arguments.dry_run,
-            repository,
+            repository['path'],
             borgmatic.borg.rlist.resolve_archive_name(
-                repository,
+                repository['path'],
                 export_tar_arguments.archive,
-                storage,
+                config,
                 local_borg_version,
+                global_arguments,
                 local_path,
                 remote_path,
             ),
             export_tar_arguments.paths,
             export_tar_arguments.destination,
-            storage,
+            config,
             local_borg_version,
+            global_arguments,
             local_path=local_path,
             remote_path=remote_path,
             tar_filter=export_tar_arguments.tar_filter,
             list_files=export_tar_arguments.list_files,
             strip_components=export_tar_arguments.strip_components,
         )
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/extract.py` & `borgmatic-1.8.0/borgmatic/actions/extract.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,61 +7,62 @@
 
 logger = logging.getLogger(__name__)
 
 
 def run_extract(
     config_filename,
     repository,
-    location,
-    storage,
-    hooks,
+    config,
     hook_context,
     local_borg_version,
     extract_arguments,
     global_arguments,
     local_path,
     remote_path,
 ):
     '''
     Run the "extract" action for the given repository.
     '''
     borgmatic.hooks.command.execute_hook(
-        hooks.get('before_extract'),
-        hooks.get('umask'),
+        config.get('before_extract'),
+        config.get('umask'),
         config_filename,
         'pre-extract',
         global_arguments.dry_run,
         **hook_context,
     )
     if extract_arguments.repository is None or borgmatic.config.validate.repositories_match(
         repository, extract_arguments.repository
     ):
-        logger.info('{}: Extracting archive {}'.format(repository, extract_arguments.archive))
+        logger.info(
+            f'{repository.get("label", repository["path"])}: Extracting archive {extract_arguments.archive}'
+        )
         borgmatic.borg.extract.extract_archive(
             global_arguments.dry_run,
-            repository,
+            repository['path'],
             borgmatic.borg.rlist.resolve_archive_name(
-                repository,
+                repository['path'],
                 extract_arguments.archive,
-                storage,
+                config,
                 local_borg_version,
+                global_arguments,
                 local_path,
                 remote_path,
             ),
             extract_arguments.paths,
-            location,
-            storage,
+            config,
             local_borg_version,
+            global_arguments,
             local_path=local_path,
             remote_path=remote_path,
             destination_path=extract_arguments.destination,
             strip_components=extract_arguments.strip_components,
             progress=extract_arguments.progress,
         )
     borgmatic.hooks.command.execute_hook(
-        hooks.get('after_extract'),
-        hooks.get('umask'),
+        config.get('after_extract'),
+        config.get('umask'),
         config_filename,
         'post-extract',
         global_arguments.dry_run,
         **hook_context,
     )
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/info.py` & `borgmatic-1.8.0/borgmatic/actions/rlist.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,41 +1,40 @@
 import json
 import logging
 
-import borgmatic.borg.info
 import borgmatic.borg.rlist
 import borgmatic.config.validate
 
 logger = logging.getLogger(__name__)
 
 
-def run_info(
-    repository, storage, local_borg_version, info_arguments, local_path, remote_path,
+def run_rlist(
+    repository,
+    config,
+    local_borg_version,
+    rlist_arguments,
+    global_arguments,
+    local_path,
+    remote_path,
 ):
     '''
-    Run the "info" action for the given repository and archive.
+    Run the "rlist" action for the given repository.
 
-    If info_arguments.json is True, yield the JSON output from the info for the archive.
+    If rlist_arguments.json is True, yield the JSON output from listing the repository.
     '''
-    if info_arguments.repository is None or borgmatic.config.validate.repositories_match(
-        repository, info_arguments.repository
+    if rlist_arguments.repository is None or borgmatic.config.validate.repositories_match(
+        repository, rlist_arguments.repository
     ):
-        if not info_arguments.json:  # pragma: nocover
-            logger.answer(f'{repository}: Displaying archive summary information')
-        info_arguments.archive = borgmatic.borg.rlist.resolve_archive_name(
-            repository,
-            info_arguments.archive,
-            storage,
-            local_borg_version,
-            local_path,
-            remote_path,
-        )
-        json_output = borgmatic.borg.info.display_archives_info(
-            repository,
-            storage,
+        if not rlist_arguments.json:  # pragma: nocover
+            logger.answer(f'{repository.get("label", repository["path"])}: Listing repository')
+
+        json_output = borgmatic.borg.rlist.list_repository(
+            repository['path'],
+            config,
             local_borg_version,
-            info_arguments=info_arguments,
+            rlist_arguments=rlist_arguments,
+            global_arguments=global_arguments,
             local_path=local_path,
             remote_path=remote_path,
         )
         if json_output:  # pragma: nocover
             yield json.loads(json_output)
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/list.py` & `borgmatic-1.8.0/borgmatic/actions/list.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,43 +1,53 @@
 import json
 import logging
 
+import borgmatic.actions.arguments
 import borgmatic.borg.list
 import borgmatic.config.validate
 
 logger = logging.getLogger(__name__)
 
 
 def run_list(
-    repository, storage, local_borg_version, list_arguments, local_path, remote_path,
+    repository,
+    config,
+    local_borg_version,
+    list_arguments,
+    global_arguments,
+    local_path,
+    remote_path,
 ):
     '''
     Run the "list" action for the given repository and archive.
 
     If list_arguments.json is True, yield the JSON output from listing the archive.
     '''
     if list_arguments.repository is None or borgmatic.config.validate.repositories_match(
         repository, list_arguments.repository
     ):
         if not list_arguments.json:  # pragma: nocover
             if list_arguments.find_paths:
-                logger.answer(f'{repository}: Searching archives')
+                logger.answer(f'{repository.get("label", repository["path"])}: Searching archives')
             elif not list_arguments.archive:
-                logger.answer(f'{repository}: Listing archives')
-        list_arguments.archive = borgmatic.borg.rlist.resolve_archive_name(
-            repository,
+                logger.answer(f'{repository.get("label", repository["path"])}: Listing archives')
+
+        archive_name = borgmatic.borg.rlist.resolve_archive_name(
+            repository['path'],
             list_arguments.archive,
-            storage,
+            config,
             local_borg_version,
+            global_arguments,
             local_path,
             remote_path,
         )
         json_output = borgmatic.borg.list.list_archive(
-            repository,
-            storage,
+            repository['path'],
+            config,
             local_borg_version,
-            list_arguments=list_arguments,
-            local_path=local_path,
-            remote_path=remote_path,
+            borgmatic.actions.arguments.update_arguments(list_arguments, archive=archive_name),
+            global_arguments,
+            local_path,
+            remote_path,
         )
         if json_output:  # pragma: nocover
             yield json.loads(json_output)
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/prune.py` & `borgmatic-1.8.0/borgmatic/actions/prune.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,17 +6,15 @@
 
 logger = logging.getLogger(__name__)
 
 
 def run_prune(
     config_filename,
     repository,
-    storage,
-    retention,
-    hooks,
+    config,
     hook_context,
     local_borg_version,
     prune_arguments,
     global_arguments,
     dry_run_label,
     local_path,
     remote_path,
@@ -26,34 +24,33 @@
     '''
     if prune_arguments.repository and not borgmatic.config.validate.repositories_match(
         repository, prune_arguments.repository
     ):
         return
 
     borgmatic.hooks.command.execute_hook(
-        hooks.get('before_prune'),
-        hooks.get('umask'),
+        config.get('before_prune'),
+        config.get('umask'),
         config_filename,
         'pre-prune',
         global_arguments.dry_run,
         **hook_context,
     )
-    logger.info('{}: Pruning archives{}'.format(repository, dry_run_label))
+    logger.info(f'{repository.get("label", repository["path"])}: Pruning archives{dry_run_label}')
     borgmatic.borg.prune.prune_archives(
         global_arguments.dry_run,
-        repository,
-        storage,
-        retention,
+        repository['path'],
+        config,
         local_borg_version,
+        prune_arguments,
+        global_arguments,
         local_path=local_path,
         remote_path=remote_path,
-        stats=prune_arguments.stats,
-        list_archives=prune_arguments.list_archives,
     )
     borgmatic.hooks.command.execute_hook(
-        hooks.get('after_prune'),
-        hooks.get('umask'),
+        config.get('after_prune'),
+        config.get('umask'),
         config_filename,
         'post-prune',
         global_arguments.dry_run,
         **hook_context,
     )
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/rcreate.py` & `borgmatic-1.8.0/borgmatic/actions/rcreate.py`

 * *Files 16% similar despite different names*

```diff
@@ -4,35 +4,36 @@
 import borgmatic.config.validate
 
 logger = logging.getLogger(__name__)
 
 
 def run_rcreate(
     repository,
-    storage,
+    config,
     local_borg_version,
     rcreate_arguments,
     global_arguments,
     local_path,
     remote_path,
 ):
     '''
     Run the "rcreate" action for the given repository.
     '''
     if rcreate_arguments.repository and not borgmatic.config.validate.repositories_match(
         repository, rcreate_arguments.repository
     ):
         return
 
-    logger.info('{}: Creating repository'.format(repository))
+    logger.info(f'{repository.get("label", repository["path"])}: Creating repository')
     borgmatic.borg.rcreate.create_repository(
         global_arguments.dry_run,
-        repository,
-        storage,
+        repository['path'],
+        config,
         local_borg_version,
+        global_arguments,
         rcreate_arguments.encryption_mode,
         rcreate_arguments.source_repository,
         rcreate_arguments.copy_crypt_key,
         rcreate_arguments.append_only,
         rcreate_arguments.storage_quota,
         rcreate_arguments.make_parent_dirs,
         local_path=local_path,
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/restore.py` & `borgmatic-1.8.0/borgmatic/actions/restore.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,32 +14,36 @@
 logger = logging.getLogger(__name__)
 
 
 UNSPECIFIED_HOOK = object()
 
 
 def get_configured_database(
-    hooks, archive_database_names, hook_name, database_name, configuration_database_name=None
+    config, archive_database_names, hook_name, database_name, configuration_database_name=None
 ):
     '''
-    Find the first database with the given hook name and database name in the configured hooks
-    dict and the given archive database names dict (from hook name to database names contained in
-    a particular backup archive). If UNSPECIFIED_HOOK is given as the hook name, search all database
+    Find the first database with the given hook name and database name in the configuration dict and
+    the given archive database names dict (from hook name to database names contained in a
+    particular backup archive). If UNSPECIFIED_HOOK is given as the hook name, search all database
     hooks for the named database. If a configuration database name is given, use that instead of the
     database name to lookup the database in the given hooks configuration.
 
     Return the found database as a tuple of (found hook name, database configuration dict).
     '''
     if not configuration_database_name:
         configuration_database_name = database_name
 
     if hook_name == UNSPECIFIED_HOOK:
-        hooks_to_search = hooks
+        hooks_to_search = {
+            hook_name: value
+            for (hook_name, value) in config.items()
+            if hook_name in borgmatic.hooks.dump.DATABASE_HOOK_NAMES
+        }
     else:
-        hooks_to_search = {hook_name: hooks[hook_name]}
+        hooks_to_search = {hook_name: config[hook_name]}
 
     return next(
         (
             (name, hook_database)
             for (name, hook) in hooks_to_search.items()
             for hook_database in hook
             if hook_database['name'] == configuration_database_name
@@ -54,91 +58,100 @@
     Find the hook name and first database dict with the given database name in the configured hooks
     dict. This searches across all database hooks.
     '''
 
 
 def restore_single_database(
     repository,
-    location,
-    storage,
-    hooks,
+    config,
     local_borg_version,
     global_arguments,
     local_path,
     remote_path,
     archive_name,
     hook_name,
     database,
+    connection_params,
 ):  # pragma: no cover
     '''
-    Given (among other things) an archive name, a database hook name, and a configured database
+    Given (among other things) an archive name, a database hook name, the hostname,
+    port, username and password as connection params, and a configured database
     configuration dict, restore that database from the archive.
     '''
-    logger.info(f'{repository}: Restoring database {database["name"]}')
+    logger.info(
+        f'{repository.get("label", repository["path"])}: Restoring database {database["name"]}'
+    )
 
     dump_pattern = borgmatic.hooks.dispatch.call_hooks(
         'make_database_dump_pattern',
-        hooks,
-        repository,
+        config,
+        repository['path'],
         borgmatic.hooks.dump.DATABASE_HOOK_NAMES,
-        location,
         database['name'],
     )[hook_name]
 
     # Kick off a single database extract to stdout.
     extract_process = borgmatic.borg.extract.extract_archive(
         dry_run=global_arguments.dry_run,
-        repository=repository,
+        repository=repository['path'],
         archive=archive_name,
         paths=borgmatic.hooks.dump.convert_glob_patterns_to_borg_patterns([dump_pattern]),
-        location_config=location,
-        storage_config=storage,
+        config=config,
         local_borg_version=local_borg_version,
+        global_arguments=global_arguments,
         local_path=local_path,
         remote_path=remote_path,
         destination_path='/',
         # A directory format dump isn't a single file, and therefore can't extract
         # to stdout. In this case, the extract_process return value is None.
         extract_to_stdout=bool(database.get('format') != 'directory'),
     )
 
     # Run a single database restore, consuming the extract stdout (if any).
     borgmatic.hooks.dispatch.call_hooks(
         'restore_database_dump',
-        {hook_name: [database]},
-        repository,
+        config,
+        repository['path'],
+        database['name'],
         borgmatic.hooks.dump.DATABASE_HOOK_NAMES,
-        location,
         global_arguments.dry_run,
         extract_process,
+        connection_params,
     )
 
 
 def collect_archive_database_names(
-    repository, archive, location, storage, local_borg_version, local_path, remote_path,
+    repository,
+    archive,
+    config,
+    local_borg_version,
+    global_arguments,
+    local_path,
+    remote_path,
 ):
     '''
-    Given a local or remote repository path, a resolved archive name, a location configuration dict,
-    a storage configuration dict, the local Borg version, and local and remote Borg paths, query the
-    archive for the names of databases it contains and return them as a dict from hook name to a
-    sequence of database names.
+    Given a local or remote repository path, a resolved archive name, a configuration dict, the
+    local Borg version, global_arguments an argparse.Namespace, and local and remote Borg paths,
+    query the archive for the names of databases it contains and return them as a dict from hook
+    name to a sequence of database names.
     '''
     borgmatic_source_directory = os.path.expanduser(
-        location.get(
+        config.get(
             'borgmatic_source_directory', borgmatic.borg.state.DEFAULT_BORGMATIC_SOURCE_DIRECTORY
         )
     ).lstrip('/')
     parent_dump_path = os.path.expanduser(
         borgmatic.hooks.dump.make_database_dump_path(borgmatic_source_directory, '*_databases/*/*')
     )
     dump_paths = borgmatic.borg.list.capture_archive_listing(
         repository,
         archive,
-        storage,
+        config,
         local_borg_version,
+        global_arguments,
         list_path=parent_dump_path,
         local_path=local_path,
         remote_path=remote_path,
     )
 
     # Determine the database names corresponding to the dumps found in the archive and
     # add them to restore_names.
@@ -176,15 +189,15 @@
     )
 
     # If "all" is in restore_names, then replace it with the names of dumps found within the
     # archive.
     if 'all' in restore_names[UNSPECIFIED_HOOK]:
         restore_names[UNSPECIFIED_HOOK].remove('all')
 
-        for (hook_name, database_names) in archive_database_names.items():
+        for hook_name, database_names in archive_database_names.items():
             restore_names.setdefault(hook_name, []).extend(database_names)
 
             # If a database is to be restored as part of "all", then remove it from restore names so
             # it doesn't get restored twice.
             for database_name in database_names:
                 if database_name in restore_names[UNSPECIFIED_HOOK]:
                     restore_names[UNSPECIFIED_HOOK].remove(database_name)
@@ -231,17 +244,15 @@
         raise ValueError(
             f"Cannot restore database{'s' if len(missing_names) > 1 else ''} {joined_names} missing from borgmatic's configuration"
         )
 
 
 def run_restore(
     repository,
-    location,
-    storage,
-    hooks,
+    config,
     local_borg_version,
     restore_arguments,
     global_arguments,
     local_path,
     remote_path,
 ):
     '''
@@ -252,94 +263,110 @@
     '''
     if restore_arguments.repository and not borgmatic.config.validate.repositories_match(
         repository, restore_arguments.repository
     ):
         return
 
     logger.info(
-        '{}: Restoring databases from archive {}'.format(repository, restore_arguments.archive)
+        f'{repository.get("label", repository["path"])}: Restoring databases from archive {restore_arguments.archive}'
     )
+
     borgmatic.hooks.dispatch.call_hooks_even_if_unconfigured(
         'remove_database_dumps',
-        hooks,
-        repository,
+        config,
+        repository['path'],
         borgmatic.hooks.dump.DATABASE_HOOK_NAMES,
-        location,
         global_arguments.dry_run,
     )
 
     archive_name = borgmatic.borg.rlist.resolve_archive_name(
-        repository, restore_arguments.archive, storage, local_borg_version, local_path, remote_path,
+        repository['path'],
+        restore_arguments.archive,
+        config,
+        local_borg_version,
+        global_arguments,
+        local_path,
+        remote_path,
     )
     archive_database_names = collect_archive_database_names(
-        repository, archive_name, location, storage, local_borg_version, local_path, remote_path,
+        repository['path'],
+        archive_name,
+        config,
+        local_borg_version,
+        global_arguments,
+        local_path,
+        remote_path,
     )
     restore_names = find_databases_to_restore(restore_arguments.databases, archive_database_names)
     found_names = set()
     remaining_restore_names = {}
+    connection_params = {
+        'hostname': restore_arguments.hostname,
+        'port': restore_arguments.port,
+        'username': restore_arguments.username,
+        'password': restore_arguments.password,
+        'restore_path': restore_arguments.restore_path,
+    }
 
     for hook_name, database_names in restore_names.items():
         for database_name in database_names:
             found_hook_name, found_database = get_configured_database(
-                hooks, archive_database_names, hook_name, database_name
+                config, archive_database_names, hook_name, database_name
             )
 
             if not found_database:
                 remaining_restore_names.setdefault(found_hook_name or hook_name, []).append(
                     database_name
                 )
                 continue
 
             found_names.add(database_name)
             restore_single_database(
                 repository,
-                location,
-                storage,
-                hooks,
+                config,
                 local_borg_version,
                 global_arguments,
                 local_path,
                 remote_path,
                 archive_name,
                 found_hook_name or hook_name,
-                found_database,
+                dict(found_database, **{'schemas': restore_arguments.schemas}),
+                connection_params,
             )
 
-    # For any database that weren't found via exact matches in the hooks configuration, try to
-    # fallback to "all" entries.
+    # For any database that weren't found via exact matches in the configuration, try to fallback
+    # to "all" entries.
     for hook_name, database_names in remaining_restore_names.items():
         for database_name in database_names:
             found_hook_name, found_database = get_configured_database(
-                hooks, archive_database_names, hook_name, database_name, 'all'
+                config, archive_database_names, hook_name, database_name, 'all'
             )
 
             if not found_database:
                 continue
 
             found_names.add(database_name)
             database = copy.copy(found_database)
             database['name'] = database_name
 
             restore_single_database(
                 repository,
-                location,
-                storage,
-                hooks,
+                config,
                 local_borg_version,
                 global_arguments,
                 local_path,
                 remote_path,
                 archive_name,
                 found_hook_name or hook_name,
-                database,
+                dict(database, **{'schemas': restore_arguments.schemas}),
+                connection_params,
             )
 
     borgmatic.hooks.dispatch.call_hooks_even_if_unconfigured(
         'remove_database_dumps',
-        hooks,
-        repository,
+        config,
+        repository['path'],
         borgmatic.hooks.dump.DATABASE_HOOK_NAMES,
-        location,
         global_arguments.dry_run,
     )
 
     ensure_databases_found(restore_names, remaining_restore_names, found_names)
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/rinfo.py` & `borgmatic-1.8.0/borgmatic/actions/rinfo.py`

 * *Files 20% similar despite different names*

```diff
@@ -4,29 +4,39 @@
 import borgmatic.borg.rinfo
 import borgmatic.config.validate
 
 logger = logging.getLogger(__name__)
 
 
 def run_rinfo(
-    repository, storage, local_borg_version, rinfo_arguments, local_path, remote_path,
+    repository,
+    config,
+    local_borg_version,
+    rinfo_arguments,
+    global_arguments,
+    local_path,
+    remote_path,
 ):
     '''
     Run the "rinfo" action for the given repository.
 
     If rinfo_arguments.json is True, yield the JSON output from the info for the repository.
     '''
     if rinfo_arguments.repository is None or borgmatic.config.validate.repositories_match(
         repository, rinfo_arguments.repository
     ):
         if not rinfo_arguments.json:  # pragma: nocover
-            logger.answer('{}: Displaying repository summary information'.format(repository))
+            logger.answer(
+                f'{repository.get("label", repository["path"])}: Displaying repository summary information'
+            )
+
         json_output = borgmatic.borg.rinfo.display_repository_info(
-            repository,
-            storage,
+            repository['path'],
+            config,
             local_borg_version,
             rinfo_arguments=rinfo_arguments,
+            global_arguments=global_arguments,
             local_path=local_path,
             remote_path=remote_path,
         )
         if json_output:  # pragma: nocover
             yield json.loads(json_output)
```

### Comparing `borgmatic-1.7.9/borgmatic/actions/transfer.py` & `borgmatic-1.8.0/borgmatic/actions/transfer.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,27 +3,30 @@
 import borgmatic.borg.transfer
 
 logger = logging.getLogger(__name__)
 
 
 def run_transfer(
     repository,
-    storage,
+    config,
     local_borg_version,
     transfer_arguments,
     global_arguments,
     local_path,
     remote_path,
 ):
     '''
     Run the "transfer" action for the given repository.
     '''
-    logger.info(f'{repository}: Transferring archives to repository')
+    logger.info(
+        f'{repository.get("label", repository["path"])}: Transferring archives to repository'
+    )
     borgmatic.borg.transfer.transfer_archives(
         global_arguments.dry_run,
-        repository,
-        storage,
+        repository['path'],
+        config,
         local_borg_version,
         transfer_arguments,
+        global_arguments,
         local_path=local_path,
         remote_path=remote_path,
     )
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/borg.py` & `borgmatic-1.8.0/borgmatic/borg/borg.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,68 +1,70 @@
 import logging
 
+import borgmatic.commands.arguments
 import borgmatic.logger
 from borgmatic.borg import environment, flags
-from borgmatic.execute import execute_command
+from borgmatic.execute import DO_NOT_CAPTURE, execute_command
 
 logger = logging.getLogger(__name__)
 
 
-REPOSITORYLESS_BORG_COMMANDS = {'serve', None}
 BORG_SUBCOMMANDS_WITH_SUBCOMMANDS = {'key', 'debug'}
-BORG_SUBCOMMANDS_WITHOUT_REPOSITORY = (('debug', 'info'), ('debug', 'convert-profile'), ())
 
 
 def run_arbitrary_borg(
-    repository,
-    storage_config,
+    repository_path,
+    config,
     local_borg_version,
     options,
     archive=None,
     local_path='borg',
     remote_path=None,
 ):
     '''
-    Given a local or remote repository path, a storage config dict, the local Borg version, a
+    Given a local or remote repository path, a configuration dict, the local Borg version, a
     sequence of arbitrary command-line Borg options, and an optional archive name, run an arbitrary
-    Borg command on the given repository/archive.
+    Borg command, passing in REPOSITORY and ARCHIVE environment variables for optional use in the
+    command.
     '''
     borgmatic.logger.add_custom_log_levels()
-    lock_wait = storage_config.get('lock_wait', None)
+    lock_wait = config.get('lock_wait', None)
 
     try:
         options = options[1:] if options[0] == '--' else options
 
         # Borg commands like "key" have a sub-command ("export", etc.) that must follow it.
         command_options_start_index = 2 if options[0] in BORG_SUBCOMMANDS_WITH_SUBCOMMANDS else 1
         borg_command = tuple(options[:command_options_start_index])
         command_options = tuple(options[command_options_start_index:])
+
+        if borg_command and borg_command[0] in borgmatic.commands.arguments.ACTION_ALIASES.keys():
+            logger.warning(
+                f"Borg's {borg_command[0]} subcommand is supported natively by borgmatic. Try this instead: borgmatic {borg_command[0]}"
+            )
     except IndexError:
         borg_command = ()
         command_options = ()
 
-    if borg_command in BORG_SUBCOMMANDS_WITHOUT_REPOSITORY:
-        repository_archive_flags = ()
-    elif archive:
-        repository_archive_flags = flags.make_repository_archive_flags(
-            repository, archive, local_borg_version
-        )
-    else:
-        repository_archive_flags = flags.make_repository_flags(repository, local_borg_version)
-
     full_command = (
         (local_path,)
         + borg_command
-        + repository_archive_flags
-        + command_options
         + (('--info',) if logger.getEffectiveLevel() == logging.INFO else ())
         + (('--debug', '--show-rc') if logger.isEnabledFor(logging.DEBUG) else ())
         + flags.make_flags('remote-path', remote_path)
         + flags.make_flags('lock-wait', lock_wait)
+        + command_options
     )
 
     return execute_command(
         full_command,
-        output_log_level=logging.ANSWER,
+        output_file=DO_NOT_CAPTURE,
         borg_local_path=local_path,
-        extra_environment=environment.make_environment(storage_config),
+        shell=True,
+        extra_environment=dict(
+            (environment.make_environment(config) or {}),
+            **{
+                'BORG_REPO': repository_path,
+                'ARCHIVE': archive if archive else '',
+            },
+        ),
     )
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/break_lock.py` & `borgmatic-1.8.0/borgmatic/borg/break_lock.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,29 +3,35 @@
 from borgmatic.borg import environment, flags
 from borgmatic.execute import execute_command
 
 logger = logging.getLogger(__name__)
 
 
 def break_lock(
-    repository, storage_config, local_borg_version, local_path='borg', remote_path=None,
+    repository_path,
+    config,
+    local_borg_version,
+    global_arguments,
+    local_path='borg',
+    remote_path=None,
 ):
     '''
-    Given a local or remote repository path, a storage configuration dict, the local Borg version,
-    and optional local and remote Borg paths, break any repository and cache locks leftover from Borg
-    aborting.
+    Given a local or remote repository path, a configuration dict, the local Borg version, an
+    argparse.Namespace of global arguments, and optional local and remote Borg paths, break any
+    repository and cache locks leftover from Borg aborting.
     '''
-    umask = storage_config.get('umask', None)
-    lock_wait = storage_config.get('lock_wait', None)
+    umask = config.get('umask', None)
+    lock_wait = config.get('lock_wait', None)
 
     full_command = (
         (local_path, 'break-lock')
         + (('--remote-path', remote_path) if remote_path else ())
         + (('--umask', str(umask)) if umask else ())
+        + (('--log-json',) if global_arguments.log_json else ())
         + (('--lock-wait', str(lock_wait)) if lock_wait else ())
         + (('--info',) if logger.getEffectiveLevel() == logging.INFO else ())
         + (('--debug', '--show-rc') if logger.isEnabledFor(logging.DEBUG) else ())
-        + flags.make_repository_flags(repository, local_borg_version)
+        + flags.make_repository_flags(repository_path, local_borg_version)
     )
 
-    borg_environment = environment.make_environment(storage_config)
+    borg_environment = environment.make_environment(config)
     execute_command(full_command, borg_local_path=local_path, extra_environment=borg_environment)
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/check.py` & `borgmatic-1.8.0/borgmatic/borg/check.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,46 +1,46 @@
 import argparse
 import datetime
+import hashlib
+import itertools
 import json
 import logging
 import os
 import pathlib
 
 from borgmatic.borg import environment, extract, feature, flags, rinfo, state
 from borgmatic.execute import DO_NOT_CAPTURE, execute_command
 
 DEFAULT_CHECKS = (
     {'name': 'repository', 'frequency': '1 month'},
     {'name': 'archives', 'frequency': '1 month'},
 )
-DEFAULT_PREFIX = '{hostname}-'
 
 
 logger = logging.getLogger(__name__)
 
 
-def parse_checks(consistency_config, only_checks=None):
+def parse_checks(config, only_checks=None):
     '''
-    Given a consistency config with a "checks" sequence of dicts and an optional list of override
+    Given a configuration dict with a "checks" sequence of dicts and an optional list of override
     checks, return a tuple of named checks to run.
 
-    For example, given a retention config of:
+    For example, given a config of:
 
         {'checks': ({'name': 'repository'}, {'name': 'archives'})}
 
     This will be returned as:
 
         ('repository', 'archives')
 
     If no "checks" option is present in the config, return the DEFAULT_CHECKS. If a checks value
     has a name of "disabled", return an empty tuple, meaning that no checks should be run.
     '''
     checks = only_checks or tuple(
-        check_config['name']
-        for check_config in (consistency_config.get('checks', None) or DEFAULT_CHECKS)
+        check_config['name'] for check_config in (config.get('checks', None) or DEFAULT_CHECKS)
     )
     checks = tuple(check.lower() for check in checks)
     if 'disabled' in checks:
         if len(checks) > 1:
             logger.warning(
                 'Multiple checks are configured, but one of them is "disabled"; not running any checks'
             )
@@ -85,56 +85,59 @@
     try:
         return datetime.timedelta(**{time_unit: number})
     except TypeError:
         raise ValueError(f"Could not parse consistency check frequency '{frequency}'")
 
 
 def filter_checks_on_frequency(
-    location_config, consistency_config, borg_repository_id, checks, force
+    config,
+    borg_repository_id,
+    checks,
+    force,
+    archives_check_id=None,
 ):
     '''
-    Given a location config, a consistency config with a "checks" sequence of dicts, a Borg
-    repository ID, a sequence of checks, and whether to force checks to run, filter down those
-    checks based on the configured "frequency" for each check as compared to its check time file.
+    Given a configuration dict with a "checks" sequence of dicts, a Borg repository ID, a sequence
+    of checks, whether to force checks to run, and an ID for the archives check potentially being
+    run (if any), filter down those checks based on the configured "frequency" for each check as
+    compared to its check time file.
 
     In other words, a check whose check time file's timestamp is too new (based on the configured
     frequency) will get cut from the returned sequence of checks. Example:
 
-    consistency_config = {
+    config = {
         'checks': [
             {
                 'name': 'archives',
                 'frequency': '2 weeks',
             },
         ]
     }
 
-    When this function is called with that consistency_config and "archives" in checks, "archives"
-    will get filtered out of the returned result if its check time file is newer than 2 weeks old,
-    indicating that it's not yet time to run that check again.
+    When this function is called with that config and "archives" in checks, "archives" will get
+    filtered out of the returned result if its check time file is newer than 2 weeks old, indicating
+    that it's not yet time to run that check again.
 
     Raise ValueError if a frequency cannot be parsed.
     '''
     filtered_checks = list(checks)
 
     if force:
         return tuple(filtered_checks)
 
-    for check_config in consistency_config.get('checks', DEFAULT_CHECKS):
+    for check_config in config.get('checks', DEFAULT_CHECKS):
         check = check_config['name']
         if checks and check not in checks:
             continue
 
         frequency_delta = parse_frequency(check_config.get('frequency'))
         if not frequency_delta:
             continue
 
-        check_time = read_check_time(
-            make_check_time_path(location_config, borg_repository_id, check)
-        )
+        check_time = probe_for_check_time(config, borg_repository_id, check, archives_check_id)
         if not check_time:
             continue
 
         # If we've not yet reached the time when the frequency dictates we're ready for another
         # check, skip this check.
         if datetime.datetime.now() < check_time + frequency_delta:
             remaining = check_time + frequency_delta - datetime.datetime.now()
@@ -142,81 +145,117 @@
                 f'Skipping {check} check due to configured frequency; {remaining} until next check'
             )
             filtered_checks.remove(check)
 
     return tuple(filtered_checks)
 
 
-def make_check_flags(local_borg_version, checks, check_last=None, prefix=None):
+def make_archive_filter_flags(local_borg_version, config, checks, check_last=None, prefix=None):
+    '''
+    Given the local Borg version, a configuration dict, a parsed sequence of checks, the check last
+    value, and a consistency check prefix, transform the checks into tuple of command-line flags for
+    filtering archives in a check command.
+
+    If a check_last value is given and "archives" is in checks, then include a "--last" flag. And if
+    a prefix value is given and "archives" is in checks, then include a "--match-archives" flag.
+    '''
+    if 'archives' in checks or 'data' in checks:
+        return (('--last', str(check_last)) if check_last else ()) + (
+            (
+                ('--match-archives', f'sh:{prefix}*')
+                if feature.available(feature.Feature.MATCH_ARCHIVES, local_borg_version)
+                else ('--glob-archives', f'{prefix}*')
+            )
+            if prefix
+            else (
+                flags.make_match_archives_flags(
+                    config.get('match_archives'),
+                    config.get('archive_name_format'),
+                    local_borg_version,
+                )
+            )
+        )
+
+    if check_last:
+        logger.warning(
+            'Ignoring check_last option, as "archives" or "data" are not in consistency checks'
+        )
+    if prefix:
+        logger.warning(
+            'Ignoring consistency prefix option, as "archives" or "data" are not in consistency checks'
+        )
+
+    return ()
+
+
+def make_archives_check_id(archive_filter_flags):
+    '''
+    Given a sequence of flags to filter archives, return a unique hash corresponding to those
+    particular flags. If there are no flags, return None.
+    '''
+    if not archive_filter_flags:
+        return None
+
+    return hashlib.sha256(' '.join(archive_filter_flags).encode()).hexdigest()
+
+
+def make_check_flags(checks, archive_filter_flags):
     '''
-    Given the local Borg version and a parsed sequence of checks, transform the checks into tuple of
-    command-line flags.
+    Given a parsed sequence of checks and a sequence of flags to filter archives, transform the
+    checks into tuple of command-line check flags.
 
     For example, given parsed checks of:
 
         ('repository',)
 
     This will be returned as:
 
         ('--repository-only',)
 
     However, if both "repository" and "archives" are in checks, then omit them from the returned
     flags because Borg does both checks by default. If "data" is in checks, that implies "archives".
-
-    Additionally, if a check_last value is given and "archives" is in checks, then include a
-    "--last" flag. And if a prefix value is given and "archives" is in checks, then include a
-    "--match-archives" flag.
     '''
     if 'data' in checks:
         data_flags = ('--verify-data',)
         checks += ('archives',)
     else:
         data_flags = ()
 
-    if 'archives' in checks:
-        last_flags = ('--last', str(check_last)) if check_last else ()
-        if feature.available(feature.Feature.MATCH_ARCHIVES, local_borg_version):
-            match_archives_flags = ('--match-archives', f'sh:{prefix}*') if prefix else ()
-        else:
-            match_archives_flags = ('--glob-archives', f'{prefix}*') if prefix else ()
-    else:
-        last_flags = ()
-        match_archives_flags = ()
-        if check_last:
-            logger.warning(
-                'Ignoring check_last option, as "archives" or "data" are not in consistency checks'
-            )
-        if prefix:
-            logger.warning(
-                'Ignoring consistency prefix option, as "archives" or "data" are not in consistency checks'
-            )
-
-    common_flags = last_flags + match_archives_flags + data_flags
+    common_flags = (archive_filter_flags if 'archives' in checks else ()) + data_flags
 
     if {'repository', 'archives'}.issubset(set(checks)):
         return common_flags
 
     return (
-        tuple('--{}-only'.format(check) for check in checks if check in ('repository', 'archives'))
+        tuple(f'--{check}-only' for check in checks if check in ('repository', 'archives'))
         + common_flags
     )
 
 
-def make_check_time_path(location_config, borg_repository_id, check_type):
+def make_check_time_path(config, borg_repository_id, check_type, archives_check_id=None):
     '''
-    Given a location configuration dict, a Borg repository ID, and the name of a check type
-    ("repository", "archives", etc.), return a path for recording that check's time (the time of
-    that check last occurring).
+    Given a configuration dict, a Borg repository ID, the name of a check type ("repository",
+    "archives", etc.), and a unique hash of the archives filter flags, return a path for recording
+    that check's time (the time of that check last occurring).
     '''
+    borgmatic_source_directory = os.path.expanduser(
+        config.get('borgmatic_source_directory', state.DEFAULT_BORGMATIC_SOURCE_DIRECTORY)
+    )
+
+    if check_type in ('archives', 'data'):
+        return os.path.join(
+            borgmatic_source_directory,
+            'checks',
+            borg_repository_id,
+            check_type,
+            archives_check_id if archives_check_id else 'all',
+        )
+
     return os.path.join(
-        os.path.expanduser(
-            location_config.get(
-                'borgmatic_source_directory', state.DEFAULT_BORGMATIC_SOURCE_DIRECTORY
-            )
-        ),
+        borgmatic_source_directory,
         'checks',
         borg_repository_id,
         check_type,
     )
 
 
 def write_check_time(path):  # pragma: no cover
@@ -238,97 +277,180 @@
 
     try:
         return datetime.datetime.fromtimestamp(os.stat(path).st_mtime)
     except FileNotFoundError:
         return None
 
 
+def probe_for_check_time(config, borg_repository_id, check, archives_check_id):
+    '''
+    Given a configuration dict, a Borg repository ID, the name of a check type ("repository",
+    "archives", etc.), and a unique hash of the archives filter flags, return a the corresponding
+    check time or None if such a check time does not exist.
+
+    When the check type is "archives" or "data", this function probes two different paths to find
+    the check time, e.g.:
+
+      ~/.borgmatic/checks/1234567890/archives/9876543210
+      ~/.borgmatic/checks/1234567890/archives/all
+
+    ... and returns the maximum modification time of the files found (if any). The first path
+    represents a more specific archives check time (a check on a subset of archives), and the second
+    is a fallback to the last "all" archives check.
+
+    For other check types, this function reads from a single check time path, e.g.:
+
+      ~/.borgmatic/checks/1234567890/repository
+    '''
+    check_times = (
+        read_check_time(group[0])
+        for group in itertools.groupby(
+            (
+                make_check_time_path(config, borg_repository_id, check, archives_check_id),
+                make_check_time_path(config, borg_repository_id, check),
+            )
+        )
+    )
+
+    try:
+        return max(check_time for check_time in check_times if check_time)
+    except ValueError:
+        return None
+
+
+def upgrade_check_times(config, borg_repository_id):
+    '''
+    Given a configuration dict and a Borg repository ID, upgrade any corresponding check times on
+    disk from old-style paths to new-style paths.
+
+    Currently, the only upgrade performed is renaming an archive or data check path that looks like:
+
+      ~/.borgmatic/checks/1234567890/archives
+
+    to:
+
+      ~/.borgmatic/checks/1234567890/archives/all
+    '''
+    for check_type in ('archives', 'data'):
+        new_path = make_check_time_path(config, borg_repository_id, check_type, 'all')
+        old_path = os.path.dirname(new_path)
+        temporary_path = f'{old_path}.temp'
+
+        if not os.path.isfile(old_path) and not os.path.isfile(temporary_path):
+            continue
+
+        logger.debug(f'Upgrading archives check time from {old_path} to {new_path}')
+
+        try:
+            os.rename(old_path, temporary_path)
+        except FileNotFoundError:
+            pass
+
+        os.mkdir(old_path)
+        os.rename(temporary_path, new_path)
+
+
 def check_archives(
-    repository,
-    location_config,
-    storage_config,
-    consistency_config,
+    repository_path,
+    config,
     local_borg_version,
+    global_arguments,
     local_path='borg',
     remote_path=None,
     progress=None,
     repair=None,
     only_checks=None,
     force=None,
 ):
     '''
-    Given a local or remote repository path, a storage config dict, a consistency config dict,
-    local/remote commands to run, whether to include progress information, whether to attempt a
-    repair, and an optional list of checks to use instead of configured checks, check the contained
-    Borg archives for consistency.
+    Given a local or remote repository path, a configuration dict, local/remote commands to run,
+    whether to include progress information, whether to attempt a repair, and an optional list of
+    checks to use instead of configured checks, check the contained Borg archives for consistency.
 
     If there are no consistency checks to run, skip running them.
 
     Raises ValueError if the Borg repository ID cannot be determined.
     '''
     try:
         borg_repository_id = json.loads(
             rinfo.display_repository_info(
-                repository,
-                storage_config,
+                repository_path,
+                config,
                 local_borg_version,
                 argparse.Namespace(json=True),
+                global_arguments,
                 local_path,
                 remote_path,
             )
         )['repository']['id']
     except (json.JSONDecodeError, KeyError):
-        raise ValueError(f'Cannot determine Borg repository ID for {repository}')
+        raise ValueError(f'Cannot determine Borg repository ID for {repository_path}')
+
+    upgrade_check_times(config, borg_repository_id)
+
+    check_last = config.get('check_last', None)
+    prefix = config.get('prefix')
+    configured_checks = parse_checks(config, only_checks)
+    lock_wait = None
+    extra_borg_options = config.get('extra_borg_options', {}).get('check', '')
+    archive_filter_flags = make_archive_filter_flags(
+        local_borg_version, config, configured_checks, check_last, prefix
+    )
+    archives_check_id = make_archives_check_id(archive_filter_flags)
 
     checks = filter_checks_on_frequency(
-        location_config,
-        consistency_config,
+        config,
         borg_repository_id,
-        parse_checks(consistency_config, only_checks),
+        configured_checks,
         force,
+        archives_check_id,
     )
-    check_last = consistency_config.get('check_last', None)
-    lock_wait = None
-    extra_borg_options = storage_config.get('extra_borg_options', {}).get('check', '')
 
     if set(checks).intersection({'repository', 'archives', 'data'}):
-        lock_wait = storage_config.get('lock_wait', None)
+        lock_wait = config.get('lock_wait')
 
         verbosity_flags = ()
         if logger.isEnabledFor(logging.INFO):
             verbosity_flags = ('--info',)
         if logger.isEnabledFor(logging.DEBUG):
             verbosity_flags = ('--debug', '--show-rc')
 
-        prefix = consistency_config.get('prefix', DEFAULT_PREFIX)
-
         full_command = (
             (local_path, 'check')
             + (('--repair',) if repair else ())
-            + make_check_flags(local_borg_version, checks, check_last, prefix)
+            + make_check_flags(checks, archive_filter_flags)
             + (('--remote-path', remote_path) if remote_path else ())
+            + (('--log-json',) if global_arguments.log_json else ())
             + (('--lock-wait', str(lock_wait)) if lock_wait else ())
             + verbosity_flags
             + (('--progress',) if progress else ())
             + (tuple(extra_borg_options.split(' ')) if extra_borg_options else ())
-            + flags.make_repository_flags(repository, local_borg_version)
+            + flags.make_repository_flags(repository_path, local_borg_version)
         )
 
-        borg_environment = environment.make_environment(storage_config)
+        borg_environment = environment.make_environment(config)
 
         # The Borg repair option triggers an interactive prompt, which won't work when output is
         # captured. And progress messes with the terminal directly.
         if repair or progress:
             execute_command(
                 full_command, output_file=DO_NOT_CAPTURE, extra_environment=borg_environment
             )
         else:
             execute_command(full_command, extra_environment=borg_environment)
 
         for check in checks:
-            write_check_time(make_check_time_path(location_config, borg_repository_id, check))
+            write_check_time(
+                make_check_time_path(config, borg_repository_id, check, archives_check_id)
+            )
 
     if 'extract' in checks:
         extract.extract_last_archive_dry_run(
-            storage_config, local_borg_version, repository, lock_wait, local_path, remote_path
+            config,
+            local_borg_version,
+            global_arguments,
+            repository_path,
+            lock_wait,
+            local_path,
+            remote_path,
         )
-        write_check_time(make_check_time_path(location_config, borg_repository_id, 'extract'))
+        write_check_time(make_check_time_path(config, borg_repository_id, 'extract'))
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/compact.py` & `borgmatic-1.8.0/borgmatic/borg/compact.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,48 +4,50 @@
 from borgmatic.execute import execute_command
 
 logger = logging.getLogger(__name__)
 
 
 def compact_segments(
     dry_run,
-    repository,
-    storage_config,
+    repository_path,
+    config,
     local_borg_version,
+    global_arguments,
     local_path='borg',
     remote_path=None,
     progress=False,
     cleanup_commits=False,
     threshold=None,
 ):
     '''
-    Given dry-run flag, a local or remote repository path, a storage config dict, and the local
-    Borg version, compact the segments in a repository.
+    Given dry-run flag, a local or remote repository path, a configuration dict, and the local Borg
+    version, compact the segments in a repository.
     '''
-    umask = storage_config.get('umask', None)
-    lock_wait = storage_config.get('lock_wait', None)
-    extra_borg_options = storage_config.get('extra_borg_options', {}).get('compact', '')
+    umask = config.get('umask', None)
+    lock_wait = config.get('lock_wait', None)
+    extra_borg_options = config.get('extra_borg_options', {}).get('compact', '')
 
     full_command = (
         (local_path, 'compact')
         + (('--remote-path', remote_path) if remote_path else ())
         + (('--umask', str(umask)) if umask else ())
+        + (('--log-json',) if global_arguments.log_json else ())
         + (('--lock-wait', str(lock_wait)) if lock_wait else ())
         + (('--progress',) if progress else ())
         + (('--cleanup-commits',) if cleanup_commits else ())
         + (('--threshold', str(threshold)) if threshold else ())
         + (('--info',) if logger.getEffectiveLevel() == logging.INFO else ())
         + (('--debug', '--show-rc') if logger.isEnabledFor(logging.DEBUG) else ())
         + (tuple(extra_borg_options.split(' ')) if extra_borg_options else ())
-        + flags.make_repository_flags(repository, local_borg_version)
+        + flags.make_repository_flags(repository_path, local_borg_version)
     )
 
     if dry_run:
-        logging.info(f'{repository}: Skipping compact (dry run)')
+        logging.info(f'{repository_path}: Skipping compact (dry run)')
         return
 
     execute_command(
         full_command,
         output_log_level=logging.INFO,
         borg_local_path=local_path,
-        extra_environment=environment.make_environment(storage_config),
+        extra_environment=environment.make_environment(config),
     )
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/create.py` & `borgmatic-1.8.0/borgmatic/borg/create.py`

 * *Files 7% similar despite different names*

```diff
@@ -142,54 +142,52 @@
     '''
     for file_object in itertools.chain.from_iterable(
         filename_list for filename_list in filename_lists if filename_list
     ):
         open(file_object).close()
 
 
-def make_pattern_flags(location_config, pattern_filename=None):
+def make_pattern_flags(config, pattern_filename=None):
     '''
-    Given a location config dict with a potential patterns_from option, and a filename containing
-    any additional patterns, return the corresponding Borg flags for those files as a tuple.
+    Given a configuration dict with a potential patterns_from option, and a filename containing any
+    additional patterns, return the corresponding Borg flags for those files as a tuple.
     '''
-    pattern_filenames = tuple(location_config.get('patterns_from') or ()) + (
+    pattern_filenames = tuple(config.get('patterns_from') or ()) + (
         (pattern_filename,) if pattern_filename else ()
     )
 
     return tuple(
         itertools.chain.from_iterable(
             ('--patterns-from', pattern_filename) for pattern_filename in pattern_filenames
         )
     )
 
 
-def make_exclude_flags(location_config, exclude_filename=None):
+def make_exclude_flags(config, exclude_filename=None):
     '''
-    Given a location config dict with various exclude options, and a filename containing any exclude
+    Given a configuration dict with various exclude options, and a filename containing any exclude
     patterns, return the corresponding Borg flags as a tuple.
     '''
-    exclude_filenames = tuple(location_config.get('exclude_from') or ()) + (
+    exclude_filenames = tuple(config.get('exclude_from') or ()) + (
         (exclude_filename,) if exclude_filename else ()
     )
     exclude_from_flags = tuple(
         itertools.chain.from_iterable(
             ('--exclude-from', exclude_filename) for exclude_filename in exclude_filenames
         )
     )
-    caches_flag = ('--exclude-caches',) if location_config.get('exclude_caches') else ()
+    caches_flag = ('--exclude-caches',) if config.get('exclude_caches') else ()
     if_present_flags = tuple(
         itertools.chain.from_iterable(
             ('--exclude-if-present', if_present)
-            for if_present in location_config.get('exclude_if_present', ())
+            for if_present in config.get('exclude_if_present', ())
         )
     )
-    keep_exclude_tags_flags = (
-        ('--keep-exclude-tags',) if location_config.get('keep_exclude_tags') else ()
-    )
-    exclude_nodump_flags = ('--exclude-nodump',) if location_config.get('exclude_nodump') else ()
+    keep_exclude_tags_flags = ('--keep-exclude-tags',) if config.get('keep_exclude_tags') else ()
+    exclude_nodump_flags = ('--exclude-nodump',) if config.get('exclude_nodump') else ()
 
     return (
         exclude_from_flags
         + caches_flag
         + if_present_flags
         + keep_exclude_tags_flags
         + exclude_nodump_flags
@@ -213,15 +211,15 @@
 
     if show_excludes:
         return f'{base_flags}x-'
     else:
         return f'{base_flags}-'
 
 
-DEFAULT_ARCHIVE_NAME_FORMAT = '{hostname}-{now:%Y-%m-%dT%H:%M:%S.%f}'
+DEFAULT_ARCHIVE_NAME_FORMAT = '{hostname}-{now:%Y-%m-%dT%H:%M:%S.%f}'  # noqa: FS003
 
 
 def collect_borgmatic_source_directories(borgmatic_source_directory):
     '''
     Return a list of borgmatic-specific source directories used for state like database backups.
     '''
     if not borgmatic_source_directory:
@@ -276,25 +274,29 @@
     return False
 
 
 def collect_special_file_paths(
     create_command, local_path, working_directory, borg_environment, skip_directories
 ):
     '''
-    Given a Borg create command as a tuple, a local Borg path, a working directory, and a dict of
+    Given a Borg create command as a tuple, a local Borg path, a working directory, a dict of
     environment variables to pass to Borg, and a sequence of parent directories to skip, collect the
     paths for any special files (character devices, block devices, and named pipes / FIFOs) that
     Borg would encounter during a create. These are all paths that could cause Borg to hang if its
     --read-special flag is used.
     '''
+    # Omit "--exclude-nodump" from the Borg dry run command, because that flag causes Borg to open
+    # files including any named pipe we've created.
     paths_output = execute_command_and_capture_output(
-        create_command + ('--dry-run', '--list'),
+        tuple(argument for argument in create_command if argument != '--exclude-nodump')
+        + ('--dry-run', '--list'),
         capture_stderr=True,
         working_directory=working_directory,
         extra_environment=borg_environment,
+        borg_local_path=local_path,
     )
 
     paths = tuple(
         path_line.split(' ', 1)[1]
         for path_line in paths_output.split('\n')
         if path_line and path_line.startswith('- ') or path_line.startswith('+ ')
     )
@@ -302,178 +304,193 @@
     return tuple(
         path
         for path in paths
         if special_file(path) and not any_parent_directories(path, skip_directories)
     )
 
 
+def check_all_source_directories_exist(source_directories):
+    '''
+    Given a sequence of source directories, check that they all exist. If any do not, raise an
+    exception.
+    '''
+    missing_directories = [
+        source_directory
+        for source_directory in source_directories
+        if not all([os.path.exists(directory) for directory in expand_directory(source_directory)])
+    ]
+    if missing_directories:
+        raise ValueError(f"Source directories do not exist: {', '.join(missing_directories)}")
+
+
 def create_archive(
     dry_run,
-    repository,
-    location_config,
-    storage_config,
+    repository_path,
+    config,
     local_borg_version,
+    global_arguments,
     local_path='borg',
     remote_path=None,
     progress=False,
     stats=False,
     json=False,
     list_files=False,
     stream_processes=None,
 ):
     '''
-    Given vebosity/dry-run flags, a local or remote repository path, a location config dict, and a
-    storage config dict, create a Borg archive and return Borg's JSON output (if any).
+    Given vebosity/dry-run flags, a local or remote repository path, and a configuration dict,
+    create a Borg archive and return Borg's JSON output (if any).
 
     If a sequence of stream processes is given (instances of subprocess.Popen), then execute the
     create command while also triggering the given processes to produce output.
     '''
     borgmatic.logger.add_custom_log_levels()
     borgmatic_source_directories = expand_directories(
-        collect_borgmatic_source_directories(location_config.get('borgmatic_source_directory'))
+        collect_borgmatic_source_directories(config.get('borgmatic_source_directory'))
     )
+    if config.get('source_directories_must_exist', False):
+        check_all_source_directories_exist(config.get('source_directories'))
     sources = deduplicate_directories(
         map_directories_to_devices(
             expand_directories(
-                tuple(location_config.get('source_directories', ())) + borgmatic_source_directories
+                tuple(config.get('source_directories', ()))
+                + borgmatic_source_directories
+                + tuple(global_arguments.used_config_paths)
             )
         ),
         additional_directory_devices=map_directories_to_devices(
-            expand_directories(pattern_root_directories(location_config.get('patterns')))
+            expand_directories(pattern_root_directories(config.get('patterns')))
         ),
     )
 
-    ensure_files_readable(location_config.get('patterns_from'), location_config.get('exclude_from'))
+    ensure_files_readable(config.get('patterns_from'), config.get('exclude_from'))
 
     try:
-        working_directory = os.path.expanduser(location_config.get('working_directory'))
+        working_directory = os.path.expanduser(config.get('working_directory'))
     except TypeError:
         working_directory = None
 
     pattern_file = (
-        write_pattern_file(location_config.get('patterns'), sources)
-        if location_config.get('patterns') or location_config.get('patterns_from')
+        write_pattern_file(config.get('patterns'), sources)
+        if config.get('patterns') or config.get('patterns_from')
         else None
     )
-    exclude_file = write_pattern_file(
-        expand_home_directories(location_config.get('exclude_patterns'))
-    )
-    checkpoint_interval = storage_config.get('checkpoint_interval', None)
-    checkpoint_volume = storage_config.get('checkpoint_volume', None)
-    chunker_params = storage_config.get('chunker_params', None)
-    compression = storage_config.get('compression', None)
-    upload_rate_limit = storage_config.get('upload_rate_limit', None)
-    umask = storage_config.get('umask', None)
-    lock_wait = storage_config.get('lock_wait', None)
+    exclude_file = write_pattern_file(expand_home_directories(config.get('exclude_patterns')))
+    checkpoint_interval = config.get('checkpoint_interval', None)
+    checkpoint_volume = config.get('checkpoint_volume', None)
+    chunker_params = config.get('chunker_params', None)
+    compression = config.get('compression', None)
+    upload_rate_limit = config.get('upload_rate_limit', None)
+    umask = config.get('umask', None)
+    lock_wait = config.get('lock_wait', None)
     list_filter_flags = make_list_filter_flags(local_borg_version, dry_run)
-    files_cache = location_config.get('files_cache')
-    archive_name_format = storage_config.get('archive_name_format', DEFAULT_ARCHIVE_NAME_FORMAT)
-    extra_borg_options = storage_config.get('extra_borg_options', {}).get('create', '')
+    files_cache = config.get('files_cache')
+    archive_name_format = config.get('archive_name_format', DEFAULT_ARCHIVE_NAME_FORMAT)
+    extra_borg_options = config.get('extra_borg_options', {}).get('create', '')
 
     if feature.available(feature.Feature.ATIME, local_borg_version):
-        atime_flags = ('--atime',) if location_config.get('atime') is True else ()
+        atime_flags = ('--atime',) if config.get('atime') is True else ()
     else:
-        atime_flags = ('--noatime',) if location_config.get('atime') is False else ()
+        atime_flags = ('--noatime',) if config.get('atime') is False else ()
 
     if feature.available(feature.Feature.NOFLAGS, local_borg_version):
-        noflags_flags = ('--noflags',) if location_config.get('flags') is False else ()
+        noflags_flags = ('--noflags',) if config.get('flags') is False else ()
     else:
-        noflags_flags = ('--nobsdflags',) if location_config.get('flags') is False else ()
+        noflags_flags = ('--nobsdflags',) if config.get('flags') is False else ()
 
     if feature.available(feature.Feature.NUMERIC_IDS, local_borg_version):
-        numeric_ids_flags = ('--numeric-ids',) if location_config.get('numeric_ids') else ()
+        numeric_ids_flags = ('--numeric-ids',) if config.get('numeric_ids') else ()
     else:
-        numeric_ids_flags = ('--numeric-owner',) if location_config.get('numeric_ids') else ()
+        numeric_ids_flags = ('--numeric-owner',) if config.get('numeric_ids') else ()
 
     if feature.available(feature.Feature.UPLOAD_RATELIMIT, local_borg_version):
         upload_ratelimit_flags = (
             ('--upload-ratelimit', str(upload_rate_limit)) if upload_rate_limit else ()
         )
     else:
         upload_ratelimit_flags = (
             ('--remote-ratelimit', str(upload_rate_limit)) if upload_rate_limit else ()
         )
 
-    if stream_processes and location_config.get('read_special') is False:
+    if stream_processes and config.get('read_special') is False:
         logger.warning(
-            f'{repository}: Ignoring configured "read_special" value of false, as true is needed for database hooks.'
+            f'{repository_path}: Ignoring configured "read_special" value of false, as true is needed for database hooks.'
         )
 
     create_command = (
         tuple(local_path.split(' '))
         + ('create',)
-        + make_pattern_flags(location_config, pattern_file.name if pattern_file else None)
-        + make_exclude_flags(location_config, exclude_file.name if exclude_file else None)
+        + make_pattern_flags(config, pattern_file.name if pattern_file else None)
+        + make_exclude_flags(config, exclude_file.name if exclude_file else None)
         + (('--checkpoint-interval', str(checkpoint_interval)) if checkpoint_interval else ())
         + (('--checkpoint-volume', str(checkpoint_volume)) if checkpoint_volume else ())
         + (('--chunker-params', chunker_params) if chunker_params else ())
         + (('--compression', compression) if compression else ())
         + upload_ratelimit_flags
-        + (
-            ('--one-file-system',)
-            if location_config.get('one_file_system') or stream_processes
-            else ()
-        )
+        + (('--one-file-system',) if config.get('one_file_system') or stream_processes else ())
         + numeric_ids_flags
         + atime_flags
-        + (('--noctime',) if location_config.get('ctime') is False else ())
-        + (('--nobirthtime',) if location_config.get('birthtime') is False else ())
-        + (('--read-special',) if location_config.get('read_special') or stream_processes else ())
+        + (('--noctime',) if config.get('ctime') is False else ())
+        + (('--nobirthtime',) if config.get('birthtime') is False else ())
+        + (('--read-special',) if config.get('read_special') or stream_processes else ())
         + noflags_flags
         + (('--files-cache', files_cache) if files_cache else ())
         + (('--remote-path', remote_path) if remote_path else ())
         + (('--umask', str(umask)) if umask else ())
+        + (('--log-json',) if global_arguments.log_json else ())
         + (('--lock-wait', str(lock_wait)) if lock_wait else ())
         + (
             ('--list', '--filter', list_filter_flags)
             if list_files and not json and not progress
             else ()
         )
         + (('--dry-run',) if dry_run else ())
         + (tuple(extra_borg_options.split(' ')) if extra_borg_options else ())
-        + flags.make_repository_archive_flags(repository, archive_name_format, local_borg_version)
+        + flags.make_repository_archive_flags(
+            repository_path, archive_name_format, local_borg_version
+        )
         + (sources if not pattern_file else ())
     )
 
     if json:
         output_log_level = None
     elif list_files or (stats and not dry_run):
         output_log_level = logging.ANSWER
     else:
         output_log_level = logging.INFO
 
     # The progress output isn't compatible with captured and logged output, as progress messes with
     # the terminal directly.
     output_file = DO_NOT_CAPTURE if progress else None
 
-    borg_environment = environment.make_environment(storage_config)
+    borg_environment = environment.make_environment(config)
 
     # If database hooks are enabled (as indicated by streaming processes), exclude files that might
     # cause Borg to hang. But skip this if the user has explicitly set the "read_special" to True.
-    if stream_processes and not location_config.get('read_special'):
-        logger.debug(f'{repository}: Collecting special file paths')
+    if stream_processes and not config.get('read_special'):
+        logger.debug(f'{repository_path}: Collecting special file paths')
         special_file_paths = collect_special_file_paths(
             create_command,
             local_path,
             working_directory,
             borg_environment,
             skip_directories=borgmatic_source_directories,
         )
 
         if special_file_paths:
             logger.warning(
-                f'{repository}: Excluding special files to prevent Borg from hanging: {", ".join(special_file_paths)}'
+                f'{repository_path}: Excluding special files to prevent Borg from hanging: {", ".join(special_file_paths)}'
             )
             exclude_file = write_pattern_file(
                 expand_home_directories(
-                    tuple(location_config.get('exclude_patterns') or ()) + special_file_paths
+                    tuple(config.get('exclude_patterns') or ()) + special_file_paths
                 ),
                 pattern_file=exclude_file,
             )
-            create_command += make_exclude_flags(location_config, exclude_file.name)
+            create_command += make_exclude_flags(config, exclude_file.name)
 
     create_command += (
         (('--info',) if logger.getEffectiveLevel() == logging.INFO and not json else ())
         + (('--stats',) if stats and not json and not dry_run else ())
         + (('--debug', '--show-rc') if logger.isEnabledFor(logging.DEBUG) and not json else ())
         + (('--progress',) if progress else ())
         + (('--json',) if json else ())
@@ -487,15 +504,18 @@
             output_file,
             borg_local_path=local_path,
             working_directory=working_directory,
             extra_environment=borg_environment,
         )
     elif output_log_level is None:
         return execute_command_and_capture_output(
-            create_command, working_directory=working_directory, extra_environment=borg_environment,
+            create_command,
+            working_directory=working_directory,
+            extra_environment=borg_environment,
+            borg_local_path=local_path,
         )
     else:
         execute_command(
             create_command,
             output_log_level,
             output_file,
             borg_local_path=local_path,
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/environment.py` & `borgmatic-1.8.0/borgmatic/borg/environment.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,39 +1,51 @@
 OPTION_TO_ENVIRONMENT_VARIABLE = {
     'borg_base_directory': 'BORG_BASE_DIR',
     'borg_config_directory': 'BORG_CONFIG_DIR',
     'borg_cache_directory': 'BORG_CACHE_DIR',
+    'borg_files_cache_ttl': 'BORG_FILES_CACHE_TTL',
     'borg_security_directory': 'BORG_SECURITY_DIR',
     'borg_keys_directory': 'BORG_KEYS_DIR',
     'encryption_passcommand': 'BORG_PASSCOMMAND',
     'encryption_passphrase': 'BORG_PASSPHRASE',
     'ssh_command': 'BORG_RSH',
     'temporary_directory': 'TMPDIR',
 }
 
-DEFAULT_BOOL_OPTION_TO_ENVIRONMENT_VARIABLE = {
+DEFAULT_BOOL_OPTION_TO_DOWNCASE_ENVIRONMENT_VARIABLE = {
     'relocated_repo_access_is_ok': 'BORG_RELOCATED_REPO_ACCESS_IS_OK',
     'unknown_unencrypted_repo_access_is_ok': 'BORG_UNKNOWN_UNENCRYPTED_REPO_ACCESS_IS_OK',
 }
 
+DEFAULT_BOOL_OPTION_TO_UPPERCASE_ENVIRONMENT_VARIABLE = {
+    'check_i_know_what_i_am_doing': 'BORG_CHECK_I_KNOW_WHAT_I_AM_DOING',
+}
+
 
-def make_environment(storage_config):
+def make_environment(config):
     '''
-    Given a borgmatic storage configuration dict, return its options converted to a Borg environment
+    Given a borgmatic configuration dict, return its options converted to a Borg environment
     variable dict.
     '''
     environment = {}
 
     for option_name, environment_variable_name in OPTION_TO_ENVIRONMENT_VARIABLE.items():
-        value = storage_config.get(option_name)
+        value = config.get(option_name)
 
         if value:
-            environment[environment_variable_name] = value
+            environment[environment_variable_name] = str(value)
 
     for (
         option_name,
         environment_variable_name,
-    ) in DEFAULT_BOOL_OPTION_TO_ENVIRONMENT_VARIABLE.items():
-        value = storage_config.get(option_name, False)
+    ) in DEFAULT_BOOL_OPTION_TO_DOWNCASE_ENVIRONMENT_VARIABLE.items():
+        value = config.get(option_name, False)
         environment[environment_variable_name] = 'yes' if value else 'no'
 
+    for (
+        option_name,
+        environment_variable_name,
+    ) in DEFAULT_BOOL_OPTION_TO_UPPERCASE_ENVIRONMENT_VARIABLE.items():
+        value = config.get(option_name, False)
+        environment[environment_variable_name] = 'YES' if value else 'NO'
+
     return environment
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/export_tar.py` & `borgmatic-1.8.0/borgmatic/borg/export_tar.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,73 +1,74 @@
 import logging
-import os
 
 import borgmatic.logger
 from borgmatic.borg import environment, flags
 from borgmatic.execute import DO_NOT_CAPTURE, execute_command
 
 logger = logging.getLogger(__name__)
 
 
 def export_tar_archive(
     dry_run,
-    repository,
+    repository_path,
     archive,
     paths,
     destination_path,
-    storage_config,
+    config,
     local_borg_version,
+    global_arguments,
     local_path='borg',
     remote_path=None,
     tar_filter=None,
     list_files=False,
     strip_components=None,
 ):
     '''
     Given a dry-run flag, a local or remote repository path, an archive name, zero or more paths to
-    export from the archive, a destination path to export to, a storage configuration dict, the
-    local Borg version, optional local and remote Borg paths, an optional filter program, whether to
-    include per-file details, and an optional number of path components to strip, export the archive
-    into the given destination path as a tar-formatted file.
+    export from the archive, a destination path to export to, a configuration dict, the local Borg
+    version, optional local and remote Borg paths, an optional filter program, whether to include
+    per-file details, and an optional number of path components to strip, export the archive into
+    the given destination path as a tar-formatted file.
 
     If the destination path is "-", then stream the output to stdout instead of to a file.
     '''
     borgmatic.logger.add_custom_log_levels()
-    umask = storage_config.get('umask', None)
-    lock_wait = storage_config.get('lock_wait', None)
+    umask = config.get('umask', None)
+    lock_wait = config.get('lock_wait', None)
 
     full_command = (
         (local_path, 'export-tar')
         + (('--remote-path', remote_path) if remote_path else ())
         + (('--umask', str(umask)) if umask else ())
+        + (('--log-json',) if global_arguments.log_json else ())
         + (('--lock-wait', str(lock_wait)) if lock_wait else ())
         + (('--info',) if logger.getEffectiveLevel() == logging.INFO else ())
         + (('--list',) if list_files else ())
         + (('--debug', '--show-rc') if logger.isEnabledFor(logging.DEBUG) else ())
         + (('--dry-run',) if dry_run else ())
         + (('--tar-filter', tar_filter) if tar_filter else ())
         + (('--strip-components', str(strip_components)) if strip_components else ())
         + flags.make_repository_archive_flags(
-            repository if ':' in repository else os.path.abspath(repository),
+            repository_path,
             archive,
             local_borg_version,
         )
         + (destination_path,)
         + (tuple(paths) if paths else ())
     )
 
     if list_files:
         output_log_level = logging.ANSWER
     else:
         output_log_level = logging.INFO
 
     if dry_run:
-        logging.info('{}: Skipping export to tar file (dry run)'.format(repository))
+        logging.info(f'{repository_path}: Skipping export to tar file (dry run)')
         return
 
     execute_command(
         full_command,
         output_file=DO_NOT_CAPTURE if destination_path == '-' else None,
         output_log_level=output_log_level,
         borg_local_path=local_path,
-        extra_environment=environment.make_environment(storage_config),
+        extra_environment=environment.make_environment(config),
     )
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/extract.py` & `borgmatic-1.8.0/borgmatic/borg/extract.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,124 +1,136 @@
 import logging
 import os
 import subprocess
 
+import borgmatic.config.validate
 from borgmatic.borg import environment, feature, flags, rlist
 from borgmatic.execute import DO_NOT_CAPTURE, execute_command
 
 logger = logging.getLogger(__name__)
 
 
 def extract_last_archive_dry_run(
-    storage_config,
+    config,
     local_borg_version,
-    repository,
+    global_arguments,
+    repository_path,
     lock_wait=None,
     local_path='borg',
     remote_path=None,
 ):
     '''
     Perform an extraction dry-run of the most recent archive. If there are no archives, skip the
     dry-run.
     '''
-    remote_path_flags = ('--remote-path', remote_path) if remote_path else ()
-    lock_wait_flags = ('--lock-wait', str(lock_wait)) if lock_wait else ()
     verbosity_flags = ()
     if logger.isEnabledFor(logging.DEBUG):
         verbosity_flags = ('--debug', '--show-rc')
     elif logger.isEnabledFor(logging.INFO):
         verbosity_flags = ('--info',)
 
     try:
         last_archive_name = rlist.resolve_archive_name(
-            repository, 'latest', storage_config, local_borg_version, local_path, remote_path
+            repository_path,
+            'latest',
+            config,
+            local_borg_version,
+            global_arguments,
+            local_path,
+            remote_path,
         )
     except ValueError:
         logger.warning('No archives found. Skipping extract consistency check.')
         return
 
     list_flag = ('--list',) if logger.isEnabledFor(logging.DEBUG) else ()
-    borg_environment = environment.make_environment(storage_config)
+    borg_environment = environment.make_environment(config)
     full_extract_command = (
         (local_path, 'extract', '--dry-run')
-        + remote_path_flags
-        + lock_wait_flags
+        + (('--remote-path', remote_path) if remote_path else ())
+        + (('--log-json',) if global_arguments.log_json else ())
+        + (('--lock-wait', str(lock_wait)) if lock_wait else ())
         + verbosity_flags
         + list_flag
-        + flags.make_repository_archive_flags(repository, last_archive_name, local_borg_version)
+        + flags.make_repository_archive_flags(
+            repository_path, last_archive_name, local_borg_version
+        )
     )
 
     execute_command(
         full_extract_command, working_directory=None, extra_environment=borg_environment
     )
 
 
 def extract_archive(
     dry_run,
     repository,
     archive,
     paths,
-    location_config,
-    storage_config,
+    config,
     local_borg_version,
+    global_arguments,
     local_path='borg',
     remote_path=None,
     destination_path=None,
     strip_components=None,
     progress=False,
     extract_to_stdout=False,
 ):
     '''
     Given a dry-run flag, a local or remote repository path, an archive name, zero or more paths to
-    restore from the archive, the local Borg version string, location/storage configuration dicts,
-    optional local and remote Borg paths, and an optional destination path to extract to, extract
-    the archive into the current directory.
+    restore from the archive, the local Borg version string, an argparse.Namespace of global
+    arguments, a configuration dict, optional local and remote Borg paths, and an optional
+    destination path to extract to, extract the archive into the current directory.
 
     If extract to stdout is True, then start the extraction streaming to stdout, and return that
     extract process as an instance of subprocess.Popen.
     '''
-    umask = storage_config.get('umask', None)
-    lock_wait = storage_config.get('lock_wait', None)
+    umask = config.get('umask', None)
+    lock_wait = config.get('lock_wait', None)
 
     if progress and extract_to_stdout:
         raise ValueError('progress and extract_to_stdout cannot both be set')
 
     if feature.available(feature.Feature.NUMERIC_IDS, local_borg_version):
-        numeric_ids_flags = ('--numeric-ids',) if location_config.get('numeric_ids') else ()
+        numeric_ids_flags = ('--numeric-ids',) if config.get('numeric_ids') else ()
     else:
-        numeric_ids_flags = ('--numeric-owner',) if location_config.get('numeric_ids') else ()
+        numeric_ids_flags = ('--numeric-owner',) if config.get('numeric_ids') else ()
 
     if strip_components == 'all':
         if not paths:
             raise ValueError('The --strip-components flag with "all" requires at least one --path')
 
         # Calculate the maximum number of leading path components of the given paths.
         strip_components = max(0, *(len(path.split(os.path.sep)) - 1 for path in paths))
 
     full_command = (
         (local_path, 'extract')
         + (('--remote-path', remote_path) if remote_path else ())
         + numeric_ids_flags
         + (('--umask', str(umask)) if umask else ())
+        + (('--log-json',) if global_arguments.log_json else ())
         + (('--lock-wait', str(lock_wait)) if lock_wait else ())
         + (('--info',) if logger.getEffectiveLevel() == logging.INFO else ())
         + (('--debug', '--list', '--show-rc') if logger.isEnabledFor(logging.DEBUG) else ())
         + (('--dry-run',) if dry_run else ())
         + (('--strip-components', str(strip_components)) if strip_components else ())
         + (('--progress',) if progress else ())
         + (('--stdout',) if extract_to_stdout else ())
         + flags.make_repository_archive_flags(
-            repository if ':' in repository else os.path.abspath(repository),
+            # Make the repository path absolute so the working directory changes below don't
+            # prevent Borg from finding the repo.
+            borgmatic.config.validate.normalize_repository_path(repository),
             archive,
             local_borg_version,
         )
         + (tuple(paths) if paths else ())
     )
 
-    borg_environment = environment.make_environment(storage_config)
+    borg_environment = environment.make_environment(config)
 
     # The progress output isn't compatible with captured and logged output, as progress messes with
     # the terminal directly.
     if progress:
         return execute_command(
             full_command,
             output_file=DO_NOT_CAPTURE,
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/info.py` & `borgmatic-1.8.0/borgmatic/borg/rinfo.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,68 +3,63 @@
 import borgmatic.logger
 from borgmatic.borg import environment, feature, flags
 from borgmatic.execute import execute_command, execute_command_and_capture_output
 
 logger = logging.getLogger(__name__)
 
 
-def display_archives_info(
-    repository,
-    storage_config,
+def display_repository_info(
+    repository_path,
+    config,
     local_borg_version,
-    info_arguments,
+    rinfo_arguments,
+    global_arguments,
     local_path='borg',
     remote_path=None,
 ):
     '''
-    Given a local or remote repository path, a storage config dict, the local Borg version, and the
-    arguments to the info action, display summary information for Borg archives in the repository or
-    return JSON summary information.
+    Given a local or remote repository path, a configuration dict, the local Borg version, the
+    arguments to the rinfo action, and global arguments as an argparse.Namespace, display summary
+    information for the Borg repository or return JSON summary information.
     '''
     borgmatic.logger.add_custom_log_levels()
-    lock_wait = storage_config.get('lock_wait', None)
+    lock_wait = config.get('lock_wait', None)
 
     full_command = (
-        (local_path, 'info')
+        (local_path,)
+        + (
+            ('rinfo',)
+            if feature.available(feature.Feature.RINFO, local_borg_version)
+            else ('info',)
+        )
         + (
             ('--info',)
-            if logger.getEffectiveLevel() == logging.INFO and not info_arguments.json
+            if logger.getEffectiveLevel() == logging.INFO and not rinfo_arguments.json
             else ()
         )
         + (
             ('--debug', '--show-rc')
-            if logger.isEnabledFor(logging.DEBUG) and not info_arguments.json
+            if logger.isEnabledFor(logging.DEBUG) and not rinfo_arguments.json
             else ()
         )
         + flags.make_flags('remote-path', remote_path)
+        + flags.make_flags('log-json', global_arguments.log_json)
         + flags.make_flags('lock-wait', lock_wait)
-        + (
-            (
-                flags.make_flags('match-archives', f'sh:{info_arguments.prefix}*')
-                if feature.available(feature.Feature.MATCH_ARCHIVES, local_borg_version)
-                else flags.make_flags('glob-archives', f'{info_arguments.prefix}*')
-            )
-            if info_arguments.prefix
-            else ()
-        )
-        + flags.make_flags_from_arguments(
-            info_arguments, excludes=('repository', 'archive', 'prefix')
-        )
-        + flags.make_repository_flags(repository, local_borg_version)
-        + (
-            flags.make_flags('match-archives', info_arguments.archive)
-            if feature.available(feature.Feature.MATCH_ARCHIVES, local_borg_version)
-            else flags.make_flags('glob-archives', info_arguments.archive)
-        )
+        + (('--json',) if rinfo_arguments.json else ())
+        + flags.make_repository_flags(repository_path, local_borg_version)
     )
 
-    if info_arguments.json:
+    extra_environment = environment.make_environment(config)
+
+    if rinfo_arguments.json:
         return execute_command_and_capture_output(
-            full_command, extra_environment=environment.make_environment(storage_config),
+            full_command,
+            extra_environment=extra_environment,
+            borg_local_path=local_path,
         )
     else:
         execute_command(
             full_command,
             output_log_level=logging.ANSWER,
             borg_local_path=local_path,
-            extra_environment=environment.make_environment(storage_config),
+            extra_environment=extra_environment,
         )
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/list.py` & `borgmatic-1.8.0/borgmatic/borg/list.py`

 * *Files 8% similar despite different names*

```diff
@@ -10,56 +10,57 @@
 logger = logging.getLogger(__name__)
 
 
 ARCHIVE_FILTER_FLAGS_MOVED_TO_RLIST = ('prefix', 'match_archives', 'sort_by', 'first', 'last')
 MAKE_FLAGS_EXCLUDES = (
     'repository',
     'archive',
-    'successful',
     'paths',
     'find_paths',
 ) + ARCHIVE_FILTER_FLAGS_MOVED_TO_RLIST
 
 
 def make_list_command(
-    repository,
-    storage_config,
+    repository_path,
+    config,
     local_borg_version,
     list_arguments,
+    global_arguments,
     local_path='borg',
     remote_path=None,
 ):
     '''
-    Given a local or remote repository path, a storage config dict, the arguments to the list
-    action, and local and remote Borg paths, return a command as a tuple to list archives or paths
-    within an archive.
+    Given a local or remote repository path, a configuration dict, the arguments to the list action,
+    and local and remote Borg paths, return a command as a tuple to list archives or paths within an
+    archive.
     '''
-    lock_wait = storage_config.get('lock_wait', None)
+    lock_wait = config.get('lock_wait', None)
 
     return (
         (local_path, 'list')
         + (
             ('--info',)
             if logger.getEffectiveLevel() == logging.INFO and not list_arguments.json
             else ()
         )
         + (
             ('--debug', '--show-rc')
             if logger.isEnabledFor(logging.DEBUG) and not list_arguments.json
             else ()
         )
         + flags.make_flags('remote-path', remote_path)
+        + flags.make_flags('log-json', global_arguments.log_json)
         + flags.make_flags('lock-wait', lock_wait)
         + flags.make_flags_from_arguments(list_arguments, excludes=MAKE_FLAGS_EXCLUDES)
         + (
             flags.make_repository_archive_flags(
-                repository, list_arguments.archive, local_borg_version
+                repository_path, list_arguments.archive, local_borg_version
             )
             if list_arguments.archive
-            else flags.make_repository_flags(repository, local_borg_version)
+            else flags.make_repository_flags(repository_path, local_borg_version)
         )
         + (tuple(list_arguments.paths) if list_arguments.paths else ())
     )
 
 
 def make_find_paths(find_paths):
     '''
@@ -82,156 +83,171 @@
         if re.compile(r'([-!+RrPp] )|(\w\w:)').match(find_path)
         else f'sh:**/*{find_path}*/**'
         for find_path in find_paths
     )
 
 
 def capture_archive_listing(
-    repository,
+    repository_path,
     archive,
-    storage_config,
+    config,
     local_borg_version,
+    global_arguments,
     list_path=None,
     local_path='borg',
     remote_path=None,
 ):
     '''
-    Given a local or remote repository path, an archive name, a storage config dict, the local Borg
-    version, the archive path in which to list files, and local and remote Borg paths, capture the
-    output of listing that archive and return it as a list of file paths.
+    Given a local or remote repository path, an archive name, a configuration dict, the local Borg
+    version, global arguments as an argparse.Namespace, the archive path in which to list files, and
+    local and remote Borg paths, capture the output of listing that archive and return it as a list
+    of file paths.
     '''
-    borg_environment = environment.make_environment(storage_config)
+    borg_environment = environment.make_environment(config)
 
     return tuple(
         execute_command_and_capture_output(
             make_list_command(
-                repository,
-                storage_config,
+                repository_path,
+                config,
                 local_borg_version,
                 argparse.Namespace(
-                    repository=repository,
+                    repository=repository_path,
                     archive=archive,
                     paths=[f'sh:{list_path}'],
                     find_paths=None,
                     json=None,
-                    format='{path}{NL}',
+                    format='{path}{NL}',  # noqa: FS003
                 ),
+                global_arguments,
                 local_path,
                 remote_path,
             ),
             extra_environment=borg_environment,
+            borg_local_path=local_path,
         )
         .strip('\n')
         .split('\n')
     )
 
 
 def list_archive(
-    repository,
-    storage_config,
+    repository_path,
+    config,
     local_borg_version,
     list_arguments,
+    global_arguments,
     local_path='borg',
     remote_path=None,
 ):
     '''
-    Given a local or remote repository path, a storage config dict, the local Borg version, the
-    arguments to the list action, and local and remote Borg paths, display the output of listing
-    the files of a Borg archive (or return JSON output). If list_arguments.find_paths are given,
-    list the files by searching across multiple archives. If neither find_paths nor archive name
-    are given, instead list the archives in the given repository.
+    Given a local or remote repository path, a configuration dict, the local Borg version, global
+    arguments as an argparse.Namespace, the arguments to the list action as an argparse.Namespace,
+    and local and remote Borg paths, display the output of listing the files of a Borg archive (or
+    return JSON output). If list_arguments.find_paths are given, list the files by searching across
+    multiple archives. If neither find_paths nor archive name are given, instead list the archives
+    in the given repository.
     '''
     borgmatic.logger.add_custom_log_levels()
 
     if not list_arguments.archive and not list_arguments.find_paths:
         if feature.available(feature.Feature.RLIST, local_borg_version):
             logger.warning(
                 'Omitting the --archive flag on the list action is deprecated when using Borg 2.x+. Use the rlist action instead.'
             )
 
         rlist_arguments = argparse.Namespace(
-            repository=repository,
+            repository=repository_path,
             short=list_arguments.short,
             format=list_arguments.format,
             json=list_arguments.json,
             prefix=list_arguments.prefix,
             match_archives=list_arguments.match_archives,
             sort_by=list_arguments.sort_by,
             first=list_arguments.first,
             last=list_arguments.last,
         )
         return rlist.list_repository(
-            repository, storage_config, local_borg_version, rlist_arguments, local_path, remote_path
+            repository_path,
+            config,
+            local_borg_version,
+            rlist_arguments,
+            global_arguments,
+            local_path,
+            remote_path,
         )
 
     if list_arguments.archive:
         for name in ARCHIVE_FILTER_FLAGS_MOVED_TO_RLIST:
             if getattr(list_arguments, name, None):
                 logger.warning(
                     f"The --{name.replace('_', '-')} flag on the list action is ignored when using the --archive flag."
                 )
 
     if list_arguments.json:
         raise ValueError(
             'The --json flag on the list action is not supported when using the --archive/--find flags.'
         )
 
-    borg_environment = environment.make_environment(storage_config)
+    borg_environment = environment.make_environment(config)
 
     # If there are any paths to find (and there's not a single archive already selected), start by
     # getting a list of archives to search.
     if list_arguments.find_paths and not list_arguments.archive:
         rlist_arguments = argparse.Namespace(
-            repository=repository,
+            repository=repository_path,
             short=True,
             format=None,
             json=None,
             prefix=list_arguments.prefix,
             match_archives=list_arguments.match_archives,
             sort_by=list_arguments.sort_by,
             first=list_arguments.first,
             last=list_arguments.last,
         )
 
         # Ask Borg to list archives. Capture its output for use below.
         archive_lines = tuple(
             execute_command_and_capture_output(
                 rlist.make_rlist_command(
-                    repository,
-                    storage_config,
+                    repository_path,
+                    config,
                     local_borg_version,
                     rlist_arguments,
+                    global_arguments,
                     local_path,
                     remote_path,
                 ),
                 extra_environment=borg_environment,
+                borg_local_path=local_path,
             )
             .strip('\n')
             .split('\n')
         )
     else:
         archive_lines = (list_arguments.archive,)
 
     # For each archive listed by Borg, run list on the contents of that archive.
     for archive in archive_lines:
-        logger.answer(f'{repository}: Listing archive {archive}')
+        logger.answer(f'{repository_path}: Listing archive {archive}')
 
         archive_arguments = copy.copy(list_arguments)
         archive_arguments.archive = archive
 
         # This list call is to show the files in a single archive, not list multiple archives. So
         # blank out any archive filtering flags. They'll break anyway in Borg 2.
         for name in ARCHIVE_FILTER_FLAGS_MOVED_TO_RLIST:
             setattr(archive_arguments, name, None)
 
         main_command = make_list_command(
-            repository,
-            storage_config,
+            repository_path,
+            config,
             local_borg_version,
             archive_arguments,
+            global_arguments,
             local_path,
             remote_path,
         ) + make_find_paths(list_arguments.find_paths)
 
         execute_command(
             main_command,
             output_log_level=logging.ANSWER,
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/mount.py` & `borgmatic-1.8.0/borgmatic/borg/mount.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,67 +3,69 @@
 from borgmatic.borg import environment, feature, flags
 from borgmatic.execute import DO_NOT_CAPTURE, execute_command
 
 logger = logging.getLogger(__name__)
 
 
 def mount_archive(
-    repository,
+    repository_path,
     archive,
-    mount_point,
-    paths,
-    foreground,
-    options,
-    storage_config,
+    mount_arguments,
+    config,
     local_borg_version,
+    global_arguments,
     local_path='borg',
     remote_path=None,
 ):
     '''
     Given a local or remote repository path, an optional archive name, a filesystem mount point,
     zero or more paths to mount from the archive, extra Borg mount options, a storage configuration
-    dict, the local Borg version, and optional local and remote Borg paths, mount the archive onto
-    the mount point.
+    dict, the local Borg version, global arguments as an argparse.Namespace instance, and optional
+    local and remote Borg paths, mount the archive onto the mount point.
     '''
-    umask = storage_config.get('umask', None)
-    lock_wait = storage_config.get('lock_wait', None)
+    umask = config.get('umask', None)
+    lock_wait = config.get('lock_wait', None)
 
     full_command = (
         (local_path, 'mount')
         + (('--remote-path', remote_path) if remote_path else ())
         + (('--umask', str(umask)) if umask else ())
+        + (('--log-json',) if global_arguments.log_json else ())
         + (('--lock-wait', str(lock_wait)) if lock_wait else ())
         + (('--info',) if logger.getEffectiveLevel() == logging.INFO else ())
         + (('--debug', '--show-rc') if logger.isEnabledFor(logging.DEBUG) else ())
-        + (('--foreground',) if foreground else ())
-        + (('-o', options) if options else ())
+        + flags.make_flags_from_arguments(
+            mount_arguments,
+            excludes=('repository', 'archive', 'mount_point', 'paths', 'options'),
+        )
+        + (('-o', mount_arguments.options) if mount_arguments.options else ())
         + (
             (
-                flags.make_repository_flags(repository, local_borg_version)
+                flags.make_repository_flags(repository_path, local_borg_version)
                 + (
                     ('--match-archives', archive)
                     if feature.available(feature.Feature.MATCH_ARCHIVES, local_borg_version)
                     else ('--glob-archives', archive)
                 )
             )
             if feature.available(feature.Feature.SEPARATE_REPOSITORY_ARCHIVE, local_borg_version)
             else (
-                flags.make_repository_archive_flags(repository, archive, local_borg_version)
+                flags.make_repository_archive_flags(repository_path, archive, local_borg_version)
                 if archive
-                else flags.make_repository_flags(repository, local_borg_version)
+                else flags.make_repository_flags(repository_path, local_borg_version)
             )
         )
-        + (mount_point,)
-        + (tuple(paths) if paths else ())
+        + (mount_arguments.mount_point,)
+        + (tuple(mount_arguments.paths) if mount_arguments.paths else ())
     )
 
-    borg_environment = environment.make_environment(storage_config)
+    borg_environment = environment.make_environment(config)
 
     # Don't capture the output when foreground mode is used so that ctrl-C can work properly.
-    if foreground:
+    if mount_arguments.foreground:
         execute_command(
             full_command,
             output_file=DO_NOT_CAPTURE,
             borg_local_path=local_path,
             extra_environment=borg_environment,
         )
         return
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/prune.py` & `borgmatic-1.8.0/borgmatic/borg/rcreate.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,90 +1,86 @@
+import argparse
 import logging
+import subprocess
 
-import borgmatic.logger
-from borgmatic.borg import environment, feature, flags
-from borgmatic.execute import execute_command
+from borgmatic.borg import environment, feature, flags, rinfo
+from borgmatic.execute import DO_NOT_CAPTURE, execute_command
 
 logger = logging.getLogger(__name__)
 
 
-def make_prune_flags(retention_config, local_borg_version):
-    '''
-    Given a retention config dict mapping from option name to value, tranform it into an iterable of
-    command-line name-value flag pairs.
-
-    For example, given a retention config of:
-
-        {'keep_weekly': 4, 'keep_monthly': 6}
-
-    This will be returned as an iterable of:
+RINFO_REPOSITORY_NOT_FOUND_EXIT_CODE = 2
 
-        (
-            ('--keep-weekly', '4'),
-            ('--keep-monthly', '6'),
-        )
-    '''
-    config = retention_config.copy()
-    prefix = config.pop('prefix', '{hostname}-')
 
-    if prefix:
-        if feature.available(feature.Feature.MATCH_ARCHIVES, local_borg_version):
-            config['match_archives'] = f'sh:{prefix}*'
-        else:
-            config['glob_archives'] = f'{prefix}*'
-
-    return (
-        ('--' + option_name.replace('_', '-'), str(value)) for option_name, value in config.items()
-    )
-
-
-def prune_archives(
+def create_repository(
     dry_run,
-    repository,
-    storage_config,
-    retention_config,
+    repository_path,
+    config,
     local_borg_version,
+    global_arguments,
+    encryption_mode,
+    source_repository=None,
+    copy_crypt_key=False,
+    append_only=None,
+    storage_quota=None,
+    make_parent_dirs=False,
     local_path='borg',
     remote_path=None,
-    stats=False,
-    list_archives=False,
 ):
     '''
-    Given dry-run flag, a local or remote repository path, a storage config dict, and a
-    retention config dict, prune Borg archives according to the retention policy specified in that
-    configuration.
+    Given a dry-run flag, a local or remote repository path, a configuration dict, the local Borg
+    version, a Borg encryption mode, the path to another repo whose key material should be reused,
+    whether the repository should be append-only, and the storage quota to use, create the
+    repository. If the repository already exists, then log and skip creation.
     '''
-    borgmatic.logger.add_custom_log_levels()
-    umask = storage_config.get('umask', None)
-    lock_wait = storage_config.get('lock_wait', None)
-    extra_borg_options = storage_config.get('extra_borg_options', {}).get('prune', '')
-
-    full_command = (
-        (local_path, 'prune')
-        + tuple(
-            element
-            for pair in make_prune_flags(retention_config, local_borg_version)
-            for element in pair
+    try:
+        rinfo.display_repository_info(
+            repository_path,
+            config,
+            local_borg_version,
+            argparse.Namespace(json=True),
+            global_arguments,
+            local_path,
+            remote_path,
         )
-        + (('--remote-path', remote_path) if remote_path else ())
-        + (('--umask', str(umask)) if umask else ())
-        + (('--lock-wait', str(lock_wait)) if lock_wait else ())
-        + (('--stats',) if stats and not dry_run else ())
+        logger.info(f'{repository_path}: Repository already exists. Skipping creation.')
+        return
+    except subprocess.CalledProcessError as error:
+        if error.returncode != RINFO_REPOSITORY_NOT_FOUND_EXIT_CODE:
+            raise
+
+    lock_wait = config.get('lock_wait')
+    extra_borg_options = config.get('extra_borg_options', {}).get('rcreate', '')
+
+    rcreate_command = (
+        (local_path,)
+        + (
+            ('rcreate',)
+            if feature.available(feature.Feature.RCREATE, local_borg_version)
+            else ('init',)
+        )
+        + (('--encryption', encryption_mode) if encryption_mode else ())
+        + (('--other-repo', source_repository) if source_repository else ())
+        + (('--copy-crypt-key',) if copy_crypt_key else ())
+        + (('--append-only',) if append_only else ())
+        + (('--storage-quota', storage_quota) if storage_quota else ())
+        + (('--make-parent-dirs',) if make_parent_dirs else ())
         + (('--info',) if logger.getEffectiveLevel() == logging.INFO else ())
-        + (('--list',) if list_archives else ())
-        + (('--debug', '--show-rc') if logger.isEnabledFor(logging.DEBUG) else ())
-        + (('--dry-run',) if dry_run else ())
+        + (('--debug',) if logger.isEnabledFor(logging.DEBUG) else ())
+        + (('--log-json',) if global_arguments.log_json else ())
+        + (('--lock-wait', str(lock_wait)) if lock_wait else ())
+        + (('--remote-path', remote_path) if remote_path else ())
         + (tuple(extra_borg_options.split(' ')) if extra_borg_options else ())
-        + flags.make_repository_flags(repository, local_borg_version)
+        + flags.make_repository_flags(repository_path, local_borg_version)
     )
 
-    if stats or list_archives:
-        output_log_level = logging.ANSWER
-    else:
-        output_log_level = logging.INFO
+    if dry_run:
+        logging.info(f'{repository_path}: Skipping repository creation (dry run)')
+        return
 
+    # Do not capture output here, so as to support interactive prompts.
     execute_command(
-        full_command,
-        output_log_level=output_log_level,
+        rcreate_command,
+        output_file=DO_NOT_CAPTURE,
         borg_local_path=local_path,
-        extra_environment=environment.make_environment(storage_config),
+        extra_environment=environment.make_environment(config),
     )
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/rinfo.py` & `borgmatic-1.8.0/borgmatic/borg/info.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,59 +3,75 @@
 import borgmatic.logger
 from borgmatic.borg import environment, feature, flags
 from borgmatic.execute import execute_command, execute_command_and_capture_output
 
 logger = logging.getLogger(__name__)
 
 
-def display_repository_info(
-    repository,
-    storage_config,
+def display_archives_info(
+    repository_path,
+    config,
     local_borg_version,
-    rinfo_arguments,
+    info_arguments,
+    global_arguments,
     local_path='borg',
     remote_path=None,
 ):
     '''
-    Given a local or remote repository path, a storage config dict, the local Borg version, and the
-    arguments to the rinfo action, display summary information for the Borg repository or return
-    JSON summary information.
+    Given a local or remote repository path, a configuration dict, the local Borg version, global
+    arguments as an argparse.Namespace, and the arguments to the info action, display summary
+    information for Borg archives in the repository or return JSON summary information.
     '''
     borgmatic.logger.add_custom_log_levels()
-    lock_wait = storage_config.get('lock_wait', None)
+    lock_wait = config.get('lock_wait', None)
 
     full_command = (
-        (local_path,)
-        + (
-            ('rinfo',)
-            if feature.available(feature.Feature.RINFO, local_borg_version)
-            else ('info',)
-        )
+        (local_path, 'info')
         + (
             ('--info',)
-            if logger.getEffectiveLevel() == logging.INFO and not rinfo_arguments.json
+            if logger.getEffectiveLevel() == logging.INFO and not info_arguments.json
             else ()
         )
         + (
             ('--debug', '--show-rc')
-            if logger.isEnabledFor(logging.DEBUG) and not rinfo_arguments.json
+            if logger.isEnabledFor(logging.DEBUG) and not info_arguments.json
             else ()
         )
         + flags.make_flags('remote-path', remote_path)
+        + flags.make_flags('log-json', global_arguments.log_json)
         + flags.make_flags('lock-wait', lock_wait)
-        + (('--json',) if rinfo_arguments.json else ())
-        + flags.make_repository_flags(repository, local_borg_version)
+        + (
+            (
+                flags.make_flags('match-archives', f'sh:{info_arguments.prefix}*')
+                if feature.available(feature.Feature.MATCH_ARCHIVES, local_borg_version)
+                else flags.make_flags('glob-archives', f'{info_arguments.prefix}*')
+            )
+            if info_arguments.prefix
+            else (
+                flags.make_match_archives_flags(
+                    info_arguments.match_archives
+                    or info_arguments.archive
+                    or config.get('match_archives'),
+                    config.get('archive_name_format'),
+                    local_borg_version,
+                )
+            )
+        )
+        + flags.make_flags_from_arguments(
+            info_arguments, excludes=('repository', 'archive', 'prefix', 'match_archives')
+        )
+        + flags.make_repository_flags(repository_path, local_borg_version)
     )
 
-    extra_environment = environment.make_environment(storage_config)
-
-    if rinfo_arguments.json:
+    if info_arguments.json:
         return execute_command_and_capture_output(
-            full_command, extra_environment=extra_environment,
+            full_command,
+            extra_environment=environment.make_environment(config),
+            borg_local_path=local_path,
         )
     else:
         execute_command(
             full_command,
             output_log_level=logging.ANSWER,
             borg_local_path=local_path,
-            extra_environment=extra_environment,
+            extra_environment=environment.make_environment(config),
         )
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/rlist.py` & `borgmatic-1.8.0/borgmatic/borg/rlist.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,71 +4,78 @@
 from borgmatic.borg import environment, feature, flags
 from borgmatic.execute import execute_command, execute_command_and_capture_output
 
 logger = logging.getLogger(__name__)
 
 
 def resolve_archive_name(
-    repository, archive, storage_config, local_borg_version, local_path='borg', remote_path=None
+    repository_path,
+    archive,
+    config,
+    local_borg_version,
+    global_arguments,
+    local_path='borg',
+    remote_path=None,
 ):
     '''
-    Given a local or remote repository path, an archive name, a storage config dict, a local Borg
-    path, and a remote Borg path, simply return the archive name. But if the archive name is
-    "latest", then instead introspect the repository for the latest archive and return its name.
+    Given a local or remote repository path, an archive name, a configuration dict, the local Borg
+    version, global arguments as an argparse.Namespace, a local Borg path, and a remote Borg path,
+    return the archive name. But if the archive name is "latest", then instead introspect the
+    repository for the latest archive and return its name.
 
     Raise ValueError if "latest" is given but there are no archives in the repository.
     '''
     if archive != 'latest':
         return archive
 
-    lock_wait = storage_config.get('lock_wait', None)
-
     full_command = (
         (
             local_path,
             'rlist' if feature.available(feature.Feature.RLIST, local_borg_version) else 'list',
         )
         + flags.make_flags('remote-path', remote_path)
-        + flags.make_flags('lock-wait', lock_wait)
+        + flags.make_flags('log-json', global_arguments.log_json)
+        + flags.make_flags('lock-wait', config.get('lock_wait'))
         + flags.make_flags('last', 1)
         + ('--short',)
-        + flags.make_repository_flags(repository, local_borg_version)
+        + flags.make_repository_flags(repository_path, local_borg_version)
     )
 
     output = execute_command_and_capture_output(
-        full_command, extra_environment=environment.make_environment(storage_config),
+        full_command,
+        extra_environment=environment.make_environment(config),
+        borg_local_path=local_path,
     )
     try:
         latest_archive = output.strip().splitlines()[-1]
     except IndexError:
         raise ValueError('No archives found in the repository')
 
-    logger.debug('{}: Latest archive is {}'.format(repository, latest_archive))
+    logger.debug(f'{repository_path}: Latest archive is {latest_archive}')
 
     return latest_archive
 
 
-MAKE_FLAGS_EXCLUDES = ('repository', 'prefix')
+MAKE_FLAGS_EXCLUDES = ('repository', 'prefix', 'match_archives')
 
 
 def make_rlist_command(
-    repository,
-    storage_config,
+    repository_path,
+    config,
     local_borg_version,
     rlist_arguments,
+    global_arguments,
     local_path='borg',
     remote_path=None,
 ):
     '''
-    Given a local or remote repository path, a storage config dict, the local Borg version, the
-    arguments to the rlist action, and local and remote Borg paths, return a command as a tuple to
-    list archives with a repository.
+    Given a local or remote repository path, a configuration dict, the local Borg version, the
+    arguments to the rlist action, global arguments as an argparse.Namespace instance, and local and
+    remote Borg paths, return a command as a tuple to list archives with a repository.
     '''
-    lock_wait = storage_config.get('lock_wait', None)
-
     return (
         (
             local_path,
             'rlist' if feature.available(feature.Feature.RLIST, local_borg_version) else 'list',
         )
         + (
             ('--info',)
@@ -77,51 +84,68 @@
         )
         + (
             ('--debug', '--show-rc')
             if logger.isEnabledFor(logging.DEBUG) and not rlist_arguments.json
             else ()
         )
         + flags.make_flags('remote-path', remote_path)
-        + flags.make_flags('lock-wait', lock_wait)
+        + flags.make_flags('log-json', global_arguments.log_json)
+        + flags.make_flags('lock-wait', config.get('lock_wait'))
         + (
             (
                 flags.make_flags('match-archives', f'sh:{rlist_arguments.prefix}*')
                 if feature.available(feature.Feature.MATCH_ARCHIVES, local_borg_version)
                 else flags.make_flags('glob-archives', f'{rlist_arguments.prefix}*')
             )
             if rlist_arguments.prefix
-            else ()
+            else (
+                flags.make_match_archives_flags(
+                    rlist_arguments.match_archives or config.get('match_archives'),
+                    config.get('archive_name_format'),
+                    local_borg_version,
+                )
+            )
         )
         + flags.make_flags_from_arguments(rlist_arguments, excludes=MAKE_FLAGS_EXCLUDES)
-        + flags.make_repository_flags(repository, local_borg_version)
+        + flags.make_repository_flags(repository_path, local_borg_version)
     )
 
 
 def list_repository(
-    repository,
-    storage_config,
+    repository_path,
+    config,
     local_borg_version,
     rlist_arguments,
+    global_arguments,
     local_path='borg',
     remote_path=None,
 ):
     '''
-    Given a local or remote repository path, a storage config dict, the local Borg version, the
-    arguments to the list action, and local and remote Borg paths, display the output of listing
-    Borg archives in the given repository (or return JSON output).
+    Given a local or remote repository path, a configuration dict, the local Borg version, the
+    arguments to the list action, global arguments as an argparse.Namespace instance, and local and
+    remote Borg paths, display the output of listing Borg archives in the given repository (or
+    return JSON output).
     '''
     borgmatic.logger.add_custom_log_levels()
-    borg_environment = environment.make_environment(storage_config)
+    borg_environment = environment.make_environment(config)
 
     main_command = make_rlist_command(
-        repository, storage_config, local_borg_version, rlist_arguments, local_path, remote_path
+        repository_path,
+        config,
+        local_borg_version,
+        rlist_arguments,
+        global_arguments,
+        local_path,
+        remote_path,
     )
 
     if rlist_arguments.json:
-        return execute_command_and_capture_output(main_command, extra_environment=borg_environment,)
+        return execute_command_and_capture_output(
+            main_command, extra_environment=borg_environment, borg_local_path=local_path
+        )
     else:
         execute_command(
             main_command,
             output_log_level=logging.ANSWER,
             borg_local_path=local_path,
             extra_environment=borg_environment,
         )
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/transfer.py` & `borgmatic-1.8.0/borgmatic/borg/transfer.py`

 * *Files 22% similar despite different names*

```diff
@@ -5,48 +5,56 @@
 from borgmatic.execute import DO_NOT_CAPTURE, execute_command
 
 logger = logging.getLogger(__name__)
 
 
 def transfer_archives(
     dry_run,
-    repository,
-    storage_config,
+    repository_path,
+    config,
     local_borg_version,
     transfer_arguments,
+    global_arguments,
     local_path='borg',
     remote_path=None,
 ):
     '''
-    Given a dry-run flag, a local or remote repository path, a storage config dict, the local Borg
-    version, and the arguments to the transfer action, transfer archives to the given repository.
+    Given a dry-run flag, a local or remote repository path, a configuration dict, the local Borg
+    version, the arguments to the transfer action, and global arguments as an argparse.Namespace
+    instance, transfer archives to the given repository.
     '''
     borgmatic.logger.add_custom_log_levels()
 
     full_command = (
         (local_path, 'transfer')
         + (('--info',) if logger.getEffectiveLevel() == logging.INFO else ())
         + (('--debug', '--show-rc') if logger.isEnabledFor(logging.DEBUG) else ())
         + flags.make_flags('remote-path', remote_path)
-        + flags.make_flags('lock-wait', storage_config.get('lock_wait', None))
-        + (('--progress',) if transfer_arguments.progress else ())
+        + flags.make_flags('log-json', global_arguments.log_json)
+        + flags.make_flags('lock-wait', config.get('lock_wait', None))
         + (
-            flags.make_flags(
-                'match-archives', transfer_arguments.match_archives or transfer_arguments.archive
+            flags.make_flags_from_arguments(
+                transfer_arguments,
+                excludes=('repository', 'source_repository', 'archive', 'match_archives'),
+            )
+            or (
+                flags.make_match_archives_flags(
+                    transfer_arguments.match_archives
+                    or transfer_arguments.archive
+                    or config.get('match_archives'),
+                    config.get('archive_name_format'),
+                    local_borg_version,
+                )
             )
         )
-        + flags.make_flags_from_arguments(
-            transfer_arguments,
-            excludes=('repository', 'source_repository', 'archive', 'match_archives'),
-        )
-        + flags.make_repository_flags(repository, local_borg_version)
+        + flags.make_repository_flags(repository_path, local_borg_version)
         + flags.make_flags('other-repo', transfer_arguments.source_repository)
         + flags.make_flags('dry-run', dry_run)
     )
 
     return execute_command(
         full_command,
         output_log_level=logging.ANSWER,
         output_file=DO_NOT_CAPTURE if transfer_arguments.progress else None,
         borg_local_path=local_path,
-        extra_environment=environment.make_environment(storage_config),
+        extra_environment=environment.make_environment(config),
     )
```

### Comparing `borgmatic-1.7.9/borgmatic/borg/umount.py` & `borgmatic-1.8.0/borgmatic/borg/umount.py`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/borgmatic/borg/version.py` & `borgmatic-1.8.0/borgmatic/borg/version.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,27 +2,29 @@
 
 from borgmatic.borg import environment
 from borgmatic.execute import execute_command_and_capture_output
 
 logger = logging.getLogger(__name__)
 
 
-def local_borg_version(storage_config, local_path='borg'):
+def local_borg_version(config, local_path='borg'):
     '''
-    Given a storage configuration dict and a local Borg binary path, return a version string for it.
+    Given a configuration dict and a local Borg binary path, return a version string for it.
 
     Raise OSError or CalledProcessError if there is a problem running Borg.
     Raise ValueError if the version cannot be parsed.
     '''
     full_command = (
         (local_path, '--version')
         + (('--info',) if logger.getEffectiveLevel() == logging.INFO else ())
         + (('--debug', '--show-rc') if logger.isEnabledFor(logging.DEBUG) else ())
     )
     output = execute_command_and_capture_output(
-        full_command, extra_environment=environment.make_environment(storage_config),
+        full_command,
+        extra_environment=environment.make_environment(config),
+        borg_local_path=local_path,
     )
 
     try:
         return output.split(' ')[1].strip()
     except IndexError:
         raise ValueError('Could not parse Borg version string')
```

### Comparing `borgmatic-1.7.9/borgmatic/commands/arguments.py` & `borgmatic-1.8.0/borgmatic/commands/arguments.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,18 +1,21 @@
 import collections
-from argparse import Action, ArgumentParser
+import itertools
+import sys
+from argparse import ArgumentParser
 
 from borgmatic.config import collect
 
-SUBPARSER_ALIASES = {
+ACTION_ALIASES = {
     'rcreate': ['init', '-I'],
     'prune': ['-p'],
     'compact': [],
     'create': ['-C'],
     'check': ['-k'],
+    'config': [],
     'extract': ['-x'],
     'export-tar': [],
     'mount': ['-m'],
     'umount': ['-u'],
     'restore': ['-r'],
     'rlist': [],
     'list': ['-l'],
@@ -20,129 +23,228 @@
     'info': ['-i'],
     'transfer': [],
     'break-lock': [],
     'borg': [],
 }
 
 
-def parse_subparser_arguments(unparsed_arguments, subparsers):
+def get_subaction_parsers(action_parser):
     '''
-    Given a sequence of arguments and a dict from subparser name to argparse.ArgumentParser
-    instance, give each requested action's subparser a shot at parsing all arguments. This allows
-    common arguments like "--repository" to be shared across multiple subparsers.
+    Given an argparse.ArgumentParser instance, lookup the subactions in it and return a dict from
+    subaction name to subaction parser.
+    '''
+    if not action_parser._subparsers:
+        return {}
+
+    return {
+        subaction_name: subaction_parser
+        for group_action in action_parser._subparsers._group_actions
+        for subaction_name, subaction_parser in group_action.choices.items()
+    }
 
-    Return the result as a tuple of (a dict mapping from subparser name to a parsed namespace of
-    arguments, a list of remaining arguments not claimed by any subparser).
+
+def get_subactions_for_actions(action_parsers):
     '''
-    arguments = collections.OrderedDict()
-    remaining_arguments = list(unparsed_arguments)
-    alias_to_subparser_name = {
-        alias: subparser_name
-        for subparser_name, aliases in SUBPARSER_ALIASES.items()
-        for alias in aliases
+    Given a dict from action name to an argparse.ArgumentParser instance, make a map from action
+    name to the names of contained sub-actions.
+    '''
+    return {
+        action: tuple(
+            subaction_name
+            for group_action in action_parser._subparsers._group_actions
+            for subaction_name in group_action.choices.keys()
+        )
+        for action, action_parser in action_parsers.items()
+        if action_parser._subparsers
     }
 
-    # If the "borg" action is used, skip all other subparsers. This avoids confusion like
-    # "borg list" triggering borgmatic's own list action.
-    if 'borg' in unparsed_arguments:
-        subparsers = {'borg': subparsers['borg']}
 
-    for argument in remaining_arguments:
-        canonical_name = alias_to_subparser_name.get(argument, argument)
-        subparser = subparsers.get(canonical_name)
+def omit_values_colliding_with_action_names(unparsed_arguments, parsed_arguments):
+    '''
+    Given a sequence of string arguments and a dict from action name to parsed argparse.Namespace
+    arguments, return the string arguments with any values omitted that happen to be the same as
+    the name of a borgmatic action.
 
-        if not subparser:
-            continue
+    This prevents, for instance, "check --only extract" from triggering the "extract" action.
+    '''
+    remaining_arguments = list(unparsed_arguments)
 
-        # If a parsed value happens to be the same as the name of a subparser, remove it from the
-        # remaining arguments. This prevents, for instance, "check --only extract" from triggering
-        # the "extract" subparser.
-        parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)
+    for action_name, parsed in parsed_arguments.items():
         for value in vars(parsed).values():
             if isinstance(value, str):
-                if value in subparsers:
+                if value in ACTION_ALIASES.keys():
                     remaining_arguments.remove(value)
             elif isinstance(value, list):
                 for item in value:
-                    if item in subparsers:
+                    if item in ACTION_ALIASES.keys():
                         remaining_arguments.remove(item)
 
-        arguments[canonical_name] = parsed
+    return tuple(remaining_arguments)
 
-    # If no actions are explicitly requested, assume defaults.
-    if not arguments and '--help' not in unparsed_arguments and '-h' not in unparsed_arguments:
-        for subparser_name in ('create', 'prune', 'compact', 'check'):
-            subparser = subparsers[subparser_name]
-            parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)
-            arguments[subparser_name] = parsed
 
-    remaining_arguments = list(unparsed_arguments)
+def parse_and_record_action_arguments(
+    unparsed_arguments, parsed_arguments, action_parser, action_name, canonical_name=None
+):
+    '''
+    Given unparsed arguments as a sequence of strings, parsed arguments as a dict from action name
+    to parsed argparse.Namespace, a parser to parse with, an action name, and an optional canonical
+    action name (in case this the action name is an alias), parse the arguments and return a list of
+    any remaining string arguments that were not parsed. Also record the parsed argparse.Namespace
+    by setting it into the given parsed arguments. Return None if no parsing occurs because the
+    given action doesn't apply to the given unparsed arguments.
+    '''
+    filtered_arguments = omit_values_colliding_with_action_names(
+        unparsed_arguments, parsed_arguments
+    )
 
-    # Now ask each subparser, one by one, to greedily consume arguments.
-    for subparser_name, subparser in subparsers.items():
-        if subparser_name not in arguments.keys():
-            continue
+    if action_name not in filtered_arguments:
+        return tuple(unparsed_arguments)
+
+    parsed, remaining = action_parser.parse_known_args(filtered_arguments)
+    parsed_arguments[canonical_name or action_name] = parsed
+
+    # Special case: If this is a "borg" action, greedily consume all arguments after (+1) the "borg"
+    # argument.
+    if action_name == 'borg':
+        borg_options_index = remaining.index('borg') + 1
+        parsed_arguments['borg'].options = remaining[borg_options_index:]
+        remaining = remaining[:borg_options_index]
 
-        subparser = subparsers[subparser_name]
-        unused_parsed, remaining_arguments = subparser.parse_known_args(remaining_arguments)
+    return tuple(argument for argument in remaining if argument != action_name)
 
-    # Special case: If "borg" is present in the arguments, consume all arguments after (+1) the
-    # "borg" action.
-    if 'borg' in arguments:
-        borg_options_index = remaining_arguments.index('borg') + 1
-        arguments['borg'].options = remaining_arguments[borg_options_index:]
-        remaining_arguments = remaining_arguments[:borg_options_index]
 
-    # Remove the subparser names themselves.
-    for subparser_name, subparser in subparsers.items():
-        if subparser_name in remaining_arguments:
-            remaining_arguments.remove(subparser_name)
+def get_unparsable_arguments(remaining_action_arguments):
+    '''
+    Given a sequence of argument tuples (one per action parser that parsed arguments), determine the
+    remaining arguments that no action parsers have consumed.
+    '''
+    if not remaining_action_arguments:
+        return ()
 
-    return (arguments, remaining_arguments)
+    return tuple(
+        argument
+        for argument in dict.fromkeys(
+            itertools.chain.from_iterable(remaining_action_arguments)
+        ).keys()
+        if all(argument in action_arguments for action_arguments in remaining_action_arguments)
+    )
 
 
-class Extend_action(Action):
+def parse_arguments_for_actions(unparsed_arguments, action_parsers, global_parser):
     '''
-    An argparse action to support Python 3.8's "extend" action in older versions of Python.
+    Given a sequence of arguments, a dict from action name to argparse.ArgumentParser instance,
+    and the global parser as a argparse.ArgumentParser instance, give each requested action's
+    parser a shot at parsing all arguments. This allows common arguments like "--repository" to be
+    shared across multiple action parsers.
+
+    Return the result as a tuple of: (a dict mapping from action name to an argparse.Namespace of
+    parsed arguments, a tuple of argument tuples where each is the remaining arguments not claimed
+    by any action parser).
     '''
+    arguments = collections.OrderedDict()
+    help_requested = bool('--help' in unparsed_arguments or '-h' in unparsed_arguments)
+    remaining_action_arguments = []
+    alias_to_action_name = {
+        alias: action_name for action_name, aliases in ACTION_ALIASES.items() for alias in aliases
+    }
+
+    # If the "borg" action is used, skip all other action parsers. This avoids confusion like
+    # "borg list" triggering borgmatic's own list action.
+    if 'borg' in unparsed_arguments:
+        action_parsers = {'borg': action_parsers['borg']}
+
+    # Ask each action parser, one by one, to parse arguments.
+    for argument in unparsed_arguments:
+        action_name = argument
+        canonical_name = alias_to_action_name.get(action_name, action_name)
+        action_parser = action_parsers.get(action_name)
 
-    def __call__(self, parser, namespace, values, option_string=None):
-        items = getattr(namespace, self.dest, None)
+        if not action_parser:
+            continue
+
+        subaction_parsers = get_subaction_parsers(action_parser)
 
-        if items:
-            items.extend(values)
+        # But first parse with subaction parsers, if any.
+        if subaction_parsers:
+            subactions_parsed = False
+
+            for subaction_name, subaction_parser in subaction_parsers.items():
+                remaining_action_arguments.append(
+                    tuple(
+                        argument
+                        for argument in parse_and_record_action_arguments(
+                            unparsed_arguments,
+                            arguments,
+                            subaction_parser,
+                            subaction_name,
+                        )
+                        if argument != action_name
+                    )
+                )
+
+                if subaction_name in arguments:
+                    subactions_parsed = True
+
+            if not subactions_parsed:
+                if help_requested:
+                    action_parser.print_help()
+                    sys.exit(0)
+                else:
+                    raise ValueError(
+                        f"Missing sub-action after {action_name} action. Expected one of: {', '.join(get_subactions_for_actions(action_parsers)[action_name])}"
+                    )
+        # Otherwise, parse with the main action parser.
         else:
-            setattr(namespace, self.dest, list(values))
+            remaining_action_arguments.append(
+                parse_and_record_action_arguments(
+                    unparsed_arguments, arguments, action_parser, action_name, canonical_name
+                )
+            )
+
+    # If no actions were explicitly requested, assume defaults.
+    if not arguments and not help_requested:
+        for default_action_name in ('create', 'prune', 'compact', 'check'):
+            default_action_parser = action_parsers[default_action_name]
+            remaining_action_arguments.append(
+                parse_and_record_action_arguments(
+                    tuple(unparsed_arguments) + (default_action_name,),
+                    arguments,
+                    default_action_parser,
+                    default_action_name,
+                )
+            )
+
+    arguments['global'], remaining = global_parser.parse_known_args(unparsed_arguments)
+    remaining_action_arguments.append(remaining)
+
+    return (
+        arguments,
+        tuple(remaining_action_arguments) if arguments else unparsed_arguments,
+    )
 
 
 def make_parsers():
     '''
-    Build a top-level parser and its subparsers and return them as a tuple.
+    Build a global arguments parser, individual action parsers, and a combined parser containing
+    both. Return them as a tuple. The global parser is useful for parsing just global arguments
+    while ignoring actions, and the combined parser is handy for displaying help that includes
+    everything: global flags, a list of actions, etc.
     '''
     config_paths = collect.get_default_config_paths(expand_home=True)
     unexpanded_config_paths = collect.get_default_config_paths(expand_home=False)
 
     global_parser = ArgumentParser(add_help=False)
-    global_parser.register('action', 'extend', Extend_action)
     global_group = global_parser.add_argument_group('global arguments')
 
     global_group.add_argument(
         '-c',
         '--config',
-        nargs='*',
         dest='config_paths',
-        default=config_paths,
-        help='Configuration filenames or directories, defaults to: {}'.format(
-            ' '.join(unexpanded_config_paths)
-        ),
-    )
-    global_group.add_argument(
-        '--excludes',
-        dest='excludes_filename',
-        help='Deprecated in favor of exclude_patterns within configuration',
+        action='append',
+        help=f"Configuration filename or directory, can specify flag multiple times, defaults to: {' '.join(unexpanded_config_paths)}",
     )
     global_group.add_argument(
         '-n',
         '--dry-run',
         dest='dry_run',
         action='store_true',
         help='Go through the motions, but do not actually write to any repositories',
@@ -150,90 +252,104 @@
     global_group.add_argument(
         '-nc', '--no-color', dest='no_color', action='store_true', help='Disable colored output'
     )
     global_group.add_argument(
         '-v',
         '--verbosity',
         type=int,
-        choices=range(-1, 3),
+        choices=range(-2, 3),
         default=0,
-        help='Display verbose progress to the console (from only errors to very verbose: -1, 0, 1, or 2)',
+        help='Display verbose progress to the console (disabled, errors only, default, some, or lots: -2, -1, 0, 1, or 2)',
     )
     global_group.add_argument(
         '--syslog-verbosity',
         type=int,
-        choices=range(-1, 3),
+        choices=range(-2, 3),
         default=0,
-        help='Log verbose progress to syslog (from only errors to very verbose: -1, 0, 1, or 2). Ignored when console is interactive or --log-file is given',
+        help='Log verbose progress to syslog (disabled, errors only, default, some, or lots: -2, -1, 0, 1, or 2). Ignored when console is interactive or --log-file is given',
     )
     global_group.add_argument(
         '--log-file-verbosity',
         type=int,
-        choices=range(-1, 3),
+        choices=range(-2, 3),
         default=0,
-        help='Log verbose progress to log file (from only errors to very verbose: -1, 0, 1, or 2). Only used when --log-file is given',
+        help='Log verbose progress to log file (disabled, errors only, default, some, or lots: -2, -1, 0, 1, or 2). Only used when --log-file is given',
     )
     global_group.add_argument(
         '--monitoring-verbosity',
         type=int,
-        choices=range(-1, 3),
+        choices=range(-2, 3),
         default=0,
-        help='Log verbose progress to monitoring integrations that support logging (from only errors to very verbose: -1, 0, 1, or 2)',
+        help='Log verbose progress to monitoring integrations that support logging (from disabled, errors only, default, some, or lots: -2, -1, 0, 1, or 2)',
     )
     global_group.add_argument(
         '--log-file',
         type=str,
-        default=None,
         help='Write log messages to this file instead of syslog',
     )
     global_group.add_argument(
+        '--log-file-format',
+        type=str,
+        help='Log format string used for log messages written to the log file',
+    )
+    global_group.add_argument(
+        '--log-json',
+        action='store_true',
+        help='Write log messages and console output as one JSON object per log line instead of formatted text',
+    )
+    global_group.add_argument(
         '--override',
-        metavar='SECTION.OPTION=VALUE',
-        nargs='+',
+        metavar='OPTION.SUBOPTION=VALUE',
         dest='overrides',
-        action='extend',
-        help='One or more configuration file options to override with specified values',
+        action='append',
+        help='Configuration file option to override with specified value, can specify flag multiple times',
     )
     global_group.add_argument(
         '--no-environment-interpolation',
         dest='resolve_env',
         action='store_false',
         help='Do not resolve environment variables in configuration file',
     )
     global_group.add_argument(
         '--bash-completion',
         default=False,
         action='store_true',
         help='Show bash completion script and exit',
     )
     global_group.add_argument(
+        '--fish-completion',
+        default=False,
+        action='store_true',
+        help='Show fish completion script and exit',
+    )
+    global_group.add_argument(
         '--version',
         dest='version',
         default=False,
         action='store_true',
         help='Display installed version number of borgmatic and exit',
     )
 
-    top_level_parser = ArgumentParser(
+    global_plus_action_parser = ArgumentParser(
         description='''
             Simple, configuration-driven backup software for servers and workstations. If none of
             the action options are given, then borgmatic defaults to: create, prune, compact, and
             check.
             ''',
         parents=[global_parser],
     )
 
-    subparsers = top_level_parser.add_subparsers(
+    action_parsers = global_plus_action_parser.add_subparsers(
         title='actions',
         metavar='',
-        help='Specify zero or more actions. Defaults to creat, prune, compact, and check. Use --help with action for details:',
+        help='Specify zero or more actions. Defaults to create, prune, compact, and check. Use --help with action for details:',
     )
-    rcreate_parser = subparsers.add_parser(
+    rcreate_parser = action_parsers.add_parser(
         'rcreate',
-        aliases=SUBPARSER_ALIASES['rcreate'],
+        aliases=ACTION_ALIASES['rcreate'],
         help='Create a new, empty Borg repository',
         description='Create a new, empty Borg repository',
         add_help=False,
     )
     rcreate_group = rcreate_parser.add_argument_group('rcreate arguments')
     rcreate_group.add_argument(
         '-e',
@@ -242,45 +358,48 @@
         help='Borg repository encryption mode',
         required=True,
     )
     rcreate_group.add_argument(
         '--source-repository',
         '--other-repo',
         metavar='KEY_REPOSITORY',
-        help='Path to an existing Borg repository whose key material should be reused (Borg 2.x+ only)',
+        help='Path to an existing Borg repository whose key material should be reused [Borg 2.x+ only]',
     )
     rcreate_group.add_argument(
         '--repository',
         help='Path of the new repository to create (must be already specified in a borgmatic configuration file), defaults to the configured repository if there is only one',
     )
     rcreate_group.add_argument(
         '--copy-crypt-key',
         action='store_true',
-        help='Copy the crypt key used for authenticated encryption from the source repository, defaults to a new random key (Borg 2.x+ only)',
+        help='Copy the crypt key used for authenticated encryption from the source repository, defaults to a new random key [Borg 2.x+ only]',
     )
     rcreate_group.add_argument(
-        '--append-only', action='store_true', help='Create an append-only repository',
+        '--append-only',
+        action='store_true',
+        help='Create an append-only repository',
     )
     rcreate_group.add_argument(
-        '--storage-quota', help='Create a repository with a fixed storage quota',
+        '--storage-quota',
+        help='Create a repository with a fixed storage quota',
     )
     rcreate_group.add_argument(
         '--make-parent-dirs',
         action='store_true',
         help='Create any missing parent directories of the repository directory',
     )
     rcreate_group.add_argument(
         '-h', '--help', action='help', help='Show this help message and exit'
     )
 
-    transfer_parser = subparsers.add_parser(
+    transfer_parser = action_parsers.add_parser(
         'transfer',
-        aliases=SUBPARSER_ALIASES['transfer'],
-        help='Transfer archives from one repository to another, optionally upgrading the transferred data (Borg 2.0+ only)',
-        description='Transfer archives from one repository to another, optionally upgrading the transferred data (Borg 2.0+ only)',
+        aliases=ACTION_ALIASES['transfer'],
+        help='Transfer archives from one repository to another, optionally upgrading the transferred data [Borg 2.0+ only]',
+        description='Transfer archives from one repository to another, optionally upgrading the transferred data [Borg 2.0+ only]',
         add_help=False,
     )
     transfer_group = transfer_parser.add_argument_group('transfer arguments')
     transfer_group.add_argument(
         '--repository',
         help='Path of existing destination repository to transfer archives to, defaults to the configured repository if there is only one',
     )
@@ -291,15 +410,15 @@
     )
     transfer_group.add_argument(
         '--archive',
         help='Name of single archive to transfer (or "latest"), defaults to transferring all archives',
     )
     transfer_group.add_argument(
         '--upgrader',
-        help='Upgrader type used to convert the transfered data, e.g. "From12To20" to upgrade data from Borg 1.2 to 2.0 format, defaults to no conversion',
+        help='Upgrader type used to convert the transferred data, e.g. "From12To20" to upgrade data from Borg 1.2 to 2.0 format, defaults to no conversion',
     )
     transfer_group.add_argument(
         '--progress',
         default=False,
         action='store_true',
         help='Display progress as each archive is transferred',
     )
@@ -318,20 +437,40 @@
         metavar='N',
         help='Only transfer first N archives after other filters are applied',
     )
     transfer_group.add_argument(
         '--last', metavar='N', help='Only transfer last N archives after other filters are applied'
     )
     transfer_group.add_argument(
+        '--oldest',
+        metavar='TIMESPAN',
+        help='Transfer archives within a specified time range starting from the timestamp of the oldest archive (e.g. 7d or 12m) [Borg 2.x+ only]',
+    )
+    transfer_group.add_argument(
+        '--newest',
+        metavar='TIMESPAN',
+        help='Transfer archives within a time range that ends at timestamp of the newest archive and starts a specified time range ago (e.g. 7d or 12m) [Borg 2.x+ only]',
+    )
+    transfer_group.add_argument(
+        '--older',
+        metavar='TIMESPAN',
+        help='Transfer archives that are older than the specified time range (e.g. 7d or 12m) from the current time [Borg 2.x+ only]',
+    )
+    transfer_group.add_argument(
+        '--newer',
+        metavar='TIMESPAN',
+        help='Transfer archives that are newer than the specified time range (e.g. 7d or 12m) from the current time [Borg 2.x+ only]',
+    )
+    transfer_group.add_argument(
         '-h', '--help', action='help', help='Show this help message and exit'
     )
 
-    prune_parser = subparsers.add_parser(
+    prune_parser = action_parsers.add_parser(
         'prune',
-        aliases=SUBPARSER_ALIASES['prune'],
+        aliases=ACTION_ALIASES['prune'],
         help='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',
         description='Prune archives according to the retention policy (with Borg 1.2+, run compact afterwards to actually free space)',
         add_help=False,
     )
     prune_group = prune_parser.add_argument_group('prune arguments')
     prune_group.add_argument(
         '--repository',
@@ -343,21 +482,41 @@
         default=False,
         action='store_true',
         help='Display statistics of archive',
     )
     prune_group.add_argument(
         '--list', dest='list_archives', action='store_true', help='List archives kept/pruned'
     )
+    prune_group.add_argument(
+        '--oldest',
+        metavar='TIMESPAN',
+        help='Prune archives within a specified time range starting from the timestamp of the oldest archive (e.g. 7d or 12m) [Borg 2.x+ only]',
+    )
+    prune_group.add_argument(
+        '--newest',
+        metavar='TIMESPAN',
+        help='Prune archives within a time range that ends at timestamp of the newest archive and starts a specified time range ago (e.g. 7d or 12m) [Borg 2.x+ only]',
+    )
+    prune_group.add_argument(
+        '--older',
+        metavar='TIMESPAN',
+        help='Prune archives that are older than the specified time range (e.g. 7d or 12m) from the current time [Borg 2.x+ only]',
+    )
+    prune_group.add_argument(
+        '--newer',
+        metavar='TIMESPAN',
+        help='Prune archives that are newer than the specified time range (e.g. 7d or 12m) from the current time [Borg 2.x+ only]',
+    )
     prune_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')
 
-    compact_parser = subparsers.add_parser(
+    compact_parser = action_parsers.add_parser(
         'compact',
-        aliases=SUBPARSER_ALIASES['compact'],
-        help='Compact segments to free space (Borg 1.2+, borgmatic 1.5.23+ only)',
-        description='Compact segments to free space (Borg 1.2+, borgmatic 1.5.23+ only)',
+        aliases=ACTION_ALIASES['compact'],
+        help='Compact segments to free space [Borg 1.2+, borgmatic 1.5.23+ only]',
+        description='Compact segments to free space [Borg 1.2+, borgmatic 1.5.23+ only]',
         add_help=False,
     )
     compact_group = compact_parser.add_argument_group('compact arguments')
     compact_group.add_argument(
         '--repository',
         help='Path of specific existing repository to compact (must be already specified in a borgmatic configuration file)',
     )
@@ -369,29 +528,29 @@
         help='Display progress as each segment is compacted',
     )
     compact_group.add_argument(
         '--cleanup-commits',
         dest='cleanup_commits',
         default=False,
         action='store_true',
-        help='Cleanup commit-only 17-byte segment files left behind by Borg 1.1 (flag in Borg 1.2 only)',
+        help='Cleanup commit-only 17-byte segment files left behind by Borg 1.1 [flag in Borg 1.2 only]',
     )
     compact_group.add_argument(
         '--threshold',
         type=int,
         dest='threshold',
         help='Minimum saved space percentage threshold for compacting a segment, defaults to 10',
     )
     compact_group.add_argument(
         '-h', '--help', action='help', help='Show this help message and exit'
     )
 
-    create_parser = subparsers.add_parser(
+    create_parser = action_parsers.add_parser(
         'create',
-        aliases=SUBPARSER_ALIASES['create'],
+        aliases=ACTION_ALIASES['create'],
         help='Create an archive (actually perform a backup)',
         description='Create an archive (actually perform a backup)',
         add_help=False,
     )
     create_group = create_parser.add_argument_group('create arguments')
     create_group.add_argument(
         '--repository',
@@ -415,17 +574,17 @@
         '--list', '--files', dest='list_files', action='store_true', help='Show per-file details'
     )
     create_group.add_argument(
         '--json', dest='json', default=False, action='store_true', help='Output results as JSON'
     )
     create_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')
 
-    check_parser = subparsers.add_parser(
+    check_parser = action_parsers.add_parser(
         'check',
-        aliases=SUBPARSER_ALIASES['check'],
+        aliases=ACTION_ALIASES['check'],
         help='Check archives for consistency',
         description='Check archives for consistency',
         add_help=False,
     )
     check_group = check_parser.add_argument_group('check arguments')
     check_group.add_argument(
         '--repository',
@@ -457,17 +616,17 @@
         '--force',
         default=False,
         action='store_true',
         help='Ignore configured check frequencies and run checks unconditionally',
     )
     check_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')
 
-    extract_parser = subparsers.add_parser(
+    extract_parser = action_parsers.add_parser(
         'extract',
-        aliases=SUBPARSER_ALIASES['extract'],
+        aliases=ACTION_ALIASES['extract'],
         help='Extract files from a named archive to the current directory',
         description='Extract a named archive to the current directory',
         add_help=False,
     )
     extract_group = extract_parser.add_argument_group('extract arguments')
     extract_group.add_argument(
         '--repository',
@@ -476,17 +635,17 @@
     extract_group.add_argument(
         '--archive', help='Name of archive to extract (or "latest")', required=True
     )
     extract_group.add_argument(
         '--path',
         '--restore-path',
         metavar='PATH',
-        nargs='+',
         dest='paths',
-        help='Paths to extract from archive, defaults to the entire archive',
+        action='append',
+        help='Path to extract from archive, can specify flag multiple times, defaults to the entire archive',
     )
     extract_group.add_argument(
         '--destination',
         metavar='PATH',
         dest='destination',
         help='Directory to extract files into, defaults to the current directory',
     )
@@ -503,17 +662,126 @@
         action='store_true',
         help='Display progress for each file as it is extracted',
     )
     extract_group.add_argument(
         '-h', '--help', action='help', help='Show this help message and exit'
     )
 
-    export_tar_parser = subparsers.add_parser(
+    config_parser = action_parsers.add_parser(
+        'config',
+        aliases=ACTION_ALIASES['config'],
+        help='Perform configuration file related operations',
+        description='Perform configuration file related operations',
+        add_help=False,
+    )
+
+    config_group = config_parser.add_argument_group('config arguments')
+    config_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')
+
+    config_parsers = config_parser.add_subparsers(
+        title='config sub-actions',
+    )
+
+    config_bootstrap_parser = config_parsers.add_parser(
+        'bootstrap',
+        help='Extract the borgmatic configuration files from a named archive',
+        description='Extract the borgmatic configuration files from a named archive',
+        add_help=False,
+    )
+    config_bootstrap_group = config_bootstrap_parser.add_argument_group(
+        'config bootstrap arguments'
+    )
+    config_bootstrap_group.add_argument(
+        '--repository',
+        help='Path of repository to extract config files from',
+        required=True,
+    )
+    config_bootstrap_group.add_argument(
+        '--borgmatic-source-directory',
+        help='Path that stores the config files used to create an archive and additional source files used for temporary internal state like borgmatic database dumps. Defaults to ~/.borgmatic',
+    )
+    config_bootstrap_group.add_argument(
+        '--archive',
+        help='Name of archive to extract config files from, defaults to "latest"',
+        default='latest',
+    )
+    config_bootstrap_group.add_argument(
+        '--destination',
+        metavar='PATH',
+        dest='destination',
+        help='Directory to extract config files into, defaults to /',
+        default='/',
+    )
+    config_bootstrap_group.add_argument(
+        '--strip-components',
+        type=lambda number: number if number == 'all' else int(number),
+        metavar='NUMBER',
+        help='Number of leading path components to remove from each extracted path or "all" to strip all leading path components. Skip paths with fewer elements',
+    )
+    config_bootstrap_group.add_argument(
+        '--progress',
+        dest='progress',
+        default=False,
+        action='store_true',
+        help='Display progress for each file as it is extracted',
+    )
+    config_bootstrap_group.add_argument(
+        '-h', '--help', action='help', help='Show this help message and exit'
+    )
+
+    config_generate_parser = config_parsers.add_parser(
+        'generate',
+        help='Generate a sample borgmatic configuration file',
+        description='Generate a sample borgmatic configuration file',
+        add_help=False,
+    )
+    config_generate_group = config_generate_parser.add_argument_group('config generate arguments')
+    config_generate_group.add_argument(
+        '-s',
+        '--source',
+        dest='source_filename',
+        help='Optional configuration file to merge into the generated configuration, useful for upgrading your configuration',
+    )
+    config_generate_group.add_argument(
+        '-d',
+        '--destination',
+        dest='destination_filename',
+        default=config_paths[0],
+        help=f'Destination configuration file, default: {unexpanded_config_paths[0]}',
+    )
+    config_generate_group.add_argument(
+        '--overwrite',
+        default=False,
+        action='store_true',
+        help='Whether to overwrite any existing destination file, defaults to false',
+    )
+    config_generate_group.add_argument(
+        '-h', '--help', action='help', help='Show this help message and exit'
+    )
+
+    config_validate_parser = config_parsers.add_parser(
+        'validate',
+        help='Validate borgmatic configuration files specified with --config (see borgmatic --help)',
+        description='Validate borgmatic configuration files specified with --config (see borgmatic --help)',
+        add_help=False,
+    )
+    config_validate_group = config_validate_parser.add_argument_group('config validate arguments')
+    config_validate_group.add_argument(
+        '-s',
+        '--show',
+        action='store_true',
+        help='Show the validated configuration after all include merging has occurred',
+    )
+    config_validate_group.add_argument(
+        '-h', '--help', action='help', help='Show this help message and exit'
+    )
+
+    export_tar_parser = action_parsers.add_parser(
         'export-tar',
-        aliases=SUBPARSER_ALIASES['export-tar'],
+        aliases=ACTION_ALIASES['export-tar'],
         help='Export an archive to a tar-formatted file or stream',
         description='Export an archive to a tar-formatted file or stream',
         add_help=False,
     )
     export_tar_group = export_tar_parser.add_argument_group('export-tar arguments')
     export_tar_group.add_argument(
         '--repository',
@@ -521,17 +789,17 @@
     )
     export_tar_group.add_argument(
         '--archive', help='Name of archive to export (or "latest")', required=True
     )
     export_tar_group.add_argument(
         '--path',
         metavar='PATH',
-        nargs='+',
         dest='paths',
-        help='Paths to export from archive, defaults to the entire archive',
+        action='append',
+        help='Path to export from archive, can specify flag multiple times, defaults to the entire archive',
     )
     export_tar_group.add_argument(
         '--destination',
         metavar='PATH',
         dest='destination',
         help='Path to destination export tar file, or "-" for stdout (but be careful about dirtying output with --verbosity or --list)',
         required=True,
@@ -549,17 +817,17 @@
         dest='strip_components',
         help='Number of leading path components to remove from each exported path. Skip paths with fewer elements',
     )
     export_tar_group.add_argument(
         '-h', '--help', action='help', help='Show this help message and exit'
     )
 
-    mount_parser = subparsers.add_parser(
+    mount_parser = action_parsers.add_parser(
         'mount',
-        aliases=SUBPARSER_ALIASES['mount'],
+        aliases=ACTION_ALIASES['mount'],
         help='Mount files from a named archive as a FUSE filesystem',
         description='Mount a named archive as a FUSE filesystem',
         add_help=False,
     )
     mount_group = mount_parser.add_argument_group('mount arguments')
     mount_group.add_argument(
         '--repository',
@@ -572,48 +840,76 @@
         dest='mount_point',
         help='Path where filesystem is to be mounted',
         required=True,
     )
     mount_group.add_argument(
         '--path',
         metavar='PATH',
-        nargs='+',
         dest='paths',
-        help='Paths to mount from archive, defaults to the entire archive',
+        action='append',
+        help='Path to mount from archive, can specify multiple times, defaults to the entire archive',
     )
     mount_group.add_argument(
         '--foreground',
         dest='foreground',
         default=False,
         action='store_true',
         help='Stay in foreground until ctrl-C is pressed',
     )
+    mount_group.add_argument(
+        '--first',
+        metavar='N',
+        help='Mount first N archives after other filters are applied',
+    )
+    mount_group.add_argument(
+        '--last', metavar='N', help='Mount last N archives after other filters are applied'
+    )
+    mount_group.add_argument(
+        '--oldest',
+        metavar='TIMESPAN',
+        help='Mount archives within a specified time range starting from the timestamp of the oldest archive (e.g. 7d or 12m) [Borg 2.x+ only]',
+    )
+    mount_group.add_argument(
+        '--newest',
+        metavar='TIMESPAN',
+        help='Mount archives within a time range that ends at timestamp of the newest archive and starts a specified time range ago (e.g. 7d or 12m) [Borg 2.x+ only]',
+    )
+    mount_group.add_argument(
+        '--older',
+        metavar='TIMESPAN',
+        help='Mount archives that are older than the specified time range (e.g. 7d or 12m) from the current time [Borg 2.x+ only]',
+    )
+    mount_group.add_argument(
+        '--newer',
+        metavar='TIMESPAN',
+        help='Mount archives that are newer than the specified time range (e.g. 7d or 12m) from the current time [Borg 2.x+ only]',
+    )
     mount_group.add_argument('--options', dest='options', help='Extra Borg mount options')
     mount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')
 
-    umount_parser = subparsers.add_parser(
+    umount_parser = action_parsers.add_parser(
         'umount',
-        aliases=SUBPARSER_ALIASES['umount'],
+        aliases=ACTION_ALIASES['umount'],
         help='Unmount a FUSE filesystem that was mounted with "borgmatic mount"',
         description='Unmount a mounted FUSE filesystem',
         add_help=False,
     )
     umount_group = umount_parser.add_argument_group('umount arguments')
     umount_group.add_argument(
         '--mount-point',
         metavar='PATH',
         dest='mount_point',
         help='Path of filesystem to unmount',
         required=True,
     )
     umount_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')
 
-    restore_parser = subparsers.add_parser(
+    restore_parser = action_parsers.add_parser(
         'restore',
-        aliases=SUBPARSER_ALIASES['restore'],
+        aliases=ACTION_ALIASES['restore'],
         help='Restore database dumps from a named archive',
         description='Restore database dumps from a named archive. (To extract files instead, use "borgmatic extract".)',
         add_help=False,
     )
     restore_group = restore_parser.add_argument_group('restore arguments')
     restore_group.add_argument(
         '--repository',
@@ -621,42 +917,70 @@
     )
     restore_group.add_argument(
         '--archive', help='Name of archive to restore from (or "latest")', required=True
     )
     restore_group.add_argument(
         '--database',
         metavar='NAME',
-        nargs='+',
         dest='databases',
-        help="Names of databases to restore from archive, defaults to all databases. Note that any databases to restore must be defined in borgmatic's configuration",
+        action='append',
+        help="Name of database to restore from archive, must be defined in borgmatic's configuration, can specify flag multiple times, defaults to all databases",
+    )
+    restore_group.add_argument(
+        '--schema',
+        metavar='NAME',
+        dest='schemas',
+        action='append',
+        help='Name of schema to restore from the database, can specify flag multiple times, defaults to all schemas. Schemas are only supported for PostgreSQL and MongoDB databases',
+    )
+    restore_group.add_argument(
+        '--hostname',
+        help='Database hostname to restore to. Defaults to the "restore_hostname" option in borgmatic\'s configuration',
+    )
+    restore_group.add_argument(
+        '--port',
+        help='Port to restore to. Defaults to the "restore_port" option in borgmatic\'s configuration',
+    )
+    restore_group.add_argument(
+        '--username',
+        help='Username with which to connect to the database. Defaults to the "restore_username" option in borgmatic\'s configuration',
+    )
+    restore_group.add_argument(
+        '--password',
+        help='Password with which to connect to the restore database. Defaults to the "restore_password" option in borgmatic\'s configuration',
+    )
+    restore_group.add_argument(
+        '--restore-path',
+        help='Path to restore SQLite database dumps to. Defaults to the "restore_path" option in borgmatic\'s configuration',
     )
     restore_group.add_argument(
         '-h', '--help', action='help', help='Show this help message and exit'
     )
 
-    rlist_parser = subparsers.add_parser(
+    rlist_parser = action_parsers.add_parser(
         'rlist',
-        aliases=SUBPARSER_ALIASES['rlist'],
+        aliases=ACTION_ALIASES['rlist'],
         help='List repository',
         description='List the archives in a repository',
         add_help=False,
     )
     rlist_group = rlist_parser.add_argument_group('rlist arguments')
     rlist_group.add_argument(
-        '--repository', help='Path of repository to list, defaults to the configured repositories',
+        '--repository',
+        help='Path of repository to list, defaults to the configured repositories',
     )
     rlist_group.add_argument(
         '--short', default=False, action='store_true', help='Output only archive names'
     )
     rlist_group.add_argument('--format', help='Format for archive listing')
     rlist_group.add_argument(
         '--json', default=False, action='store_true', help='Output results as JSON'
     )
     rlist_group.add_argument(
-        '-P', '--prefix', help='Only list archive names starting with this prefix'
+        '-P', '--prefix', help='Deprecated. Only list archive names starting with this prefix'
     )
     rlist_group.add_argument(
         '-a',
         '--match-archives',
         '--glob-archives',
         metavar='PATTERN',
         help='Only list archive names matching this pattern',
@@ -666,67 +990,81 @@
     )
     rlist_group.add_argument(
         '--first', metavar='N', help='List first N archives after other filters are applied'
     )
     rlist_group.add_argument(
         '--last', metavar='N', help='List last N archives after other filters are applied'
     )
+    rlist_group.add_argument(
+        '--oldest',
+        metavar='TIMESPAN',
+        help='List archives within a specified time range starting from the timestamp of the oldest archive (e.g. 7d or 12m) [Borg 2.x+ only]',
+    )
+    rlist_group.add_argument(
+        '--newest',
+        metavar='TIMESPAN',
+        help='List archives within a time range that ends at timestamp of the newest archive and starts a specified time range ago (e.g. 7d or 12m) [Borg 2.x+ only]',
+    )
+    rlist_group.add_argument(
+        '--older',
+        metavar='TIMESPAN',
+        help='List archives that are older than the specified time range (e.g. 7d or 12m) from the current time [Borg 2.x+ only]',
+    )
+    rlist_group.add_argument(
+        '--newer',
+        metavar='TIMESPAN',
+        help='List archives that are newer than the specified time range (e.g. 7d or 12m) from the current time [Borg 2.x+ only]',
+    )
     rlist_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')
 
-    list_parser = subparsers.add_parser(
+    list_parser = action_parsers.add_parser(
         'list',
-        aliases=SUBPARSER_ALIASES['list'],
+        aliases=ACTION_ALIASES['list'],
         help='List archive',
         description='List the files in an archive or search for a file across archives',
         add_help=False,
     )
     list_group = list_parser.add_argument_group('list arguments')
     list_group.add_argument(
         '--repository',
         help='Path of repository containing archive to list, defaults to the configured repositories',
     )
     list_group.add_argument('--archive', help='Name of the archive to list (or "latest")')
     list_group.add_argument(
         '--path',
         metavar='PATH',
-        nargs='+',
         dest='paths',
-        help='Paths or patterns to list from a single selected archive (via "--archive"), defaults to listing the entire archive',
+        action='append',
+        help='Path or pattern to list from a single selected archive (via "--archive"), can specify flag multiple times, defaults to listing the entire archive',
     )
     list_group.add_argument(
         '--find',
         metavar='PATH',
-        nargs='+',
         dest='find_paths',
-        help='Partial paths or patterns to search for and list across multiple archives',
+        action='append',
+        help='Partial path or pattern to search for and list across multiple archives, can specify flag multiple times',
     )
     list_group.add_argument(
         '--short', default=False, action='store_true', help='Output only path names'
     )
     list_group.add_argument('--format', help='Format for file listing')
     list_group.add_argument(
         '--json', default=False, action='store_true', help='Output results as JSON'
     )
     list_group.add_argument(
-        '-P', '--prefix', help='Only list archive names starting with this prefix'
+        '-P', '--prefix', help='Deprecated. Only list archive names starting with this prefix'
     )
     list_group.add_argument(
         '-a',
         '--match-archives',
         '--glob-archives',
         metavar='PATTERN',
         help='Only list archive names matching this pattern',
     )
     list_group.add_argument(
-        '--successful',
-        default=True,
-        action='store_true',
-        help='Deprecated; no effect. Newer versions of Borg shows successful (non-checkpoint) archives by default.',
-    )
-    list_group.add_argument(
         '--sort-by', metavar='KEYS', help='Comma-separated list of sorting keys'
     )
     list_group.add_argument(
         '--first', metavar='N', help='List first N archives after other filters are applied'
     )
     list_group.add_argument(
         '--last', metavar='N', help='List last N archives after other filters are applied'
@@ -741,49 +1079,51 @@
     list_group.add_argument(
         '--patterns-from',
         metavar='FILENAME',
         help='Include or exclude paths matching patterns from pattern file, one per line',
     )
     list_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')
 
-    rinfo_parser = subparsers.add_parser(
+    rinfo_parser = action_parsers.add_parser(
         'rinfo',
-        aliases=SUBPARSER_ALIASES['rinfo'],
+        aliases=ACTION_ALIASES['rinfo'],
         help='Show repository summary information such as disk space used',
         description='Show repository summary information such as disk space used',
         add_help=False,
     )
     rinfo_group = rinfo_parser.add_argument_group('rinfo arguments')
     rinfo_group.add_argument(
         '--repository',
         help='Path of repository to show info for, defaults to the configured repository if there is only one',
     )
     rinfo_group.add_argument(
         '--json', dest='json', default=False, action='store_true', help='Output results as JSON'
     )
     rinfo_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')
 
-    info_parser = subparsers.add_parser(
+    info_parser = action_parsers.add_parser(
         'info',
-        aliases=SUBPARSER_ALIASES['info'],
+        aliases=ACTION_ALIASES['info'],
         help='Show archive summary information such as disk space used',
         description='Show archive summary information such as disk space used',
         add_help=False,
     )
     info_group = info_parser.add_argument_group('info arguments')
     info_group.add_argument(
         '--repository',
         help='Path of repository containing archive to show info for, defaults to the configured repository if there is only one',
     )
     info_group.add_argument('--archive', help='Name of archive to show info for (or "latest")')
     info_group.add_argument(
         '--json', dest='json', default=False, action='store_true', help='Output results as JSON'
     )
     info_group.add_argument(
-        '-P', '--prefix', help='Only show info for archive names starting with this prefix'
+        '-P',
+        '--prefix',
+        help='Deprecated. Only show info for archive names starting with this prefix',
     )
     info_group.add_argument(
         '-a',
         '--match-archives',
         '--glob-archives',
         metavar='PATTERN',
         help='Only show info for archive names matching this pattern',
@@ -795,35 +1135,55 @@
         '--first',
         metavar='N',
         help='Show info for first N archives after other filters are applied',
     )
     info_group.add_argument(
         '--last', metavar='N', help='Show info for last N archives after other filters are applied'
     )
+    info_group.add_argument(
+        '--oldest',
+        metavar='TIMESPAN',
+        help='Show info for archives within a specified time range starting from the timestamp of the oldest archive (e.g. 7d or 12m) [Borg 2.x+ only]',
+    )
+    info_group.add_argument(
+        '--newest',
+        metavar='TIMESPAN',
+        help='Show info for archives within a time range that ends at timestamp of the newest archive and starts a specified time range ago (e.g. 7d or 12m) [Borg 2.x+ only]',
+    )
+    info_group.add_argument(
+        '--older',
+        metavar='TIMESPAN',
+        help='Show info for archives that are older than the specified time range (e.g. 7d or 12m) from the current time [Borg 2.x+ only]',
+    )
+    info_group.add_argument(
+        '--newer',
+        metavar='TIMESPAN',
+        help='Show info for archives that are newer than the specified time range (e.g. 7d or 12m) from the current time [Borg 2.x+ only]',
+    )
     info_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')
 
-    break_lock_parser = subparsers.add_parser(
+    break_lock_parser = action_parsers.add_parser(
         'break-lock',
-        aliases=SUBPARSER_ALIASES['break-lock'],
+        aliases=ACTION_ALIASES['break-lock'],
         help='Break the repository and cache locks left behind by Borg aborting',
         description='Break Borg repository and cache locks left behind by Borg aborting',
         add_help=False,
     )
     break_lock_group = break_lock_parser.add_argument_group('break-lock arguments')
     break_lock_group.add_argument(
         '--repository',
         help='Path of repository to break the lock for, defaults to the configured repository if there is only one',
     )
     break_lock_group.add_argument(
         '-h', '--help', action='help', help='Show this help message and exit'
     )
 
-    borg_parser = subparsers.add_parser(
+    borg_parser = action_parsers.add_parser(
         'borg',
-        aliases=SUBPARSER_ALIASES['borg'],
+        aliases=ACTION_ALIASES['borg'],
         help='Run an arbitrary Borg command',
         description="Run an arbitrary Borg command based on borgmatic's configuration",
         add_help=False,
     )
     borg_group = borg_parser.add_argument_group('borg arguments')
     borg_group.add_argument(
         '--repository',
@@ -835,53 +1195,86 @@
         metavar='OPTION',
         dest='options',
         nargs='+',
         help='Options to pass to Borg, command first ("create", "list", etc). "--" is optional. To specify the repository or the archive, you must use --repository or --archive instead of providing them here.',
     )
     borg_group.add_argument('-h', '--help', action='help', help='Show this help message and exit')
 
-    return top_level_parser, subparsers
+    return global_parser, action_parsers, global_plus_action_parser
 
 
 def parse_arguments(*unparsed_arguments):
     '''
     Given command-line arguments with which this script was invoked, parse the arguments and return
-    them as a dict mapping from subparser name (or "global") to an argparse.Namespace instance.
-    '''
-    top_level_parser, subparsers = make_parsers()
+    them as a dict mapping from action name (or "global") to an argparse.Namespace instance.
 
-    arguments, remaining_arguments = parse_subparser_arguments(
-        unparsed_arguments, subparsers.choices
-    )
-    arguments['global'] = top_level_parser.parse_args(remaining_arguments)
+    Raise ValueError if the arguments cannot be parsed.
+    Raise SystemExit with an error code of 0 if "--help" was requested.
+    '''
+    global_parser, action_parsers, global_plus_action_parser = make_parsers()
+    arguments, remaining_action_arguments = parse_arguments_for_actions(
+        unparsed_arguments, action_parsers.choices, global_parser
+    )
+
+    if not arguments['global'].config_paths:
+        arguments['global'].config_paths = collect.get_default_config_paths(expand_home=True)
+
+    for action_name in ('bootstrap', 'generate', 'validate'):
+        if (
+            action_name in arguments.keys() and len(arguments.keys()) > 2
+        ):  # 2 = 1 for 'global' + 1 for the action
+            raise ValueError(
+                f'The {action_name} action cannot be combined with other actions. Please run it separately.'
+            )
+
+    unknown_arguments = get_unparsable_arguments(remaining_action_arguments)
+
+    if unknown_arguments:
+        if '--help' in unknown_arguments or '-h' in unknown_arguments:
+            global_plus_action_parser.print_help()
+            sys.exit(0)
 
-    if arguments['global'].excludes_filename:
+        global_plus_action_parser.print_usage()
         raise ValueError(
-            'The --excludes flag has been replaced with exclude_patterns in configuration.'
+            f"Unrecognized argument{'s' if len(unknown_arguments) > 1 else ''}: {' '.join(unknown_arguments)}"
         )
 
     if 'create' in arguments and arguments['create'].list_files and arguments['create'].progress:
         raise ValueError(
             'With the create action, only one of --list (--files) and --progress flags can be used.'
         )
+    if 'create' in arguments and arguments['create'].list_files and arguments['create'].json:
+        raise ValueError(
+            'With the create action, only one of --list (--files) and --json flags can be used.'
+        )
 
     if (
         ('list' in arguments and 'rinfo' in arguments and arguments['list'].json)
         or ('list' in arguments and 'info' in arguments and arguments['list'].json)
         or ('rinfo' in arguments and 'info' in arguments and arguments['rinfo'].json)
     ):
         raise ValueError('With the --json flag, multiple actions cannot be used together.')
 
     if (
         'transfer' in arguments
         and arguments['transfer'].archive
         and arguments['transfer'].match_archives
     ):
         raise ValueError(
-            'With the transfer action, only one of --archive and --glob-archives flags can be used.'
+            'With the transfer action, only one of --archive and --match-archives flags can be used.'
+        )
+
+    if 'list' in arguments and (arguments['list'].prefix and arguments['list'].match_archives):
+        raise ValueError(
+            'With the list action, only one of --prefix or --match-archives flags can be used.'
+        )
+
+    if 'rlist' in arguments and (arguments['rlist'].prefix and arguments['rlist'].match_archives):
+        raise ValueError(
+            'With the rlist action, only one of --prefix or --match-archives flags can be used.'
         )
 
     if 'info' in arguments and (
         (arguments['info'].archive and arguments['info'].prefix)
         or (arguments['info'].archive and arguments['info'].match_archives)
         or (arguments['info'].prefix and arguments['info'].match_archives)
     ):
```

### Comparing `borgmatic-1.7.9/borgmatic/commands/borgmatic.py` & `borgmatic-1.8.0/borgmatic/commands/borgmatic.py`

 * *Files 14% similar despite different names*

```diff
@@ -4,493 +4,526 @@
 import os
 import sys
 import time
 from queue import Queue
 from subprocess import CalledProcessError
 
 import colorama
-import pkg_resources
+
+try:
+    import importlib_metadata
+except ModuleNotFoundError:  # pragma: nocover
+    import importlib.metadata as importlib_metadata
 
 import borgmatic.actions.borg
 import borgmatic.actions.break_lock
 import borgmatic.actions.check
 import borgmatic.actions.compact
+import borgmatic.actions.config.bootstrap
+import borgmatic.actions.config.generate
+import borgmatic.actions.config.validate
 import borgmatic.actions.create
 import borgmatic.actions.export_tar
 import borgmatic.actions.extract
 import borgmatic.actions.info
 import borgmatic.actions.list
 import borgmatic.actions.mount
 import borgmatic.actions.prune
 import borgmatic.actions.rcreate
 import borgmatic.actions.restore
 import borgmatic.actions.rinfo
 import borgmatic.actions.rlist
 import borgmatic.actions.transfer
-import borgmatic.commands.completion
+import borgmatic.commands.completion.bash
+import borgmatic.commands.completion.fish
 from borgmatic.borg import umount as borg_umount
 from borgmatic.borg import version as borg_version
 from borgmatic.commands.arguments import parse_arguments
-from borgmatic.config import checks, collect, convert, validate
+from borgmatic.config import checks, collect, validate
 from borgmatic.hooks import command, dispatch, monitor
-from borgmatic.logger import add_custom_log_levels, configure_logging, should_do_markup
+from borgmatic.logger import DISABLED, add_custom_log_levels, configure_logging, should_do_markup
 from borgmatic.signals import configure_signals
 from borgmatic.verbosity import verbosity_to_log_level
 
 logger = logging.getLogger(__name__)
 
-LEGACY_CONFIG_PATH = '/etc/borgmatic/config'
-
 
 def run_configuration(config_filename, config, arguments):
     '''
     Given a config filename, the corresponding parsed config dict, and command-line arguments as a
     dict from subparser name to a namespace of parsed arguments, execute the defined create, prune,
     compact, check, and/or other actions.
 
     Yield a combination of:
 
       * JSON output strings from successfully executing any actions that produce JSON
       * logging.LogRecord instances containing errors from any actions or backup hooks that fail
     '''
-    (location, storage, retention, consistency, hooks) = (
-        config.get(section_name, {})
-        for section_name in ('location', 'storage', 'retention', 'consistency', 'hooks')
-    )
     global_arguments = arguments['global']
 
-    local_path = location.get('local_path', 'borg')
-    remote_path = location.get('remote_path')
-    retries = storage.get('retries', 0)
-    retry_wait = storage.get('retry_wait', 0)
+    local_path = config.get('local_path', 'borg')
+    remote_path = config.get('remote_path')
+    retries = config.get('retries', 0)
+    retry_wait = config.get('retry_wait', 0)
     encountered_error = None
     error_repository = ''
     using_primary_action = {'create', 'prune', 'compact', 'check'}.intersection(arguments)
     monitoring_log_level = verbosity_to_log_level(global_arguments.monitoring_verbosity)
+    monitoring_hooks_are_activated = using_primary_action and monitoring_log_level != DISABLED
 
     try:
-        local_borg_version = borg_version.local_borg_version(storage, local_path)
+        local_borg_version = borg_version.local_borg_version(config, local_path)
     except (OSError, CalledProcessError, ValueError) as error:
-        yield from log_error_records(
-            '{}: Error getting local Borg version'.format(config_filename), error
-        )
+        yield from log_error_records(f'{config_filename}: Error getting local Borg version', error)
         return
 
     try:
-        if using_primary_action:
+        if monitoring_hooks_are_activated:
             dispatch.call_hooks(
                 'initialize_monitor',
-                hooks,
+                config,
                 config_filename,
                 monitor.MONITOR_HOOK_NAMES,
                 monitoring_log_level,
                 global_arguments.dry_run,
             )
-        if using_primary_action:
+
             dispatch.call_hooks(
                 'ping_monitor',
-                hooks,
+                config,
                 config_filename,
                 monitor.MONITOR_HOOK_NAMES,
                 monitor.State.START,
                 monitoring_log_level,
                 global_arguments.dry_run,
             )
     except (OSError, CalledProcessError) as error:
         if command.considered_soft_failure(config_filename, error):
             return
 
         encountered_error = error
-        yield from log_error_records('{}: Error pinging monitor'.format(config_filename), error)
+        yield from log_error_records(f'{config_filename}: Error pinging monitor', error)
 
     if not encountered_error:
         repo_queue = Queue()
-        for repo in location['repositories']:
-            repo_queue.put((repo, 0),)
+        for repo in config['repositories']:
+            repo_queue.put(
+                (repo, 0),
+            )
 
         while not repo_queue.empty():
-            repository_path, retry_num = repo_queue.get()
+            repository, retry_num = repo_queue.get()
+            logger.debug(
+                f'{repository.get("label", repository["path"])}: Running actions for repository'
+            )
             timeout = retry_num * retry_wait
             if timeout:
-                logger.warning(f'{config_filename}: Sleeping {timeout}s before next retry')
+                logger.warning(
+                    f'{repository.get("label", repository["path"])}: Sleeping {timeout}s before next retry'
+                )
                 time.sleep(timeout)
             try:
                 yield from run_actions(
                     arguments=arguments,
                     config_filename=config_filename,
-                    location=location,
-                    storage=storage,
-                    retention=retention,
-                    consistency=consistency,
-                    hooks=hooks,
+                    config=config,
                     local_path=local_path,
                     remote_path=remote_path,
                     local_borg_version=local_borg_version,
-                    repository_path=repository_path,
+                    repository=repository,
                 )
             except (OSError, CalledProcessError, ValueError) as error:
                 if retry_num < retries:
-                    repo_queue.put((repository_path, retry_num + 1),)
+                    repo_queue.put(
+                        (repository, retry_num + 1),
+                    )
                     tuple(  # Consume the generator so as to trigger logging.
                         log_error_records(
-                            '{}: Error running actions for repository'.format(repository_path),
+                            f'{repository.get("label", repository["path"])}: Error running actions for repository',
                             error,
                             levelno=logging.WARNING,
                             log_command_error_output=True,
                         )
                     )
                     logger.warning(
-                        f'{config_filename}: Retrying... attempt {retry_num + 1}/{retries}'
+                        f'{repository.get("label", repository["path"])}: Retrying... attempt {retry_num + 1}/{retries}'
                     )
                     continue
 
                 if command.considered_soft_failure(config_filename, error):
                     return
 
                 yield from log_error_records(
-                    '{}: Error running actions for repository'.format(repository_path), error
+                    f'{repository.get("label", repository["path"])}: Error running actions for repository',
+                    error,
                 )
                 encountered_error = error
-                error_repository = repository_path
+                error_repository = repository['path']
 
     try:
-        if using_primary_action:
+        if monitoring_hooks_are_activated:
             # send logs irrespective of error
             dispatch.call_hooks(
                 'ping_monitor',
-                hooks,
+                config,
                 config_filename,
                 monitor.MONITOR_HOOK_NAMES,
                 monitor.State.LOG,
                 monitoring_log_level,
                 global_arguments.dry_run,
             )
     except (OSError, CalledProcessError) as error:
         if command.considered_soft_failure(config_filename, error):
             return
 
         encountered_error = error
-        yield from log_error_records('{}: Error pinging monitor'.format(config_filename), error)
+        yield from log_error_records(f'{repository["path"]}: Error pinging monitor', error)
 
     if not encountered_error:
         try:
-            if using_primary_action:
+            if monitoring_hooks_are_activated:
                 dispatch.call_hooks(
                     'ping_monitor',
-                    hooks,
+                    config,
                     config_filename,
                     monitor.MONITOR_HOOK_NAMES,
                     monitor.State.FINISH,
                     monitoring_log_level,
                     global_arguments.dry_run,
                 )
                 dispatch.call_hooks(
                     'destroy_monitor',
-                    hooks,
+                    config,
                     config_filename,
                     monitor.MONITOR_HOOK_NAMES,
                     monitoring_log_level,
                     global_arguments.dry_run,
                 )
         except (OSError, CalledProcessError) as error:
             if command.considered_soft_failure(config_filename, error):
                 return
 
             encountered_error = error
-            yield from log_error_records('{}: Error pinging monitor'.format(config_filename), error)
+            yield from log_error_records(f'{config_filename}: Error pinging monitor', error)
 
     if encountered_error and using_primary_action:
         try:
             command.execute_hook(
-                hooks.get('on_error'),
-                hooks.get('umask'),
+                config.get('on_error'),
+                config.get('umask'),
                 config_filename,
                 'on-error',
                 global_arguments.dry_run,
                 repository=error_repository,
                 error=encountered_error,
                 output=getattr(encountered_error, 'output', ''),
             )
             dispatch.call_hooks(
                 'ping_monitor',
-                hooks,
+                config,
                 config_filename,
                 monitor.MONITOR_HOOK_NAMES,
                 monitor.State.FAIL,
                 monitoring_log_level,
                 global_arguments.dry_run,
             )
             dispatch.call_hooks(
                 'destroy_monitor',
-                hooks,
+                config,
                 config_filename,
                 monitor.MONITOR_HOOK_NAMES,
                 monitoring_log_level,
                 global_arguments.dry_run,
             )
         except (OSError, CalledProcessError) as error:
             if command.considered_soft_failure(config_filename, error):
                 return
 
-            yield from log_error_records(
-                '{}: Error running on-error hook'.format(config_filename), error
-            )
+            yield from log_error_records(f'{config_filename}: Error running on-error hook', error)
 
 
 def run_actions(
     *,
     arguments,
     config_filename,
-    location,
-    storage,
-    retention,
-    consistency,
-    hooks,
+    config,
     local_path,
     remote_path,
     local_borg_version,
-    repository_path,
+    repository,
 ):
     '''
     Given parsed command-line arguments as an argparse.ArgumentParser instance, the configuration
     filename, several different configuration dicts, local and remote paths to Borg, a local Borg
     version string, and a repository name, run all actions from the command-line arguments on the
     given repository.
 
     Yield JSON output strings from executing any actions that produce JSON.
 
     Raise OSError or subprocess.CalledProcessError if an error occurs running a command for an
     action or a hook. Raise ValueError if the arguments or configuration passed to action are
     invalid.
     '''
     add_custom_log_levels()
-    repository = os.path.expanduser(repository_path)
+    repository_path = os.path.expanduser(repository['path'])
     global_arguments = arguments['global']
     dry_run_label = ' (dry run; not making any changes)' if global_arguments.dry_run else ''
     hook_context = {
         'repository': repository_path,
         # Deprecated: For backwards compatibility with borgmatic < 1.6.0.
-        'repositories': ','.join(location['repositories']),
+        'repositories': ','.join([repo['path'] for repo in config['repositories']]),
+        'log_file': global_arguments.log_file if global_arguments.log_file else '',
     }
 
     command.execute_hook(
-        hooks.get('before_actions'),
-        hooks.get('umask'),
+        config.get('before_actions'),
+        config.get('umask'),
         config_filename,
         'pre-actions',
         global_arguments.dry_run,
         **hook_context,
     )
 
-    for (action_name, action_arguments) in arguments.items():
+    for action_name, action_arguments in arguments.items():
         if action_name == 'rcreate':
             borgmatic.actions.rcreate.run_rcreate(
                 repository,
-                storage,
+                config,
                 local_borg_version,
                 action_arguments,
                 global_arguments,
                 local_path,
                 remote_path,
             )
         elif action_name == 'transfer':
             borgmatic.actions.transfer.run_transfer(
                 repository,
-                storage,
+                config,
                 local_borg_version,
                 action_arguments,
                 global_arguments,
                 local_path,
                 remote_path,
             )
         elif action_name == 'create':
             yield from borgmatic.actions.create.run_create(
                 config_filename,
                 repository,
-                location,
-                storage,
-                hooks,
+                config,
                 hook_context,
                 local_borg_version,
                 action_arguments,
                 global_arguments,
                 dry_run_label,
                 local_path,
                 remote_path,
             )
         elif action_name == 'prune':
             borgmatic.actions.prune.run_prune(
                 config_filename,
                 repository,
-                storage,
-                retention,
-                hooks,
+                config,
                 hook_context,
                 local_borg_version,
                 action_arguments,
                 global_arguments,
                 dry_run_label,
                 local_path,
                 remote_path,
             )
         elif action_name == 'compact':
             borgmatic.actions.compact.run_compact(
                 config_filename,
                 repository,
-                storage,
-                retention,
-                hooks,
+                config,
                 hook_context,
                 local_borg_version,
                 action_arguments,
                 global_arguments,
                 dry_run_label,
                 local_path,
                 remote_path,
             )
         elif action_name == 'check':
-            if checks.repository_enabled_for_checks(repository, consistency):
+            if checks.repository_enabled_for_checks(repository, config):
                 borgmatic.actions.check.run_check(
                     config_filename,
                     repository,
-                    location,
-                    storage,
-                    consistency,
-                    hooks,
+                    config,
                     hook_context,
                     local_borg_version,
                     action_arguments,
                     global_arguments,
                     local_path,
                     remote_path,
                 )
         elif action_name == 'extract':
             borgmatic.actions.extract.run_extract(
                 config_filename,
                 repository,
-                location,
-                storage,
-                hooks,
+                config,
                 hook_context,
                 local_borg_version,
                 action_arguments,
                 global_arguments,
                 local_path,
                 remote_path,
             )
         elif action_name == 'export-tar':
             borgmatic.actions.export_tar.run_export_tar(
                 repository,
-                storage,
+                config,
                 local_borg_version,
                 action_arguments,
                 global_arguments,
                 local_path,
                 remote_path,
             )
         elif action_name == 'mount':
             borgmatic.actions.mount.run_mount(
                 repository,
-                storage,
+                config,
                 local_borg_version,
-                arguments['mount'],
+                action_arguments,
+                global_arguments,
                 local_path,
                 remote_path,
             )
         elif action_name == 'restore':
             borgmatic.actions.restore.run_restore(
                 repository,
-                location,
-                storage,
-                hooks,
+                config,
                 local_borg_version,
                 action_arguments,
                 global_arguments,
                 local_path,
                 remote_path,
             )
         elif action_name == 'rlist':
             yield from borgmatic.actions.rlist.run_rlist(
-                repository, storage, local_borg_version, action_arguments, local_path, remote_path,
+                repository,
+                config,
+                local_borg_version,
+                action_arguments,
+                global_arguments,
+                local_path,
+                remote_path,
             )
         elif action_name == 'list':
             yield from borgmatic.actions.list.run_list(
-                repository, storage, local_borg_version, action_arguments, local_path, remote_path,
+                repository,
+                config,
+                local_borg_version,
+                action_arguments,
+                global_arguments,
+                local_path,
+                remote_path,
             )
         elif action_name == 'rinfo':
             yield from borgmatic.actions.rinfo.run_rinfo(
-                repository, storage, local_borg_version, action_arguments, local_path, remote_path,
+                repository,
+                config,
+                local_borg_version,
+                action_arguments,
+                global_arguments,
+                local_path,
+                remote_path,
             )
         elif action_name == 'info':
             yield from borgmatic.actions.info.run_info(
-                repository, storage, local_borg_version, action_arguments, local_path, remote_path,
+                repository,
+                config,
+                local_borg_version,
+                action_arguments,
+                global_arguments,
+                local_path,
+                remote_path,
             )
         elif action_name == 'break-lock':
             borgmatic.actions.break_lock.run_break_lock(
                 repository,
-                storage,
+                config,
                 local_borg_version,
-                arguments['break-lock'],
+                action_arguments,
+                global_arguments,
                 local_path,
                 remote_path,
             )
         elif action_name == 'borg':
             borgmatic.actions.borg.run_borg(
-                repository, storage, local_borg_version, action_arguments, local_path, remote_path,
+                repository,
+                config,
+                local_borg_version,
+                action_arguments,
+                global_arguments,
+                local_path,
+                remote_path,
             )
 
     command.execute_hook(
-        hooks.get('after_actions'),
-        hooks.get('umask'),
+        config.get('after_actions'),
+        config.get('umask'),
         config_filename,
         'post-actions',
         global_arguments.dry_run,
         **hook_context,
     )
 
 
 def load_configurations(config_filenames, overrides=None, resolve_env=True):
     '''
     Given a sequence of configuration filenames, load and validate each configuration file. Return
     the results as a tuple of: dict of configuration filename to corresponding parsed configuration,
     and sequence of logging.LogRecord instances containing any parse errors.
+
+    Log records are returned here instead of being logged directly because logging isn't yet
+    initialized at this point!
     '''
     # Dict mapping from config filename to corresponding parsed config dict.
     configs = collections.OrderedDict()
     logs = []
 
     # Parse and load each configuration file.
     for config_filename in config_filenames:
+        logs.extend(
+            [
+                logging.makeLogRecord(
+                    dict(
+                        levelno=logging.DEBUG,
+                        levelname='DEBUG',
+                        msg=f'{config_filename}: Loading configuration file',
+                    )
+                ),
+            ]
+        )
         try:
             configs[config_filename], parse_logs = validate.parse_configuration(
                 config_filename, validate.schema_filename(), overrides, resolve_env
             )
             logs.extend(parse_logs)
         except PermissionError:
             logs.extend(
                 [
                     logging.makeLogRecord(
                         dict(
                             levelno=logging.WARNING,
                             levelname='WARNING',
-                            msg='{}: Insufficient permissions to read configuration file'.format(
-                                config_filename
-                            ),
+                            msg=f'{config_filename}: Insufficient permissions to read configuration file',
                         )
                     ),
                 ]
             )
         except (ValueError, OSError, validate.Validation_error) as error:
             logs.extend(
                 [
                     logging.makeLogRecord(
                         dict(
                             levelno=logging.CRITICAL,
                             levelname='CRITICAL',
-                            msg='{}: Error parsing configuration file'.format(config_filename),
+                            msg=f'{config_filename}: Error parsing configuration file',
                         )
                     ),
                     logging.makeLogRecord(
                         dict(levelno=logging.CRITICAL, levelname='CRITICAL', msg=error)
                     ),
                 ]
             )
@@ -507,14 +540,17 @@
     if suppress_log:
         return record
 
     logger.handle(record)
     return record
 
 
+MAX_CAPTURED_OUTPUT_LENGTH = 1000
+
+
 def log_error_records(
     message, error=None, levelno=logging.CRITICAL, log_command_error_output=False
 ):
     '''
     Given error message text, an optional exception object, an optional log level, and whether to
     log the error output of a CalledProcessError (if any), log error summary information and also
     yield it as a series of logging.LogRecord instances.
@@ -529,20 +565,26 @@
         return
 
     try:
         raise error
     except CalledProcessError as error:
         yield log_record(levelno=levelno, levelname=level_name, msg=message)
         if error.output:
+            try:
+                output = error.output.decode('utf-8')
+            except (UnicodeDecodeError, AttributeError):
+                output = error.output
+
             # Suppress these logs for now and save full error output for the log summary at the end.
             yield log_record(
                 levelno=levelno,
                 levelname=level_name,
-                msg=error.output,
-                suppress_log=not log_command_error_output,
+                msg=output[:MAX_CAPTURED_OUTPUT_LENGTH]
+                + ' ...' * (len(output) > MAX_CAPTURED_OUTPUT_LENGTH),
+                suppress_log=True,
             )
         yield log_record(levelno=levelno, levelname=level_name, msg=error)
     except (ValueError, OSError) as error:
         yield log_record(levelno=levelno, levelname=level_name, msg=message)
         yield log_record(levelno=levelno, levelname=level_name, msg=error)
     except:  # noqa: E722
         # Raising above only as a means of determining the error type. Swallow the exception here
@@ -551,20 +593,114 @@
 
 
 def get_local_path(configs):
     '''
     Arbitrarily return the local path from the first configuration dict. Default to "borg" if not
     set.
     '''
-    return next(iter(configs.values())).get('location', {}).get('local_path', 'borg')
+    return next(iter(configs.values())).get('local_path', 'borg')
+
+
+def collect_highlander_action_summary_logs(configs, arguments, configuration_parse_errors):
+    '''
+    Given a dict of configuration filename to corresponding parsed configuration, parsed
+    command-line arguments as a dict from subparser name to a parsed namespace of arguments, and
+    whether any configuration files encountered errors during parsing, run a highlander action
+    specified in the arguments, if any, and yield a series of logging.LogRecord instances containing
+    summary information.
+
+    A highlander action is an action that cannot coexist with other actions on the borgmatic
+    command-line, and borgmatic exits after processing such an action.
+    '''
+    add_custom_log_levels()
+
+    if 'bootstrap' in arguments:
+        try:
+            # No configuration file is needed for bootstrap.
+            local_borg_version = borg_version.local_borg_version({}, 'borg')
+        except (OSError, CalledProcessError, ValueError) as error:
+            yield from log_error_records('Error getting local Borg version', error)
+            return
+
+        try:
+            borgmatic.actions.config.bootstrap.run_bootstrap(
+                arguments['bootstrap'], arguments['global'], local_borg_version
+            )
+            yield logging.makeLogRecord(
+                dict(
+                    levelno=logging.ANSWER,
+                    levelname='ANSWER',
+                    msg='Bootstrap successful',
+                )
+            )
+        except (
+            CalledProcessError,
+            ValueError,
+            OSError,
+        ) as error:
+            yield from log_error_records(error)
+
+        return
+
+    if 'generate' in arguments:
+        try:
+            borgmatic.actions.config.generate.run_generate(
+                arguments['generate'], arguments['global']
+            )
+            yield logging.makeLogRecord(
+                dict(
+                    levelno=logging.ANSWER,
+                    levelname='ANSWER',
+                    msg='Generate successful',
+                )
+            )
+        except (
+            CalledProcessError,
+            ValueError,
+            OSError,
+        ) as error:
+            yield from log_error_records(error)
+
+        return
+
+    if 'validate' in arguments:
+        if configuration_parse_errors:
+            yield logging.makeLogRecord(
+                dict(
+                    levelno=logging.CRITICAL,
+                    levelname='CRITICAL',
+                    msg='Configuration validation failed',
+                )
+            )
+
+            return
+
+        try:
+            borgmatic.actions.config.validate.run_validate(arguments['validate'], configs)
+
+            yield logging.makeLogRecord(
+                dict(
+                    levelno=logging.ANSWER,
+                    levelname='ANSWER',
+                    msg='All configuration files are valid',
+                )
+            )
+        except (
+            CalledProcessError,
+            ValueError,
+            OSError,
+        ) as error:
+            yield from log_error_records(error)
+
+        return
 
 
 def collect_configuration_run_summary_logs(configs, arguments):
     '''
-    Given a dict of configuration filename to corresponding parsed configuration, and parsed
+    Given a dict of configuration filename to corresponding parsed configuration and parsed
     command-line arguments as a dict from subparser name to a parsed namespace of arguments, run
     each configuration file and yield a series of logging.LogRecord instances containing summary
     information about each run.
 
     As a side effect of running through these configuration files, output their JSON results, if
     any, to stdout.
     '''
@@ -583,27 +719,24 @@
         validate.guard_configuration_contains_repository(repository, configs)
     except ValueError as error:
         yield from log_error_records(str(error))
         return
 
     if not configs:
         yield from log_error_records(
-            '{}: No valid configuration files found'.format(
-                ' '.join(arguments['global'].config_paths)
-            )
+            f"{' '.join(arguments['global'].config_paths)}: No valid configuration files found",
         )
         return
 
     if 'create' in arguments:
         try:
             for config_filename, config in configs.items():
-                hooks = config.get('hooks', {})
                 command.execute_hook(
-                    hooks.get('before_everything'),
-                    hooks.get('umask'),
+                    config.get('before_everything'),
+                    config.get('umask'),
                     config_filename,
                     'pre-everything',
                     arguments['global'].dry_run,
                 )
         except (CalledProcessError, ValueError, OSError) as error:
             yield from log_error_records('Error running pre-everything hook', error)
             return
@@ -611,48 +744,46 @@
     # Execute the actions corresponding to each configuration file.
     json_results = []
     for config_filename, config in configs.items():
         results = list(run_configuration(config_filename, config, arguments))
         error_logs = tuple(result for result in results if isinstance(result, logging.LogRecord))
 
         if error_logs:
-            yield from log_error_records(
-                '{}: Error running configuration file'.format(config_filename)
-            )
+            yield from log_error_records(f'{config_filename}: An error occurred')
             yield from error_logs
         else:
             yield logging.makeLogRecord(
                 dict(
                     levelno=logging.INFO,
                     levelname='INFO',
-                    msg='{}: Successfully ran configuration file'.format(config_filename),
+                    msg=f'{config_filename}: Successfully ran configuration file',
                 )
             )
             if results:
                 json_results.extend(results)
 
     if 'umount' in arguments:
-        logger.info('Unmounting mount point {}'.format(arguments['umount'].mount_point))
+        logger.info(f"Unmounting mount point {arguments['umount'].mount_point}")
         try:
             borg_umount.unmount_archive(
-                mount_point=arguments['umount'].mount_point, local_path=get_local_path(configs),
+                mount_point=arguments['umount'].mount_point,
+                local_path=get_local_path(configs),
             )
         except (CalledProcessError, OSError) as error:
             yield from log_error_records('Error unmounting mount point', error)
 
     if json_results:
         sys.stdout.write(json.dumps(json_results))
 
     if 'create' in arguments:
         try:
             for config_filename, config in configs.items():
-                hooks = config.get('hooks', {})
                 command.execute_hook(
-                    hooks.get('after_everything'),
-                    hooks.get('umask'),
+                    config.get('after_everything'),
+                    config.get('umask'),
                     config_filename,
                     'post-everything',
                     arguments['global'].dry_run,
                 )
         except (CalledProcessError, ValueError, OSError) as error:
             yield from log_error_records('Error running post-everything hook', error)
 
@@ -662,42 +793,49 @@
     Display a link to get help and exit with an error code.
     '''
     logger.critical('')
     logger.critical('Need some help? https://torsion.org/borgmatic/#issues')
     sys.exit(1)
 
 
-def main():  # pragma: no cover
+def main(extra_summary_logs=[]):  # pragma: no cover
     configure_signals()
 
     try:
         arguments = parse_arguments(*sys.argv[1:])
     except ValueError as error:
         configure_logging(logging.CRITICAL)
         logger.critical(error)
         exit_with_help_link()
     except SystemExit as error:
         if error.code == 0:
             raise error
         configure_logging(logging.CRITICAL)
-        logger.critical('Error parsing arguments: {}'.format(' '.join(sys.argv)))
+        logger.critical(f"Error parsing arguments: {' '.join(sys.argv)}")
         exit_with_help_link()
 
     global_arguments = arguments['global']
     if global_arguments.version:
-        print(pkg_resources.require('borgmatic')[0].version)
+        print(importlib_metadata.version('borgmatic'))
         sys.exit(0)
     if global_arguments.bash_completion:
-        print(borgmatic.commands.completion.bash_completion())
+        print(borgmatic.commands.completion.bash.bash_completion())
+        sys.exit(0)
+    if global_arguments.fish_completion:
+        print(borgmatic.commands.completion.fish.fish_completion())
         sys.exit(0)
 
     config_filenames = tuple(collect.collect_config_filenames(global_arguments.config_paths))
+    global_arguments.used_config_paths = list(config_filenames)
     configs, parse_logs = load_configurations(
         config_filenames, global_arguments.overrides, global_arguments.resolve_env
     )
+    configuration_parse_errors = (
+        (max(log.levelno for log in parse_logs) >= logging.CRITICAL) if parse_logs else False
+    )
 
     any_json_flags = any(
         getattr(sub_arguments, 'json', False) for sub_arguments in arguments.values()
     )
     colorama.init(
         autoreset=True,
         strip=not should_do_markup(global_arguments.no_color or any_json_flags, configs),
@@ -705,24 +843,33 @@
     try:
         configure_logging(
             verbosity_to_log_level(global_arguments.verbosity),
             verbosity_to_log_level(global_arguments.syslog_verbosity),
             verbosity_to_log_level(global_arguments.log_file_verbosity),
             verbosity_to_log_level(global_arguments.monitoring_verbosity),
             global_arguments.log_file,
+            global_arguments.log_file_format,
         )
     except (FileNotFoundError, PermissionError) as error:
         configure_logging(logging.CRITICAL)
-        logger.critical('Error configuring logging: {}'.format(error))
+        logger.critical(f'Error configuring logging: {error}')
         exit_with_help_link()
 
-    logger.debug('Ensuring legacy configuration is upgraded')
-    convert.guard_configuration_upgraded(LEGACY_CONFIG_PATH, config_filenames)
-
-    summary_logs = parse_logs + list(collect_configuration_run_summary_logs(configs, arguments))
+    summary_logs = (
+        extra_summary_logs
+        + parse_logs
+        + (
+            list(
+                collect_highlander_action_summary_logs(
+                    configs, arguments, configuration_parse_errors
+                )
+            )
+            or list(collect_configuration_run_summary_logs(configs, arguments))
+        )
+    )
     summary_logs_max_level = max(log.levelno for log in summary_logs)
 
     for message in ('', 'summary:'):
         log_record(
             levelno=summary_logs_max_level,
             levelname=logging.getLevelName(summary_logs_max_level),
             msg=message,
```

### Comparing `borgmatic-1.7.9/borgmatic/config/collect.py` & `borgmatic-1.8.0/borgmatic/config/collect.py`

 * *Files 8% similar despite different names*

```diff
@@ -12,43 +12,43 @@
     user_config_directory = os.getenv('XDG_CONFIG_HOME') or os.path.join('$HOME', '.config')
     if expand_home:
         user_config_directory = os.path.expandvars(user_config_directory)
 
     return [
         '/etc/borgmatic/config.yaml',
         '/etc/borgmatic.d',
-        '%s/borgmatic/config.yaml' % user_config_directory,
-        '%s/borgmatic.d' % user_config_directory,
+        os.path.join(user_config_directory, 'borgmatic/config.yaml'),
+        os.path.join(user_config_directory, 'borgmatic.d'),
     ]
 
 
 def collect_config_filenames(config_paths):
     '''
     Given a sequence of config paths, both filenames and directories, resolve that to an iterable
-    of files. Accomplish this by listing any given directories looking for contained config files
-    (ending with the ".yaml" or ".yml" extension). This is non-recursive, so any directories within the given
-    directories are ignored.
+    of absolute files. Accomplish this by listing any given directories looking for contained config
+    files (ending with the ".yaml" or ".yml" extension). This is non-recursive, so any directories
+    within the given directories are ignored.
 
     Return paths even if they don't exist on disk, so the user can find out about missing
     configuration paths. However, skip a default config path if it's missing, so the user doesn't
     have to create a default config path unless they need it.
     '''
     real_default_config_paths = set(map(os.path.realpath, get_default_config_paths()))
 
     for path in config_paths:
         exists = os.path.exists(path)
 
         if os.path.realpath(path) in real_default_config_paths and not exists:
             continue
 
         if not os.path.isdir(path) or not exists:
-            yield path
+            yield os.path.abspath(path)
             continue
 
         if not os.access(path, os.R_OK):
             continue
 
         for filename in sorted(os.listdir(path)):
             full_filename = os.path.join(path, filename)
             matching_filetype = full_filename.endswith('.yaml') or full_filename.endswith('.yml')
             if matching_filetype and not os.path.isdir(full_filename):
-                yield full_filename
+                yield os.path.abspath(full_filename)
```

### Comparing `borgmatic-1.7.9/borgmatic/config/environment.py` & `borgmatic-1.8.0/borgmatic/config/environment.py`

 * *Files 6% similar despite different names*

```diff
@@ -10,19 +10,22 @@
     '''
     Get the value from environment given a matcher containing a name and an optional default value.
     If the variable is not defined in environment and no default value is provided, an Error is raised.
     '''
     if matcher.group('escape') is not None:
         # in case of escaped envvar, unescape it
         return matcher.group('variable')
+
     # resolve the env var
     name, default = matcher.group('name'), matcher.group('default')
     out = os.getenv(name, default=default)
+
     if out is None:
-        raise ValueError('Cannot find variable ${name} in environment'.format(name=name))
+        raise ValueError(f'Cannot find variable {name} in environment')
+
     return out
 
 
 def resolve_env_variables(item):
     '''
     Resolves variables like or ${FOO} from given configuration with values from process environment
     Supported formats:
```

### Comparing `borgmatic-1.7.9/borgmatic/config/generate.py` & `borgmatic-1.8.0/borgmatic/config/generate.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,71 +7,71 @@
 
 from borgmatic.config import load, normalize
 
 INDENT = 4
 SEQUENCE_INDENT = 2
 
 
-def _insert_newline_before_comment(config, field_name):
+def insert_newline_before_comment(config, field_name):
     '''
     Using some ruamel.yaml black magic, insert a blank line in the config right before the given
     field and its comments.
     '''
     config.ca.items[field_name][1].insert(
         0, yaml.tokens.CommentToken('\n', yaml.error.CommentMark(0), None)
     )
 
 
-def _schema_to_sample_configuration(schema, level=0, parent_is_sequence=False):
+def schema_to_sample_configuration(schema, level=0, parent_is_sequence=False):
     '''
     Given a loaded configuration schema, generate and return sample config for it. Include comments
-    for each section based on the schema "description".
+    for each option based on the schema "description".
     '''
     schema_type = schema.get('type')
     example = schema.get('example')
     if example is not None:
         return example
 
     if schema_type == 'array':
         config = yaml.comments.CommentedSeq(
-            [_schema_to_sample_configuration(schema['items'], level, parent_is_sequence=True)]
+            [schema_to_sample_configuration(schema['items'], level, parent_is_sequence=True)]
         )
         add_comments_to_configuration_sequence(config, schema, indent=(level * INDENT))
     elif schema_type == 'object':
         config = yaml.comments.CommentedMap(
             [
-                (field_name, _schema_to_sample_configuration(sub_schema, level + 1))
+                (field_name, schema_to_sample_configuration(sub_schema, level + 1))
                 for field_name, sub_schema in schema['properties'].items()
             ]
         )
         indent = (level * INDENT) + (SEQUENCE_INDENT if parent_is_sequence else 0)
         add_comments_to_configuration_object(
             config, schema, indent=indent, skip_first=parent_is_sequence
         )
     else:
-        raise ValueError('Schema at level {} is unsupported: {}'.format(level, schema))
+        raise ValueError(f'Schema at level {level} is unsupported: {schema}')
 
     return config
 
 
-def _comment_out_line(line):
+def comment_out_line(line):
     # If it's already is commented out (or empty), there's nothing further to do!
     stripped_line = line.lstrip()
     if not stripped_line or stripped_line.startswith('#'):
         return line
 
-    # Comment out the names of optional sections, inserting the '#' after any indent for aesthetics.
+    # Comment out the names of optional options, inserting the '#' after any indent for aesthetics.
     matches = re.match(r'(\s*)', line)
     indent_spaces = matches.group(0) if matches else ''
     count_indent_spaces = len(indent_spaces)
 
     return '# '.join((indent_spaces, line[count_indent_spaces:]))
 
 
-def _comment_out_optional_configuration(rendered_config):
+def comment_out_optional_configuration(rendered_config):
     '''
     Post-process a rendered configuration string to comment out optional key/values, as determined
     by a sentinel in the comment before each key.
 
     The idea is that the pre-commented configuration prevents the user from having to comment out a
     bunch of configuration they don't care about to get to a minimal viable configuration file.
 
@@ -80,23 +80,23 @@
     '''
     lines = []
     optional = False
 
     for line in rendered_config.split('\n'):
         # Upon encountering an optional configuration option, comment out lines until the next blank
         # line.
-        if line.strip().startswith('# {}'.format(COMMENTED_OUT_SENTINEL)):
+        if line.strip().startswith(f'# {COMMENTED_OUT_SENTINEL}'):
             optional = True
             continue
 
         # Hit a blank line, so reset commenting.
         if not line.strip():
             optional = False
 
-        lines.append(_comment_out_line(line) if optional else line)
+        lines.append(comment_out_line(line) if optional else line)
 
     return '\n'.join(lines)
 
 
 def render_configuration(config):
     '''
     Given a config data structure of nested OrderedDicts, render the config as YAML and return it.
@@ -113,17 +113,15 @@
     '''
     Given a target config filename and rendered config YAML, write it out to file. Create any
     containing directories as needed. But if the file already exists and overwrite is False,
     abort before writing anything.
     '''
     if not overwrite and os.path.exists(config_filename):
         raise FileExistsError(
-            '{} already exists. Aborting. Use --overwrite to replace the file.'.format(
-                config_filename
-            )
+            f'{config_filename} already exists. Aborting. Use --overwrite to replace the file.'
         )
 
     try:
         os.makedirs(os.path.dirname(config_filename), mode=0o700)
     except (FileExistsError, FileNotFoundError):
         pass
 
@@ -163,15 +161,14 @@
         config[0].yaml_set_start_comment(description, indent=indent)
 
         # We only want the first key's description here, as the rest of the keys get commented by
         # add_comments_to_configuration_object().
         return
 
 
-REQUIRED_SECTION_NAMES = {'location', 'retention'}
 REQUIRED_KEYS = {'source_directories', 'repositories', 'keep_daily'}
 COMMENTED_OUT_SENTINEL = 'COMMENT_OUT'
 
 
 def add_comments_to_configuration_object(config, schema, indent=0, skip_first=False):
     '''
     Using descriptions from a schema as a source, add those descriptions as comments to the given
@@ -183,29 +180,29 @@
 
         field_schema = schema['properties'].get(field_name, {})
         description = field_schema.get('description', '').strip()
 
         # If this is an optional key, add an indicator to the comment flagging it to be commented
         # out from the sample configuration. This sentinel is consumed by downstream processing that
         # does the actual commenting out.
-        if field_name not in REQUIRED_SECTION_NAMES and field_name not in REQUIRED_KEYS:
+        if field_name not in REQUIRED_KEYS:
             description = (
                 '\n'.join((description, COMMENTED_OUT_SENTINEL))
                 if description
                 else COMMENTED_OUT_SENTINEL
             )
 
         # No description to use? Skip it.
         if not field_schema or not description:  # pragma: no cover
             continue
 
         config.yaml_set_comment_before_after_key(key=field_name, before=description, indent=indent)
 
         if index > 0:
-            _insert_newline_before_comment(config, field_name)
+            insert_newline_before_comment(config, field_name)
 
 
 RUAMEL_YAML_COMMENTS_INDEX = 1
 
 
 def remove_commented_out_sentinel(config, field_name):
     '''
@@ -214,15 +211,15 @@
     commented out by downstream processing that consumes the sentinel.
     '''
     try:
         last_comment_value = config.ca.items[field_name][RUAMEL_YAML_COMMENTS_INDEX][-1].value
     except KeyError:
         return
 
-    if last_comment_value == '# {}\n'.format(COMMENTED_OUT_SENTINEL):
+    if last_comment_value == f'# {COMMENTED_OUT_SENTINEL}\n':
         config.ca.items[field_name][RUAMEL_YAML_COMMENTS_INDEX].pop()
 
 
 def merge_source_configuration_into_destination(destination_config, source_config):
     '''
     Deep merge the given source configuration dict into the destination configuration CommentedMap,
     favoring values from the source when there are collisions.
@@ -258,22 +255,22 @@
                         source_item,
                     )
                     for index, source_item in enumerate(source_value)
                 ]
             )
             continue
 
-        # This is some sort of scalar. Simply set it into the destination.
+        # This is some sort of scalar. Set it into the destination.
         destination_config[field_name] = source_config[field_name]
 
     return destination_config
 
 
 def generate_sample_configuration(
-    source_filename, destination_filename, schema_filename, overwrite=False
+    dry_run, source_filename, destination_filename, schema_filename, overwrite=False
 ):
     '''
     Given an optional source configuration filename, and a required destination configuration
     filename, the path to a schema filename in a YAML rendition of the JSON Schema format, and
     whether to overwrite a destination file, write out a sample configuration file based on that
     schema. If a source filename is provided, merge the parsed contents of that configuration into
     the generated configuration.
@@ -282,15 +279,18 @@
     source_config = None
 
     if source_filename:
         source_config = load.load_configuration(source_filename)
         normalize.normalize(source_filename, source_config)
 
     destination_config = merge_source_configuration_into_destination(
-        _schema_to_sample_configuration(schema), source_config
+        schema_to_sample_configuration(schema), source_config
     )
 
+    if dry_run:
+        return
+
     write_configuration(
         destination_filename,
-        _comment_out_optional_configuration(render_configuration(destination_config)),
+        comment_out_optional_configuration(render_configuration(destination_config)),
         overwrite=overwrite,
     )
```

### Comparing `borgmatic-1.7.9/borgmatic/config/override.py` & `borgmatic-1.8.0/borgmatic/config/override.py`

 * *Files 12% similar despite different names*

```diff
@@ -28,52 +28,71 @@
     converted to that type.
 
     Raise ruamel.yaml.error.YAMLError if there's a parse issue with the YAML.
     '''
     return ruamel.yaml.YAML(typ='safe').load(io.StringIO(value))
 
 
+LEGACY_SECTION_NAMES = {'location', 'storage', 'retention', 'consistency', 'output', 'hooks'}
+
+
+def strip_section_names(parsed_override_key):
+    '''
+    Given a parsed override key as a tuple of option and suboption names, strip out any initial
+    legacy section names, since configuration file normalization also strips them out.
+    '''
+    if parsed_override_key[0] in LEGACY_SECTION_NAMES:
+        return parsed_override_key[1:]
+
+    return parsed_override_key
+
+
 def parse_overrides(raw_overrides):
     '''
-    Given a sequence of configuration file override strings in the form of "section.option=value",
+    Given a sequence of configuration file override strings in the form of "option.suboption=value",
     parse and return a sequence of tuples (keys, values), where keys is a sequence of strings. For
     instance, given the following raw overrides:
 
-        ['section.my_option=value1', 'section.other_option=value2']
+        ['my_option.suboption=value1', 'other_option=value2']
 
     ... return this:
 
         (
-            (('section', 'my_option'), 'value1'),
-            (('section', 'other_option'), 'value2'),
+            (('my_option', 'suboption'), 'value1'),
+            (('other_option'), 'value2'),
         )
 
     Raise ValueError if an override can't be parsed.
     '''
     if not raw_overrides:
         return ()
 
     parsed_overrides = []
 
     for raw_override in raw_overrides:
         try:
             raw_keys, value = raw_override.split('=', 1)
-            parsed_overrides.append((tuple(raw_keys.split('.')), convert_value_type(value),))
+            parsed_overrides.append(
+                (
+                    strip_section_names(tuple(raw_keys.split('.'))),
+                    convert_value_type(value),
+                )
+            )
         except ValueError:
             raise ValueError(
-                f"Invalid override '{raw_override}'. Make sure you use the form: SECTION.OPTION=VALUE"
+                f"Invalid override '{raw_override}'. Make sure you use the form: OPTION=VALUE or OPTION.SUBOPTION=VALUE"
             )
         except ruamel.yaml.error.YAMLError as error:
             raise ValueError(f"Invalid override '{raw_override}': {error.problem}")
 
     return tuple(parsed_overrides)
 
 
 def apply_overrides(config, raw_overrides):
     '''
     Given a configuration dict and a sequence of configuration file override strings in the form of
-    "section.option=value", parse each override and set it the configuration dict.
+    "option.suboption=value", parse each override and set it the configuration dict.
     '''
     overrides = parse_overrides(raw_overrides)
 
-    for (keys, value) in overrides:
+    for keys, value in overrides:
         set_values(config, keys, value)
```

### Comparing `borgmatic-1.7.9/borgmatic/config/schema.yaml` & `borgmatic-1.8.0/borgmatic/config/schema.yaml`

 * *Files 11% similar despite different names*

```diff
@@ -1,1269 +1,1287 @@
 type: object
 required:
-    - location
+    - repositories
 additionalProperties: false
 properties:
-    location:
+    constants:
         type: object
         description: |
-            Where to look for files to backup, and where to store those backups.
-            See https://borgbackup.readthedocs.io/en/stable/quickstart.html and
-            https://borgbackup.readthedocs.io/en/stable/usage/create.html
-            for details.
-        required:
-            - repositories
-        additionalProperties: false
-        properties:
-            source_directories:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of source directories to backup. Globs and tildes are
-                    expanded. Do not backslash spaces in path names.
-                example:
-                    - /home
-                    - /etc
-                    - /var/log/syslog*
-                    - /home/user/path with spaces
-            repositories:
-                type: array
-                items:
-                    type: string
-                description: |
-                    Paths to local or remote repositories (required). Tildes are
-                    expanded. Multiple repositories are backed up to in
-                    sequence. Borg placeholders can be used. See the output of
-                    "borg help placeholders" for details. See ssh_command for
-                    SSH options like identity file or port. If systemd service
-                    is used, then add local repository paths in the systemd
-                    service file to the ReadWritePaths list.
-                example:
-                    - ssh://user@backupserver/./sourcehostname.borg
-                    - ssh://user@backupserver/./{fqdn}
-                    - /var/local/backups/local.borg
-            working_directory:
-                type: string
-                description: |
-                    Working directory for the "borg create" command. Tildes are
-                    expanded. Useful for backing up using relative paths. See
-                    http://borgbackup.readthedocs.io/en/stable/usage/create.html
-                    for details. Defaults to not set.
-                example: /path/to/working/directory
-            one_file_system:
-                type: boolean
-                description: |
-                    Stay in same file system: do not cross mount points beyond
-                    the given source directories. Defaults to false. But when a
-                    database hook is used, the setting here is ignored and
-                    one_file_system is considered true.
-                example: true
-            numeric_ids:
-                type: boolean
-                description: |
-                    Only store/extract numeric user and group identifiers.
-                    Defaults to false.
-                example: true
-            atime:
-                type: boolean
-                description: |
-                    Store atime into archive. Defaults to true in Borg < 1.2,
-                    false in Borg 1.2+.
-                example: false
-            ctime:
-                type: boolean
-                description: Store ctime into archive. Defaults to true.
-                example: false
-            birthtime:
-                type: boolean
-                description: |
-                    Store birthtime (creation date) into archive. Defaults to
-                    true.
-                example: false
-            read_special:
-                type: boolean
-                description: |
-                    Use Borg's --read-special flag to allow backup of block and
-                    other special devices. Use with caution, as it will lead to
-                    problems if used when backing up special devices such as
-                    /dev/zero. Defaults to false. But when a database hook is
-                    used, the setting here is ignored and read_special is
-                    considered true.
-                example: false
-            flags:
-                type: boolean
-                description: |
-                    Record filesystem flags (e.g. NODUMP, IMMUTABLE) in archive.
-                    Defaults to true.
-                example: true
-            files_cache:
-                type: string
-                description: |
-                    Mode in which to operate the files cache. See
-                    http://borgbackup.readthedocs.io/en/stable/usage/create.html
-                    for details. Defaults to "ctime,size,inode".
-                example: ctime,size,inode
-            local_path:
-                type: string
-                description: |
-                    Alternate Borg local executable. Defaults to "borg".
-                example: borg1
-            remote_path:
-                type: string
-                description: |
-                    Alternate Borg remote executable. Defaults to "borg".
-                example: borg1
-            patterns:
-                type: array
-                items:
-                    type: string
-                description: |
-                    Any paths matching these patterns are included/excluded from
-                    backups. Globs are expanded. (Tildes are not.) See the
-                    output of "borg help patterns" for more details. Quote any
-                    value if it contains leading punctuation, so it parses
-                    correctly. Note that only one of "patterns" and
-                    "source_directories" may be used.
-                example:
-                    - 'R /'
-                    - '- /home/*/.cache'
-                    - '+ /home/susan'
-                    - '- /home/*'
-            patterns_from:
-                type: array
-                items:
-                    type: string
-                description: |
-                    Read include/exclude patterns from one or more separate
-                    named files, one pattern per line. Note that Borg considers
-                    this option experimental. See the output of "borg help
-                    patterns" for more details.
-                example:
-                    - /etc/borgmatic/patterns
-            exclude_patterns:
-                type: array
-                items:
-                    type: string
-                description: |
-                    Any paths matching these patterns are excluded from backups.
-                    Globs and tildes are expanded. Note that a glob pattern must
-                    either start with a glob or be an absolute path. Do not
-                    backslash spaces in path names. See the output of "borg help
-                    patterns" for more details.
-                example:
-                    - '*.pyc'
-                    - /home/*/.cache
-                    - '*/.vim*.tmp'
-                    - /etc/ssl
-                    - /home/user/path with spaces
-            exclude_from:
-                type: array
-                items:
+            Constants to use in the configuration file. All occurrences of the
+            constant name within culy braces will be replaced with the value.
+            For example, if you have a constant named "hostname" with the value
+            "myhostname", then the string "{hostname}" will be replaced with
+            "myhostname" in the configuration file.
+        example:
+            hostname: myhostname
+            prefix: myprefix
+    source_directories:
+        type: array
+        items:
+            type: string
+        description: |
+            List of source directories and files to backup. Globs and tildes are
+            expanded. Do not backslash spaces in path names.
+        example:
+            - /home
+            - /etc
+            - /var/log/syslog*
+            - /home/user/path with spaces
+    repositories:
+        type: array
+        items:
+            type: object 
+            required:
+                - path
+            properties:
+                path:
                     type: string
-                description: |
-                    Read exclude patterns from one or more separate named files,
-                    one pattern per line. See the output of "borg help patterns"
-                    for more details.
-                example:
-                    - /etc/borgmatic/excludes
-            exclude_caches:
-                type: boolean
-                description: |
-                    Exclude directories that contain a CACHEDIR.TAG file. See
-                    http://www.brynosaurus.com/cachedir/spec.html for details.
-                    Defaults to false.
-                example: true
-            exclude_if_present:
-                type: array
-                items:
+                    example: ssh://user@backupserver/./{fqdn}
+                label:
                     type: string
-                description: |
-                    Exclude directories that contain a file with the given
-                    filenames. Defaults to not set.
-                example:
-                    - .nobackup
-            keep_exclude_tags:
-                type: boolean
-                description: |
-                    If true, the exclude_if_present filename is included in
-                    backups. Defaults to false, meaning that the
-                    exclude_if_present filename is omitted from backups.
-                example: true
-            exclude_nodump:
-                type: boolean
-                description: |
-                    Exclude files with the NODUMP flag. Defaults to false.
-                example: true
-            borgmatic_source_directory:
-                type: string
-                description: |
-                    Path for additional source files used for temporary internal
-                    state like borgmatic database dumps. Note that changing this
-                    path prevents "borgmatic restore" from finding any database
-                    dumps created before the change. Defaults to ~/.borgmatic
-                example: /tmp/borgmatic
-    storage:
-        type: object
+                    example: backupserver
+        description: |
+            A required list of local or remote repositories with paths and
+            optional labels (which can be used with the --repository flag to
+            select a repository). Tildes are expanded. Multiple repositories are
+            backed up to in sequence. Borg placeholders can be used. See the
+            output of "borg help placeholders" for details. See ssh_command for
+            SSH options like identity file or port. If systemd service is used,
+            then add local repository paths in the systemd service file to the
+            ReadWritePaths list. Prior to borgmatic 1.7.10, repositories was a
+            list of plain path strings.
+        example:
+            - path: ssh://user@backupserver/./sourcehostname.borg
+              label: backupserver
+            - path: /mnt/backup
+              label: local
+    working_directory:
+        type: string
+        description: |
+            Working directory for the "borg create" command. Tildes are
+            expanded. Useful for backing up using relative paths. See
+            http://borgbackup.readthedocs.io/en/stable/usage/create.html for
+            details. Defaults to not set.
+        example: /path/to/working/directory
+    one_file_system:
+        type: boolean
+        description: |
+            Stay in same file system; do not cross mount points beyond the given
+            source directories. Defaults to false. But when a database hook is
+            used, the setting here is ignored and one_file_system is considered
+            true.
+        example: true
+    numeric_ids:
+        type: boolean
+        description: |
+            Only store/extract numeric user and group identifiers. Defaults to
+            false.
+        example: true
+    atime:
+        type: boolean
+        description: |
+            Store atime into archive. Defaults to true in Borg < 1.2, false in
+            Borg 1.2+.
+        example: false
+    ctime:
+        type: boolean
+        description: Store ctime into archive. Defaults to true.
+        example: false
+    birthtime:
+        type: boolean
+        description: |
+            Store birthtime (creation date) into archive. Defaults to true.
+        example: false
+    read_special:
+        type: boolean
+        description: |
+            Use Borg's --read-special flag to allow backup of block and other
+            special devices. Use with caution, as it will lead to problems if
+            used when backing up special devices such as /dev/zero. Defaults to
+            false. But when a database hook is used, the setting here is ignored
+            and read_special is considered true.
+        example: false
+    flags:
+        type: boolean
         description: |
-            Repository storage options. See
-            https://borgbackup.readthedocs.io/en/stable/usage/create.html and
-            https://borgbackup.readthedocs.io/en/stable/usage/general.html for
+            Record filesystem flags (e.g. NODUMP, IMMUTABLE) in archive.
+            Defaults to true.
+        example: true
+    files_cache:
+        type: string
+        description: |
+            Mode in which to operate the files cache. See
+            http://borgbackup.readthedocs.io/en/stable/usage/create.html for
+            details. Defaults to "ctime,size,inode".
+        example: ctime,size,inode
+    local_path:
+        type: string
+        description: |
+            Alternate Borg local executable. Defaults to "borg".
+        example: borg1
+    remote_path:
+        type: string
+        description: |
+            Alternate Borg remote executable. Defaults to "borg".
+        example: borg1
+    patterns:
+        type: array
+        items:
+            type: string
+        description: |
+            Any paths matching these patterns are included/excluded from
+            backups. Globs are expanded. (Tildes are not.) See the output of
+            "borg help patterns" for more details. Quote any value if it
+            contains leading punctuation, so it parses correctly. Note that only
+            one of "patterns" and "source_directories" may be used.
+        example:
+            - 'R /'
+            - '- /home/*/.cache'
+            - '+ /home/susan'
+            - '- /home/*'
+    patterns_from:
+        type: array
+        items:
+            type: string
+        description: |
+            Read include/exclude patterns from one or more separate named files,
+            one pattern per line. Note that Borg considers this option
+            experimental. See the output of "borg help patterns" for more
             details.
+        example:
+            - /etc/borgmatic/patterns
+    exclude_patterns:
+        type: array
+        items:
+            type: string
+        description: |
+            Any paths matching these patterns are excluded from backups. Globs
+            and tildes are expanded. Note that a glob pattern must either start
+            with a glob or be an absolute path. Do not backslash spaces in path
+            names. See the output of "borg help patterns" for more details.
+        example:
+            - '*.pyc'
+            - /home/*/.cache
+            - '*/.vim*.tmp'
+            - /etc/ssl
+            - /home/user/path with spaces
+    exclude_from:
+        type: array
+        items:
+            type: string
+        description: |
+            Read exclude patterns from one or more separate named files, one
+            pattern per line. See the output of "borg help patterns" for more
+            details.
+        example:
+            - /etc/borgmatic/excludes
+    exclude_caches:
+        type: boolean
+        description: |
+            Exclude directories that contain a CACHEDIR.TAG file. See
+            http://www.brynosaurus.com/cachedir/spec.html for details. Defaults
+            to false.
+        example: true
+    exclude_if_present:
+        type: array
+        items:
+            type: string
+        description: |
+            Exclude directories that contain a file with the given filenames.
+            Defaults to not set.
+        example:
+            - .nobackup
+    keep_exclude_tags:
+        type: boolean
+        description: |
+            If true, the exclude_if_present filename is included in backups.
+            Defaults to false, meaning that the exclude_if_present filename is
+            omitted from backups.
+        example: true
+    exclude_nodump:
+        type: boolean
+        description: |
+            Exclude files with the NODUMP flag. Defaults to false.
+        example: true
+    borgmatic_source_directory:
+        type: string
+        description: |
+            Path for additional source files used for temporary internal state
+            like borgmatic database dumps. Note that changing this path prevents
+            "borgmatic restore" from finding any database dumps created before
+            the change. Defaults to ~/.borgmatic
+        example: /tmp/borgmatic
+    source_directories_must_exist:
+        type: boolean
+        description: |
+            If true, then source directories must exist, otherwise an error is
+            raised. Defaults to false.
+        example: true
+    encryption_passcommand:
+        type: string
+        description: |
+            The standard output of this command is used to unlock the encryption
+            key. Only use on repositories that were initialized with
+            passcommand/repokey/keyfile encryption. Note that if both
+            encryption_passcommand and encryption_passphrase are set, then
+            encryption_passphrase takes precedence. Defaults to not set.
+        example: "secret-tool lookup borg-repository repo-name"
+    encryption_passphrase:
+        type: string
+        description: |
+            Passphrase to unlock the encryption key with. Only use on
+            repositories that were initialized with passphrase/repokey/keyfile
+            encryption. Quote the value if it contains punctuation, so it parses
+            correctly. And backslash any quote or backslash literals as well.
+            Defaults to not set.
+        example: "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"
+    checkpoint_interval:
+        type: integer
+        description: |
+            Number of seconds between each checkpoint during a long-running
+            backup. See https://borgbackup.readthedocs.io/en/stable/faq.html for
+            details. Defaults to checkpoints every 1800 seconds (30 minutes).
+        example: 1800
+    checkpoint_volume:
+        type: integer
+        description: |
+            Number of backed up bytes between each checkpoint during a
+            long-running backup. Only supported with Borg 2+. See
+            https://borgbackup.readthedocs.io/en/stable/faq.html for details.
+            Defaults to only time-based checkpointing (see
+            "checkpoint_interval") instead of volume-based checkpointing.
+        example: 1048576
+    chunker_params:
+        type: string
+        description: |
+            Specify the parameters passed to then chunker (CHUNK_MIN_EXP,
+            CHUNK_MAX_EXP, HASH_MASK_BITS, HASH_WINDOW_SIZE). See
+            https://borgbackup.readthedocs.io/en/stable/internals.html for
+            details. Defaults to "19,23,21,4095".
+        example: 19,23,21,4095
+    compression:
+        type: string
+        description: |
+            Type of compression to use when creating archives. See
+            http://borgbackup.readthedocs.io/en/stable/usage/create.html for
+            details. Defaults to "lz4".
+        example: lz4
+    upload_rate_limit:
+        type: integer
+        description: |
+            Remote network upload rate limit in kiBytes/second. Defaults to
+            unlimited.
+        example: 100
+    retries:
+        type: integer
+        description: |
+            Number of times to retry a failing backup before giving up. Defaults
+            to 0 (i.e., does not attempt retry).
+        example: 3
+    retry_wait:
+        type: integer
+        description: |
+            Wait time between retries (in seconds) to allow transient issues to
+            pass. Increases after each retry as a form of backoff. Defaults to 0
+            (no wait).
+        example: 10
+    temporary_directory:
+        type: string
+        description: |
+            Directory where temporary files are stored. Defaults to $TMPDIR.
+        example: /path/to/tmpdir
+    ssh_command:
+        type: string
+        description: |
+            Command to use instead of "ssh". This can be used to specify ssh
+            options.  Defaults to not set.
+        example: ssh -i /path/to/private/key
+    borg_base_directory:
+        type: string
+        description: |
+            Base path used for various Borg directories. Defaults to $HOME,
+            ~$USER, or ~.
+        example: /path/to/base
+    borg_config_directory:
+        type: string
+        description: |
+            Path for Borg configuration files. Defaults to
+            $borg_base_directory/.config/borg
+        example: /path/to/base/config
+    borg_cache_directory:
+        type: string
+        description: |
+            Path for Borg cache files. Defaults to
+            $borg_base_directory/.cache/borg
+        example: /path/to/base/cache
+    borg_files_cache_ttl:
+        type: integer
+        description: |
+            Maximum time to live (ttl) for entries in the Borg files cache.
+        example: 20
+    borg_security_directory:
+        type: string
+        description: |
+            Path for Borg security and encryption nonce files. Defaults to
+            $borg_base_directory/.config/borg/security
+        example: /path/to/base/config/security
+    borg_keys_directory:
+        type: string
+        description: |
+            Path for Borg encryption key files. Defaults to
+            $borg_base_directory/.config/borg/keys
+        example: /path/to/base/config/keys
+    umask:
+        type: integer
+        description: |
+            Umask used for when executing Borg or calling hooks. Defaults to
+            0077 for Borg or the umask that borgmatic is run with for hooks.
+        example: 0077
+    lock_wait:
+        type: integer
+        description: |
+            Maximum seconds to wait for acquiring a repository/cache lock.
+            Defaults to 1.
+        example: 5
+    archive_name_format:
+        type: string
+        description: |
+            Name of the archive. Borg placeholders can be used. See the output
+            of "borg help placeholders" for details. Defaults to
+            "{hostname}-{now:%Y-%m-%dT%H:%M:%S.%f}". When running actions like
+            rlist, info, or check, borgmatic automatically tries to match only
+            archives created with this name format.
+        example: "{hostname}-documents-{now}"
+    match_archives:
+        type: string
+        description: |
+            A Borg pattern for filtering down the archives used by borgmatic
+            actions that operate on multiple archives. For Borg 1.x, use a shell
+            pattern here and see the output of "borg help placeholders" for
+            details. For Borg 2.x, see the output of "borg help match-archives".
+            If match_archives is not specified, borgmatic defaults to deriving
+            the match_archives value from archive_name_format.
+        example: "sh:{hostname}-*"
+    relocated_repo_access_is_ok:
+        type: boolean
+        description: |
+            Bypass Borg error about a repository that has been moved. Defaults
+            to false.
+        example: true
+    unknown_unencrypted_repo_access_is_ok:
+        type: boolean
+        description: |
+            Bypass Borg error about a previously unknown unencrypted repository.
+            Defaults to false.
+        example: true
+    check_i_know_what_i_am_doing:
+        type: boolean
+        description: |
+            Bypass Borg confirmation about check with repair option.
+            Defaults to false.
+        example: true
+    extra_borg_options:
+        type: object
         additionalProperties: false
         properties:
-            encryption_passcommand:
-                type: string
-                description: |
-                    The standard output of this command is used to unlock the
-                    encryption key. Only use on repositories that were
-                    initialized with passcommand/repokey/keyfile encryption.
-                    Note that if both encryption_passcommand and
-                    encryption_passphrase are set, then encryption_passphrase
-                    takes precedence. Defaults to not set.
-                example: "secret-tool lookup borg-repository repo-name"
-            encryption_passphrase:
-                type: string
-                description: |
-                    Passphrase to unlock the encryption key with. Only use on
-                    repositories that were initialized with
-                    passphrase/repokey/keyfile encryption. Quote the value if it
-                    contains punctuation, so it parses correctly. And backslash
-                    any quote or backslash literals as well. Defaults to not
-                    set.
-                example: "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"
-            checkpoint_interval:
-                type: integer
-                description: |
-                    Number of seconds between each checkpoint during a
-                    long-running backup. See
-                    https://borgbackup.readthedocs.io/en/stable/faq.html
-                    for details. Defaults to checkpoints every 1800 seconds (30
-                    minutes).
-                example: 1800
-            checkpoint_volume:
-                type: integer
-                description: |
-                    Number of backed up bytes between each checkpoint during a
-                    long-running backup. Only supported with Borg 2+. See
-                    https://borgbackup.readthedocs.io/en/stable/faq.html
-                    for details. Defaults to only time-based checkpointing (see
-                    "checkpoint_interval") instead of volume-based
-                    checkpointing.
-                example: 1048576
-            chunker_params:
+            init:
                 type: string
                 description: |
-                    Specify the parameters passed to then chunker
-                    (CHUNK_MIN_EXP, CHUNK_MAX_EXP, HASH_MASK_BITS,
-                    HASH_WINDOW_SIZE). See
-                    https://borgbackup.readthedocs.io/en/stable/internals.html
-                    for details. Defaults to "19,23,21,4095".
-                example: 19,23,21,4095
-            compression:
-                type: string
-                description: |
-                    Type of compression to use when creating archives. See
-                    http://borgbackup.readthedocs.io/en/stable/usage/create.html
-                    for details. Defaults to "lz4".
-                example: lz4
-            upload_rate_limit:
-                type: integer
-                description: |
-                    Remote network upload rate limit in kiBytes/second. Defaults
-                    to unlimited.
-                example: 100
-            retries:
-                type: integer
-                description: |
-                    Number of times to retry a failing backup before giving up.
-                    Defaults to 0 (i.e., does not attempt retry).
-                example: 3
-            retry_wait:
-                type: integer
-                description: |
-                    Wait time between retries (in seconds) to allow transient
-                    issues to pass. Increases after each retry as a form of
-                    backoff. Defaults to 0 (no wait).
-                example: 10
-            temporary_directory:
+                  Extra command-line options to pass to "borg init".
+                example: "--extra-option"
+            create:
                 type: string
                 description: |
-                    Directory where temporary files are stored. Defaults to
-                    $TMPDIR
-                example: /path/to/tmpdir
-            ssh_command:
+                  Extra command-line options to pass to "borg create".
+                example: "--extra-option"
+            prune:
                 type: string
                 description: |
-                    Command to use instead of "ssh". This can be used to specify
-                    ssh options.  Defaults to not set.
-                example: ssh -i /path/to/private/key
-            borg_base_directory:
+                  Extra command-line options to pass to "borg prune".
+                example: "--extra-option"
+            compact:
                 type: string
                 description: |
-                    Base path used for various Borg directories. Defaults to
-                    $HOME, ~$USER, or ~.
-                example: /path/to/base
-            borg_config_directory:
+                  Extra command-line options to pass to "borg compact".
+                example: "--extra-option"
+            check:
                 type: string
                 description: |
-                    Path for Borg configuration files. Defaults to
-                    $borg_base_directory/.config/borg
-                example: /path/to/base/config
-            borg_cache_directory:
+                  Extra command-line options to pass to "borg check".
+                example: "--extra-option"
+        description: |
+            Additional options to pass directly to particular Borg commands,
+            handy for Borg options that borgmatic does not yet support natively.
+            Note that borgmatic does not perform any validation on these
+            options. Running borgmatic with "--verbosity 2" shows the exact Borg
+            command-line invocation.
+    keep_within:
+        type: string
+        description: Keep all archives within this time interval.
+        example: 3H
+    keep_secondly:
+        type: integer
+        description: Number of secondly archives to keep.
+        example: 60
+    keep_minutely:
+        type: integer
+        description: Number of minutely archives to keep.
+        example: 60
+    keep_hourly:
+        type: integer
+        description: Number of hourly archives to keep.
+        example: 24
+    keep_daily:
+        type: integer
+        description: Number of daily archives to keep.
+        example: 7
+    keep_weekly:
+        type: integer
+        description: Number of weekly archives to keep.
+        example: 4
+    keep_monthly:
+        type: integer
+        description: Number of monthly archives to keep.
+        example: 6
+    keep_yearly:
+        type: integer
+        description: Number of yearly archives to keep.
+        example: 1
+    prefix:
+        type: string
+        description: |
+            Deprecated. When pruning or checking archives, only consider archive
+            names starting with this prefix. Borg placeholders can be used. See
+            the output of "borg help placeholders" for details. If a prefix is
+            not specified, borgmatic defaults to matching archives based on the
+            archive_name_format (see above).
+        example: sourcehostname
+    checks:
+        type: array
+        items:
+            type: object
+            required: ['name']
+            additionalProperties: false
+            properties:
+                name:
+                    type: string
+                    enum:
+                        - repository
+                        - archives
+                        - data
+                        - extract
+                        - disabled
+                    description: |
+                        Name of consistency check to run: "repository",
+                        "archives", "data", and/or "extract". Set to "disabled"
+                        to disable all consistency checks. "repository" checks
+                        the consistency of the repository, "archives" checks all
+                        of the archives, "data" verifies the integrity of the
+                        data within the archives, and "extract" does an
+                        extraction dry-run of the most recent archive. Note that
+                        "data" implies "archives".
+                    example: repository
+                frequency:
+                    type: string
+                    description: |
+                        How frequently to run this type of consistency check (as
+                        a best effort). The value is a number followed by a unit
+                        of time. E.g., "2 weeks" to run this consistency check
+                        no more than every two weeks for a given repository or
+                        "1 month" to run it no more than monthly. Defaults to
+                        "always": running this check every time checks are run.
+                    example: 2 weeks
+        description: |
+            List of one or more consistency checks to run on a periodic basis
+            (if "frequency" is set) or every time borgmatic runs checks (if
+            "frequency" is omitted).
+    check_repositories:
+        type: array
+        items:
+            type: string
+        description: |
+            Paths or labels for a subset of the configured "repositories" (see
+            above) on which to run consistency checks. Handy in case some of
+            your repositories are very large, and so running consistency checks
+            on them would take too long. Defaults to running consistency checks
+            on all configured repositories.
+        example:
+            - user@backupserver:sourcehostname.borg
+    check_last:
+        type: integer
+        description: |
+            Restrict the number of checked archives to the last n. Applies only
+            to the "archives" check. Defaults to checking all archives.
+        example: 3
+    color:
+        type: boolean
+        description: |
+            Apply color to console output. Can be overridden with --no-color
+            command-line flag. Defaults to true.
+        example: false
+    before_actions:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute before all
+            the actions for each repository.
+        example:
+            - "echo Starting actions."
+    before_backup:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute before
+            creating a backup, run once per repository.
+        example:
+            - "echo Starting a backup."
+    before_prune:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute before
+            pruning, run once per repository.
+        example:
+            - "echo Starting pruning."
+    before_compact:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute before
+            compaction, run once per repository.
+        example:
+            - "echo Starting compaction."
+    before_check:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute before
+            consistency checks, run once per repository.
+        example:
+            - "echo Starting checks."
+    before_extract:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute before
+            extracting a backup, run once per repository.
+        example:
+            - "echo Starting extracting."
+    after_backup:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute after
+            creating a backup, run once per repository.
+        example:
+            - "echo Finished a backup."
+    after_compact:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute after
+            compaction, run once per repository.
+        example:
+            - "echo Finished compaction."
+    after_prune:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute after
+            pruning, run once per repository.
+        example:
+            - "echo Finished pruning."
+    after_check:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute after
+            consistency checks, run once per repository.
+        example:
+            - "echo Finished checks."
+    after_extract:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute after
+            extracting a backup, run once per repository.
+        example:
+            - "echo Finished extracting."
+    after_actions:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute after all
+            actions for each repository.
+        example:
+            - "echo Finished actions."
+    on_error:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute when an
+            exception occurs during a "create", "prune", "compact", or "check"
+            action or an associated before/after hook.
+        example:
+            - "echo Error during create/prune/compact/check."
+    before_everything:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute before
+            running all actions (if one of them is "create"). These are
+            collected from all configuration files and then run once before all
+            of them (prior to all actions).
+        example:
+            - "echo Starting actions."
+    after_everything:
+        type: array
+        items:
+            type: string
+        description: |
+            List of one or more shell commands or scripts to execute after
+            running all actions (if one of them is "create"). These are
+            collected from all configuration files and then run once after all
+            of them (after any action).
+        example:
+            - "echo Completed actions."
+    postgresql_databases:
+        type: array
+        items:
+            type: object
+            required: ['name']
+            additionalProperties: false
+            properties:
+                name:
+                    type: string
+                    description: |
+                        Database name (required if using this hook). Or "all" to
+                        dump all databases on the host. (Also set the "format"
+                        to dump each database to a separate file instead of one
+                        combined file.) Note that using this database hook
+                        implicitly enables both read_special and one_file_system
+                        (see above) to support dump and restore streaming.
+                    example: users
+                hostname:
+                    type: string
+                    description: |
+                        Database hostname to connect to. Defaults to connecting
+                        via local Unix socket.
+                    example: database.example.org
+                restore_hostname:
+                    type: string
+                    description: |
+                        Database hostname to restore to. Defaults to the
+                        "hostname" option.
+                    example: database.example.org
+                port:
+                    type: integer
+                    description: Port to connect to. Defaults to 5432.
+                    example: 5433
+                restore_port:
+                    type: integer
+                    description: |
+                        Port to restore to. Defaults to the "port" option.
+                    example: 5433
+                username:
+                    type: string
+                    description: |
+                        Username with which to connect to the database. Defaults
+                        to the username of the current user. You probably want
+                        to specify the "postgres" superuser here when the
+                        database name is "all".
+                    example: dbuser
+                restore_username:
+                    type: string
+                    description: |
+                        Username with which to restore the database. Defaults to
+                        the "username" option.
+                    example: dbuser
+                password:
+                    type: string
+                    description: |
+                        Password with which to connect to the database. Omitting
+                        a password will only work if PostgreSQL is configured to
+                        trust the configured username without a password or you
+                        create a ~/.pgpass file.
+                    example: trustsome1
+                restore_password:
+                    type: string
+                    description: |
+                        Password with which to connect to the restore database.
+                        Defaults to the "password" option.
+                    example: trustsome1
+                no_owner:
+                    type: boolean
+                    description: |
+                        Do not output commands to set ownership of objects to
+                        match the original database. By default, pg_dump and
+                        pg_restore issue ALTER OWNER or SET SESSION
+                        AUTHORIZATION statements to set ownership of created
+                        schema elements. These statements will fail unless the
+                        initial connection to the database is made by a
+                        superuser.
+                    example: true
+                format:
+                    type: string
+                    enum: ['plain', 'custom', 'directory', 'tar']
+                    description: |
+                        Database dump output format. One of "plain", "custom",
+                        "directory", or "tar". Defaults to "custom" (unlike raw
+                        pg_dump) for a single database. Or, when database name
+                        is "all" and format is blank, dumps all databases to a
+                        single file. But if a format is specified with an "all"
+                        database name, dumps each database to a separate file of
+                        that format, allowing more convenient restores of
+                        individual databases. See the pg_dump documentation for
+                        more about formats.
+                    example: directory
+                ssl_mode:
+                    type: string
+                    enum: ['disable', 'allow', 'prefer',
+                          'require', 'verify-ca', 'verify-full']
+                    description: |
+                        SSL mode to use to connect to the database server. One
+                        of "disable", "allow", "prefer", "require", "verify-ca"
+                        or "verify-full". Defaults to "disable".
+                    example: require
+                ssl_cert:
+                    type: string
+                    description: |
+                        Path to a client certificate.
+                    example: "/root/.postgresql/postgresql.crt"
+                ssl_key:
+                    type: string
+                    description: |
+                        Path to a private client key.
+                    example: "/root/.postgresql/postgresql.key"
+                ssl_root_cert:
+                    type: string
+                    description: |
+                        Path to a root certificate containing a list of trusted
+                        certificate authorities.
+                    example: "/root/.postgresql/root.crt"
+                ssl_crl:
+                    type: string
+                    description: |
+                        Path to a certificate revocation list.
+                    example: "/root/.postgresql/root.crl"
+                pg_dump_command:
+                    type: string
+                    description: |
+                        Command to use instead of "pg_dump" or "pg_dumpall".
+                        This can be used to run a specific pg_dump version
+                        (e.g., one inside a running container). Defaults to
+                        "pg_dump" for single database dump or "pg_dumpall" to
+                        dump all databases.
+                    example: docker exec my_pg_container pg_dump
+                pg_restore_command:
+                    type: string
+                    description: |
+                        Command to use instead of "pg_restore". This can be used
+                        to run a specific pg_restore version (e.g., one inside a
+                        running container). Defaults to "pg_restore".
+                    example: docker exec my_pg_container pg_restore
+                psql_command:
+                    type: string
+                    description: |
+                        Command to use instead of "psql". This can be used to
+                        run a specific psql version (e.g., one inside a running
+                        container). Defaults to "psql".
+                    example: docker exec my_pg_container psql
+                options:
+                    type: string
+                    description: |
+                        Additional pg_dump/pg_dumpall options to pass directly
+                        to the dump command, without performing any validation
+                        on them. See pg_dump documentation for details.
+                    example: --role=someone
+                list_options:
+                    type: string
+                    description: |
+                        Additional psql options to pass directly to the psql
+                        command that lists available databases, without
+                        performing any validation on them. See psql
+                        documentation for details.
+                    example: --role=someone
+                restore_options:
+                    type: string
+                    description: |
+                        Additional pg_restore/psql options to pass directly to
+                        the restore command, without performing any validation
+                        on them. See pg_restore/psql documentation for details.
+                    example: --role=someone
+                analyze_options:
+                    type: string
+                    description: |
+                        Additional psql options to pass directly to the analyze
+                        command run after a restore, without performing any
+                        validation on them. See psql documentation for details.
+                    example: --role=someone
+        description: |
+            List of one or more PostgreSQL databases to dump before creating a
+            backup, run once per configuration file. The database dumps are
+            added to your source directories at runtime, backed up, and removed
+            afterwards. Requires pg_dump/pg_dumpall/pg_restore commands. See
+            https://www.postgresql.org/docs/current/app-pgdump.html and
+            https://www.postgresql.org/docs/current/libpq-ssl.html for details.
+    mysql_databases:
+        type: array
+        items:
+            type: object
+            required: ['name']
+            additionalProperties: false
+            properties:
+                name:
+                    type: string
+                    description: |
+                        Database name (required if using this hook). Or "all" to
+                        dump all databases on the host. Note that using this
+                        database hook implicitly enables both read_special and
+                        one_file_system (see above) to support dump and restore
+                        streaming.
+                    example: users
+                hostname:
+                    type: string
+                    description: |
+                        Database hostname to connect to. Defaults to connecting
+                        via local Unix socket.
+                    example: database.example.org
+                restore_hostname:
+                    type: string
+                    description: |
+                        Database hostname to restore to. Defaults to the
+                        "hostname" option.
+                    example: database.example.org
+                port:
+                    type: integer
+                    description: Port to connect to. Defaults to 3306.
+                    example: 3307
+                restore_port:
+                    type: integer
+                    description: |
+                        Port to restore to. Defaults to the "port" option.
+                    example: 5433
+                username:
+                    type: string
+                    description: |
+                        Username with which to connect to the database. Defaults
+                        to the username of the current user.
+                    example: dbuser
+                restore_username:
+                    type: string
+                    description: |
+                        Username with which to restore the database. Defaults to
+                        the "username" option.
+                    example: dbuser                        
+                password:
+                    type: string
+                    description: |
+                        Password with which to connect to the database. Omitting
+                        a password will only work if MySQL is configured to
+                        trust the configured username without a password.
+                    example: trustsome1
+                restore_password:
+                    type: string
+                    description: |
+                        Password with which to connect to the restore database.
+                        Defaults to the "password" option.
+                    example: trustsome1                        
+                format:
+                    type: string
+                    enum: ['sql']
+                    description: |
+                        Database dump output format. Currently only "sql" is
+                        supported. Defaults to "sql" for a single database. Or,
+                        when database name is "all" and format is blank, dumps
+                        all databases to a single file. But if a format is
+                        specified with an "all" database name, dumps each
+                        database to a separate file of that format, allowing
+                        more convenient restores of individual databases.
+                    example: directory
+                add_drop_database:
+                    type: boolean
+                    description: |
+                        Use the "--add-drop-database" flag with mysqldump,
+                        causing the database to be dropped right before restore.
+                        Defaults to true.
+                    example: false
+                options:
+                    type: string
+                    description: |
+                        Additional mysqldump options to pass directly to the
+                        dump command, without performing any validation on them.
+                        See mysqldump documentation for details.
+                    example: --skip-comments
+                list_options:
+                    type: string
+                    description: |
+                        Additional mysql options to pass directly to the mysql
+                        command that lists available databases, without
+                        performing any validation on them. See mysql
+                        documentation for details.
+                    example: --defaults-extra-file=my.cnf
+                restore_options:
+                    type: string
+                    description: |
+                        Additional mysql options to pass directly to the mysql
+                        command that restores database dumps, without performing
+                        any validation on them. See mysql documentation for
+                        details.
+                    example: --defaults-extra-file=my.cnf
+        description: |
+            List of one or more MySQL/MariaDB databases to dump before creating
+            a backup, run once per configuration file. The database dumps are
+            added to your source directories at runtime, backed up, and removed
+            afterwards. Requires mysqldump/mysql commands (from either MySQL or
+            MariaDB). See https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html
+            or https://mariadb.com/kb/en/library/mysqldump/ for details.
+    sqlite_databases:
+        type: array
+        items:
+            type: object
+            required: ['path','name']
+            additionalProperties: false
+            properties:
+                name:
+                    type: string
+                    description: |
+                        This is used to tag the database dump file with a name.
+                        It is not the path to the database file itself. The name
+                        "all" has no special meaning for SQLite databases.
+                    example: users
+                path:
+                    type: string
+                    description: |
+                        Path to the SQLite database file to dump. If relative,
+                        it is relative to the current working directory. Note
+                        that using this database hook implicitly enables both
+                        read_special and one_file_system (see above) to support
+                        dump and restore streaming.
+                    example: /var/lib/sqlite/users.db
+                restore_path:
+                    type: string
+                    description: |
+                        Path to the SQLite database file to restore to. Defaults
+                        to the "path" option.
+                    example: /var/lib/sqlite/users.db
+    mongodb_databases:
+        type: array
+        items:
+            type: object
+            required: ['name']
+            additionalProperties: false
+            properties:
+                name:
+                    type: string
+                    description: |
+                        Database name (required if using this hook). Or "all" to
+                        dump all databases on the host. Note that using this
+                        database hook implicitly enables both read_special and
+                        one_file_system (see above) to support dump and restore
+                        streaming.
+                    example: users
+                hostname:
+                    type: string
+                    description: |
+                        Database hostname to connect to. Defaults to connecting
+                        to localhost.
+                    example: database.example.org
+                restore_hostname:
+                    type: string
+                    description: |
+                        Database hostname to restore to. Defaults to the
+                        "hostname" option.
+                    example: database.example.org
+                port:
+                    type: integer
+                    description: Port to connect to. Defaults to 27017.
+                    example: 27018
+                restore_port:
+                    type: integer
+                    description: |
+                        Port to restore to. Defaults to the "port" option.
+                    example: 5433                        
+                username:
+                    type: string
+                    description: |
+                        Username with which to connect to the database. Skip it
+                        if no authentication is needed.
+                    example: dbuser
+                restore_username:
+                    type: string
+                    description: |
+                        Username with which to restore the database. Defaults to
+                        the "username" option.
+                    example: dbuser                        
+                password:
+                    type: string
+                    description: |
+                        Password with which to connect to the database. Skip it
+                        if no authentication is needed.
+                    example: trustsome1
+                restore_password:
+                    type: string
+                    description: |
+                        Password with which to connect to the restore database.
+                        Defaults to the "password" option.
+                    example: trustsome1
+                authentication_database:
+                    type: string
+                    description: |
+                        Authentication database where the specified username
+                        exists. If no authentication database is specified, the
+                        database provided in "name" is used. If "name" is "all",
+                        the "admin" database is used.
+                    example: admin
+                format:
+                    type: string
+                    enum: ['archive', 'directory']
+                    description: |
+                        Database dump output format. One of "archive", or
+                        "directory". Defaults to "archive". See mongodump
+                        documentation for details. Note that format is ignored
+                        when the database name is "all".
+                    example: directory
+                options:
+                    type: string
+                    description: |
+                        Additional mongodump options to pass directly to the
+                        dump command, without performing any validation on them.
+                        See mongodump documentation for details.
+                    example: --dumpDbUsersAndRoles
+                restore_options:
+                    type: string
+                    description: |
+                        Additional mongorestore options to pass directly to the
+                        dump command, without performing any validation on them.
+                        See mongorestore documentation for details.
+                    example: --restoreDbUsersAndRoles
+        description: |
+            List of one or more MongoDB databases to dump before creating a
+            backup, run once per configuration file. The database dumps are
+            added to your source directories at runtime, backed up, and removed
+            afterwards. Requires mongodump/mongorestore commands. See
+            https://docs.mongodb.com/database-tools/mongodump/ and
+            https://docs.mongodb.com/database-tools/mongorestore/ for details.
+    ntfy:
+        type: object
+        required: ['topic']
+        additionalProperties: false
+        properties:
+            topic:
                 type: string
                 description: |
-                    Path for Borg cache files. Defaults to
-                    $borg_base_directory/.cache/borg
-                example: /path/to/base/cache
-            borg_security_directory:
+                    The topic to publish to. See https://ntfy.sh/docs/publish/
+                    for details.
+                example: topic
+            server:
                 type: string
                 description: |
-                    Path for Borg security and encryption nonce files. Defaults
-                    to $borg_base_directory/.config/borg/security
-                example: /path/to/base/config/security
-            borg_keys_directory:
+                    The address of your self-hosted ntfy.sh instance.
+                example: https://ntfy.your-domain.com
+            username:
                 type: string
                 description: |
-                    Path for Borg encryption key files. Defaults to
-                    $borg_base_directory/.config/borg/keys
-                example: /path/to/base/config/keys
-            umask:
-                type: integer
-                description: Umask to be used for borg create. Defaults to 0077.
-                example: 0077
-            lock_wait:
-                type: integer
-                description: |
-                    Maximum seconds to wait for acquiring a repository/cache
-                    lock. Defaults to 1.
-                example: 5
-            archive_name_format:
+                    The username used for authentication.
+                example: testuser
+            password:
                 type: string
                 description: |
-                    Name of the archive. Borg placeholders can be used. See the
-                    output of "borg help placeholders" for details. Defaults to
-                    "{hostname}-{now:%Y-%m-%dT%H:%M:%S.%f}". If you specify this
-                    option, consider also specifying a prefix in the retention
-                    and consistency sections to avoid accidental
-                    pruning/checking of archives with different archive name
-                    formats.
-                example: "{hostname}-documents-{now}"
-            relocated_repo_access_is_ok:
-                type: boolean
-                description: |
-                    Bypass Borg error about a repository that has been moved.
-                    Defaults to false.
-                example: true
-            unknown_unencrypted_repo_access_is_ok:
-                type: boolean
-                description: |
-                    Bypass Borg error about a previously unknown unencrypted
-                    repository. Defaults to false.
-                example: true
-            extra_borg_options:
+                    The password used for authentication.
+                example: fakepassword
+            start:
                 type: object
-                additionalProperties: false
                 properties:
-                    init:
-                        type: string
-                        description: |
-                          Extra command-line options to pass to "borg init".
-                        example: "--extra-option"
-                    create:
+                    title:
                         type: string
                         description: |
-                          Extra command-line options to pass to "borg create".
-                        example: "--extra-option"
-                    prune:
+                            The title of the message.
+                        example: Ping!
+                    message:
                         type: string
                         description: |
-                          Extra command-line options to pass to "borg prune".
-                        example: "--extra-option"
-                    compact:
+                            The message body to publish.
+                        example: Your backups have failed.
+                    priority:
                         type: string
                         description: |
-                          Extra command-line options to pass to "borg compact".
-                        example: "--extra-option"
-                    check:
+                            The priority to set.
+                        example: urgent
+                    tags:
                         type: string
                         description: |
-                          Extra command-line options to pass to "borg check".
-                        example: "--extra-option"
-                description: |
-                    Additional options to pass directly to particular Borg
-                    commands, handy for Borg options that borgmatic does not yet
-                    support natively. Note that borgmatic does not perform any
-                    validation on these options. Running borgmatic with
-                    "--verbosity 2" shows the exact Borg command-line
-                    invocation.
-    retention:
-        type: object
-        description: |
-            Retention policy for how many backups to keep in each category. See
-            https://borgbackup.readthedocs.io/en/stable/usage/prune.html for
-            details. At least one of the "keep" options is required for pruning
-            to work. To skip pruning entirely, run "borgmatic create" or "check"
-            without the "prune" action. See borgmatic documentation for details.
-        additionalProperties: false
-        properties:
-            keep_within:
-                type: string
-                description: Keep all archives within this time interval.
-                example: 3H
-            keep_secondly:
-                type: integer
-                description: Number of secondly archives to keep.
-                example: 60
-            keep_minutely:
-                type: integer
-                description: Number of minutely archives to keep.
-                example: 60
-            keep_hourly:
-                type: integer
-                description: Number of hourly archives to keep.
-                example: 24
-            keep_daily:
-                type: integer
-                description: Number of daily archives to keep.
-                example: 7
-            keep_weekly:
-                type: integer
-                description: Number of weekly archives to keep.
-                example: 4
-            keep_monthly:
-                type: integer
-                description: Number of monthly archives to keep.
-                example: 6
-            keep_yearly:
-                type: integer
-                description: Number of yearly archives to keep.
-                example: 1
-            prefix:
-                type: string
-                description: |
-                    When pruning, only consider archive names starting with this
-                    prefix.  Borg placeholders can be used. See the output of
-                    "borg help placeholders" for details. Defaults to
-                    "{hostname}-". Use an empty value to disable the default.
-                example: sourcehostname
-    consistency:
-        type: object
-        description: |
-            Consistency checks to run after backups. See
-            https://borgbackup.readthedocs.io/en/stable/usage/check.html and
-            https://borgbackup.readthedocs.io/en/stable/usage/extract.html for
-            details.
-        additionalProperties: false
-        properties:
-            checks:
-                type: array
-                items:
-                    type: object
-                    required: ['name']
-                    additionalProperties: false
-                    properties:
-                        name:
-                            type: string
-                            enum:
-                                - repository
-                                - archives
-                                - data
-                                - extract
-                                - disabled
-                            description: |
-                                Name of consistency check to run: "repository",
-                                "archives", "data", and/or "extract". Set to
-                                "disabled" to disable all consistency checks.
-                                "repository" checks the consistency of the
-                                repository, "archives" checks all of the
-                                archives, "data" verifies the integrity of the
-                                data within the archives, and "extract" does an
-                                extraction dry-run of the most recent archive.
-                                Note that "data" implies "archives".
-                            example: repository
-                        frequency:
-                            type: string
-                            description: |
-                                How frequently to run this type of consistency
-                                check (as a best effort). The value is a number
-                                followed by a unit of time. E.g., "2 weeks" to
-                                run this consistency check no more than every
-                                two weeks for a given repository or "1 month" to
-                                run it no more than monthly. Defaults to
-                                "always": running this check every time checks
-                                are run.
-                            example: 2 weeks
-                description: |
-                    List of one or more consistency checks to run on a periodic
-                    basis (if "frequency" is set) or every time borgmatic runs
-                    checks (if "frequency" is omitted).
-            check_repositories:
-                type: array
-                items:
-                    type: string
-                description: |
-                    Paths to a subset of the repositories in the location
-                    section on which to run consistency checks. Handy in case
-                    some of your repositories are very large, and so running
-                    consistency checks on them would take too long. Defaults to
-                    running consistency checks on all repositories configured in
-                    the location section.
-                example:
-                    - user@backupserver:sourcehostname.borg
-            check_last:
-                type: integer
-                description: |
-                    Restrict the number of checked archives to the last n.
-                    Applies only to the "archives" check. Defaults to checking
-                    all archives.
-                example: 3
-            prefix:
-                type: string
-                description: |
-                    When performing the "archives" check, only consider archive
-                    names starting with this prefix. Borg placeholders can be
-                    used. See the output of "borg help placeholders" for
-                    details. Defaults to "{hostname}-". Use an empty value to
-                    disable the default.
-                example: sourcehostname
-    output:
-        type: object
-        description: |
-            Options for customizing borgmatic's own output and logging.
-        additionalProperties: false
-        properties:
-            color:
-                type: boolean
-                description: |
-                    Apply color to console output. Can be overridden with
-                    --no-color command-line flag. Defaults to true.
-                example: false
-    hooks:
-        type: object
-        description: |
-            Shell commands, scripts, or integrations to execute at various
-            points during a borgmatic run. IMPORTANT: All provided commands and
-            scripts are executed with user permissions of borgmatic. Do not
-            forget to set secure permissions on this configuration file (chmod
-            0600) as well as on any script called from a hook (chmod 0700) to
-            prevent potential shell injection or privilege escalation.
-        additionalProperties: false
-        properties:
-            before_actions:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    before all the actions for each repository.
-                example:
-                    - echo "Starting actions."
-            before_backup:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    before creating a backup, run once per repository.
-                example:
-                    - echo "Starting a backup."
-            before_prune:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    before pruning, run once per repository.
-                example:
-                    - echo "Starting pruning."
-            before_compact:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    before compaction, run once per repository.
-                example:
-                    - echo "Starting compaction."
-            before_check:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    before consistency checks, run once per repository.
-                example:
-                    - echo "Starting checks."
-            before_extract:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    before extracting a backup, run once per repository.
-                example:
-                    - echo "Starting extracting."
-            after_backup:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    after creating a backup, run once per repository.
-                example:
-                    - echo "Finished a backup."
-            after_compact:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    after compaction, run once per repository.
-                example:
-                    - echo "Finished compaction."
-            after_prune:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    after pruning, run once per repository.
-                example:
-                    - echo "Finished pruning."
-            after_check:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    after consistency checks, run once per repository.
-                example:
-                    - echo "Finished checks."
-            after_extract:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    after extracting a backup, run once per repository.
-                example:
-                    - echo "Finished extracting."
-            after_actions:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    after all actions for each repository.
-                example:
-                    - echo "Finished actions."
-            on_error:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    when an exception occurs during a "create", "prune",
-                    "compact", or "check" action or an associated before/after
-                    hook.
-                example:
-                    - echo "Error during create/prune/compact/check."
-            before_everything:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    before running all actions (if one of them is "create").
-                    These are collected from all configuration files and then
-                    run once before all of them (prior to all actions).
-                example:
-                    - echo "Starting actions."
-            after_everything:
-                type: array
-                items:
-                    type: string
-                description: |
-                    List of one or more shell commands or scripts to execute
-                    after running all actions (if one of them is "create").
-                    These are collected from all configuration files and then
-                    run once after all of them (after any action).
-                example:
-                    - echo "Completed actions."
-            postgresql_databases:
-                type: array
-                items:
-                    type: object
-                    required: ['name']
-                    additionalProperties: false
-                    properties:
-                        name:
-                            type: string
-                            description: |
-                                Database name (required if using this hook). Or
-                                "all" to dump all databases on the host. (Also
-                                set the "format" to dump each database to a
-                                separate file instead of one combined file.)
-                                Note that using this database hook implicitly
-                                enables both read_special and one_file_system
-                                (see above) to support dump and restore
-                                streaming.
-                            example: users
-                        hostname:
-                            type: string
-                            description: |
-                                Database hostname to connect to. Defaults to
-                                connecting via local Unix socket.
-                            example: database.example.org
-                        port:
-                            type: integer
-                            description: Port to connect to. Defaults to 5432.
-                            example: 5433
-                        username:
-                            type: string
-                            description: |
-                                Username with which to connect to the database.
-                                Defaults to the username of the current user.
-                                You probably want to specify the "postgres"
-                                superuser here when the database name is "all".
-                            example: dbuser
-                        password:
-                            type: string
-                            description: |
-                                Password with which to connect to the database.
-                                Omitting a password will only work if PostgreSQL
-                                is configured to trust the configured username
-                                without a password or you create a ~/.pgpass
-                                file.
-                            example: trustsome1
-                        format:
-                            type: string
-                            enum: ['plain', 'custom', 'directory', 'tar']
-                            description: |
-                                Database dump output format. One of "plain",
-                                "custom", "directory", or "tar". Defaults to
-                                "custom" (unlike raw pg_dump) for a single
-                                database. Or, when database name is "all" and
-                                format is blank, dumps all databases to a single
-                                file. But if a format is specified with an "all"
-                                database name, dumps each database to a separate
-                                file of that format, allowing more convenient
-                                restores of individual databases. See the
-                                pg_dump documentation for more about formats.
-                            example: directory
-                        ssl_mode:
-                            type: string
-                            enum: ['disable', 'allow', 'prefer',
-                                  'require', 'verify-ca', 'verify-full']
-                            description: |
-                                SSL mode to use to connect to the database
-                                server. One of "disable", "allow", "prefer",
-                                "require", "verify-ca" or "verify-full".
-                                Defaults to "disable".
-                            example: require
-                        ssl_cert:
-                            type: string
-                            description: |
-                                Path to a client certificate.
-                            example: "/root/.postgresql/postgresql.crt"
-                        ssl_key:
-                            type: string
-                            description: |
-                                Path to a private client key.
-                            example: "/root/.postgresql/postgresql.key"
-                        ssl_root_cert:
-                            type: string
-                            description: |
-                                Path to a root certificate containing a list of
-                                trusted certificate authorities.
-                            example: "/root/.postgresql/root.crt"
-                        ssl_crl:
-                            type: string
-                            description: |
-                                Path to a certificate revocation list.
-                            example: "/root/.postgresql/root.crl"
-                        pg_dump_command:
-                            type: string
-                            description: |
-                                Command to use instead of "pg_dump" or
-                                "pg_dumpall". This can be used to run a specific
-                                pg_dump version (e.g., one inside a running
-                                docker container). Defaults to "pg_dump" for
-                                single database dump or "pg_dumpall" to dump
-                                all databases.
-                            example: docker exec my_pg_container pg_dump
-                        pg_restore_command:
-                            type: string
-                            description: |
-                                Command to use instead of "pg_restore". This
-                                can be used to run a specific pg_restore
-                                version (e.g., one inside a running docker
-                                container). Defaults to "pg_restore".
-                            example: docker exec my_pg_container pg_restore
-                        psql_command:
-                            type: string
-                            description: |
-                                Command to use instead of "psql". This can be
-                                used to run a specific psql version (e.g.,
-                                one inside a running docker container).
-                                Defaults to "psql".
-                            example: docker exec my_pg_container psql
-                        options:
-                            type: string
-                            description: |
-                                Additional pg_dump/pg_dumpall options to pass
-                                directly to the dump command, without performing
-                                any validation on them. See pg_dump
-                                documentation for details.
-                            example: --role=someone
-                        list_options:
-                            type: string
-                            description: |
-                                Additional psql options to pass directly to the
-                                psql command that lists available databases,
-                                without performing any validation on them. See
-                                psql documentation for details.
-                            example: --role=someone
-                        restore_options:
-                            type: string
-                            description: |
-                                Additional pg_restore/psql options to pass
-                                directly to the restore command, without
-                                performing any validation on them. See
-                                pg_restore/psql documentation for details.
-                            example: --role=someone
-                        analyze_options:
-                            type: string
-                            description: |
-                                Additional psql options to pass directly to the
-                                analyze command run after a restore, without
-                                performing any validation on them. See psql
-                                documentation for details.
-                            example: --role=someone
-                description: |
-                    List of one or more PostgreSQL databases to dump before
-                    creating a backup, run once per configuration file. The
-                    database dumps are added to your source directories at
-                    runtime, backed up, and removed afterwards. Requires
-                    pg_dump/pg_dumpall/pg_restore commands. See
-                    https://www.postgresql.org/docs/current/app-pgdump.html and
-                    https://www.postgresql.org/docs/current/libpq-ssl.html for
-                    details.
-            mysql_databases:
-                type: array
-                items:
-                    type: object
-                    required: ['name']
-                    additionalProperties: false
-                    properties:
-                        name:
-                            type: string
-                            description: |
-                                Database name (required if using this hook). Or
-                                "all" to dump all databases on the host. Note
-                                that using this database hook implicitly enables
-                                both read_special and one_file_system (see
-                                above) to support dump and restore streaming.
-                            example: users
-                        hostname:
-                            type: string
-                            description: |
-                                Database hostname to connect to. Defaults to
-                                connecting via local Unix socket.
-                            example: database.example.org
-                        port:
-                            type: integer
-                            description: Port to connect to. Defaults to 3306.
-                            example: 3307
-                        username:
-                            type: string
-                            description: |
-                                Username with which to connect to the database.
-                                Defaults to the username of the current user.
-                            example: dbuser
-                        password:
-                            type: string
-                            description: |
-                                Password with which to connect to the database.
-                                Omitting a password will only work if MySQL is
-                                configured to trust the configured username
-                                without a password.
-                            example: trustsome1
-                        format:
-                            type: string
-                            enum: ['sql']
-                            description: |
-                                Database dump output format. Currenly only "sql"
-                                is supported. Defaults to "sql" for a single
-                                database. Or, when database name is "all" and
-                                format is blank, dumps all databases to a single
-                                file. But if a format is specified with an "all"
-                                database name, dumps each database to a separate
-                                file of that format, allowing more convenient
-                                restores of individual databases.
-                            example: directory
-                        add_drop_database:
-                            type: boolean
-                            description: |
-                                Use the "--add-drop-database" flag with
-                                mysqldump, causing the database to be dropped
-                                right before restore. Defaults to true.
-                            example: false
-                        options:
-                            type: string
-                            description: |
-                                Additional mysqldump options to pass directly to
-                                the dump command, without performing any
-                                validation on them. See mysqldump documentation
-                                for details.
-                            example: --skip-comments
-                        list_options:
-                            type: string
-                            description: |
-                                Additional mysql options to pass directly to
-                                the mysql command that lists available
-                                databases, without performing any validation on
-                                them. See mysql documentation for details.
-                            example: --defaults-extra-file=my.cnf
-                        restore_options:
-                            type: string
-                            description: |
-                                Additional mysql options to pass directly to
-                                the mysql command that restores database dumps,
-                                without performing any validation on them. See
-                                mysql documentation for details.
-                            example: --defaults-extra-file=my.cnf
-                description: |
-                    List of one or more MySQL/MariaDB databases to dump before
-                    creating a backup, run once per configuration file. The
-                    database dumps are added to your source directories at
-                    runtime, backed up, and removed afterwards. Requires
-                    mysqldump/mysql commands (from either MySQL or MariaDB). See
-                    https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html or
-                    https://mariadb.com/kb/en/library/mysqldump/ for details.
-            sqlite_databases:
-                type: array
-                items:
-                    type: object
-                    required: ['path','name']
-                    additionalProperties: false
-                    properties:
-                        name:
-                            type: string
-                            description: |
-                                This is used to tag the database dump file
-                                with a name. It is not the path to the database
-                                file itself. The name "all" has no special
-                                meaning for SQLite databases.
-                            example: users
-                        path:
-                            type: string
-                            description: |
-                                Path to the SQLite database file to dump. If
-                                relative, it is relative to the current working
-                                directory. Note that using this
-                                database hook implicitly enables both
-                                read_special and one_file_system (see above) to
-                                support dump and restore streaming.
-                            example: /var/lib/sqlite/users.db
-            mongodb_databases:
-                type: array
-                items:
-                    type: object
-                    required: ['name']
-                    additionalProperties: false
-                    properties:
-                        name:
-                            type: string
-                            description: |
-                                Database name (required if using this hook). Or
-                                "all" to dump all databases on the host. Note
-                                that using this database hook implicitly enables
-                                both read_special and one_file_system (see
-                                above) to support dump and restore streaming.
-                            example: users
-                        hostname:
-                            type: string
-                            description: |
-                                Database hostname to connect to. Defaults to
-                                connecting to localhost.
-                            example: database.example.org
-                        port:
-                            type: integer
-                            description: Port to connect to. Defaults to 27017.
-                            example: 27018
-                        username:
-                            type: string
-                            description: |
-                                Username with which to connect to the database.
-                                Skip it if no authentication is needed.
-                            example: dbuser
-                        password:
-                            type: string
-                            description: |
-                                Password with which to connect to the database.
-                                Skip it if no authentication is needed.
-                            example: trustsome1
-                        authentication_database:
-                            type: string
-                            description: |
-                                Authentication database where the specified
-                                username exists. If no authentication database
-                                is specified, the database provided in "name"
-                                is used. If "name" is "all", the "admin"
-                                database is used.
-                            example: admin
-                        format:
-                            type: string
-                            enum: ['archive', 'directory']
-                            description: |
-                                Database dump output format. One of "archive",
-                                or "directory". Defaults to "archive". See
-                                mongodump documentation for details. Note that
-                                format is ignored when the database name is
-                                "all".
-                            example: directory
-                        options:
-                            type: string
-                            description: |
-                                Additional mongodump options to pass
-                                directly to the dump command, without performing
-                                any validation on them. See mongodump
-                                documentation for details.
-                            example: --dumpDbUsersAndRoles
-                        restore_options:
-                            type: string
-                            description: |
-                                Additional mongorestore options to pass
-                                directly to the dump command, without performing
-                                any validation on them. See mongorestore
-                                documentation for details.
-                            example: --restoreDbUsersAndRoles
-                description: |
-                    List of one or more MongoDB databases to dump before
-                    creating a backup, run once per configuration file. The
-                    database dumps are added to your source directories at
-                    runtime, backed up, and removed afterwards. Requires
-                    mongodump/mongorestore commands. See
-                    https://docs.mongodb.com/database-tools/mongodump/ and
-                    https://docs.mongodb.com/database-tools/mongorestore/ for
-                    details.
-            ntfy:
+                            Tags to attach to the message.
+                        example: incoming_envelope
+            finish:
                 type: object
-                required: ['topic']
-                additionalProperties: false
                 properties:
-                    topic:
+                    title:
                         type: string
                         description: |
-                            The topic to publish to.
-                            (https://ntfy.sh/docs/publish/)
-                        example: topic
-                    server:
+                            The title of the message.
+                        example: Ping!
+                    message:
                         type: string
                         description: |
-                            The address of your self-hosted ntfy.sh instance.
-                        example: https://ntfy.your-domain.com
-                    username:
+                            The message body to publish.
+                        example: Your backups have failed.
+                    priority:
                         type: string
                         description: |
-                            The username used for authentication.
-                        example: testuser
-                    password:
+                            The priority to set.
+                        example: urgent
+                    tags:
                         type: string
                         description: |
-                            The password used for authentication.
-                        example: fakepassword
-                    start:
-                        type: object
-                        properties:
-                            title:
-                                type: string
-                                description: |
-                                    The title of the message
-                                example: Ping!
-                            message:
-                                type: string
-                                description: |
-                                    The message body to publish.
-                                example: Your backups have failed.
-                            priority:
-                                type: string
-                                description: |
-                                    The priority to set.
-                                example: urgent
-                            tags:
-                                type: string
-                                description: |
-                                    Tags to attach to the message.
-                                example: incoming_envelope
-                    finish:
-                        type: object
-                        properties:
-                            title:
-                                type: string
-                                description: |
-                                    The title of the message.
-                                example: Ping!
-                            message:
-                                type: string
-                                description: |
-                                    The message body to publish.
-                                example: Your backups have failed.
-                            priority:
-                                type: string
-                                description: |
-                                    The priority to set.
-                                example: urgent
-                            tags:
-                                type: string
-                                description: |
-                                    Tags to attach to the message.
-                                example: incoming_envelope
-                    fail:
-                        type: object
-                        properties:
-                            title:
-                                type: string
-                                description: |
-                                    The title of the message.
-                                example: Ping!
-                            message:
-                                type: string
-                                description: |
-                                    The message body to publish.
-                                example: Your backups have failed.
-                            priority:
-                                type: string
-                                description: |
-                                    The priority to set.
-                                example: urgent
-                            tags:
-                                type: string
-                                description: |
-                                    Tags to attach to the message.
-                                example: incoming_envelope
-                    states:
-                        type: array
-                        items:
-                            type: string
-                            enum:
-                                - start
-                                - finish
-                                - fail
-                            uniqueItems: true
-                        description: |
-                            List of one or more monitoring states to ping for:
-                            "start", "finish", and/or "fail". Defaults to
-                            pinging for failure only.
-                        example:
-                            - start
-                            - finish
-            healthchecks:
+                            Tags to attach to the message.
+                        example: incoming_envelope
+            fail:
                 type: object
-                required: ['ping_url']
-                additionalProperties: false
                 properties:
-                    ping_url:
+                    title:
                         type: string
                         description: |
-                            Healthchecks ping URL or UUID to notify when a
-                            backup begins, ends, errors or just to send logs.
-                        example: https://hc-ping.com/your-uuid-here
-                    verify_tls:
-                        type: boolean
-                        description: |
-                            Verify the TLS certificate of the ping URL host.
-                            Defaults to true.
-                        example: false
-                    send_logs:
-                        type: boolean
-                        description: |
-                            Send borgmatic logs to Healthchecks as part the
-                            "finish", "fail", and "log" states. Defaults to
-                            true.
-                        example: false
-                    ping_body_limit:
-                        type: integer
-                        description: |
-                            Number of bytes of borgmatic logs to send to
-                            Healthchecks, ideally the same as PING_BODY_LIMIT
-                            configured on the Healthchecks server. Set to 0 to
-                            send all logs and disable this truncation. Defaults
-                            to 100000.
-                        example: 200000
-                    states:
-                        type: array
-                        items:
-                            type: string
-                            enum:
-                                - start
-                                - finish
-                                - fail
-                                - log
-                            uniqueItems: true
-                        description: |
-                            List of one or more monitoring states to ping for:
-                            "start", "finish", "fail", and/or "log". Defaults to
-                            pinging for all states.
-                        example:
-                            - finish
-                description: |
-                    Configuration for a monitoring integration with
-                    Healthchecks. Create an account at https://healthchecks.io
-                    (or self-host Healthchecks) if you'd like to use this
-                    service. See borgmatic monitoring documentation for details.
-            cronitor:
-                type: object
-                required: ['ping_url']
-                additionalProperties: false
-                properties:
-                    ping_url:
+                            The title of the message.
+                        example: Ping!
+                    message:
                         type: string
                         description: |
-                            Cronitor ping URL to notify when a backup begins,
-                            ends, or errors.
-                        example: https://cronitor.link/d3x0c1
-                description: |
-                    Configuration for a monitoring integration with Cronitor.
-                    Create an account at https://cronitor.io if you'd
-                    like to use this service. See borgmatic monitoring
-                    documentation for details.
-            pagerduty:
-                type: object
-                required: ['integration_key']
-                additionalProperties: false
-                properties:
-                    integration_key:
+                            The message body to publish.
+                        example: Your backups have failed.
+                    priority:
                         type: string
                         description: |
-                            PagerDuty integration key used to notify PagerDuty
-                            when a backup errors.
-                        example: a177cad45bd374409f78906a810a3074
-                description: |
-                    Configuration for a monitoring integration with PagerDuty.
-                    Create an account at https://www.pagerduty.com/ if you'd
-                    like to use this service. See borgmatic monitoring
-                    documentation for details.
-            cronhub:
-                type: object
-                required: ['ping_url']
-                additionalProperties: false
-                properties:
-                    ping_url:
+                            The priority to set.
+                        example: urgent
+                    tags:
                         type: string
                         description: |
-                            Cronhub ping URL to notify when a backup begins,
-                            ends, or errors.
-                        example: https://cronhub.io/ping/1f5e3410-254c-5587
+                            Tags to attach to the message.
+                        example: incoming_envelope
+            states:
+                type: array
+                items:
+                    type: string
+                    enum:
+                        - start
+                        - finish
+                        - fail
+                    uniqueItems: true
                 description: |
-                    Configuration for a monitoring integration with Crunhub.
-                    Create an account at https://cronhub.io if you'd like to
-                    use this service. See borgmatic monitoring documentation
-                    for details.
-            umask:
+                    List of one or more monitoring states to ping for: "start",
+                    "finish", and/or "fail". Defaults to pinging for failure
+                    only.
+                example:
+                    - start
+                    - finish
+    healthchecks:
+        type: object
+        required: ['ping_url']
+        additionalProperties: false
+        properties:
+            ping_url:
+                type: string
+                description: |
+                    Healthchecks ping URL or UUID to notify when a backup
+                    begins, ends, errors, or to send only logs.
+                example: https://hc-ping.com/your-uuid-here
+            verify_tls:
+                type: boolean
+                description: |
+                    Verify the TLS certificate of the ping URL host. Defaults to
+                    true.
+                example: false
+            send_logs:
+                type: boolean
+                description: |
+                    Send borgmatic logs to Healthchecks as part the "finish",
+                    "fail", and "log" states. Defaults to true.
+                example: false
+            ping_body_limit:
                 type: integer
                 description: |
-                    Umask used when executing hooks. Defaults to the umask that
-                    borgmatic is run with.
-                example: 0077
+                    Number of bytes of borgmatic logs to send to Healthchecks,
+                    ideally the same as PING_BODY_LIMIT configured on the
+                    Healthchecks server. Set to 0 to send all logs and disable
+                    this truncation. Defaults to 100000.
+                example: 200000
+            states:
+                type: array
+                items:
+                    type: string
+                    enum:
+                        - start
+                        - finish
+                        - fail
+                        - log
+                    uniqueItems: true
+                description: |
+                    List of one or more monitoring states to ping for: "start",
+                    "finish", "fail", and/or "log". Defaults to pinging for all
+                    states.
+                example:
+                    - finish
+        description: |
+            Configuration for a monitoring integration with Healthchecks. Create
+            an account at https://healthchecks.io (or self-host Healthchecks) if
+            you'd like to use this service. See borgmatic monitoring
+            documentation for details.
+    cronitor:
+        type: object
+        required: ['ping_url']
+        additionalProperties: false
+        properties:
+            ping_url:
+                type: string
+                description: |
+                    Cronitor ping URL to notify when a backup begins,
+                    ends, or errors.
+                example: https://cronitor.link/d3x0c1
+        description: |
+            Configuration for a monitoring integration with Cronitor. Create an
+            account at https://cronitor.io if you'd like to use this service.
+            See borgmatic monitoring documentation for details.
+    pagerduty:
+        type: object
+        required: ['integration_key']
+        additionalProperties: false
+        properties:
+            integration_key:
+                type: string
+                description: |
+                    PagerDuty integration key used to notify PagerDuty
+                    when a backup errors.
+                example: a177cad45bd374409f78906a810a3074
+        description: |
+            Configuration for a monitoring integration with PagerDuty. Create an
+            account at https://www.pagerduty.com/ if you'd like to use this
+            service. See borgmatic monitoring documentation for details.
+    cronhub:
+        type: object
+        required: ['ping_url']
+        additionalProperties: false
+        properties:
+            ping_url:
+                type: string
+                description: |
+                    Cronhub ping URL to notify when a backup begins,
+                    ends, or errors.
+                example: https://cronhub.io/ping/1f5e3410-254c-5587
+        description: |
+            Configuration for a monitoring integration with Crunhub. Create an
+            account at https://cronhub.io if you'd like to use this service. See
+            borgmatic monitoring documentation for details.
```

### Comparing `borgmatic-1.7.9/borgmatic/config/validate.py` & `borgmatic-1.8.0/borgmatic/config/validate.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,43 +1,48 @@
 import os
 
 import jsonschema
-import pkg_resources
 import ruamel.yaml
 
+import borgmatic.config
 from borgmatic.config import environment, load, normalize, override
 
 
 def schema_filename():
     '''
     Path to the installed YAML configuration schema file, used to validate and parse the
     configuration.
+
+    Raise FileNotFoundError when the schema path does not exist.
     '''
-    return pkg_resources.resource_filename('borgmatic', 'config/schema.yaml')
+    schema_path = os.path.join(os.path.dirname(borgmatic.config.__file__), 'schema.yaml')
+
+    with open(schema_path):
+        return schema_path
 
 
 def format_json_error_path_element(path_element):
     '''
     Given a path element into a JSON data structure, format it for display as a string.
     '''
     if isinstance(path_element, int):
-        return str('[{}]'.format(path_element))
+        return str(f'[{path_element}]')
 
-    return str('.{}'.format(path_element))
+    return str(f'.{path_element}')
 
 
 def format_json_error(error):
     '''
     Given an instance of jsonschema.exceptions.ValidationError, format it for display as a string.
     '''
     if not error.path:
-        return 'At the top level: {}'.format(error.message)
+        return f'At the top level: {error.message}'
 
     formatted_path = ''.join(format_json_error_path_element(element) for element in error.path)
-    return "At '{}': {}".format(formatted_path.lstrip('.'), error.message)
+    return f"At '{formatted_path.lstrip('.')}': {error.message}"
 
 
 class Validation_error(ValueError):
     '''
     A collection of error messages generated when attempting to validate a particular
     configuration file.
     '''
@@ -50,48 +55,51 @@
         self.config_filename = config_filename
         self.errors = errors
 
     def __str__(self):
         '''
         Render a validation error as a user-facing string.
         '''
-        return 'An error occurred while parsing a configuration file at {}:\n'.format(
-            self.config_filename
-        ) + '\n'.join(error for error in self.errors)
+        return (
+            f'An error occurred while parsing a configuration file at {self.config_filename}:\n'
+            + '\n'.join(error for error in self.errors)
+        )
 
 
 def apply_logical_validation(config_filename, parsed_configuration):
     '''
     Given a parsed and schematically valid configuration as a data structure of nested dicts (see
     below), run through any additional logical validation checks. If there are any such validation
     problems, raise a Validation_error.
     '''
-    location_repositories = parsed_configuration.get('location', {}).get('repositories')
-    check_repositories = parsed_configuration.get('consistency', {}).get('check_repositories', [])
+    repositories = parsed_configuration.get('repositories')
+    check_repositories = parsed_configuration.get('check_repositories', [])
     for repository in check_repositories:
-        if repository not in location_repositories:
+        if not any(
+            repositories_match(repository, config_repository) for config_repository in repositories
+        ):
             raise Validation_error(
                 config_filename,
-                (
-                    'Unknown repository in the "consistency" section\'s "check_repositories": {}'.format(
-                        repository
-                    ),
-                ),
+                (f'Unknown repository in "check_repositories": {repository}',),
             )
 
 
 def parse_configuration(config_filename, schema_filename, overrides=None, resolve_env=True):
     '''
     Given the path to a config filename in YAML format, the path to a schema filename in a YAML
     rendition of JSON Schema format, a sequence of configuration file override strings in the form
-    of "section.option=value", return the parsed configuration as a data structure of nested dicts
+    of "option.suboption=value", return the parsed configuration as a data structure of nested dicts
     and lists corresponding to the schema. Example return value:
 
-       {'location': {'source_directories': ['/home', '/etc'], 'repository': 'hostname.borg'},
-       'retention': {'keep_daily': 7}, 'consistency': {'checks': ['repository', 'archives']}}
+        {
+            'source_directories': ['/home', '/etc'],
+            'repository': 'hostname.borg',
+            'keep_daily': 7,
+            'checks': ['repository', 'archives'],
+        }
 
     Also return a sequence of logging.LogRecord instances containing any warnings about the
     configuration.
 
     Raise FileNotFoundError if the file does not exist, PermissionError if the user does not
     have permissions to read the file, or Validation_error if the config does not match the schema.
     '''
@@ -122,26 +130,37 @@
     return config, logs
 
 
 def normalize_repository_path(repository):
     '''
     Given a repository path, return the absolute path of it (for local repositories).
     '''
-    # A colon in the repository indicates it's a remote repository. Bail.
-    if ':' in repository:
+    # A colon in the repository could mean that it's either a file:// URL or a remote repository.
+    # If it's a remote repository, we don't want to normalize it. If it's a file:// URL, we do.
+    if ':' not in repository:
+        return os.path.abspath(repository)
+    elif repository.startswith('file://'):
+        return os.path.abspath(repository.partition('file://')[-1])
+    else:
         return repository
 
-    return os.path.abspath(repository)
-
 
 def repositories_match(first, second):
     '''
-    Given two repository paths (relative and/or absolute), return whether they match.
+    Given two repository dicts with keys 'path' (relative and/or absolute),
+    and 'label', or two repository paths, return whether they match.
     '''
-    return normalize_repository_path(first) == normalize_repository_path(second)
+    if isinstance(first, str):
+        first = {'path': first, 'label': first}
+    if isinstance(second, str):
+        second = {'path': second, 'label': second}
+    return (first.get('label') == second.get('label')) or (
+        normalize_repository_path(first.get('path'))
+        == normalize_repository_path(second.get('path'))
+    )
 
 
 def guard_configuration_contains_repository(repository, configurations):
     '''
     Given a repository path and a dict mapping from config filename to corresponding parsed config
     dict, ensure that the repository is declared exactly once in all of the configurations. If no
     repository is given, skip this check.
@@ -152,23 +171,23 @@
     if not repository:
         return
 
     count = len(
         tuple(
             config_repository
             for config in configurations.values()
-            for config_repository in config['location']['repositories']
-            if repositories_match(repository, config_repository)
+            for config_repository in config['repositories']
+            if repositories_match(config_repository, repository)
         )
     )
 
     if count == 0:
-        raise ValueError('Repository {} not found in configuration files'.format(repository))
+        raise ValueError(f'Repository {repository} not found in configuration files')
     if count > 1:
-        raise ValueError('Repository {} found in multiple configuration files'.format(repository))
+        raise ValueError(f'Repository {repository} found in multiple configuration files')
 
 
 def guard_single_repository_selected(repository, configurations):
     '''
     Given a repository path and a dict mapping from config filename to corresponding parsed config
     dict, ensure either a single repository exists across all configuration files or a repository
     path was given.
@@ -176,15 +195,15 @@
     if repository:
         return
 
     count = len(
         tuple(
             config_repository
             for config in configurations.values()
-            for config_repository in config['location']['repositories']
+            for config_repository in config['repositories']
         )
     )
 
     if count != 1:
         raise ValueError(
             "Can't determine which repository to use. Use --repository to disambiguate"
         )
```

### Comparing `borgmatic-1.7.9/borgmatic/execute.py` & `borgmatic-1.8.0/borgmatic/execute.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,25 +7,23 @@
 logger = logging.getLogger(__name__)
 
 
 ERROR_OUTPUT_MAX_LINE_COUNT = 25
 BORG_ERROR_EXIT_CODE = 2
 
 
-def exit_code_indicates_error(process, exit_code, borg_local_path=None):
+def exit_code_indicates_error(command, exit_code, borg_local_path=None):
     '''
     Return True if the given exit code from running a command corresponds to an error. If a Borg
     local path is given and matches the process' command, then treat exit code 1 as a warning
     instead of an error.
     '''
     if exit_code is None:
         return False
 
-    command = process.args.split(' ') if isinstance(process.args, str) else process.args
-
     if borg_local_path and command[0] == borg_local_path:
         return bool(exit_code < 0 or exit_code >= BORG_ERROR_EXIT_CODE)
 
     return bool(exit_code != 0)
 
 
 def command_for_process(process):
@@ -41,14 +39,31 @@
     Given a process as an instance of subprocess.Popen and a sequence of stdouts to exclude, return
     either the process's stdout or stderr. The idea is that if stdout is excluded for a process, we
     still have stderr to log.
     '''
     return process.stderr if process.stdout in exclude_stdouts else process.stdout
 
 
+def append_last_lines(last_lines, captured_output, line, output_log_level):
+    '''
+    Given a rolling list of last lines, a list of captured output, a line to append, and an output
+    log level, append the line to the last lines and (if necessary) the captured output. Then log
+    the line at the requested output log level.
+    '''
+    last_lines.append(line)
+
+    if len(last_lines) > ERROR_OUTPUT_MAX_LINE_COUNT:
+        last_lines.pop(0)
+
+    if output_log_level is None:
+        captured_output.append(line)
+    else:
+        logger.log(output_log_level, line)
+
+
 def log_outputs(processes, exclude_stdouts, output_log_level, borg_local_path):
     '''
     Given a sequence of subprocess.Popen() instances for multiple processes, log the output for each
     process with the requested log level. Additionally, raise a CalledProcessError if a process
     exits with an error (or a warning for exit code 1, if that process does not match the Borg local
     path).
 
@@ -96,42 +111,50 @@
                 while True:
                     line = ready_buffer.readline().rstrip().decode()
                     if not line or not ready_process:
                         break
 
                     # Keep the last few lines of output in case the process errors, and we need the output for
                     # the exception below.
-                    last_lines = buffer_last_lines[ready_buffer]
-                    last_lines.append(line)
-                    if len(last_lines) > ERROR_OUTPUT_MAX_LINE_COUNT:
-                        last_lines.pop(0)
-
-                    if output_log_level is None:
-                        captured_outputs[ready_process].append(line)
-                    else:
-                        logger.log(output_log_level, line)
+                    append_last_lines(
+                        buffer_last_lines[ready_buffer],
+                        captured_outputs[ready_process],
+                        line,
+                        output_log_level,
+                    )
 
         if not still_running:
             break
 
         still_running = False
 
         for process in processes:
             exit_code = process.poll() if output_buffers else process.wait()
 
             if exit_code is None:
                 still_running = True
 
+            command = process.args.split(' ') if isinstance(process.args, str) else process.args
             # If any process errors, then raise accordingly.
-            if exit_code_indicates_error(process, exit_code, borg_local_path):
+            if exit_code_indicates_error(command, exit_code, borg_local_path):
                 # If an error occurs, include its output in the raised exception so that we don't
                 # inadvertently hide error output.
                 output_buffer = output_buffer_for_process(process, exclude_stdouts)
-
                 last_lines = buffer_last_lines[output_buffer] if output_buffer else []
+
+                # Collect any straggling output lines that came in since we last gathered output.
+                while output_buffer:  # pragma: no cover
+                    line = output_buffer.readline().rstrip().decode()
+                    if not line:
+                        break
+
+                    append_last_lines(
+                        last_lines, captured_outputs[process], line, output_log_level=logging.ERROR
+                    )
+
                 if len(last_lines) == ERROR_OUTPUT_MAX_LINE_COUNT:
                     last_lines.insert(0, '...')
 
                 # Something has gone wrong. So vent each process' output buffer to prevent it from
                 # hanging. And then kill the process.
                 for other_process in processes:
                     if other_process.poll() is None:
@@ -151,16 +174,16 @@
 def log_command(full_command, input_file=None, output_file=None):
     '''
     Log the given command (a sequence of command/argument strings), along with its input/output file
     paths.
     '''
     logger.debug(
         ' '.join(full_command)
-        + (' < {}'.format(getattr(input_file, 'name', '')) if input_file else '')
-        + (' > {}'.format(getattr(output_file, 'name', '')) if output_file else '')
+        + (f" < {getattr(input_file, 'name', '')}" if input_file else '')
+        + (f" > {getattr(output_file, 'name', '')}" if output_file else '')
     )
 
 
 # An sentinel passed as an output file to execute_command() to indicate that the command's output
 # should be allowed to flow through to stdout without being captured for logging. Useful for
 # commands with interactive prompts or those that mess directly with the console.
 DO_NOT_CAPTURE = object()
@@ -209,36 +232,48 @@
 
     log_outputs(
         (process,), (input_file, output_file), output_log_level, borg_local_path=borg_local_path
     )
 
 
 def execute_command_and_capture_output(
-    full_command, capture_stderr=False, shell=False, extra_environment=None, working_directory=None,
+    full_command,
+    capture_stderr=False,
+    shell=False,
+    extra_environment=None,
+    working_directory=None,
+    borg_local_path=None,
 ):
     '''
     Execute the given command (a sequence of command/argument strings), capturing and returning its
     output (stdout). If capture stderr is True, then capture and return stderr in addition to
     stdout. If shell is True, execute the command within a shell. If an extra environment dict is
     given, then use it to augment the current environment, and pass the result into the command. If
-    a working directory is given, use that as the present working directory when running the command.
+    a working directory is given, use that as the present working directory when running the
+    command. If a Borg local path is given, and the command matches it (regardless of arguments),
+    treat exit code 1 as a warning instead of an error.
 
     Raise subprocesses.CalledProcessError if an error occurs while running the command.
     '''
     log_command(full_command)
     environment = {**os.environ, **extra_environment} if extra_environment else None
     command = ' '.join(full_command) if shell else full_command
 
-    output = subprocess.check_output(
-        command,
-        stderr=subprocess.STDOUT if capture_stderr else None,
-        shell=shell,
-        env=environment,
-        cwd=working_directory,
-    )
+    try:
+        output = subprocess.check_output(
+            command,
+            stderr=subprocess.STDOUT if capture_stderr else None,
+            shell=shell,
+            env=environment,
+            cwd=working_directory,
+        )
+    except subprocess.CalledProcessError as error:
+        if exit_code_indicates_error(command, error.returncode, borg_local_path):
+            raise
+        output = error.output
 
     return output.decode() if output is not None else None
 
 
 def execute_command_with_processes(
     full_command,
     processes,
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/command.py` & `borgmatic-1.8.0/borgmatic/hooks/command.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 
 def interpolate_context(config_filename, hook_description, command, context):
     '''
     Given a config filename, a hook description, a single hook command, and a dict of context
     names/values, interpolate the values by "{name}" into the command and return the result.
     '''
     for name, value in context.items():
-        command = command.replace('{%s}' % name, str(value))
+        command = command.replace(f'{{{name}}}', str(value))
 
     for unsupported_variable in re.findall(r'{\w+}', command):
         logger.warning(
             f"{config_filename}: Variable '{unsupported_variable}' is not supported in {hook_description} hook"
         )
 
     return command
@@ -34,38 +34,34 @@
 
     The context contains optional values interpolated by name into the hook commands.
 
     Raise ValueError if the umask cannot be parsed.
     Raise subprocesses.CalledProcessError if an error occurs in a hook.
     '''
     if not commands:
-        logger.debug('{}: No commands to run for {} hook'.format(config_filename, description))
+        logger.debug(f'{config_filename}: No commands to run for {description} hook')
         return
 
     dry_run_label = ' (dry run; not actually running hooks)' if dry_run else ''
 
     context['configuration_filename'] = config_filename
     commands = [
         interpolate_context(config_filename, description, command, context) for command in commands
     ]
 
     if len(commands) == 1:
-        logger.info(
-            '{}: Running command for {} hook{}'.format(config_filename, description, dry_run_label)
-        )
+        logger.info(f'{config_filename}: Running command for {description} hook{dry_run_label}')
     else:
         logger.info(
-            '{}: Running {} commands for {} hook{}'.format(
-                config_filename, len(commands), description, dry_run_label
-            )
+            f'{config_filename}: Running {len(commands)} commands for {description} hook{dry_run_label}',
         )
 
     if umask:
         parsed_umask = int(str(umask), 8)
-        logger.debug('{}: Set hook umask to {}'.format(config_filename, oct(parsed_umask)))
+        logger.debug(f'{config_filename}: Set hook umask to {oct(parsed_umask)}')
         original_umask = os.umask(parsed_umask)
     else:
         original_umask = None
 
     try:
         for command in commands:
             if not dry_run:
@@ -89,14 +85,12 @@
     '''
     exit_code = getattr(error, 'returncode', None)
     if exit_code is None:
         return False
 
     if exit_code == SOFT_FAIL_EXIT_CODE:
         logger.info(
-            '{}: Command hook exited with soft failure exit code ({}); skipping remaining actions'.format(
-                config_filename, SOFT_FAIL_EXIT_CODE
-            )
+            f'{config_filename}: Command hook exited with soft failure exit code ({SOFT_FAIL_EXIT_CODE}); skipping remaining actions',
         )
         return True
 
     return False
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/cronhub.py` & `borgmatic-1.8.0/borgmatic/hooks/cronhub.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,56 +10,54 @@
     monitor.State.START: 'start',
     monitor.State.FINISH: 'finish',
     monitor.State.FAIL: 'fail',
 }
 
 
 def initialize_monitor(
-    ping_url, config_filename, monitoring_log_level, dry_run
+    ping_url, config, config_filename, monitoring_log_level, dry_run
 ):  # pragma: no cover
     '''
     No initialization is necessary for this monitor.
     '''
     pass
 
 
-def ping_monitor(hook_config, config_filename, state, monitoring_log_level, dry_run):
+def ping_monitor(hook_config, config, config_filename, state, monitoring_log_level, dry_run):
     '''
     Ping the configured Cronhub URL, modified with the monitor.State. Use the given configuration
     filename in any log entries. If this is a dry run, then don't actually ping anything.
     '''
     if state not in MONITOR_STATE_TO_CRONHUB:
         logger.debug(
             f'{config_filename}: Ignoring unsupported monitoring {state.name.lower()} in Cronhub hook'
         )
         return
 
     dry_run_label = ' (dry run; not actually pinging)' if dry_run else ''
-    formatted_state = '/{}/'.format(MONITOR_STATE_TO_CRONHUB[state])
+    formatted_state = f'/{MONITOR_STATE_TO_CRONHUB[state]}/'
     ping_url = (
         hook_config['ping_url']
         .replace('/start/', formatted_state)
         .replace('/ping/', formatted_state)
     )
 
-    logger.info(
-        '{}: Pinging Cronhub {}{}'.format(config_filename, state.name.lower(), dry_run_label)
-    )
-    logger.debug('{}: Using Cronhub ping URL {}'.format(config_filename, ping_url))
+    logger.info(f'{config_filename}: Pinging Cronhub {state.name.lower()}{dry_run_label}')
+    logger.debug(f'{config_filename}: Using Cronhub ping URL {ping_url}')
 
     if not dry_run:
         logging.getLogger('urllib3').setLevel(logging.ERROR)
         try:
             response = requests.get(ping_url)
             if not response.ok:
                 response.raise_for_status()
         except requests.exceptions.RequestException as error:
             logger.warning(f'{config_filename}: Cronhub error: {error}')
 
 
 def destroy_monitor(
-    ping_url_or_uuid, config_filename, monitoring_log_level, dry_run
+    ping_url_or_uuid, config, config_filename, monitoring_log_level, dry_run
 ):  # pragma: no cover
     '''
     No destruction is necessary for this monitor.
     '''
     pass
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/cronitor.py` & `borgmatic-1.8.0/borgmatic/hooks/cronitor.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,51 +10,49 @@
     monitor.State.START: 'run',
     monitor.State.FINISH: 'complete',
     monitor.State.FAIL: 'fail',
 }
 
 
 def initialize_monitor(
-    ping_url, config_filename, monitoring_log_level, dry_run
+    ping_url, config, config_filename, monitoring_log_level, dry_run
 ):  # pragma: no cover
     '''
     No initialization is necessary for this monitor.
     '''
     pass
 
 
-def ping_monitor(hook_config, config_filename, state, monitoring_log_level, dry_run):
+def ping_monitor(hook_config, config, config_filename, state, monitoring_log_level, dry_run):
     '''
     Ping the configured Cronitor URL, modified with the monitor.State. Use the given configuration
     filename in any log entries. If this is a dry run, then don't actually ping anything.
     '''
     if state not in MONITOR_STATE_TO_CRONITOR:
         logger.debug(
             f'{config_filename}: Ignoring unsupported monitoring {state.name.lower()} in Cronitor hook'
         )
         return
 
     dry_run_label = ' (dry run; not actually pinging)' if dry_run else ''
-    ping_url = '{}/{}'.format(hook_config['ping_url'], MONITOR_STATE_TO_CRONITOR[state])
+    ping_url = f"{hook_config['ping_url']}/{MONITOR_STATE_TO_CRONITOR[state]}"
 
-    logger.info(
-        '{}: Pinging Cronitor {}{}'.format(config_filename, state.name.lower(), dry_run_label)
-    )
-    logger.debug('{}: Using Cronitor ping URL {}'.format(config_filename, ping_url))
+    logger.info(f'{config_filename}: Pinging Cronitor {state.name.lower()}{dry_run_label}')
+    logger.debug(f'{config_filename}: Using Cronitor ping URL {ping_url}')
 
     if not dry_run:
         logging.getLogger('urllib3').setLevel(logging.ERROR)
         try:
             response = requests.get(ping_url)
             if not response.ok:
                 response.raise_for_status()
         except requests.exceptions.RequestException as error:
             logger.warning(f'{config_filename}: Cronitor error: {error}')
 
 
 def destroy_monitor(
-    ping_url_or_uuid, config_filename, monitoring_log_level, dry_run
+    ping_url_or_uuid, config, config_filename, monitoring_log_level, dry_run
 ):  # pragma: no cover
     '''
     No destruction is necessary for this monitor.
     '''
     pass
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/dispatch.py` & `borgmatic-1.8.0/borgmatic/hooks/dispatch.py`

 * *Files 10% similar despite different names*

```diff
@@ -23,64 +23,63 @@
     'ntfy': ntfy,
     'pagerduty': pagerduty,
     'postgresql_databases': postgresql,
     'sqlite_databases': sqlite,
 }
 
 
-def call_hook(function_name, hooks, log_prefix, hook_name, *args, **kwargs):
+def call_hook(function_name, config, log_prefix, hook_name, *args, **kwargs):
     '''
-    Given the hooks configuration dict and a prefix to use in log entries, call the requested
-    function of the Python module corresponding to the given hook name. Supply that call with the
-    configuration for this hook (if any), the log prefix, and any given args and kwargs. Return any
-    return value.
+    Given a configuration dict and a prefix to use in log entries, call the requested function of
+    the Python module corresponding to the given hook name. Supply that call with the configuration
+    for this hook (if any), the log prefix, and any given args and kwargs. Return any return value.
 
     Raise ValueError if the hook name is unknown.
     Raise AttributeError if the function name is not found in the module.
     Raise anything else that the called function raises.
     '''
-    config = hooks.get(hook_name, {})
+    hook_config = config.get(hook_name, {})
 
     try:
         module = HOOK_NAME_TO_MODULE[hook_name]
     except KeyError:
-        raise ValueError('Unknown hook name: {}'.format(hook_name))
+        raise ValueError(f'Unknown hook name: {hook_name}')
 
-    logger.debug('{}: Calling {} hook function {}'.format(log_prefix, hook_name, function_name))
-    return getattr(module, function_name)(config, log_prefix, *args, **kwargs)
+    logger.debug(f'{log_prefix}: Calling {hook_name} hook function {function_name}')
+    return getattr(module, function_name)(hook_config, config, log_prefix, *args, **kwargs)
 
 
-def call_hooks(function_name, hooks, log_prefix, hook_names, *args, **kwargs):
+def call_hooks(function_name, config, log_prefix, hook_names, *args, **kwargs):
     '''
-    Given the hooks configuration dict and a prefix to use in log entries, call the requested
-    function of the Python module corresponding to each given hook name. Supply each call with the
-    configuration for that hook, the log prefix, and any given args and kwargs. Collect any return
-    values into a dict from hook name to return value.
+    Given a configuration dict and a prefix to use in log entries, call the requested function of
+    the Python module corresponding to each given hook name. Supply each call with the configuration
+    for that hook, the log prefix, and any given args and kwargs. Collect any return values into a
+    dict from hook name to return value.
 
     If the hook name is not present in the hooks configuration, then don't call the function for it
     and omit it from the return values.
 
     Raise ValueError if the hook name is unknown.
     Raise AttributeError if the function name is not found in the module.
     Raise anything else that a called function raises. An error stops calls to subsequent functions.
     '''
     return {
-        hook_name: call_hook(function_name, hooks, log_prefix, hook_name, *args, **kwargs)
+        hook_name: call_hook(function_name, config, log_prefix, hook_name, *args, **kwargs)
         for hook_name in hook_names
-        if hooks.get(hook_name)
+        if config.get(hook_name)
     }
 
 
-def call_hooks_even_if_unconfigured(function_name, hooks, log_prefix, hook_names, *args, **kwargs):
+def call_hooks_even_if_unconfigured(function_name, config, log_prefix, hook_names, *args, **kwargs):
     '''
-    Given the hooks configuration dict and a prefix to use in log entries, call the requested
-    function of the Python module corresponding to each given hook name. Supply each call with the
-    configuration for that hook, the log prefix, and any given args and kwargs. Collect any return
-    values into a dict from hook name to return value.
+    Given a configuration dict and a prefix to use in log entries, call the requested function of
+    the Python module corresponding to each given hook name. Supply each call with the configuration
+    for that hook, the log prefix, and any given args and kwargs. Collect any return values into a
+    dict from hook name to return value.
 
     Raise AttributeError if the function name is not found in the module.
     Raise anything else that a called function raises. An error stops calls to subsequent functions.
     '''
     return {
-        hook_name: call_hook(function_name, hooks, log_prefix, hook_name, *args, **kwargs)
+        hook_name: call_hook(function_name, config, log_prefix, hook_name, *args, **kwargs)
         for hook_name in hook_names
     }
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/dump.py` & `borgmatic-1.8.0/borgmatic/hooks/dump.py`

 * *Files 10% similar despite different names*

```diff
@@ -29,15 +29,15 @@
     '''
     Based on the given dump directory path, database name, and hostname, return a filename to use
     for the database dump. The hostname defaults to localhost.
 
     Raise ValueError if the database name is invalid.
     '''
     if os.path.sep in name:
-        raise ValueError('Invalid database name {}'.format(name))
+        raise ValueError(f'Invalid database name {name}')
 
     return os.path.join(os.path.expanduser(dump_path), hostname or 'localhost', name)
 
 
 def create_parent_directory_for_dump(dump_path):
     '''
     Create a directory to contain the given dump path.
@@ -56,17 +56,15 @@
 def remove_database_dumps(dump_path, database_type_name, log_prefix, dry_run):
     '''
     Remove all database dumps in the given dump directory path (including the directory itself). If
     this is a dry run, then don't actually remove anything.
     '''
     dry_run_label = ' (dry run; not actually removing anything)' if dry_run else ''
 
-    logger.debug(
-        '{}: Removing {} database dumps{}'.format(log_prefix, database_type_name, dry_run_label)
-    )
+    logger.debug(f'{log_prefix}: Removing {database_type_name} database dumps{dry_run_label}')
 
     expanded_path = os.path.expanduser(dump_path)
 
     if dry_run:
         return
 
     if os.path.exists(expanded_path):
@@ -74,8 +72,8 @@
 
 
 def convert_glob_patterns_to_borg_patterns(patterns):
     '''
     Convert a sequence of shell glob patterns like "/etc/*" to the corresponding Borg archive
     patterns like "sh:etc/*".
     '''
-    return ['sh:{}'.format(pattern.lstrip(os.path.sep)) for pattern in patterns]
+    return [f'sh:{pattern.lstrip(os.path.sep)}' for pattern in patterns]
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/healthchecks.py` & `borgmatic-1.8.0/borgmatic/hooks/healthchecks.py`

 * *Files 6% similar despite different names*

```diff
@@ -66,15 +66,15 @@
 
     if buffering_handler.forgot:
         return PAYLOAD_TRUNCATION_INDICATOR + payload
 
     return payload
 
 
-def initialize_monitor(hook_config, config_filename, monitoring_log_level, dry_run):
+def initialize_monitor(hook_config, config, config_filename, monitoring_log_level, dry_run):
     '''
     Add a handler to the root logger that stores in memory the most recent logs emitted. That way,
     we can send them all to Healthchecks upon a finish or failure state. But skip this if the
     "send_logs" option is false.
     '''
     if hook_config.get('send_logs') is False:
         return
@@ -86,41 +86,39 @@
     )
 
     logging.getLogger().addHandler(
         Forgetful_buffering_handler(ping_body_limit, monitoring_log_level)
     )
 
 
-def ping_monitor(hook_config, config_filename, state, monitoring_log_level, dry_run):
+def ping_monitor(hook_config, config, config_filename, state, monitoring_log_level, dry_run):
     '''
     Ping the configured Healthchecks URL or UUID, modified with the monitor.State. Use the given
     configuration filename in any log entries, and log to Healthchecks with the giving log level.
     If this is a dry run, then don't actually ping anything.
     '''
     ping_url = (
         hook_config['ping_url']
         if hook_config['ping_url'].startswith('http')
-        else 'https://hc-ping.com/{}'.format(hook_config['ping_url'])
+        else f"https://hc-ping.com/{hook_config['ping_url']}"
     )
     dry_run_label = ' (dry run; not actually pinging)' if dry_run else ''
 
     if 'states' in hook_config and state.name.lower() not in hook_config['states']:
         logger.info(
             f'{config_filename}: Skipping Healthchecks {state.name.lower()} ping due to configured states'
         )
         return
 
     healthchecks_state = MONITOR_STATE_TO_HEALTHCHECKS.get(state)
     if healthchecks_state:
-        ping_url = '{}/{}'.format(ping_url, healthchecks_state)
+        ping_url = f'{ping_url}/{healthchecks_state}'
 
-    logger.info(
-        '{}: Pinging Healthchecks {}{}'.format(config_filename, state.name.lower(), dry_run_label)
-    )
-    logger.debug('{}: Using Healthchecks ping URL {}'.format(config_filename, ping_url))
+    logger.info(f'{config_filename}: Pinging Healthchecks {state.name.lower()}{dry_run_label}')
+    logger.debug(f'{config_filename}: Using Healthchecks ping URL {ping_url}')
 
     if state in (monitor.State.FINISH, monitor.State.FAIL, monitor.State.LOG):
         payload = format_buffered_logs_for_payload()
     else:
         payload = ''
 
     if not dry_run:
@@ -131,15 +129,15 @@
             )
             if not response.ok:
                 response.raise_for_status()
         except requests.exceptions.RequestException as error:
             logger.warning(f'{config_filename}: Healthchecks error: {error}')
 
 
-def destroy_monitor(hook_config, config_filename, monitoring_log_level, dry_run):
+def destroy_monitor(hook_config, config, config_filename, monitoring_log_level, dry_run):
     '''
     Remove the monitor handler that was added to the root logger. This prevents the handler from
     getting reused by other instances of this monitor.
     '''
     logger = logging.getLogger()
 
     for handler in tuple(logger.handlers):
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/mongodb.py` & `borgmatic-1.8.0/borgmatic/hooks/mongodb.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,49 +2,46 @@
 
 from borgmatic.execute import execute_command, execute_command_with_processes
 from borgmatic.hooks import dump
 
 logger = logging.getLogger(__name__)
 
 
-def make_dump_path(location_config):  # pragma: no cover
+def make_dump_path(config):  # pragma: no cover
     '''
-    Make the dump path from the given location configuration and the name of this hook.
+    Make the dump path from the given configuration dict and the name of this hook.
     '''
     return dump.make_database_dump_path(
-        location_config.get('borgmatic_source_directory'), 'mongodb_databases'
+        config.get('borgmatic_source_directory'), 'mongodb_databases'
     )
 
 
-def dump_databases(databases, log_prefix, location_config, dry_run):
+def dump_databases(databases, config, log_prefix, dry_run):
     '''
     Dump the given MongoDB databases to a named pipe. The databases are supplied as a sequence of
-    dicts, one dict describing each database as per the configuration schema. Use the given log
-    prefix in any log entries. Use the given location configuration dict to construct the
-    destination path.
+    dicts, one dict describing each database as per the configuration schema. Use the configuration
+    dict to construct the destination path and the given log prefix in any log entries.
 
     Return a sequence of subprocess.Popen instances for the dump processes ready to spew to a named
     pipe. But if this is a dry run, then don't actually dump anything and return an empty sequence.
     '''
     dry_run_label = ' (dry run; not actually dumping anything)' if dry_run else ''
 
-    logger.info('{}: Dumping MongoDB databases{}'.format(log_prefix, dry_run_label))
+    logger.info(f'{log_prefix}: Dumping MongoDB databases{dry_run_label}')
 
     processes = []
     for database in databases:
         name = database['name']
         dump_filename = dump.make_database_dump_filename(
-            make_dump_path(location_config), name, database.get('hostname')
+            make_dump_path(config), name, database.get('hostname')
         )
         dump_format = database.get('format', 'archive')
 
         logger.debug(
-            '{}: Dumping MongoDB database {} to {}{}'.format(
-                log_prefix, name, dump_filename, dry_run_label
-            )
+            f'{log_prefix}: Dumping MongoDB database {name} to {dump_filename}{dry_run_label}',
         )
         if dry_run:
             continue
 
         command = build_dump_command(database, dump_filename, dump_format)
 
         if dump_format == 'directory':
@@ -80,89 +77,111 @@
     if 'options' in database:
         command.extend(database['options'].split(' '))
     if dump_format != 'directory':
         command.extend(('--archive', '>', dump_filename))
     return command
 
 
-def remove_database_dumps(databases, log_prefix, location_config, dry_run):  # pragma: no cover
+def remove_database_dumps(databases, config, log_prefix, dry_run):  # pragma: no cover
     '''
     Remove all database dump files for this hook regardless of the given databases. Use the log
-    prefix in any log entries. Use the given location configuration dict to construct the
-    destination path. If this is a dry run, then don't actually remove anything.
+    prefix in any log entries. Use the given configuration dict to construct the destination path.
+    If this is a dry run, then don't actually remove anything.
     '''
-    dump.remove_database_dumps(make_dump_path(location_config), 'MongoDB', log_prefix, dry_run)
+    dump.remove_database_dumps(make_dump_path(config), 'MongoDB', log_prefix, dry_run)
 
 
-def make_database_dump_pattern(
-    databases, log_prefix, location_config, name=None
-):  # pragma: no cover
+def make_database_dump_pattern(databases, config, log_prefix, name=None):  # pragma: no cover
     '''
-    Given a sequence of configurations dicts, a prefix to log with, a location configuration dict,
+    Given a sequence of database configurations dicts, a configuration dict, a prefix to log with,
     and a database name to match, return the corresponding glob patterns to match the database dump
     in an archive.
     '''
-    return dump.make_database_dump_filename(make_dump_path(location_config), name, hostname='*')
+    return dump.make_database_dump_filename(make_dump_path(config), name, hostname='*')
 
 
-def restore_database_dump(database_config, log_prefix, location_config, dry_run, extract_process):
-    '''
-    Restore the given MongoDB database from an extract stream. The database is supplied as a
-    one-element sequence containing a dict describing the database, as per the configuration schema.
-    Use the given log prefix in any log entries. If this is a dry run, then don't actually restore
-    anything. Trigger the given active extract process (an instance of subprocess.Popen) to produce
-    output to consume.
+def restore_database_dump(
+    databases_config, config, log_prefix, database_name, dry_run, extract_process, connection_params
+):
+    '''
+    Restore the given MongoDB database from an extract stream. The databases are supplied as a
+    sequence containing one dict describing each database (as per the configuration schema), but
+    only the database corresponding to the given database name is restored. Use the configuration
+    dict to construct the destination path and the given log prefix in any log entries. If this is a
+    dry run, then don't actually restore anything. Trigger the given active extract process (an
+    instance of subprocess.Popen) to produce output to consume.
 
     If the extract process is None, then restore the dump from the filesystem rather than from an
     extract stream.
     '''
     dry_run_label = ' (dry run; not actually restoring anything)' if dry_run else ''
 
-    if len(database_config) != 1:
-        raise ValueError('The database configuration value is invalid')
+    try:
+        database = next(
+            database_config
+            for database_config in databases_config
+            if database_config.get('name') == database_name
+        )
+    except StopIteration:
+        raise ValueError(
+            f'A database named "{database_name}" could not be found in the configuration'
+        )
 
-    database = database_config[0]
     dump_filename = dump.make_database_dump_filename(
-        make_dump_path(location_config), database['name'], database.get('hostname')
+        make_dump_path(config), database['name'], database.get('hostname')
     )
-    restore_command = build_restore_command(extract_process, database, dump_filename)
-
-    logger.debug(
-        '{}: Restoring MongoDB database {}{}'.format(log_prefix, database['name'], dry_run_label)
+    restore_command = build_restore_command(
+        extract_process, database, dump_filename, connection_params
     )
+
+    logger.debug(f"{log_prefix}: Restoring MongoDB database {database['name']}{dry_run_label}")
     if dry_run:
         return
 
     # Don't give Borg local path so as to error on warnings, as "borg extract" only gives a warning
     # if the restore paths don't exist in the archive.
     execute_command_with_processes(
         restore_command,
         [extract_process] if extract_process else [],
         output_log_level=logging.DEBUG,
         input_file=extract_process.stdout if extract_process else None,
     )
 
 
-def build_restore_command(extract_process, database, dump_filename):
+def build_restore_command(extract_process, database, dump_filename, connection_params):
     '''
     Return the mongorestore command from a single database configuration.
     '''
+    hostname = connection_params['hostname'] or database.get(
+        'restore_hostname', database.get('hostname')
+    )
+    port = str(connection_params['port'] or database.get('restore_port', database.get('port', '')))
+    username = connection_params['username'] or database.get(
+        'restore_username', database.get('username')
+    )
+    password = connection_params['password'] or database.get(
+        'restore_password', database.get('password')
+    )
+
     command = ['mongorestore']
     if extract_process:
         command.append('--archive')
     else:
         command.extend(('--dir', dump_filename))
     if database['name'] != 'all':
         command.extend(('--drop', '--db', database['name']))
-    if 'hostname' in database:
-        command.extend(('--host', database['hostname']))
-    if 'port' in database:
-        command.extend(('--port', str(database['port'])))
-    if 'username' in database:
-        command.extend(('--username', database['username']))
-    if 'password' in database:
-        command.extend(('--password', database['password']))
+    if hostname:
+        command.extend(('--host', hostname))
+    if port:
+        command.extend(('--port', str(port)))
+    if username:
+        command.extend(('--username', username))
+    if password:
+        command.extend(('--password', password))
     if 'authentication_database' in database:
         command.extend(('--authenticationDatabase', database['authentication_database']))
     if 'restore_options' in database:
         command.extend(database['restore_options'].split(' '))
+    if database['schemas']:
+        for schema in database['schemas']:
+            command.extend(('--nsInclude', schema))
     return command
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/mysql.py` & `borgmatic-1.8.0/borgmatic/hooks/mysql.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,21 +8,19 @@
     execute_command_with_processes,
 )
 from borgmatic.hooks import dump
 
 logger = logging.getLogger(__name__)
 
 
-def make_dump_path(location_config):  # pragma: no cover
+def make_dump_path(config):  # pragma: no cover
     '''
-    Make the dump path from the given location configuration and the name of this hook.
+    Make the dump path from the given configuration dict and the name of this hook.
     '''
-    return dump.make_database_dump_path(
-        location_config.get('borgmatic_source_directory'), 'mysql_databases'
-    )
+    return dump.make_database_dump_path(config.get('borgmatic_source_directory'), 'mysql_databases')
 
 
 SYSTEM_DATABASE_NAMES = ('information_schema', 'mysql', 'performance_schema', 'sys')
 
 
 def database_names_to_dump(database, extra_environment, log_prefix, dry_run):
     '''
@@ -84,49 +82,48 @@
         + (('--add-drop-database',) if database.get('add_drop_database', True) else ())
         + (('--host', database['hostname']) if 'hostname' in database else ())
         + (('--port', str(database['port'])) if 'port' in database else ())
         + (('--protocol', 'tcp') if 'hostname' in database or 'port' in database else ())
         + (('--user', database['username']) if 'username' in database else ())
         + ('--databases',)
         + database_names
-        # Use shell redirection rather than execute_command(output_file=open(...)) to prevent
-        # the open() call on a named pipe from hanging the main borgmatic process.
-        + ('>', dump_filename)
+        + ('--result-file', dump_filename)
     )
 
     logger.debug(
         f'{log_prefix}: Dumping MySQL database "{database_name}" to {dump_filename}{dry_run_label}'
     )
     if dry_run:
         return None
 
     dump.create_named_pipe_for_dump(dump_filename)
 
     return execute_command(
-        dump_command, shell=True, extra_environment=extra_environment, run_to_completion=False,
+        dump_command,
+        extra_environment=extra_environment,
+        run_to_completion=False,
     )
 
 
-def dump_databases(databases, log_prefix, location_config, dry_run):
+def dump_databases(databases, config, log_prefix, dry_run):
     '''
     Dump the given MySQL/MariaDB databases to a named pipe. The databases are supplied as a sequence
-    of dicts, one dict describing each database as per the configuration schema. Use the given log
-    prefix in any log entries. Use the given location configuration dict to construct the
-    destination path.
+    of dicts, one dict describing each database as per the configuration schema. Use the given
+    configuration dict to construct the destination path and the given log prefix in any log entries.
 
     Return a sequence of subprocess.Popen instances for the dump processes ready to spew to a named
     pipe. But if this is a dry run, then don't actually dump anything and return an empty sequence.
     '''
     dry_run_label = ' (dry run; not actually dumping anything)' if dry_run else ''
     processes = []
 
-    logger.info('{}: Dumping MySQL databases{}'.format(log_prefix, dry_run_label))
+    logger.info(f'{log_prefix}: Dumping MySQL databases{dry_run_label}')
 
     for database in databases:
-        dump_path = make_dump_path(location_config)
+        dump_path = make_dump_path(config)
         extra_environment = {'MYSQL_PWD': database['password']} if 'password' in database else None
         dump_database_names = database_names_to_dump(
             database, extra_environment, log_prefix, dry_run
         )
 
         if not dump_database_names:
             if dry_run:
@@ -161,61 +158,77 @@
                     dry_run_label,
                 )
             )
 
     return [process for process in processes if process]
 
 
-def remove_database_dumps(databases, log_prefix, location_config, dry_run):  # pragma: no cover
+def remove_database_dumps(databases, config, log_prefix, dry_run):  # pragma: no cover
     '''
-    Remove all database dump files for this hook regardless of the given databases. Use the log
-    prefix in any log entries. Use the given location configuration dict to construct the
-    destination path. If this is a dry run, then don't actually remove anything.
+    Remove all database dump files for this hook regardless of the given databases. Use the given
+    configuration dict to construct the destination path and the log prefix in any log entries. If
+    this is a dry run, then don't actually remove anything.
     '''
-    dump.remove_database_dumps(make_dump_path(location_config), 'MySQL', log_prefix, dry_run)
+    dump.remove_database_dumps(make_dump_path(config), 'MySQL', log_prefix, dry_run)
 
 
-def make_database_dump_pattern(
-    databases, log_prefix, location_config, name=None
-):  # pragma: no cover
+def make_database_dump_pattern(databases, config, log_prefix, name=None):  # pragma: no cover
     '''
-    Given a sequence of configurations dicts, a prefix to log with, a location configuration dict,
-    and a database name to match, return the corresponding glob patterns to match the database dump
-    in an archive.
+    Given a sequence of configurations dicts, a configuration dict, a prefix to log with, and a
+    database name to match, return the corresponding glob patterns to match the database dump in an
+    archive.
     '''
-    return dump.make_database_dump_filename(make_dump_path(location_config), name, hostname='*')
+    return dump.make_database_dump_filename(make_dump_path(config), name, hostname='*')
 
 
-def restore_database_dump(database_config, log_prefix, location_config, dry_run, extract_process):
+def restore_database_dump(
+    databases_config, config, log_prefix, database_name, dry_run, extract_process, connection_params
+):
     '''
-    Restore the given MySQL/MariaDB database from an extract stream. The database is supplied as a
-    one-element sequence containing a dict describing the database, as per the configuration schema.
-    Use the given log prefix in any log entries. If this is a dry run, then don't actually restore
-    anything. Trigger the given active extract process (an instance of subprocess.Popen) to produce
-    output to consume.
+    Restore the given MySQL/MariaDB database from an extract stream. The databases are supplied as a
+    sequence containing one dict describing each database (as per the configuration schema), but
+    only the database corresponding to the given database name is restored. Use the given log
+    prefix in any log entries. If this is a dry run, then don't actually restore anything. Trigger
+    the given active extract process (an instance of subprocess.Popen) to produce output to consume.
     '''
     dry_run_label = ' (dry run; not actually restoring anything)' if dry_run else ''
 
-    if len(database_config) != 1:
-        raise ValueError('The database configuration value is invalid')
+    try:
+        database = next(
+            database_config
+            for database_config in databases_config
+            if database_config.get('name') == database_name
+        )
+    except StopIteration:
+        raise ValueError(
+            f'A database named "{database_name}" could not be found in the configuration'
+        )
+
+    hostname = connection_params['hostname'] or database.get(
+        'restore_hostname', database.get('hostname')
+    )
+    port = str(connection_params['port'] or database.get('restore_port', database.get('port', '')))
+    username = connection_params['username'] or database.get(
+        'restore_username', database.get('username')
+    )
+    password = connection_params['password'] or database.get(
+        'restore_password', database.get('password')
+    )
 
-    database = database_config[0]
     restore_command = (
         ('mysql', '--batch')
         + (tuple(database['restore_options'].split(' ')) if 'restore_options' in database else ())
-        + (('--host', database['hostname']) if 'hostname' in database else ())
-        + (('--port', str(database['port'])) if 'port' in database else ())
-        + (('--protocol', 'tcp') if 'hostname' in database or 'port' in database else ())
-        + (('--user', database['username']) if 'username' in database else ())
+        + (('--host', hostname) if hostname else ())
+        + (('--port', str(port)) if port else ())
+        + (('--protocol', 'tcp') if hostname or port else ())
+        + (('--user', username) if username else ())
     )
-    extra_environment = {'MYSQL_PWD': database['password']} if 'password' in database else None
+    extra_environment = {'MYSQL_PWD': password} if password else None
 
-    logger.debug(
-        '{}: Restoring MySQL database {}{}'.format(log_prefix, database['name'], dry_run_label)
-    )
+    logger.debug(f"{log_prefix}: Restoring MySQL database {database['name']}{dry_run_label}")
     if dry_run:
         return
 
     # Don't give Borg local path so as to error on warnings, as "borg extract" only gives a warning
     # if the restore paths don't exist in the archive.
     execute_command_with_processes(
         restore_command,
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/ntfy.py` & `borgmatic-1.8.0/borgmatic/hooks/ntfy.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,23 +2,23 @@
 
 import requests
 
 logger = logging.getLogger(__name__)
 
 
 def initialize_monitor(
-    ping_url, config_filename, monitoring_log_level, dry_run
+    ping_url, config, config_filename, monitoring_log_level, dry_run
 ):  # pragma: no cover
     '''
     No initialization is necessary for this monitor.
     '''
     pass
 
 
-def ping_monitor(hook_config, config_filename, state, monitoring_log_level, dry_run):
+def ping_monitor(hook_config, config, config_filename, state, monitoring_log_level, dry_run):
     '''
     Ping the configured Ntfy topic. Use the given configuration filename in any log entries.
     If this is a dry run, then don't actually ping anything.
     '''
 
     run_states = hook_config.get('states', ['fail'])
 
@@ -71,13 +71,13 @@
                 if not response.ok:
                     response.raise_for_status()
             except requests.exceptions.RequestException as error:
                 logger.warning(f'{config_filename}: ntfy error: {error}')
 
 
 def destroy_monitor(
-    ping_url_or_uuid, config_filename, monitoring_log_level, dry_run
+    ping_url_or_uuid, config, config_filename, monitoring_log_level, dry_run
 ):  # pragma: no cover
     '''
     No destruction is necessary for this monitor.
     '''
     pass
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/pagerduty.py` & `borgmatic-1.8.0/borgmatic/hooks/pagerduty.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,77 +9,75 @@
 
 logger = logging.getLogger(__name__)
 
 EVENTS_API_URL = 'https://events.pagerduty.com/v2/enqueue'
 
 
 def initialize_monitor(
-    integration_key, config_filename, monitoring_log_level, dry_run
+    integration_key, config, config_filename, monitoring_log_level, dry_run
 ):  # pragma: no cover
     '''
     No initialization is necessary for this monitor.
     '''
     pass
 
 
-def ping_monitor(hook_config, config_filename, state, monitoring_log_level, dry_run):
+def ping_monitor(hook_config, config, config_filename, state, monitoring_log_level, dry_run):
     '''
     If this is an error state, create a PagerDuty event with the configured integration key. Use
     the given configuration filename in any log entries. If this is a dry run, then don't actually
     create an event.
     '''
     if state != monitor.State.FAIL:
         logger.debug(
-            '{}: Ignoring unsupported monitoring {} in PagerDuty hook'.format(
-                config_filename, state.name.lower()
-            )
+            f'{config_filename}: Ignoring unsupported monitoring {state.name.lower()} in PagerDuty hook',
         )
         return
 
     dry_run_label = ' (dry run; not actually sending)' if dry_run else ''
-    logger.info('{}: Sending failure event to PagerDuty {}'.format(config_filename, dry_run_label))
+    logger.info(f'{config_filename}: Sending failure event to PagerDuty {dry_run_label}')
 
     if dry_run:
         return
 
     hostname = platform.node()
     local_timestamp = (
         datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc).astimezone().isoformat()
     )
     payload = json.dumps(
         {
             'routing_key': hook_config['integration_key'],
             'event_action': 'trigger',
             'payload': {
-                'summary': 'backup failed on {}'.format(hostname),
+                'summary': f'backup failed on {hostname}',
                 'severity': 'error',
                 'source': hostname,
                 'timestamp': local_timestamp,
                 'component': 'borgmatic',
                 'group': 'backups',
                 'class': 'backup failure',
                 'custom_details': {
                     'hostname': hostname,
                     'configuration filename': config_filename,
                     'server time': local_timestamp,
                 },
             },
         }
     )
-    logger.debug('{}: Using PagerDuty payload: {}'.format(config_filename, payload))
+    logger.debug(f'{config_filename}: Using PagerDuty payload: {payload}')
 
     logging.getLogger('urllib3').setLevel(logging.ERROR)
     try:
         response = requests.post(EVENTS_API_URL, data=payload.encode('utf-8'))
         if not response.ok:
             response.raise_for_status()
     except requests.exceptions.RequestException as error:
         logger.warning(f'{config_filename}: PagerDuty error: {error}')
 
 
 def destroy_monitor(
-    ping_url_or_uuid, config_filename, monitoring_log_level, dry_run
+    ping_url_or_uuid, config, config_filename, monitoring_log_level, dry_run
 ):  # pragma: no cover
     '''
     No destruction is necessary for this monitor.
     '''
     pass
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/postgresql.py` & `borgmatic-1.8.0/borgmatic/hooks/postgresql.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,49 @@
 import csv
+import itertools
 import logging
 import os
+import shlex
 
 from borgmatic.execute import (
     execute_command,
     execute_command_and_capture_output,
     execute_command_with_processes,
 )
 from borgmatic.hooks import dump
 
 logger = logging.getLogger(__name__)
 
 
-def make_dump_path(location_config):  # pragma: no cover
+def make_dump_path(config):  # pragma: no cover
     '''
-    Make the dump path from the given location configuration and the name of this hook.
+    Make the dump path from the given configuration dict and the name of this hook.
     '''
     return dump.make_database_dump_path(
-        location_config.get('borgmatic_source_directory'), 'postgresql_databases'
+        config.get('borgmatic_source_directory'), 'postgresql_databases'
     )
 
 
-def make_extra_environment(database):
+def make_extra_environment(database, restore_connection_params=None):
     '''
     Make the extra_environment dict from the given database configuration.
+    If restore connection params are given, this is for a restore operation.
     '''
     extra = dict()
-    if 'password' in database:
-        extra['PGPASSWORD'] = database['password']
+
+    try:
+        if restore_connection_params:
+            extra['PGPASSWORD'] = restore_connection_params.get('password') or database.get(
+                'restore_password', database['password']
+            )
+        else:
+            extra['PGPASSWORD'] = database['password']
+    except (AttributeError, KeyError):
+        pass
+
     extra['PGSSLMODE'] = database.get('ssl_mode', 'disable')
     if 'ssl_cert' in database:
         extra['PGSSLCERT'] = database['ssl_cert']
     if 'ssl_key' in database:
         extra['PGSSLKEY'] = database['ssl_key']
     if 'ssl_root_cert' in database:
         extra['PGSSLROOTCERT'] = database['ssl_root_cert']
@@ -55,16 +67,18 @@
     if requested_name != 'all':
         return (requested_name,)
     if not database.get('format'):
         return ('all',)
     if dry_run:
         return ()
 
+    psql_command = shlex.split(database.get('psql_command') or 'psql')
     list_command = (
-        ('psql', '--list', '--no-password', '--csv', '--tuples-only')
+        tuple(psql_command)
+        + ('--list', '--no-password', '--no-psqlrc', '--csv', '--tuples-only')
         + (('--host', database['hostname']) if 'hostname' in database else ())
         + (('--port', str(database['port'])) if 'port' in database else ())
         + (('--username', database['username']) if 'username' in database else ())
         + (tuple(database['list_options'].split(' ')) if 'list_options' in database else ())
     )
     logger.debug(f'{log_prefix}: Querying for "all" PostgreSQL databases to dump')
     list_output = execute_command_and_capture_output(
@@ -74,34 +88,34 @@
     return tuple(
         row[0]
         for row in csv.reader(list_output.splitlines(), delimiter=',', quotechar='"')
         if row[0] not in EXCLUDED_DATABASE_NAMES
     )
 
 
-def dump_databases(databases, log_prefix, location_config, dry_run):
+def dump_databases(databases, config, log_prefix, dry_run):
     '''
     Dump the given PostgreSQL databases to a named pipe. The databases are supplied as a sequence of
-    dicts, one dict describing each database as per the configuration schema. Use the given log
-    prefix in any log entries. Use the given location configuration dict to construct the
-    destination path.
+    dicts, one dict describing each database as per the configuration schema. Use the given
+    configuration dict to construct the destination path and the given log prefix in any log
+    entries.
 
     Return a sequence of subprocess.Popen instances for the dump processes ready to spew to a named
     pipe. But if this is a dry run, then don't actually dump anything and return an empty sequence.
 
     Raise ValueError if the databases to dump cannot be determined.
     '''
     dry_run_label = ' (dry run; not actually dumping anything)' if dry_run else ''
     processes = []
 
-    logger.info('{}: Dumping PostgreSQL databases{}'.format(log_prefix, dry_run_label))
+    logger.info(f'{log_prefix}: Dumping PostgreSQL databases{dry_run_label}')
 
     for database in databases:
         extra_environment = make_extra_environment(database)
-        dump_path = make_dump_path(location_config)
+        dump_path = make_dump_path(config)
         dump_database_names = database_names_to_dump(
             database, extra_environment, log_prefix, dry_run
         )
 
         if not dump_database_names:
             if dry_run:
                 continue
@@ -118,18 +132,24 @@
             if os.path.exists(dump_filename):
                 logger.warning(
                     f'{log_prefix}: Skipping duplicate dump of PostgreSQL database "{database_name}" to {dump_filename}'
                 )
                 continue
 
             command = (
-                (dump_command, '--no-password', '--clean', '--if-exists',)
+                (
+                    dump_command,
+                    '--no-password',
+                    '--clean',
+                    '--if-exists',
+                )
                 + (('--host', database['hostname']) if 'hostname' in database else ())
                 + (('--port', str(database['port'])) if 'port' in database else ())
                 + (('--username', database['username']) if 'username' in database else ())
+                + (('--no-owner',) if database.get('no_owner', False) else ())
                 + (('--format', dump_format) if dump_format else ())
                 + (('--file', dump_filename) if dump_format == 'directory' else ())
                 + (tuple(database['options'].split(' ')) if 'options' in database else ())
                 + (() if database_name == 'all' else (database_name,))
                 # Use shell redirection rather than the --file flag to sidestep synchronization issues
                 # when pg_dump/pg_dumpall tries to write to a named pipe. But for the directory dump
                 # format in a particular, a named destination is required, and redirection doesn't work.
@@ -141,15 +161,17 @@
             )
             if dry_run:
                 continue
 
             if dump_format == 'directory':
                 dump.create_parent_directory_for_dump(dump_filename)
                 execute_command(
-                    command, shell=True, extra_environment=extra_environment,
+                    command,
+                    shell=True,
+                    extra_environment=extra_environment,
                 )
             else:
                 dump.create_named_pipe_for_dump(dump_filename)
                 processes.append(
                     execute_command(
                         command,
                         shell=True,
@@ -157,84 +179,110 @@
                         run_to_completion=False,
                     )
                 )
 
     return processes
 
 
-def remove_database_dumps(databases, log_prefix, location_config, dry_run):  # pragma: no cover
+def remove_database_dumps(databases, config, log_prefix, dry_run):  # pragma: no cover
     '''
-    Remove all database dump files for this hook regardless of the given databases. Use the log
-    prefix in any log entries. Use the given location configuration dict to construct the
-    destination path. If this is a dry run, then don't actually remove anything.
+    Remove all database dump files for this hook regardless of the given databases. Use the given
+    configuration dict to construct the destination path and the log prefix in any log entries. If
+    this is a dry run, then don't actually remove anything.
     '''
-    dump.remove_database_dumps(make_dump_path(location_config), 'PostgreSQL', log_prefix, dry_run)
+    dump.remove_database_dumps(make_dump_path(config), 'PostgreSQL', log_prefix, dry_run)
 
 
-def make_database_dump_pattern(
-    databases, log_prefix, location_config, name=None
-):  # pragma: no cover
+def make_database_dump_pattern(databases, config, log_prefix, name=None):  # pragma: no cover
     '''
-    Given a sequence of configurations dicts, a prefix to log with, a location configuration dict,
-    and a database name to match, return the corresponding glob patterns to match the database dump
-    in an archive.
+    Given a sequence of configurations dicts, a configuration dict, a prefix to log with, and a
+    database name to match, return the corresponding glob patterns to match the database dump in an
+    archive.
     '''
-    return dump.make_database_dump_filename(make_dump_path(location_config), name, hostname='*')
+    return dump.make_database_dump_filename(make_dump_path(config), name, hostname='*')
 
 
-def restore_database_dump(database_config, log_prefix, location_config, dry_run, extract_process):
+def restore_database_dump(
+    databases_config, config, log_prefix, database_name, dry_run, extract_process, connection_params
+):
     '''
-    Restore the given PostgreSQL database from an extract stream. The database is supplied as a
-    one-element sequence containing a dict describing the database, as per the configuration schema.
-    Use the given log prefix in any log entries. If this is a dry run, then don't actually restore
-    anything. Trigger the given active extract process (an instance of subprocess.Popen) to produce
-    output to consume.
+    Restore the given PostgreSQL database from an extract stream. The databases are supplied as a
+    sequence containing one dict describing each database (as per the configuration schema), but
+    only the database corresponding to the given database name is restored. Use the given
+    configuration dict to construct the destination path and the given log prefix in any log
+    entries. If this is a dry run, then don't actually restore anything. Trigger the given active
+    extract process (an instance of subprocess.Popen) to produce output to consume.
 
     If the extract process is None, then restore the dump from the filesystem rather than from an
     extract stream.
+
+    Use the given connection parameters to connect to the database. The connection parameters are
+    hostname, port, username, and password.
     '''
     dry_run_label = ' (dry run; not actually restoring anything)' if dry_run else ''
 
-    if len(database_config) != 1:
-        raise ValueError('The database configuration value is invalid')
+    try:
+        database = next(
+            database_config
+            for database_config in databases_config
+            if database_config.get('name') == database_name
+        )
+    except StopIteration:
+        raise ValueError(
+            f'A database named "{database_name}" could not be found in the configuration'
+        )
+
+    hostname = connection_params['hostname'] or database.get(
+        'restore_hostname', database.get('hostname')
+    )
+    port = str(connection_params['port'] or database.get('restore_port', database.get('port', '')))
+    username = connection_params['username'] or database.get(
+        'restore_username', database.get('username')
+    )
 
-    database = database_config[0]
     all_databases = bool(database['name'] == 'all')
     dump_filename = dump.make_database_dump_filename(
-        make_dump_path(location_config), database['name'], database.get('hostname')
+        make_dump_path(config), database['name'], database.get('hostname')
     )
-    psql_command = database.get('psql_command') or 'psql'
+    psql_command = shlex.split(database.get('psql_command') or 'psql')
     analyze_command = (
-        (psql_command, '--no-password', '--quiet')
-        + (('--host', database['hostname']) if 'hostname' in database else ())
-        + (('--port', str(database['port'])) if 'port' in database else ())
-        + (('--username', database['username']) if 'username' in database else ())
+        tuple(psql_command)
+        + ('--no-password', '--no-psqlrc', '--quiet')
+        + (('--host', hostname) if hostname else ())
+        + (('--port', port) if port else ())
+        + (('--username', username) if username else ())
         + (('--dbname', database['name']) if not all_databases else ())
         + (tuple(database['analyze_options'].split(' ')) if 'analyze_options' in database else ())
         + ('--command', 'ANALYZE')
     )
-    pg_restore_command = database.get('pg_restore_command') or 'pg_restore'
+    use_psql_command = all_databases or database.get('format') == 'plain'
+    pg_restore_command = shlex.split(database.get('pg_restore_command') or 'pg_restore')
     restore_command = (
-        (psql_command if all_databases else pg_restore_command, '--no-password')
-        + (
-            ('--if-exists', '--exit-on-error', '--clean', '--dbname', database['name'])
-            if not all_databases
-            else ()
-        )
-        + (('--host', database['hostname']) if 'hostname' in database else ())
-        + (('--port', str(database['port'])) if 'port' in database else ())
-        + (('--username', database['username']) if 'username' in database else ())
+        tuple(psql_command if use_psql_command else pg_restore_command)
+        + ('--no-password',)
+        + (('--no-psqlrc',) if use_psql_command else ('--if-exists', '--exit-on-error', '--clean'))
+        + (('--dbname', database['name']) if not all_databases else ())
+        + (('--host', hostname) if hostname else ())
+        + (('--port', port) if port else ())
+        + (('--username', username) if username else ())
+        + (('--no-owner',) if database.get('no_owner', False) else ())
         + (tuple(database['restore_options'].split(' ')) if 'restore_options' in database else ())
         + (() if extract_process else (dump_filename,))
+        + tuple(
+            itertools.chain.from_iterable(('--schema', schema) for schema in database['schemas'])
+            if database.get('schemas')
+            else ()
+        )
     )
-    extra_environment = make_extra_environment(database)
 
-    logger.debug(
-        '{}: Restoring PostgreSQL database {}{}'.format(log_prefix, database['name'], dry_run_label)
+    extra_environment = make_extra_environment(
+        database, restore_connection_params=connection_params
     )
+
+    logger.debug(f"{log_prefix}: Restoring PostgreSQL database {database['name']}{dry_run_label}")
     if dry_run:
         return
 
     # Don't give Borg local path so as to error on warnings, as "borg extract" only gives a warning
     # if the restore paths don't exist in the archive.
     execute_command_with_processes(
         restore_command,
```

### Comparing `borgmatic-1.7.9/borgmatic/hooks/sqlite.py` & `borgmatic-1.8.0/borgmatic/hooks/sqlite.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,46 +3,46 @@
 
 from borgmatic.execute import execute_command, execute_command_with_processes
 from borgmatic.hooks import dump
 
 logger = logging.getLogger(__name__)
 
 
-def make_dump_path(location_config):  # pragma: no cover
+def make_dump_path(config):  # pragma: no cover
     '''
-    Make the dump path from the given location configuration and the name of this hook.
+    Make the dump path from the given configuration dict and the name of this hook.
     '''
     return dump.make_database_dump_path(
-        location_config.get('borgmatic_source_directory'), 'sqlite_databases'
+        config.get('borgmatic_source_directory'), 'sqlite_databases'
     )
 
 
-def dump_databases(databases, log_prefix, location_config, dry_run):
+def dump_databases(databases, config, log_prefix, dry_run):
     '''
     Dump the given SQLite3 databases to a file. The databases are supplied as a sequence of
-    configuration dicts, as per the configuration schema. Use the given log prefix in any log
-    entries. Use the given location configuration dict to construct the destination path. If this
-    is a dry run, then don't actually dump anything.
+    configuration dicts, as per the configuration schema. Use the given configuration dict to
+    construct the destination path and the given log prefix in any log entries. If this is a dry
+    run, then don't actually dump anything.
     '''
     dry_run_label = ' (dry run; not actually dumping anything)' if dry_run else ''
     processes = []
 
-    logger.info('{}: Dumping SQLite databases{}'.format(log_prefix, dry_run_label))
+    logger.info(f'{log_prefix}: Dumping SQLite databases{dry_run_label}')
 
     for database in databases:
         database_path = database['path']
 
         if database['name'] == 'all':
             logger.warning('The "all" database name has no meaning for SQLite3 databases')
         if not os.path.exists(database_path):
             logger.warning(
                 f'{log_prefix}: No SQLite database at {database_path}; An empty database will be created and dumped'
             )
 
-        dump_path = make_dump_path(location_config)
+        dump_path = make_dump_path(config)
         dump_filename = dump.make_database_dump_filename(dump_path, database['name'])
         if os.path.exists(dump_filename):
             logger.warning(
                 f'{log_prefix}: Skipping duplicate dump of SQLite database at {database_path} to {dump_filename}'
             )
             continue
 
@@ -61,48 +61,58 @@
 
         dump.create_parent_directory_for_dump(dump_filename)
         processes.append(execute_command(command, shell=True, run_to_completion=False))
 
     return processes
 
 
-def remove_database_dumps(databases, log_prefix, location_config, dry_run):  # pragma: no cover
+def remove_database_dumps(databases, config, log_prefix, dry_run):  # pragma: no cover
     '''
     Remove the given SQLite3 database dumps from the filesystem. The databases are supplied as a
-    sequence of configuration dicts, as per the configuration schema. Use the given log prefix in
-    any log entries. Use the given location configuration dict to construct the destination path.
-    If this is a dry run, then don't actually remove anything.
+    sequence of configuration dicts, as per the configuration schema. Use the given configuration
+    dict to construct the destination path and the given log prefix in any log entries. If this is a
+    dry run, then don't actually remove anything.
     '''
-    dump.remove_database_dumps(make_dump_path(location_config), 'SQLite', log_prefix, dry_run)
+    dump.remove_database_dumps(make_dump_path(config), 'SQLite', log_prefix, dry_run)
 
 
-def make_database_dump_pattern(
-    databases, log_prefix, location_config, name=None
-):  # pragma: no cover
+def make_database_dump_pattern(databases, config, log_prefix, name=None):  # pragma: no cover
     '''
     Make a pattern that matches the given SQLite3 databases. The databases are supplied as a
     sequence of configuration dicts, as per the configuration schema.
     '''
-    return dump.make_database_dump_filename(make_dump_path(location_config), name)
+    return dump.make_database_dump_filename(make_dump_path(config), name)
 
 
-def restore_database_dump(database_config, log_prefix, location_config, dry_run, extract_process):
-    '''
-    Restore the given SQLite3 database from an extract stream. The database is supplied as a
-    one-element sequence containing a dict describing the database, as per the configuration schema.
-    Use the given log prefix in any log entries. If this is a dry run, then don't actually restore
-    anything. Trigger the given active extract process (an instance of subprocess.Popen) to produce
-    output to consume.
+def restore_database_dump(
+    databases_config, config, log_prefix, database_name, dry_run, extract_process, connection_params
+):
+    '''
+    Restore the given SQLite3 database from an extract stream. The databases are supplied as a
+    sequence containing one dict describing each database (as per the configuration schema), but
+    only the database corresponding to the given database name is restored. Use the given log prefix
+    in any log entries. If this is a dry run, then don't actually restore anything. Trigger the
+    given active extract process (an instance of subprocess.Popen) to produce output to consume.
     '''
     dry_run_label = ' (dry run; not actually restoring anything)' if dry_run else ''
 
-    if len(database_config) != 1:
-        raise ValueError('The database configuration value is invalid')
+    try:
+        database = next(
+            database_config
+            for database_config in databases_config
+            if database_config.get('name') == database_name
+        )
+    except StopIteration:
+        raise ValueError(
+            f'A database named "{database_name}" could not be found in the configuration'
+        )
 
-    database_path = database_config[0]['path']
+    database_path = connection_params['restore_path'] or database.get(
+        'restore_path', database.get('path')
+    )
 
     logger.debug(f'{log_prefix}: Restoring SQLite database at {database_path}{dry_run_label}')
     if dry_run:
         return
 
     try:
         os.remove(database_path)
```

### Comparing `borgmatic-1.7.9/borgmatic/logger.py` & `borgmatic-1.8.0/borgmatic/logger.py`

 * *Files 4% similar despite different names*

```diff
@@ -64,15 +64,15 @@
         super(Multi_stream_handler, self).flush()
 
         for handler in self.handlers:
             handler.flush()
 
     def emit(self, record):
         '''
-        Dispatch the log record to the approriate stream handler for the record's log level.
+        Dispatch the log record to the appropriate stream handler for the record's log level.
         '''
         self.log_level_to_handler[record.levelno].emit(record)
 
     def setFormatter(self, formatter):  # pragma: no cover
         super(Multi_stream_handler, self).setFormatter(formatter)
 
         for handler in self.handlers:
@@ -104,15 +104,15 @@
 def color_text(color, message):
     '''
     Give colored text.
     '''
     if not color:
         return message
 
-    return '{}{}{}'.format(color, message, colorama.Style.RESET_ALL)
+    return f'{color}{message}{colorama.Style.RESET_ALL}'
 
 
 def add_logging_level(level_name, level_number):
     '''
     Globally add a custom logging level based on the given (all uppercase) level name and number.
     Do this idempotently.
 
@@ -137,29 +137,32 @@
         def log_to_root(message, *args, **kwargs):  # pragma: no cover
             logging.log(level_number, message, *args, **kwargs)
 
         setattr(logging, method_name, log_to_root)
 
 
 ANSWER = logging.WARN - 5
+DISABLED = logging.CRITICAL + 10
 
 
 def add_custom_log_levels():  # pragma: no cover
     '''
     Add a custom log level between WARN and INFO for user-requested answers.
     '''
     add_logging_level('ANSWER', ANSWER)
+    add_logging_level('DISABLED', DISABLED)
 
 
 def configure_logging(
     console_log_level,
     syslog_log_level=None,
     log_file_log_level=None,
     monitoring_log_level=None,
     log_file=None,
+    log_file_format=None,
 ):
     '''
     Configure logging to go to both the console and (syslog or log file). Use the given log levels,
     respectively.
 
     Raise FileNotFoundError or PermissionError if the log file could not be opened for writing.
     '''
@@ -170,46 +173,54 @@
     if monitoring_log_level is None:
         monitoring_log_level = console_log_level
 
     add_custom_log_levels()
 
     # Log certain log levels to console stderr and others to stdout. This supports use cases like
     # grepping (non-error) output.
+    console_disabled = logging.NullHandler()
     console_error_handler = logging.StreamHandler(sys.stderr)
     console_standard_handler = logging.StreamHandler(sys.stdout)
     console_handler = Multi_stream_handler(
         {
+            logging.DISABLED: console_disabled,
             logging.CRITICAL: console_error_handler,
             logging.ERROR: console_error_handler,
             logging.WARN: console_error_handler,
             logging.ANSWER: console_standard_handler,
             logging.INFO: console_standard_handler,
             logging.DEBUG: console_standard_handler,
         }
     )
     console_handler.setFormatter(Console_color_formatter())
     console_handler.setLevel(console_log_level)
 
     syslog_path = None
-    if log_file is None:
+    if log_file is None and syslog_log_level != logging.DISABLED:
         if os.path.exists('/dev/log'):
             syslog_path = '/dev/log'
         elif os.path.exists('/var/run/syslog'):
             syslog_path = '/var/run/syslog'
         elif os.path.exists('/var/run/log'):
             syslog_path = '/var/run/log'
 
     if syslog_path and not interactive_console():
         syslog_handler = logging.handlers.SysLogHandler(address=syslog_path)
-        syslog_handler.setFormatter(logging.Formatter('borgmatic: %(levelname)s %(message)s'))
+        syslog_handler.setFormatter(
+            logging.Formatter('borgmatic: {levelname} {message}', style='{')  # noqa: FS003
+        )
         syslog_handler.setLevel(syslog_log_level)
         handlers = (console_handler, syslog_handler)
-    elif log_file:
+    elif log_file and log_file_log_level != logging.DISABLED:
         file_handler = logging.handlers.WatchedFileHandler(log_file)
-        file_handler.setFormatter(logging.Formatter('[%(asctime)s] %(levelname)s: %(message)s'))
+        file_handler.setFormatter(
+            logging.Formatter(
+                log_file_format or '[{asctime}] {levelname}: {message}', style='{'  # noqa: FS003
+            )
+        )
         file_handler.setLevel(log_file_log_level)
         handlers = (console_handler, file_handler)
     else:
         handlers = (console_handler,)
 
     logging.basicConfig(
         level=min(console_log_level, syslog_log_level, log_file_log_level, monitoring_log_level),
```

### Comparing `borgmatic-1.7.9/borgmatic/signals.py` & `borgmatic-1.8.0/borgmatic/signals.py`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/borgmatic/verbosity.py` & `borgmatic-1.8.0/borgmatic/verbosity.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,22 +1,24 @@
 import logging
 
 import borgmatic.logger
 
+VERBOSITY_DISABLED = -2
 VERBOSITY_ERROR = -1
 VERBOSITY_ANSWER = 0
 VERBOSITY_SOME = 1
 VERBOSITY_LOTS = 2
 
 
 def verbosity_to_log_level(verbosity):
     '''
     Given a borgmatic verbosity value, return the corresponding Python log level.
     '''
     borgmatic.logger.add_custom_log_levels()
 
     return {
+        VERBOSITY_DISABLED: logging.DISABLED,
         VERBOSITY_ERROR: logging.ERROR,
         VERBOSITY_ANSWER: logging.ANSWER,
         VERBOSITY_SOME: logging.INFO,
         VERBOSITY_LOTS: logging.DEBUG,
     }.get(verbosity, logging.WARNING)
```

### Comparing `borgmatic-1.7.9/borgmatic.egg-info/PKG-INFO` & `borgmatic-1.8.0/borgmatic.egg-info/PKG-INFO`

 * *Files 24% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: borgmatic
-Version: 1.7.9
+Version: 1.8.0
 Summary: Simple, configuration-driven backup software for servers and workstations
 Home-page: https://torsion.org/borgmatic
 Author: Dan Helfman
 Author-email: witten@torsion.org
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Environment :: Console
 Classifier: Intended Audience :: System Administrators
```

### Comparing `borgmatic-1.7.9/borgmatic.egg-info/SOURCES.txt` & `borgmatic-1.8.0/borgmatic.egg-info/SOURCES.txt`

 * *Files 5% similar despite different names*

```diff
@@ -10,27 +10,30 @@
 README.md
 SECURITY.md
 pyproject.toml
 setup.cfg
 setup.py
 test_requirements.txt
 tox.ini
-.gitea/issue_template.md
+.gitea/issue_template/bug_template.yaml
+.gitea/issue_template/config.yaml
+.gitea/issue_template/feature_template.yaml
 borgmatic/__init__.py
 borgmatic/execute.py
 borgmatic/logger.py
 borgmatic/signals.py
 borgmatic/verbosity.py
 borgmatic.egg-info/PKG-INFO
 borgmatic.egg-info/SOURCES.txt
 borgmatic.egg-info/dependency_links.txt
 borgmatic.egg-info/entry_points.txt
 borgmatic.egg-info/requires.txt
 borgmatic.egg-info/top_level.txt
 borgmatic/actions/__init__.py
+borgmatic/actions/arguments.py
 borgmatic/actions/borg.py
 borgmatic/actions/break_lock.py
 borgmatic/actions/check.py
 borgmatic/actions/compact.py
 borgmatic/actions/create.py
 borgmatic/actions/export_tar.py
 borgmatic/actions/extract.py
@@ -39,14 +42,18 @@
 borgmatic/actions/mount.py
 borgmatic/actions/prune.py
 borgmatic/actions/rcreate.py
 borgmatic/actions/restore.py
 borgmatic/actions/rinfo.py
 borgmatic/actions/rlist.py
 borgmatic/actions/transfer.py
+borgmatic/actions/config/__init__.py
+borgmatic/actions/config/bootstrap.py
+borgmatic/actions/config/generate.py
+borgmatic/actions/config/validate.py
 borgmatic/borg/__init__.py
 borgmatic/borg/borg.py
 borgmatic/borg/break_lock.py
 borgmatic/borg/check.py
 borgmatic/borg/compact.py
 borgmatic/borg/create.py
 borgmatic/borg/environment.py
@@ -64,25 +71,25 @@
 borgmatic/borg/state.py
 borgmatic/borg/transfer.py
 borgmatic/borg/umount.py
 borgmatic/borg/version.py
 borgmatic/commands/__init__.py
 borgmatic/commands/arguments.py
 borgmatic/commands/borgmatic.py
-borgmatic/commands/completion.py
-borgmatic/commands/convert_config.py
 borgmatic/commands/generate_config.py
 borgmatic/commands/validate_config.py
+borgmatic/commands/completion/__init__.py
+borgmatic/commands/completion/actions.py
+borgmatic/commands/completion/bash.py
+borgmatic/commands/completion/fish.py
 borgmatic/config/__init__.py
 borgmatic/config/checks.py
 borgmatic/config/collect.py
-borgmatic/config/convert.py
 borgmatic/config/environment.py
 borgmatic/config/generate.py
-borgmatic/config/legacy.py
 borgmatic/config/load.py
 borgmatic/config/normalize.py
 borgmatic/config/override.py
 borgmatic/config/schema.yaml
 borgmatic/config/validate.py
 borgmatic/hooks/__init__.py
 borgmatic/hooks/command.py
@@ -97,14 +104,16 @@
 borgmatic/hooks/ntfy.py
 borgmatic/hooks/pagerduty.py
 borgmatic/hooks/postgresql.py
 borgmatic/hooks/sqlite.py
 docs/Dockerfile
 docs/README.md
 docs/SECURITY.md
+docs/docker-compose.yaml
+docs/_data/borgmatic.js
 docs/_data/layout.json
 docs/_includes/asciinema.css
 docs/_includes/header.njk
 docs/_includes/index.css
 docs/_includes/prism-theme.css
 docs/_includes/components/external-links.css
 docs/_includes/components/info-blocks.css
@@ -144,55 +153,64 @@
 docs/static/mongodb.png
 docs/static/mysql.png
 docs/static/ntfy.png
 docs/static/pagerduty.png
 docs/static/postgresql.png
 docs/static/sqlite.png
 sample/cron/borgmatic
+sample/systemd/borgmatic-user.service
+sample/systemd/borgmatic-user.timer
 sample/systemd/borgmatic.service
 sample/systemd/borgmatic.timer
 scripts/dev-docs
 scripts/find-unsupported-borg-options
 scripts/push
 scripts/release
-scripts/run-full-dev-tests
+scripts/run-end-to-end-dev-tests
 scripts/run-full-tests
 tests/__init__.py
 tests/end-to-end/__init__.py
 tests/end-to-end/docker-compose.yaml
 tests/end-to-end/test_borgmatic.py
 tests/end-to-end/test_completion.py
 tests/end-to-end/test_database.py
+tests/end-to-end/test_dev_parity_with_build_server.py
 tests/end-to-end/test_generate_config.py
 tests/end-to-end/test_override.py
 tests/end-to-end/test_validate_config.py
 tests/integration/__init__.py
 tests/integration/test_execute.py
+tests/integration/actions/__init__.py
+tests/integration/actions/config/__init__.py
+tests/integration/actions/config/test_validate.py
+tests/integration/borg/test_commands.py
 tests/integration/borg/test_feature.py
 tests/integration/commands/__init__.py
 tests/integration/commands/test_arguments.py
 tests/integration/commands/test_borgmatic.py
-tests/integration/commands/test_completion.py
-tests/integration/commands/test_convert_config.py
 tests/integration/commands/test_generate_config.py
 tests/integration/commands/test_validate_config.py
+tests/integration/commands/completion/__init__.py
+tests/integration/commands/completion/test_actions.py
+tests/integration/commands/completion/test_bash.py
+tests/integration/commands/completion/test_fish.py
 tests/integration/config/__init__.py
 tests/integration/config/test_generate.py
-tests/integration/config/test_legacy.py
 tests/integration/config/test_load.py
 tests/integration/config/test_override.py
 tests/integration/config/test_schema.py
 tests/integration/config/test_validate.py
 tests/integration/hooks/test_healthchecks.py
 tests/unit/__init__.py
 tests/unit/test_execute.py
 tests/unit/test_logger.py
 tests/unit/test_signals.py
 tests/unit/test_verbosity.py
 tests/unit/actions/__init__.py
+tests/unit/actions/test_arguments.py
 tests/unit/actions/test_borg.py
 tests/unit/actions/test_break_lock.py
 tests/unit/actions/test_check.py
 tests/unit/actions/test_compact.py
 tests/unit/actions/test_create.py
 tests/unit/actions/test_export_tar.py
 tests/unit/actions/test_extract.py
@@ -201,14 +219,17 @@
 tests/unit/actions/test_mount.py
 tests/unit/actions/test_prune.py
 tests/unit/actions/test_rcreate.py
 tests/unit/actions/test_restore.py
 tests/unit/actions/test_rinfo.py
 tests/unit/actions/test_rlist.py
 tests/unit/actions/test_transfer.py
+tests/unit/actions/config/test_bootstrap.py
+tests/unit/actions/config/test_generate.py
+tests/unit/actions/config/test_validate.py
 tests/unit/borg/__init__.py
 tests/unit/borg/test_borg.py
 tests/unit/borg/test_break_lock.py
 tests/unit/borg/test_check.py
 tests/unit/borg/test_compact.py
 tests/unit/borg/test_create.py
 tests/unit/borg/test_environment.py
@@ -224,21 +245,23 @@
 tests/unit/borg/test_rlist.py
 tests/unit/borg/test_transfer.py
 tests/unit/borg/test_umount.py
 tests/unit/borg/test_version.py
 tests/unit/commands/__init__.py
 tests/unit/commands/test_arguments.py
 tests/unit/commands/test_borgmatic.py
+tests/unit/commands/completion/__init__.py
+tests/unit/commands/completion/test_actions.py
+tests/unit/commands/completion/test_bash.py
+tests/unit/commands/completion/test_fish.py
 tests/unit/config/__init__.py
 tests/unit/config/test_checks.py
 tests/unit/config/test_collect.py
-tests/unit/config/test_convert.py
 tests/unit/config/test_environment.py
 tests/unit/config/test_generate.py
-tests/unit/config/test_legacy.py
 tests/unit/config/test_normalize.py
 tests/unit/config/test_override.py
 tests/unit/config/test_validate.py
 tests/unit/hooks/__init__.py
 tests/unit/hooks/test_command.py
 tests/unit/hooks/test_cronhub.py
 tests/unit/hooks/test_cronitor.py
```

### Comparing `borgmatic-1.7.9/docs/Dockerfile` & `borgmatic-1.8.0/docs/Dockerfile`

 * *Files 8% similar despite different names*

```diff
@@ -1,33 +1,34 @@
-FROM alpine:3.17.1 as borgmatic
+FROM docker.io/alpine:3.17.1 as borgmatic
 
 COPY . /app
 RUN apk add --no-cache py3-pip py3-ruamel.yaml py3-ruamel.yaml.clib
 RUN pip install --no-cache /app && generate-borgmatic-config && chmod +r /etc/borgmatic/config.yaml
 RUN borgmatic --help > /command-line.txt \
-    && for action in rcreate transfer create prune compact check extract export-tar mount umount restore rlist list rinfo info break-lock borg; do \
+    && for action in rcreate transfer create prune compact check extract config "config bootstrap" "config generate" "config validate" export-tar mount umount restore rlist list rinfo info break-lock borg; do \
            echo -e "\n--------------------------------------------------------------------------------\n" >> /command-line.txt \
-           && borgmatic "$action" --help >> /command-line.txt; done
+           && borgmatic $action --help >> /command-line.txt; done
 
-FROM node:19.5.0-alpine as html
+FROM docker.io/node:19.5.0-alpine as html
 
 ARG ENVIRONMENT=production
 
 WORKDIR /source
 
 RUN npm install @11ty/eleventy \
     @11ty/eleventy-plugin-syntaxhighlight \
     @11ty/eleventy-plugin-inclusive-language \
     @11ty/eleventy-navigation \
+    eleventy-plugin-code-clipboard \
     markdown-it \
     markdown-it-anchor \
     markdown-it-replace-link
 COPY --from=borgmatic /etc/borgmatic/config.yaml /source/docs/_includes/borgmatic/config.yaml
 COPY --from=borgmatic /command-line.txt /source/docs/_includes/borgmatic/command-line.txt
 COPY . /source
 RUN NODE_ENV=${ENVIRONMENT} npx eleventy --input=/source/docs --output=/output/docs \
   && mv /output/docs/index.html /output/index.html
 
-FROM nginx:1.22.1-alpine
+FROM docker.io/nginx:1.22.1-alpine
 
 COPY --from=html /output /usr/share/nginx/html
 COPY --from=borgmatic /etc/borgmatic/config.yaml /usr/share/nginx/html/docs/reference/config.yaml
```

### Comparing `borgmatic-1.7.9/docs/README.md` & `borgmatic-1.8.0/docs/README.md`

 * *Files 5% similar despite different names*

```diff
@@ -7,62 +7,54 @@
 
 <img src="docs/static/borgmatic.png" alt="borgmatic logo" width="150px" style="float: right; padding-left: 1em;">
 
 borgmatic is simple, configuration-driven backup software for servers and
 workstations. Protect your files with client-side encryption. Backup your
 databases too. Monitor it all with integrated third-party services.
 
-The canonical home of borgmatic is at <a href="https://torsion.org/borgmatic">https://torsion.org/borgmatic</a>.
+The canonical home of borgmatic is at <a href="https://torsion.org/borgmatic">https://torsion.org/borgmatic/</a>
 
 Here's an example configuration file:
 
 ```yaml
-location:
-    # List of source directories to backup.
-    source_directories:
-        - /home
-        - /etc
-
-    # Paths of local or remote repositories to backup to.
-    repositories:
-        - ssh://1234@usw-s001.rsync.net/./backups.borg
-        - ssh://k8pDxu32@k8pDxu32.repo.borgbase.com/./repo
-        - /var/lib/backups/local.borg
-
-retention:
-    # Retention policy for how many backups to keep.
-    keep_daily: 7
-    keep_weekly: 4
-    keep_monthly: 6
-
-consistency:
-    # List of checks to run to validate your backups.
-    checks:
-        - name: repository
-        - name: archives
-          frequency: 2 weeks
-
-hooks:
-    # Custom preparation scripts to run.
-    before_backup:
-        - prepare-for-backup.sh
-
-    # Databases to dump and include in backups.
-    postgresql_databases:
-        - name: users
+# List of source directories to backup.
+source_directories:
+    - /home
+    - /etc
+
+# Paths of local or remote repositories to backup to.
+repositories:
+    - path: ssh://k8pDxu32@k8pDxu32.repo.borgbase.com/./repo
+      label: borgbase
+    - path: /var/lib/backups/local.borg
+      label: local
+
+# Retention policy for how many backups to keep.
+keep_daily: 7
+keep_weekly: 4
+keep_monthly: 6
+
+# List of checks to run to validate your backups.
+checks:
+    - name: repository
+    - name: archives
+      frequency: 2 weeks
+
+# Custom preparation scripts to run.
+before_backup:
+    - prepare-for-backup.sh
+
+# Databases to dump and include in backups.
+postgresql_databases:
+    - name: users
 
-    # Third-party services to notify you if backups aren't happening.
-    healthchecks: https://hc-ping.com/be067061-cf96-4412-8eae-62b0c50d6a8c
+# Third-party services to notify you if backups aren't happening.
+healthchecks: https://hc-ping.com/be067061-cf96-4412-8eae-62b0c50d6a8c
 ```
 
-Want to see borgmatic in action? Check out the <a
-href="https://asciinema.org/a/203761?autoplay=1" target="_blank">screencast</a>.
-
-<a href="https://asciinema.org/a/203761?autoplay=1" target="_blank"><img src="https://asciinema.org/a/203761.png" width="480"></a>
-
 borgmatic is powered by [Borg Backup](https://www.borgbackup.org/).
 
 ## Integrations
 
 <a href="https://www.postgresql.org/"><img src="docs/static/postgresql.png" alt="PostgreSQL" height="60px" style="margin-bottom:20px;"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <a href="https://www.mysql.com/"><img src="docs/static/mysql.png" alt="MySQL" height="60px" style="margin-bottom:20px;"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <a href="https://mariadb.com/"><img src="docs/static/mariadb.png" alt="MariaDB" height="60px" style="margin-bottom:20px;"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
@@ -86,24 +78,23 @@
 reference guides</a>.
 
 
 ## Hosting providers
 
 Need somewhere to store your encrypted off-site backups? The following hosting
 providers include specific support for Borg/borgmaticand fund borgmatic
-development and hosting when you use these links to sign up. (These are
-referral links, but without any tracking scripts or cookies.)
+development and hosting when you use these referral links to sign up:
 
 <ul>
  <li class="referral"><a href="https://www.borgbase.com/?utm_source=borgmatic">BorgBase</a>: Borg hosting service with support for monitoring, 2FA, and append-only repos</li>
+ <li class="referral"><a href="https://hetzner.cloud/?ref=v9dOJ98Ic9I8">Hetzner</a>: A "storage box" that includes support for Borg</li>
 </ul>
 
-Additionally, [rsync.net](https://www.rsync.net/products/borg.html) and
-[Hetzner](https://www.hetzner.com/storage/storage-box) have compatible storage
-offerings, but do not currently fund borgmatic development or hosting.
+Additionally, rsync.net has a compatible storage offering, but does not fund
+borgmatic development or hosting.
 
 ## Support and contributing
 
 ### Issues
 
 Are you experiencing an issue with borgmatic? Or do you have an idea for a
 feature enhancement? Head on over to our [issue
@@ -116,18 +107,15 @@
 Also see the [security
 policy](https://torsion.org/borgmatic/docs/security-policy/) for any security
 issues.
 
 
 ### Social
 
-Check out the [Borg subreddit](https://www.reddit.com/r/BorgBackup/) for
-general Borg and borgmatic discussion and support.
-
-Also follow [borgmatic on Mastodon](https://fosstodon.org/@borgmatic).
+Follow [borgmatic on Mastodon](https://fosstodon.org/@borgmatic).
 
 
 ### Chat
 
 To chat with borgmatic developers or users, check out the `#borgmatic`
 IRC channel on Libera Chat, either via <a
 href="https://web.libera.chat/#borgmatic">web chat</a> or a native <a
@@ -160,9 +148,9 @@
 first. We also accept Pull Requests on GitHub, if that's more your thing. In
 general, contributions are very welcome. We don't bite!
 
 Also, please check out the [borgmatic development
 how-to](https://torsion.org/borgmatic/docs/how-to/develop-on-borgmatic/) for
 info on cloning source code, running tests, etc.
 
-<a href="https://build.torsion.org/borgmatic-collective/borgmatic" alt="build status">![Build Status](https://build.torsion.org/api/badges/borgmatic-collective/borgmatic/status.svg?ref=refs/heads/master)</a>
+<a href="https://build.torsion.org/borgmatic-collective/borgmatic" alt="build status">![Build Status](https://build.torsion.org/api/badges/borgmatic-collective/borgmatic/status.svg?ref=refs/heads/main)</a>
```

#### html2text {}

```diff
@@ -1,54 +1,49 @@
 --- title: borgmatic permalink: index.html --- ## It's your data. Keep it that
 way. [borgmatic logo] borgmatic is simple, configuration-driven backup software
 for servers and workstations. Protect your files with client-side encryption.
 Backup your databases too. Monitor it all with integrated third-party services.
-The canonical home of borgmatic is at https://torsion.org/borgmatic. Here's an
-example configuration file: ```yaml location: # List of source directories to
-backup. source_directories: - /home - /etc # Paths of local or remote
-repositories to backup to. repositories: - ssh://1234@usw-s001.rsync.net/./
-backups.borg - ssh://k8pDxu32@k8pDxu32.repo.borgbase.com/./repo - /var/lib/
-backups/local.borg retention: # Retention policy for how many backups to keep.
-keep_daily: 7 keep_weekly: 4 keep_monthly: 6 consistency: # List of checks to
-run to validate your backups. checks: - name: repository - name: archives
-frequency: 2 weeks hooks: # Custom preparation scripts to run. before_backup: -
-prepare-for-backup.sh # Databases to dump and include in backups.
-postgresql_databases: - name: users # Third-party services to notify you if
-backups aren't happening. healthchecks: https://hc-ping.com/be067061-cf96-4412-
-8eae-62b0c50d6a8c ``` Want to see borgmatic in action? Check out the
-screencast. [https://asciinema.org/a/203761.png] borgmatic is powered by [Borg
-Backup](https://www.borgbackup.org/). ## Integrations [PostgreSQL]
-[MySQL] [MariaDB] [MongoDB] [SQLite] [Healthchecks]
-[Cronitor] [Cronhub] [PagerDuty] [ntfy] [BorgBase] ##
-Getting started Your first step is to [install and configure borgmatic](https:/
-/torsion.org/borgmatic/docs/how-to/set-up-backups/). For additional
-documentation, check out the links above (left panel on wide screens) for
-borgmatic_how-to_and_reference_guides. ## Hosting providers Need somewhere to
-store your encrypted off-site backups? The following hosting providers include
-specific support for Borg/borgmaticand fund borgmatic development and
-hosting when you use these links to sign up. (These are referral links, but
-without any tracking scripts or cookies.)
+The canonical home of borgmatic is at https://torsion.org/borgmatic/ Here's an
+example configuration file: ```yaml # List of source directories to backup.
+source_directories: - /home - /etc # Paths of local or remote repositories to
+backup to. repositories: - path: ssh://k8pDxu32@k8pDxu32.repo.borgbase.com/./
+repo label: borgbase - path: /var/lib/backups/local.borg label: local #
+Retention policy for how many backups to keep. keep_daily: 7 keep_weekly: 4
+keep_monthly: 6 # List of checks to run to validate your backups. checks: -
+name: repository - name: archives frequency: 2 weeks # Custom preparation
+scripts to run. before_backup: - prepare-for-backup.sh # Databases to dump and
+include in backups. postgresql_databases: - name: users # Third-party services
+to notify you if backups aren't happening. healthchecks: https://hc-ping.com/
+be067061-cf96-4412-8eae-62b0c50d6a8c ``` borgmatic is powered by [Borg Backup]
+(https://www.borgbackup.org/). ## Integrations [PostgreSQL] [MySQL]
+[MariaDB] [MongoDB] [SQLite] [Healthchecks] [Cronitor]
+[Cronhub] [PagerDuty] [ntfy] [BorgBase] ## Getting started
+Your first step is to [install and configure borgmatic](https://torsion.org/
+borgmatic/docs/how-to/set-up-backups/). For additional documentation, check out
+the links above (left panel on wide screens) for borgmatic_how-to_and_reference
+guides. ## Hosting providers Need somewhere to store your encrypted off-site
+backups? The following hosting providers include specific support for Borg/
+borgmaticand fund borgmatic development and hosting when you use these
+referral links to sign up:
     * BorgBase: Borg hosting service with support for monitoring, 2FA, and
       append-only repos
-Additionally, [rsync.net](https://www.rsync.net/products/borg.html) and
-[Hetzner](https://www.hetzner.com/storage/storage-box) have compatible storage
-offerings, but do not currently fund borgmatic development or hosting. ##
-Support and contributing ### Issues Are you experiencing an issue with
-borgmatic? Or do you have an idea for a feature enhancement? Head on over to
-our [issue tracker](https://projects.torsion.org/borgmatic-collective/
-borgmatic/issues). In order to create a new issue or add a comment, you'll need
-to [register](https://projects.torsion.org/user/sign_up?invite_code=borgmatic)
-first. If you prefer to use an existing GitHub account, you can skip account
-creation and [login directly](https://projects.torsion.org/user/login). Also
-see the [security policy](https://torsion.org/borgmatic/docs/security-policy/
-) for any security issues. ### Social Check out the [Borg subreddit](https://
-www.reddit.com/r/BorgBackup/) for general Borg and borgmatic discussion and
-support. Also follow [borgmatic on Mastodon](https://fosstodon.org/@borgmatic).
-### Chat To chat with borgmatic developers or users, check out the `#borgmatic`
-IRC channel on Libera Chat, either via web_chat or a native IRC_client. If you
+    * Hetzner: A "storage box" that includes support for Borg
+Additionally, rsync.net has a compatible storage offering, but does not fund
+borgmatic development or hosting. ## Support and contributing ### Issues Are
+you experiencing an issue with borgmatic? Or do you have an idea for a feature
+enhancement? Head on over to our [issue tracker](https://projects.torsion.org/
+borgmatic-collective/borgmatic/issues). In order to create a new issue or add a
+comment, you'll need to [register](https://projects.torsion.org/user/
+sign_up?invite_code=borgmatic) first. If you prefer to use an existing GitHub
+account, you can skip account creation and [login directly](https://
+projects.torsion.org/user/login). Also see the [security policy](https://
+torsion.org/borgmatic/docs/security-policy/) for any security issues. ###
+Social Follow [borgmatic on Mastodon](https://fosstodon.org/@borgmatic). ###
+Chat To chat with borgmatic developers or users, check out the `#borgmatic` IRC
+channel on Libera Chat, either via web_chat or a native IRC_client. If you
 don't get a response right away, please hang around a whileor file a ticket
 instead. ### Other Other questions or comments? Contact [witten@torsion.org]
 (mailto:witten@torsion.org). ### Contributing borgmatic [source code is
 available](https://projects.torsion.org/borgmatic-collective/borgmatic) and is
 also mirrored on [GitHub](https://github.com/borgmatic-collective/borgmatic)
 for convenience. borgmatic is licensed under the GNU General Public License
 version 3 or any later version. If you'd like to contribute to borgmatic
@@ -57,8 +52,8 @@
 (https://projects.torsion.org/borgmatic-collective/borgmatic/issues) to discuss
 your idea. Note that you'll need to [register](https://projects.torsion.org/
 user/sign_up?invite_code=borgmatic) first. We also accept Pull Requests on
 GitHub, if that's more your thing. In general, contributions are very welcome.
 We don't bite! Also, please check out the [borgmatic development how-to](https:
 //torsion.org/borgmatic/docs/how-to/develop-on-borgmatic/) for info on cloning
 source code, running tests, etc. ![Build_Status](https://build.torsion.org/api/
-badges/borgmatic-collective/borgmatic/status.svg?ref=refs/heads/master)
+badges/borgmatic-collective/borgmatic/status.svg?ref=refs/heads/main)
```

### Comparing `borgmatic-1.7.9/docs/SECURITY.md` & `borgmatic-1.8.0/SECURITY.md`

 * *Files 14% similar despite different names*

```diff
@@ -2,18 +2,17 @@
 title: Security policy
 permalink: security-policy/index.html
 ---
 
 ## Supported versions
 
 While we want to hear about security vulnerabilities in all versions of
-borgmatic, security fixes will only be made to the most recently released
-version. It's not practical for our small volunteer effort to maintain
-multiple different release branches and put out separate security patches for
-each.
+borgmatic, security fixes are only made to the most recently released version.
+It's not practical for our small volunteer effort to maintain multiple release
+branches and put out separate security patches for each.
 
 ## Reporting a vulnerability
 
 If you find a security vulnerability, please [file a
 ticket](https://torsion.org/borgmatic/#issues) or [send email
 directly](mailto:witten@torsion.org) as appropriate. You should expect to hear
-back within a few days at most, and generally sooner.
+back within a few days at most and generally sooner.
```

### Comparing `borgmatic-1.7.9/docs/_includes/components/info-blocks.css` & `borgmatic-1.8.0/docs/_includes/components/info-blocks.css`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/_includes/components/lists.css` & `borgmatic-1.8.0/docs/_includes/components/lists.css`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/_includes/components/minilink.css` & `borgmatic-1.8.0/docs/_includes/components/minilink.css`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/_includes/components/toc.css` & `borgmatic-1.8.0/docs/_includes/components/toc.css`

 * *Files 1% similar despite different names*

```diff
@@ -90,11 +90,11 @@
 
 /* Show only active nested lists */
 .elv-toc-list ul.elv-toc-active,
 .elv-toc-list li.elv-toc-active > ul {
 	display: block;
 }
 
-/* Footer catgory navigation */
+/* Footer category navigation */
 .elv-cat-list-active {
 	font-weight: 600;
 }
```

### Comparing `borgmatic-1.7.9/docs/_includes/index.css` & `borgmatic-1.8.0/docs/_includes/index.css`

 * *Files 3% similar despite different names*

```diff
@@ -529,7 +529,22 @@
 .header-anchor {
     text-decoration: none;
 }
 
 .header-anchor:hover::after {
     content: " ";
 }
+
+.mdi {
+    display: inline-block;
+    width: 1em;
+    height: 1em;
+    background-color: currentColor;
+    -webkit-mask: no-repeat center / 100%;
+    mask: no-repeat center / 100%;
+    -webkit-mask-image: var(--svg);
+    mask-image: var(--svg);
+}
+
+.mdi.mdi-content-copy {
+    --svg: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='black' d='M19 21H8V7h11m0-2H8a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2m-3-4H4a2 2 0 0 0-2 2v14h2V3h12V1Z'/%3E%3C/svg%3E");
+}
```

### Comparing `borgmatic-1.7.9/docs/_includes/layouts/base.njk` & `borgmatic-1.8.0/docs/_includes/layouts/base.njk`

 * *Files 18% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 <!doctype html>
 <html lang="en"{% if templateClass %} class="{{ templateClass }}"{% endif %}>
 	<head>
 		<meta charset="utf-8">
 		<meta name="viewport" content="width=device-width, initial-scale=1.0">
+		<link rel="icon" href="docs/static/borgmatic.png" type="image/x-icon">
 		<title>{{ subtitle + ' - ' if subtitle}}{{ title }}</title>
 {%- set css %}
 {% include 'index.css' %}
 {% include 'components/lists.css' %}
 {% include 'components/external-links.css' %}
 {% include 'components/minilink.css' %}
 {% include 'components/toc.css' %}
@@ -18,10 +19,10 @@
 {% if feedTitle and feedUrl %}
 		<link rel="alternate" href="{{ feedUrl }}" title="{{ feedTitle }}" type="application/atom+xml">
 {% endif %}
 	</head>
 	<body>
 
 		{{ content | safe }}
-
+		{% initClipboardJS %}
 	</body>
 </html>
```

#### html2text {}

```diff
@@ -1,11 +1,12 @@
 
 % if templateClass %} class="{{ templateClass }}"{% endif %}>
 
+
 {%- set css %} {% include 'index.css' %} {% include 'components/lists.css' %}
 {% include 'components/external-links.css' %} {% include 'components/
 minilink.css' %} {% include 'components/toc.css' %} {% include 'components/
 info-blocks.css' %} {% include 'prism-theme.css' %} {% include 'asciinema.css'
 %} {% endset %}
  {% if feedTitle and feedUrl %}
  {% endif %}
-{{ content | safe }}
+{{ content | safe }} {% initClipboardJS %}
```

### Comparing `borgmatic-1.7.9/docs/_includes/prism-theme.css` & `borgmatic-1.8.0/docs/_includes/prism-theme.css`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/how-to/add-preparation-and-cleanup-steps-to-backups.md` & `borgmatic-1.8.0/docs/how-to/add-preparation-and-cleanup-steps-to-backups.md`

 * *Files 14% similar despite different names*

```diff
@@ -48,236 +48,283 @@
 000002f0: 650a 7275 6e6e 696e 6720 6261 636b 7570  e.running backup
 00000300: 732c 2061 6e64 2073 7065 6369 6679 2060  s, and specify `
 00000310: 6166 7465 725f 6261 636b 7570 6020 686f  after_backup` ho
 00000320: 6f6b 7320 746f 2070 6572 666f 726d 2063  oks to perform c
 00000330: 6c65 616e 7570 2073 7465 7073 0a61 6674  leanup steps.aft
 00000340: 6572 7761 7264 732e 2048 6572 6527 7320  erwards. Here's 
 00000350: 616e 2065 7861 6d70 6c65 3a0a 0a60 6060  an example:..```
-00000360: 7961 6d6c 0a68 6f6f 6b73 3a0a 2020 2020  yaml.hooks:.    
-00000370: 6265 666f 7265 5f62 6163 6b75 703a 0a20  before_backup:. 
-00000380: 2020 2020 2020 202d 206d 6f75 6e74 202f         - mount /
-00000390: 736f 6d65 2f66 696c 6573 7973 7465 6d0a  some/filesystem.
-000003a0: 2020 2020 6166 7465 725f 6261 636b 7570      after_backup
-000003b0: 3a0a 2020 2020 2020 2020 2d20 756d 6f75  :.        - umou
-000003c0: 6e74 202f 736f 6d65 2f66 696c 6573 7973  nt /some/filesys
-000003d0: 7465 6d0a 6060 600a 0a3c 7370 616e 2063  tem.```..<span c
-000003e0: 6c61 7373 3d22 6d69 6e69 6c69 6e6b 206d  lass="minilink m
-000003f0: 696e 696c 696e 6b2d 6164 6465 6469 6e22  inilink-addedin"
-00000400: 3e4e 6577 2069 6e20 7665 7273 696f 6e20  >New in version 
-00000410: 312e 362e 303c 2f73 7061 6e3e 2054 6865  1.6.0</span> The
-00000420: 0a60 6265 666f 7265 5f62 6163 6b75 7060  .`before_backup`
-00000430: 2061 6e64 2060 6166 7465 725f 6261 636b   and `after_back
-00000440: 7570 6020 686f 6f6b 7320 6561 6368 2072  up` hooks each r
-00000450: 756e 206f 6e63 6520 7065 7220 7265 706f  un once per repo
-00000460: 7369 746f 7279 2069 6e20 610a 636f 6e66  sitory in a.conf
-00000470: 6967 7572 6174 696f 6e20 6669 6c65 2e20  iguration file. 
-00000480: 6062 6566 6f72 655f 6261 636b 7570 6020  `before_backup` 
-00000490: 686f 6f6b 7320 7275 6e73 2072 6967 6874  hooks runs right
-000004a0: 2062 6566 6f72 6520 7468 6520 6063 7265   before the `cre
-000004b0: 6174 6560 0a61 6374 696f 6e20 666f 7220  ate`.action for 
-000004c0: 6120 7061 7274 6963 756c 6172 2072 6570  a particular rep
-000004d0: 6f73 6974 6f72 792c 2061 6e64 2060 6166  ository, and `af
-000004e0: 7465 725f 6261 636b 7570 6020 686f 6f6b  ter_backup` hook
-000004f0: 7320 7275 6e20 6166 7465 7277 6172 6473  s run afterwards
-00000500: 2c0a 6275 7420 6e6f 7420 6966 2061 6e20  ,.but not if an 
-00000510: 6572 726f 7220 6f63 6375 7273 2069 6e20  error occurs in 
-00000520: 6120 7072 6576 696f 7573 2068 6f6f 6b20  a previous hook 
-00000530: 6f72 2069 6e20 7468 6520 6261 636b 7570  or in the backup
-00000540: 7320 7468 656d 7365 6c76 6573 2e0a 2850  s themselves..(P
-00000550: 7269 6f72 2074 6f20 626f 7267 6d61 7469  rior to borgmati
-00000560: 6320 312e 362e 302c 2074 6865 7365 2068  c 1.6.0, these h
-00000570: 6f6f 6b73 2069 6e73 7465 6164 2072 616e  ooks instead ran
-00000580: 206f 6e63 6520 7065 7220 636f 6e66 6967   once per config
-00000590: 7572 6174 696f 6e20 6669 6c65 0a72 6174  uration file.rat
-000005a0: 6865 7220 7468 616e 206f 6e63 6520 7065  her than once pe
-000005b0: 7220 7265 706f 7369 746f 7279 2e29 0a0a  r repository.)..
-000005c0: 5468 6572 6520 6172 6520 6164 6469 7469  There are additi
-000005d0: 6f6e 616c 2068 6f6f 6b73 2074 6861 7420  onal hooks that 
-000005e0: 7275 6e20 6265 666f 7265 2f61 6674 6572  run before/after
-000005f0: 206f 7468 6572 2061 6374 696f 6e73 2061   other actions a
-00000600: 7320 7765 6c6c 2e20 466f 720a 696e 7374  s well. For.inst
-00000610: 616e 6365 2c20 6062 6566 6f72 655f 7072  ance, `before_pr
-00000620: 756e 6560 2072 756e 7320 6265 666f 7265  une` runs before
-00000630: 2061 2060 7072 756e 6560 2061 6374 696f   a `prune` actio
-00000640: 6e20 666f 7220 6120 7265 706f 7369 746f  n for a reposito
-00000650: 7279 2c20 7768 696c 650a 6061 6674 6572  ry, while.`after
-00000660: 5f70 7275 6e65 6020 7275 6e73 2061 6674  _prune` runs aft
-00000670: 6572 2069 742e 0a0a 3c73 7061 6e20 636c  er it...<span cl
-00000680: 6173 733d 226d 696e 696c 696e 6b20 6d69  ass="minilink mi
-00000690: 6e69 6c69 6e6b 2d61 6464 6564 696e 223e  nilink-addedin">
-000006a0: 4e65 7720 696e 2076 6572 7369 6f6e 2031  New in version 1
-000006b0: 2e37 2e30 3c2f 7370 616e 3e20 5468 650a  .7.0</span> The.
-000006c0: 6062 6566 6f72 655f 6163 7469 6f6e 7360  `before_actions`
-000006d0: 2061 6e64 2060 6166 7465 725f 6163 7469   and `after_acti
-000006e0: 6f6e 7360 2068 6f6f 6b73 2072 756e 2062  ons` hooks run b
-000006f0: 6566 6f72 652f 6166 7465 7220 616c 6c20  efore/after all 
-00000700: 7468 6520 6163 7469 6f6e 730a 286c 696b  the actions.(lik
-00000710: 6520 6063 7265 6174 6560 2c20 6070 7275  e `create`, `pru
-00000720: 6e65 602c 2065 7463 2e29 2066 6f72 2065  ne`, etc.) for e
-00000730: 6163 6820 7265 706f 7369 746f 7279 2e20  ach repository. 
-00000740: 5468 6573 6520 686f 6f6b 7320 6172 6520  These hooks are 
-00000750: 6120 676f 6f64 0a70 6c61 6365 2074 6f20  a good.place to 
-00000760: 7275 6e20 7065 722d 7265 706f 7369 746f  run per-reposito
-00000770: 7279 2073 7465 7073 206c 696b 6520 6d6f  ry steps like mo
-00000780: 756e 7469 6e67 2f75 6e6d 6f75 6e74 696e  unting/unmountin
-00000790: 6720 6120 7265 6d6f 7465 0a66 696c 6573  g a remote.files
-000007a0: 7973 7465 6d2e 0a0a 0a23 2320 5661 7269  ystem....## Vari
-000007b0: 6162 6c65 2069 6e74 6572 706f 6c61 7469  able interpolati
-000007c0: 6f6e 0a0a 5468 6520 6265 666f 7265 2061  on..The before a
-000007d0: 6e64 2061 6674 6572 2061 6374 696f 6e20  nd after action 
-000007e0: 686f 6f6b 7320 7375 7070 6f72 7420 696e  hooks support in
-000007f0: 7465 7270 6f6c 6174 696e 6720 7061 7274  terpolating part
-00000800: 6963 756c 6172 2072 756e 7469 6d65 0a76  icular runtime.v
-00000810: 6172 6961 626c 6573 2069 6e74 6f20 7468  ariables into th
-00000820: 6520 686f 6f6b 2063 6f6d 6d61 6e64 2e20  e hook command. 
-00000830: 4865 7265 2773 2061 6e20 6578 616d 706c  Here's an exampl
-00000840: 6520 7468 6174 2061 7373 756d 6573 2079  e that assumes y
-00000850: 6f75 2070 726f 7669 6465 2061 0a73 6570  ou provide a.sep
-00000860: 6172 6174 6520 7368 656c 6c20 7363 7269  arate shell scri
-00000870: 7074 3a0a 0a60 6060 7961 6d6c 0a68 6f6f  pt:..```yaml.hoo
-00000880: 6b73 3a0a 2020 2020 6166 7465 725f 7072  ks:.    after_pr
-00000890: 756e 653a 0a20 2020 2020 2020 202d 2072  une:.        - r
-000008a0: 6563 6f72 642d 7072 756e 652e 7368 2022  ecord-prune.sh "
-000008b0: 7b63 6f6e 6669 6775 7261 7469 6f6e 5f66  {configuration_f
-000008c0: 696c 656e 616d 657d 2220 227b 7265 706f  ilename}" "{repo
-000008d0: 7369 746f 7279 7d22 0a60 6060 0a0a 496e  sitory}".```..In
-000008e0: 2074 6869 7320 6578 616d 706c 652c 2077   this example, w
-000008f0: 6865 6e20 7468 6520 686f 6f6b 2069 7320  hen the hook is 
-00000900: 7472 6967 6765 7265 642c 2062 6f72 676d  triggered, borgm
-00000910: 6174 6963 2069 6e74 6572 706f 6c61 7465  atic interpolate
-00000920: 7320 7275 6e74 696d 650a 7661 6c75 6573  s runtime.values
-00000930: 2069 6e74 6f20 7468 6520 686f 6f6b 2063   into the hook c
-00000940: 6f6d 6d61 6e64 3a20 7468 6520 626f 7267  ommand: the borg
-00000950: 6d61 7469 6320 636f 6e66 6967 7572 6174  matic configurat
-00000960: 696f 6e20 6669 6c65 6e61 6d65 2061 6e64  ion filename and
-00000970: 2074 6865 0a70 6174 6873 206f 6620 7468   the.paths of th
-00000980: 6520 6375 7272 656e 7420 426f 7267 2072  e current Borg r
-00000990: 6570 6f73 6974 6f72 792e 2048 6572 6527  epository. Here'
-000009a0: 7320 7468 6520 6675 6c6c 2073 6574 206f  s the full set o
-000009b0: 6620 7375 7070 6f72 7465 640a 7661 7269  f supported.vari
-000009c0: 6162 6c65 7320 796f 7520 6361 6e20 7573  ables you can us
-000009d0: 6520 6865 7265 3a0a 0a20 2a20 6063 6f6e  e here:.. * `con
-000009e0: 6669 6775 7261 7469 6f6e 5f66 696c 656e  figuration_filen
-000009f0: 616d 6560 3a20 626f 7267 6d61 7469 6320  ame`: borgmatic 
-00000a00: 636f 6e66 6967 7572 6174 696f 6e20 6669  configuration fi
-00000a10: 6c65 6e61 6d65 2069 6e20 7768 6963 6820  lename in which 
-00000a20: 7468 650a 2020 2068 6f6f 6b20 7761 7320  the.   hook was 
-00000a30: 6465 6669 6e65 640a 202a 2060 7265 706f  defined. * `repo
-00000a40: 7369 746f 7279 603a 2070 6174 6820 6f66  sitory`: path of
-00000a50: 2074 6865 2063 7572 7265 6e74 2072 6570   the current rep
-00000a60: 6f73 6974 6f72 7920 6173 2063 6f6e 6669  ository as confi
-00000a70: 6775 7265 6420 696e 2074 6865 2063 7572  gured in the cur
-00000a80: 7265 6e74 0a20 2020 626f 7267 6d61 7469  rent.   borgmati
-00000a90: 6320 636f 6e66 6967 7572 6174 696f 6e20  c configuration 
-00000aa0: 6669 6c65 0a0a 4e6f 7465 2074 6861 7420  file..Note that 
-00000ab0: 796f 7520 6361 6e20 616c 736f 2069 6e74  you can also int
-00000ac0: 6572 706f 6c61 7465 2069 6e20 5b61 7262  erpolate in [arb
-00000ad0: 6974 7261 7279 2065 6e76 6972 6f6e 6d65  itrary environme
-00000ae0: 6e74 0a76 6172 6961 626c 6573 5d28 6874  nt.variables](ht
-00000af0: 7470 733a 2f2f 746f 7273 696f 6e2e 6f72  tps://torsion.or
-00000b00: 672f 626f 7267 6d61 7469 632f 646f 6373  g/borgmatic/docs
-00000b10: 2f68 6f77 2d74 6f2f 7072 6f76 6964 652d  /how-to/provide-
-00000b20: 796f 7572 2d70 6173 7377 6f72 6473 2f29  your-passwords/)
-00000b30: 2e0a 0a0a 2323 2047 6c6f 6261 6c20 686f  ....## Global ho
-00000b40: 6f6b 730a 0a59 6f75 2063 616e 2061 6c73  oks..You can als
-00000b50: 6f20 7573 6520 6062 6566 6f72 655f 6576  o use `before_ev
-00000b60: 6572 7974 6869 6e67 6020 616e 6420 6061  erything` and `a
-00000b70: 6674 6572 5f65 7665 7279 7468 696e 6760  fter_everything`
-00000b80: 2068 6f6f 6b73 2074 6f20 7065 7266 6f72   hooks to perfor
-00000b90: 6d0a 676c 6f62 616c 2073 6574 7570 206f  m.global setup o
-00000ba0: 7220 636c 6561 6e75 703a 0a0a 6060 6079  r cleanup:..```y
-00000bb0: 616d 6c0a 686f 6f6b 733a 0a20 2020 2062  aml.hooks:.    b
-00000bc0: 6566 6f72 655f 6576 6572 7974 6869 6e67  efore_everything
-00000bd0: 3a0a 2020 2020 2020 2020 2d20 7365 742d  :.        - set-
-00000be0: 7570 2d73 7475 6666 2d67 6c6f 6261 6c6c  up-stuff-globall
-00000bf0: 790a 2020 2020 6166 7465 725f 6576 6572  y.    after_ever
-00000c00: 7974 6869 6e67 3a0a 2020 2020 2020 2020  ything:.        
-00000c10: 2d20 636c 6561 6e2d 7570 2d73 7475 6666  - clean-up-stuff
-00000c20: 2d67 6c6f 6261 6c6c 790a 6060 600a 0a60  -globally.```..`
-00000c30: 6265 666f 7265 5f65 7665 7279 7468 696e  before_everythin
-00000c40: 6760 2068 6f6f 6b73 2063 6f6c 6c65 6374  g` hooks collect
-00000c50: 6564 2066 726f 6d20 616c 6c20 626f 7267  ed from all borg
-00000c60: 6d61 7469 6320 636f 6e66 6967 7572 6174  matic configurat
-00000c70: 696f 6e20 6669 6c65 7320 7275 6e0a 6f6e  ion files run.on
-00000c80: 6365 2062 6566 6f72 6520 616c 6c20 636f  ce before all co
-00000c90: 6e66 6967 7572 6174 696f 6e20 6669 6c65  nfiguration file
-00000ca0: 7320 2870 7269 6f72 2074 6f20 616c 6c20  s (prior to all 
-00000cb0: 6163 7469 6f6e 7329 2c20 6275 7420 6f6e  actions), but on
-00000cc0: 6c79 2069 6620 7468 6572 650a 6973 2061  ly if there.is a
-00000cd0: 2060 6372 6561 7465 6020 6163 7469 6f6e   `create` action
-00000ce0: 2e20 416e 2065 7272 6f72 2065 6e63 6f75  . An error encou
-00000cf0: 6e74 6572 6564 2064 7572 696e 6720 6120  ntered during a 
-00000d00: 6062 6566 6f72 655f 6576 6572 7974 6869  `before_everythi
-00000d10: 6e67 6020 686f 6f6b 0a63 6175 7365 7320  ng` hook.causes 
-00000d20: 626f 7267 6d61 7469 6320 746f 2065 7869  borgmatic to exi
-00000d30: 7420 7769 7468 6f75 7420 6372 6561 7469  t without creati
-00000d40: 6e67 2062 6163 6b75 7073 2e0a 0a60 6166  ng backups...`af
-00000d50: 7465 725f 6576 6572 7974 6869 6e67 6020  ter_everything` 
-00000d60: 686f 6f6b 7320 7275 6e20 6f6e 6365 2061  hooks run once a
-00000d70: 6674 6572 2061 6c6c 2063 6f6e 6669 6775  fter all configu
-00000d80: 7261 7469 6f6e 2066 696c 6573 2061 6e64  ration files and
-00000d90: 2061 6374 696f 6e73 2c0a 6275 7420 6f6e   actions,.but on
-00000da0: 6c79 2069 6620 7468 6572 6520 6973 2061  ly if there is a
-00000db0: 2060 6372 6561 7465 6020 6163 7469 6f6e   `create` action
-00000dc0: 2e20 4974 2072 756e 7320 6576 656e 2069  . It runs even i
-00000dd0: 6620 616e 2065 7272 6f72 206f 6363 7572  f an error occur
-00000de0: 7320 6475 7269 6e67 0a61 2062 6163 6b75  s during.a backu
-00000df0: 7020 6f72 2061 2062 6163 6b75 7020 686f  p or a backup ho
-00000e00: 6f6b 2c20 6275 7420 6e6f 7420 6966 2061  ok, but not if a
-00000e10: 6e20 6572 726f 7220 6f63 6375 7273 2064  n error occurs d
-00000e20: 7572 696e 6720 610a 6062 6566 6f72 655f  uring a.`before_
-00000e30: 6576 6572 7974 6869 6e67 6020 686f 6f6b  everything` hook
-00000e40: 2e0a 0a23 2320 4572 726f 7220 686f 6f6b  ...## Error hook
-00000e50: 730a 0a62 6f72 676d 6174 6963 2061 6c73  s..borgmatic als
-00000e60: 6f20 7275 6e73 2060 6f6e 5f65 7272 6f72  o runs `on_error
-00000e70: 6020 686f 6f6b 7320 6966 2061 6e20 6572  ` hooks if an er
-00000e80: 726f 7220 6f63 6375 7273 2c20 6569 7468  ror occurs, eith
-00000e90: 6572 2077 6865 6e20 6372 6561 7469 6e67  er when creating
-00000ea0: 0a61 2062 6163 6b75 7020 6f72 2072 756e  .a backup or run
-00000eb0: 6e69 6e67 2061 2062 6163 6b75 7020 686f  ning a backup ho
-00000ec0: 6f6b 2e20 5365 6520 7468 6520 5b6d 6f6e  ok. See the [mon
-00000ed0: 6974 6f72 696e 6720 616e 6420 616c 6572  itoring and aler
-00000ee0: 7469 6e67 0a64 6f63 756d 656e 7461 7469  ting.documentati
-00000ef0: 6f6e 5d28 6874 7470 733a 2f2f 746f 7273  on](https://tors
-00000f00: 696f 6e2e 6f72 672f 626f 7267 6d61 7469  ion.org/borgmati
-00000f10: 632f 646f 6373 2f68 6f77 2d74 6f2f 6d6f  c/docs/how-to/mo
-00000f20: 6e69 746f 722d 796f 7572 2d62 6163 6b75  nitor-your-backu
-00000f30: 7073 2f29 0a66 6f72 206d 6f72 6520 696e  ps/).for more in
-00000f40: 666f 726d 6174 696f 6e2e 0a0a 2323 2048  formation...## H
-00000f50: 6f6f 6b20 6f75 7470 7574 0a0a 416e 7920  ook output..Any 
-00000f60: 6f75 7470 7574 2070 726f 6475 6365 6420  output produced 
-00000f70: 6279 2079 6f75 7220 686f 6f6b 7320 7368  by your hooks sh
-00000f80: 6f77 7320 7570 2062 6f74 6820 6174 2074  ows up both at t
-00000f90: 6865 2063 6f6e 736f 6c65 2061 6e64 2069  he console and i
-00000fa0: 6e20 7379 736c 6f67 0a28 7768 656e 2072  n syslog.(when r
-00000fb0: 756e 2069 6e20 6120 6e6f 6e2d 696e 7465  un in a non-inte
-00000fc0: 7261 6374 6976 6520 636f 6e73 6f6c 6529  ractive console)
-00000fd0: 2e20 466f 7220 6d6f 7265 2069 6e66 6f72  . For more infor
-00000fe0: 6d61 7469 6f6e 2c20 7265 6164 2061 626f  mation, read abo
-00000ff0: 7574 203c 610a 6872 6566 3d22 6874 7470  ut <a.href="http
-00001000: 733a 2f2f 746f 7273 696f 6e2e 6f72 672f  s://torsion.org/
-00001010: 626f 7267 6d61 7469 632f 646f 6373 2f68  borgmatic/docs/h
-00001020: 6f77 2d74 6f2f 696e 7370 6563 742d 796f  ow-to/inspect-yo
-00001030: 7572 2d62 6163 6b75 7073 2f22 3e69 6e73  ur-backups/">ins
-00001040: 7065 6374 696e 670a 796f 7572 2062 6163  pecting.your bac
-00001050: 6b75 7073 3c2f 613e 2e0a 0a23 2320 5365  kups</a>...## Se
-00001060: 6375 7269 7479 0a0a 416e 2069 6d70 6f72  curity..An impor
-00001070: 7461 6e74 2073 6563 7572 6974 7920 6e6f  tant security no
-00001080: 7465 2061 626f 7574 2068 6f6f 6b73 3a20  te about hooks: 
-00001090: 626f 7267 6d61 7469 6320 6578 6563 7574  borgmatic execut
-000010a0: 6573 2061 6c6c 2068 6f6f 6b20 636f 6d6d  es all hook comm
-000010b0: 616e 6473 0a77 6974 6820 7468 6520 7573  ands.with the us
-000010c0: 6572 2070 6572 6d69 7373 696f 6e73 206f  er permissions o
-000010d0: 6620 626f 7267 6d61 7469 6320 6974 7365  f borgmatic itse
-000010e0: 6c66 2e20 536f 2074 6f20 7072 6576 656e  lf. So to preven
-000010f0: 7420 706f 7465 6e74 6961 6c20 7368 656c  t potential shel
-00001100: 6c0a 696e 6a65 6374 696f 6e20 6f72 2070  l.injection or p
-00001110: 7269 7669 6c65 6765 2065 7363 616c 6174  rivilege escalat
-00001120: 696f 6e2c 2064 6f20 6e6f 7420 666f 7267  ion, do not forg
-00001130: 6574 2074 6f20 7365 7420 7365 6375 7265  et to set secure
-00001140: 2070 6572 6d69 7373 696f 6e73 0a6f 6e20   permissions.on 
-00001150: 626f 7267 6d61 7469 6320 636f 6e66 6967  borgmatic config
-00001160: 7572 6174 696f 6e20 6669 6c65 7320 2860  uration files (`
-00001170: 6368 6d6f 6420 3036 3030 6029 2061 6e64  chmod 0600`) and
-00001180: 2073 6372 6970 7473 2028 6063 686d 6f64   scripts (`chmod
-00001190: 2030 3730 3060 290a 696e 766f 6b65 6420   0700`).invoked 
-000011a0: 6279 2068 6f6f 6b73 2e0a                 by hooks..
+00000360: 7961 6d6c 0a62 6566 6f72 655f 6261 636b  yaml.before_back
+00000370: 7570 3a0a 2020 2020 2d20 6d6f 756e 7420  up:.    - mount 
+00000380: 2f73 6f6d 652f 6669 6c65 7379 7374 656d  /some/filesystem
+00000390: 0a61 6674 6572 5f62 6163 6b75 703a 0a20  .after_backup:. 
+000003a0: 2020 202d 2075 6d6f 756e 7420 2f73 6f6d     - umount /som
+000003b0: 652f 6669 6c65 7379 7374 656d 0a60 6060  e/filesystem.```
+000003c0: 0a0a 4966 2079 6f75 7220 636f 6d6d 616e  ..If your comman
+000003d0: 6420 636f 6e74 6169 6e73 2061 2073 7065  d contains a spe
+000003e0: 6369 616c 2059 414d 4c20 6368 6172 6163  cial YAML charac
+000003f0: 7465 7220 7375 6368 2061 7320 6120 636f  ter such as a co
+00000400: 6c6f 6e2c 2079 6f75 206d 6179 0a6e 6565  lon, you may.nee
+00000410: 6420 746f 2071 756f 7465 2074 6865 2065  d to quote the e
+00000420: 6e74 6972 6520 7374 7269 6e67 2028 6f72  ntire string (or
+00000430: 2075 7365 2061 205b 6d75 6c74 696c 696e   use a [multilin
+00000440: 650a 7374 7269 6e67 5d28 6874 7470 733a  e.string](https:
+00000450: 2f2f 7961 6d6c 2d6d 756c 7469 6c69 6e65  //yaml-multiline
+00000460: 2e69 6e66 6f2f 2929 2074 6f20 6176 6f69  .info/)) to avoi
+00000470: 6420 616e 2065 7272 6f72 3a0a 0a60 6060  d an error:..```
+00000480: 7961 6d6c 0a62 6566 6f72 655f 6261 636b  yaml.before_back
+00000490: 7570 3a0a 2020 2020 2d20 2265 6368 6f20  up:.    - "echo 
+000004a0: 4261 636b 7570 3a20 7374 6172 7422 0a60  Backup: start".`
+000004b0: 6060 0a0a 5468 6572 6520 6172 6520 6164  ``..There are ad
+000004c0: 6469 7469 6f6e 616c 2068 6f6f 6b73 2074  ditional hooks t
+000004d0: 6861 7420 7275 6e20 6265 666f 7265 2f61  hat run before/a
+000004e0: 6674 6572 206f 7468 6572 2061 6374 696f  fter other actio
+000004f0: 6e73 2061 7320 7765 6c6c 2e20 466f 720a  ns as well. For.
+00000500: 696e 7374 616e 6365 2c20 6062 6566 6f72  instance, `befor
+00000510: 655f 7072 756e 6560 2072 756e 7320 6265  e_prune` runs be
+00000520: 666f 7265 2061 2060 7072 756e 6560 2061  fore a `prune` a
+00000530: 6374 696f 6e20 666f 7220 6120 7265 706f  ction for a repo
+00000540: 7369 746f 7279 2c20 7768 696c 650a 6061  sitory, while.`a
+00000550: 6674 6572 5f70 7275 6e65 6020 7275 6e73  fter_prune` runs
+00000560: 2061 6674 6572 2069 742e 0a0a 3c73 7061   after it...<spa
+00000570: 6e20 636c 6173 733d 226d 696e 696c 696e  n class="minilin
+00000580: 6b20 6d69 6e69 6c69 6e6b 2d61 6464 6564  k minilink-added
+00000590: 696e 223e 5072 696f 7220 746f 2076 6572  in">Prior to ver
+000005a0: 7369 6f6e 2031 2e38 2e30 3c2f 7370 616e  sion 1.8.0</span
+000005b0: 3e20 5075 740a 7468 6573 6520 6f70 7469  > Put.these opti
+000005c0: 6f6e 7320 696e 2074 6865 2060 686f 6f6b  ons in the `hook
+000005d0: 733a 6020 7365 6374 696f 6e20 6f66 2079  s:` section of y
+000005e0: 6f75 7220 636f 6e66 6967 7572 6174 696f  our configuratio
+000005f0: 6e2e 0a0a 3c73 7061 6e20 636c 6173 733d  n...<span class=
+00000600: 226d 696e 696c 696e 6b20 6d69 6e69 6c69  "minilink minili
+00000610: 6e6b 2d61 6464 6564 696e 223e 4e65 7720  nk-addedin">New 
+00000620: 696e 2076 6572 7369 6f6e 2031 2e37 2e30  in version 1.7.0
+00000630: 3c2f 7370 616e 3e20 5468 650a 6062 6566  </span> The.`bef
+00000640: 6f72 655f 6163 7469 6f6e 7360 2061 6e64  ore_actions` and
+00000650: 2060 6166 7465 725f 6163 7469 6f6e 7360   `after_actions`
+00000660: 2068 6f6f 6b73 2072 756e 2062 6566 6f72   hooks run befor
+00000670: 652f 6166 7465 7220 616c 6c20 7468 6520  e/after all the 
+00000680: 6163 7469 6f6e 730a 286c 696b 6520 6063  actions.(like `c
+00000690: 7265 6174 6560 2c20 6070 7275 6e65 602c  reate`, `prune`,
+000006a0: 2065 7463 2e29 2066 6f72 2065 6163 6820   etc.) for each 
+000006b0: 7265 706f 7369 746f 7279 2e20 5468 6573  repository. Thes
+000006c0: 6520 686f 6f6b 7320 6172 6520 6120 676f  e hooks are a go
+000006d0: 6f64 0a70 6c61 6365 2074 6f20 7275 6e20  od.place to run 
+000006e0: 7065 722d 7265 706f 7369 746f 7279 2073  per-repository s
+000006f0: 7465 7073 206c 696b 6520 6d6f 756e 7469  teps like mounti
+00000700: 6e67 2f75 6e6d 6f75 6e74 696e 6720 6120  ng/unmounting a 
+00000710: 7265 6d6f 7465 0a66 696c 6573 7973 7465  remote.filesyste
+00000720: 6d2e 0a0a 3c73 7061 6e20 636c 6173 733d  m...<span class=
+00000730: 226d 696e 696c 696e 6b20 6d69 6e69 6c69  "minilink minili
+00000740: 6e6b 2d61 6464 6564 696e 223e 4e65 7720  nk-addedin">New 
+00000750: 696e 2076 6572 7369 6f6e 2031 2e36 2e30  in version 1.6.0
+00000760: 3c2f 7370 616e 3e20 5468 650a 6062 6566  </span> The.`bef
+00000770: 6f72 655f 6261 636b 7570 6020 616e 6420  ore_backup` and 
+00000780: 6061 6674 6572 5f62 6163 6b75 7060 2068  `after_backup` h
+00000790: 6f6f 6b73 2065 6163 6820 7275 6e20 6f6e  ooks each run on
+000007a0: 6365 2070 6572 2072 6570 6f73 6974 6f72  ce per repositor
+000007b0: 7920 696e 2061 0a63 6f6e 6669 6775 7261  y in a.configura
+000007c0: 7469 6f6e 2066 696c 652e 2060 6265 666f  tion file. `befo
+000007d0: 7265 5f62 6163 6b75 7060 2068 6f6f 6b73  re_backup` hooks
+000007e0: 2072 756e 7320 7269 6768 7420 6265 666f   runs right befo
+000007f0: 7265 2074 6865 2060 6372 6561 7465 600a  re the `create`.
+00000800: 6163 7469 6f6e 2066 6f72 2061 2070 6172  action for a par
+00000810: 7469 6375 6c61 7220 7265 706f 7369 746f  ticular reposito
+00000820: 7279 2c20 616e 6420 6061 6674 6572 5f62  ry, and `after_b
+00000830: 6163 6b75 7060 2068 6f6f 6b73 2072 756e  ackup` hooks run
+00000840: 2061 6674 6572 7761 7264 732c 0a62 7574   afterwards,.but
+00000850: 206e 6f74 2069 6620 616e 2065 7272 6f72   not if an error
+00000860: 206f 6363 7572 7320 696e 2061 2070 7265   occurs in a pre
+00000870: 7669 6f75 7320 686f 6f6b 206f 7220 696e  vious hook or in
+00000880: 2074 6865 2062 6163 6b75 7073 2074 6865   the backups the
+00000890: 6d73 656c 7665 732e 0a28 5072 696f 7220  mselves..(Prior 
+000008a0: 746f 2062 6f72 676d 6174 6963 2031 2e36  to borgmatic 1.6
+000008b0: 2e30 2c20 7468 6573 6520 686f 6f6b 7320  .0, these hooks 
+000008c0: 696e 7374 6561 6420 7261 6e20 6f6e 6365  instead ran once
+000008d0: 2070 6572 2063 6f6e 6669 6775 7261 7469   per configurati
+000008e0: 6f6e 2066 696c 650a 7261 7468 6572 2074  on file.rather t
+000008f0: 6861 6e20 6f6e 6365 2070 6572 2072 6570  han once per rep
+00000900: 6f73 6974 6f72 792e 290a 0a0a 2323 2056  ository.)...## V
+00000910: 6172 6961 626c 6520 696e 7465 7270 6f6c  ariable interpol
+00000920: 6174 696f 6e0a 0a54 6865 2062 6566 6f72  ation..The befor
+00000930: 6520 616e 6420 6166 7465 7220 6163 7469  e and after acti
+00000940: 6f6e 2068 6f6f 6b73 2073 7570 706f 7274  on hooks support
+00000950: 2069 6e74 6572 706f 6c61 7469 6e67 2070   interpolating p
+00000960: 6172 7469 6375 6c61 7220 7275 6e74 696d  articular runtim
+00000970: 650a 7661 7269 6162 6c65 7320 696e 746f  e.variables into
+00000980: 2074 6865 2068 6f6f 6b20 636f 6d6d 616e   the hook comman
+00000990: 642e 2048 6572 6527 7320 616e 2065 7861  d. Here's an exa
+000009a0: 6d70 6c65 2074 6861 7420 6173 7375 6d65  mple that assume
+000009b0: 7320 796f 7520 7072 6f76 6964 6520 610a  s you provide a.
+000009c0: 7365 7061 7261 7465 2073 6865 6c6c 2073  separate shell s
+000009d0: 6372 6970 743a 0a0a 6060 6079 616d 6c0a  cript:..```yaml.
+000009e0: 6166 7465 725f 7072 756e 653a 0a20 2020  after_prune:.   
+000009f0: 202d 2072 6563 6f72 642d 7072 756e 652e   - record-prune.
+00000a00: 7368 2022 7b63 6f6e 6669 6775 7261 7469  sh "{configurati
+00000a10: 6f6e 5f66 696c 656e 616d 657d 2220 227b  on_filename}" "{
+00000a20: 7265 706f 7369 746f 7279 7d22 0a60 6060  repository}".```
+00000a30: 0a0a 3c73 7061 6e20 636c 6173 733d 226d  ..<span class="m
+00000a40: 696e 696c 696e 6b20 6d69 6e69 6c69 6e6b  inilink minilink
+00000a50: 2d61 6464 6564 696e 223e 5072 696f 7220  -addedin">Prior 
+00000a60: 746f 2076 6572 7369 6f6e 2031 2e38 2e30  to version 1.8.0
+00000a70: 3c2f 7370 616e 3e20 5075 740a 7468 6973  </span> Put.this
+00000a80: 206f 7074 696f 6e20 696e 2074 6865 2060   option in the `
+00000a90: 686f 6f6b 733a 6020 7365 6374 696f 6e20  hooks:` section 
+00000aa0: 6f66 2079 6f75 7220 636f 6e66 6967 7572  of your configur
+00000ab0: 6174 696f 6e2e 0a0a 496e 2074 6869 7320  ation...In this 
+00000ac0: 6578 616d 706c 652c 2077 6865 6e20 7468  example, when th
+00000ad0: 6520 686f 6f6b 2069 7320 7472 6967 6765  e hook is trigge
+00000ae0: 7265 642c 2062 6f72 676d 6174 6963 2069  red, borgmatic i
+00000af0: 6e74 6572 706f 6c61 7465 7320 7275 6e74  nterpolates runt
+00000b00: 696d 650a 7661 6c75 6573 2069 6e74 6f20  ime.values into 
+00000b10: 7468 6520 686f 6f6b 2063 6f6d 6d61 6e64  the hook command
+00000b20: 3a20 7468 6520 626f 7267 6d61 7469 6320  : the borgmatic 
+00000b30: 636f 6e66 6967 7572 6174 696f 6e20 6669  configuration fi
+00000b40: 6c65 6e61 6d65 2061 6e64 2074 6865 0a70  lename and the.p
+00000b50: 6174 6873 206f 6620 7468 6520 6375 7272  aths of the curr
+00000b60: 656e 7420 426f 7267 2072 6570 6f73 6974  ent Borg reposit
+00000b70: 6f72 792e 2048 6572 6527 7320 7468 6520  ory. Here's the 
+00000b80: 6675 6c6c 2073 6574 206f 6620 7375 7070  full set of supp
+00000b90: 6f72 7465 640a 7661 7269 6162 6c65 7320  orted.variables 
+00000ba0: 796f 7520 6361 6e20 7573 6520 6865 7265  you can use here
+00000bb0: 3a0a 0a20 2a20 6063 6f6e 6669 6775 7261  :.. * `configura
+00000bc0: 7469 6f6e 5f66 696c 656e 616d 6560 3a20  tion_filename`: 
+00000bd0: 626f 7267 6d61 7469 6320 636f 6e66 6967  borgmatic config
+00000be0: 7572 6174 696f 6e20 6669 6c65 6e61 6d65  uration filename
+00000bf0: 2069 6e20 7768 6963 6820 7468 650a 2020   in which the.  
+00000c00: 2068 6f6f 6b20 7761 7320 6465 6669 6e65   hook was define
+00000c10: 640a 202a 2060 6c6f 675f 6669 6c65 600a  d. * `log_file`.
+00000c20: 2020 203c 7370 616e 2063 6c61 7373 3d22     <span class="
+00000c30: 6d69 6e69 6c69 6e6b 206d 696e 696c 696e  minilink minilin
+00000c40: 6b2d 6164 6465 6469 6e22 3e4e 6577 2069  k-addedin">New i
+00000c50: 6e20 7665 7273 696f 6e20 312e 372e 3132  n version 1.7.12
+00000c60: 3c2f 7370 616e 3e3a 0a20 2020 7061 7468  </span>:.   path
+00000c70: 206f 6620 7468 6520 626f 7267 6d61 7469   of the borgmati
+00000c80: 6320 6c6f 6720 6669 6c65 2c20 6f6e 6c79  c log file, only
+00000c90: 2073 6574 2077 6865 6e20 7468 6520 602d   set when the `-
+00000ca0: 2d6c 6f67 2d66 696c 6560 2066 6c61 6720  -log-file` flag 
+00000cb0: 6973 2075 7365 640a 202a 2060 7265 706f  is used. * `repo
+00000cc0: 7369 746f 7279 603a 2070 6174 6820 6f66  sitory`: path of
+00000cd0: 2074 6865 2063 7572 7265 6e74 2072 6570   the current rep
+00000ce0: 6f73 6974 6f72 7920 6173 2063 6f6e 6669  ository as confi
+00000cf0: 6775 7265 6420 696e 2074 6865 2063 7572  gured in the cur
+00000d00: 7265 6e74 0a20 2020 626f 7267 6d61 7469  rent.   borgmati
+00000d10: 6320 636f 6e66 6967 7572 6174 696f 6e20  c configuration 
+00000d20: 6669 6c65 0a0a 4e6f 7465 2074 6861 7420  file..Note that 
+00000d30: 796f 7520 6361 6e20 616c 736f 2069 6e74  you can also int
+00000d40: 6572 706f 6c61 7465 2069 6e20 5b61 7262  erpolate in [arb
+00000d50: 6974 7261 7279 2065 6e76 6972 6f6e 6d65  itrary environme
+00000d60: 6e74 0a76 6172 6961 626c 6573 5d28 6874  nt.variables](ht
+00000d70: 7470 733a 2f2f 746f 7273 696f 6e2e 6f72  tps://torsion.or
+00000d80: 672f 626f 7267 6d61 7469 632f 646f 6373  g/borgmatic/docs
+00000d90: 2f68 6f77 2d74 6f2f 7072 6f76 6964 652d  /how-to/provide-
+00000da0: 796f 7572 2d70 6173 7377 6f72 6473 2f29  your-passwords/)
+00000db0: 2e0a 0a0a 2323 2047 6c6f 6261 6c20 686f  ....## Global ho
+00000dc0: 6f6b 730a 0a59 6f75 2063 616e 2061 6c73  oks..You can als
+00000dd0: 6f20 7573 6520 6062 6566 6f72 655f 6576  o use `before_ev
+00000de0: 6572 7974 6869 6e67 6020 616e 6420 6061  erything` and `a
+00000df0: 6674 6572 5f65 7665 7279 7468 696e 6760  fter_everything`
+00000e00: 2068 6f6f 6b73 2074 6f20 7065 7266 6f72   hooks to perfor
+00000e10: 6d0a 676c 6f62 616c 2073 6574 7570 206f  m.global setup o
+00000e20: 7220 636c 6561 6e75 703a 0a0a 6060 6079  r cleanup:..```y
+00000e30: 616d 6c0a 6265 666f 7265 5f65 7665 7279  aml.before_every
+00000e40: 7468 696e 673a 0a20 2020 202d 2073 6574  thing:.    - set
+00000e50: 2d75 702d 7374 7566 662d 676c 6f62 616c  -up-stuff-global
+00000e60: 6c79 0a61 6674 6572 5f65 7665 7279 7468  ly.after_everyth
+00000e70: 696e 673a 0a20 2020 202d 2063 6c65 616e  ing:.    - clean
+00000e80: 2d75 702d 7374 7566 662d 676c 6f62 616c  -up-stuff-global
+00000e90: 6c79 0a60 6060 0a0a 3c73 7061 6e20 636c  ly.```..<span cl
+00000ea0: 6173 733d 226d 696e 696c 696e 6b20 6d69  ass="minilink mi
+00000eb0: 6e69 6c69 6e6b 2d61 6464 6564 696e 223e  nilink-addedin">
+00000ec0: 5072 696f 7220 746f 2076 6572 7369 6f6e  Prior to version
+00000ed0: 2031 2e38 2e30 3c2f 7370 616e 3e20 5075   1.8.0</span> Pu
+00000ee0: 740a 7468 6573 6520 6f70 7469 6f6e 7320  t.these options 
+00000ef0: 696e 2074 6865 2060 686f 6f6b 733a 6020  in the `hooks:` 
+00000f00: 7365 6374 696f 6e20 6f66 2079 6f75 7220  section of your 
+00000f10: 636f 6e66 6967 7572 6174 696f 6e2e 0a0a  configuration...
+00000f20: 6062 6566 6f72 655f 6576 6572 7974 6869  `before_everythi
+00000f30: 6e67 6020 686f 6f6b 7320 636f 6c6c 6563  ng` hooks collec
+00000f40: 7465 6420 6672 6f6d 2061 6c6c 2062 6f72  ted from all bor
+00000f50: 676d 6174 6963 2063 6f6e 6669 6775 7261  gmatic configura
+00000f60: 7469 6f6e 2066 696c 6573 2072 756e 0a6f  tion files run.o
+00000f70: 6e63 6520 6265 666f 7265 2061 6c6c 2063  nce before all c
+00000f80: 6f6e 6669 6775 7261 7469 6f6e 2066 696c  onfiguration fil
+00000f90: 6573 2028 7072 696f 7220 746f 2061 6c6c  es (prior to all
+00000fa0: 2061 6374 696f 6e73 292c 2062 7574 206f   actions), but o
+00000fb0: 6e6c 7920 6966 2074 6865 7265 0a69 7320  nly if there.is 
+00000fc0: 6120 6063 7265 6174 6560 2061 6374 696f  a `create` actio
+00000fd0: 6e2e 2041 6e20 6572 726f 7220 656e 636f  n. An error enco
+00000fe0: 756e 7465 7265 6420 6475 7269 6e67 2061  untered during a
+00000ff0: 2060 6265 666f 7265 5f65 7665 7279 7468   `before_everyth
+00001000: 696e 6760 2068 6f6f 6b0a 6361 7573 6573  ing` hook.causes
+00001010: 2062 6f72 676d 6174 6963 2074 6f20 6578   borgmatic to ex
+00001020: 6974 2077 6974 686f 7574 2063 7265 6174  it without creat
+00001030: 696e 6720 6261 636b 7570 732e 0a0a 6061  ing backups...`a
+00001040: 6674 6572 5f65 7665 7279 7468 696e 6760  fter_everything`
+00001050: 2068 6f6f 6b73 2072 756e 206f 6e63 6520   hooks run once 
+00001060: 6166 7465 7220 616c 6c20 636f 6e66 6967  after all config
+00001070: 7572 6174 696f 6e20 6669 6c65 7320 616e  uration files an
+00001080: 6420 6163 7469 6f6e 732c 0a62 7574 206f  d actions,.but o
+00001090: 6e6c 7920 6966 2074 6865 7265 2069 7320  nly if there is 
+000010a0: 6120 6063 7265 6174 6560 2061 6374 696f  a `create` actio
+000010b0: 6e2e 2049 7420 7275 6e73 2065 7665 6e20  n. It runs even 
+000010c0: 6966 2061 6e20 6572 726f 7220 6f63 6375  if an error occu
+000010d0: 7273 2064 7572 696e 670a 6120 6261 636b  rs during.a back
+000010e0: 7570 206f 7220 6120 6261 636b 7570 2068  up or a backup h
+000010f0: 6f6f 6b2c 2062 7574 206e 6f74 2069 6620  ook, but not if 
+00001100: 616e 2065 7272 6f72 206f 6363 7572 7320  an error occurs 
+00001110: 6475 7269 6e67 2061 0a60 6265 666f 7265  during a.`before
+00001120: 5f65 7665 7279 7468 696e 6760 2068 6f6f  _everything` hoo
+00001130: 6b2e 0a0a 0a23 2320 4572 726f 7220 686f  k....## Error ho
+00001140: 6f6b 730a 0a62 6f72 676d 6174 6963 2061  oks..borgmatic a
+00001150: 6c73 6f20 7275 6e73 2060 6f6e 5f65 7272  lso runs `on_err
+00001160: 6f72 6020 686f 6f6b 7320 6966 2061 6e20  or` hooks if an 
+00001170: 6572 726f 7220 6f63 6375 7273 2c20 6569  error occurs, ei
+00001180: 7468 6572 2077 6865 6e20 6372 6561 7469  ther when creati
+00001190: 6e67 0a61 2062 6163 6b75 7020 6f72 2072  ng.a backup or r
+000011a0: 756e 6e69 6e67 2061 2062 6163 6b75 7020  unning a backup 
+000011b0: 686f 6f6b 2e20 5365 6520 7468 6520 5b6d  hook. See the [m
+000011c0: 6f6e 6974 6f72 696e 6720 616e 6420 616c  onitoring and al
+000011d0: 6572 7469 6e67 0a64 6f63 756d 656e 7461  erting.documenta
+000011e0: 7469 6f6e 5d28 6874 7470 733a 2f2f 746f  tion](https://to
+000011f0: 7273 696f 6e2e 6f72 672f 626f 7267 6d61  rsion.org/borgma
+00001200: 7469 632f 646f 6373 2f68 6f77 2d74 6f2f  tic/docs/how-to/
+00001210: 6d6f 6e69 746f 722d 796f 7572 2d62 6163  monitor-your-bac
+00001220: 6b75 7073 2f29 0a66 6f72 206d 6f72 6520  kups/).for more 
+00001230: 696e 666f 726d 6174 696f 6e2e 0a0a 0a23  information....#
+00001240: 2320 486f 6f6b 206f 7574 7075 740a 0a41  # Hook output..A
+00001250: 6e79 206f 7574 7075 7420 7072 6f64 7563  ny output produc
+00001260: 6564 2062 7920 796f 7572 2068 6f6f 6b73  ed by your hooks
+00001270: 2073 686f 7773 2075 7020 626f 7468 2061   shows up both a
+00001280: 7420 7468 6520 636f 6e73 6f6c 6520 616e  t the console an
+00001290: 6420 696e 2073 7973 6c6f 670a 2877 6865  d in syslog.(whe
+000012a0: 6e20 7275 6e20 696e 2061 206e 6f6e 2d69  n run in a non-i
+000012b0: 6e74 6572 6163 7469 7665 2063 6f6e 736f  nteractive conso
+000012c0: 6c65 292e 2046 6f72 206d 6f72 6520 696e  le). For more in
+000012d0: 666f 726d 6174 696f 6e2c 2072 6561 6420  formation, read 
+000012e0: 6162 6f75 7420 3c61 0a68 7265 663d 2268  about <a.href="h
+000012f0: 7474 7073 3a2f 2f74 6f72 7369 6f6e 2e6f  ttps://torsion.o
+00001300: 7267 2f62 6f72 676d 6174 6963 2f64 6f63  rg/borgmatic/doc
+00001310: 732f 686f 772d 746f 2f69 6e73 7065 6374  s/how-to/inspect
+00001320: 2d79 6f75 722d 6261 636b 7570 732f 223e  -your-backups/">
+00001330: 696e 7370 6563 7469 6e67 0a79 6f75 7220  inspecting.your 
+00001340: 6261 636b 7570 733c 2f61 3e2e 0a0a 0a23  backups</a>....#
+00001350: 2320 5365 6375 7269 7479 0a0a 416e 2069  # Security..An i
+00001360: 6d70 6f72 7461 6e74 2073 6563 7572 6974  mportant securit
+00001370: 7920 6e6f 7465 2061 626f 7574 2068 6f6f  y note about hoo
+00001380: 6b73 3a20 626f 7267 6d61 7469 6320 6578  ks: borgmatic ex
+00001390: 6563 7574 6573 2061 6c6c 2068 6f6f 6b20  ecutes all hook 
+000013a0: 636f 6d6d 616e 6473 0a77 6974 6820 7468  commands.with th
+000013b0: 6520 7573 6572 2070 6572 6d69 7373 696f  e user permissio
+000013c0: 6e73 206f 6620 626f 7267 6d61 7469 6320  ns of borgmatic 
+000013d0: 6974 7365 6c66 2e20 536f 2074 6f20 7072  itself. So to pr
+000013e0: 6576 656e 7420 706f 7465 6e74 6961 6c20  event potential 
+000013f0: 7368 656c 6c0a 696e 6a65 6374 696f 6e20  shell.injection 
+00001400: 6f72 2070 7269 7669 6c65 6765 2065 7363  or privilege esc
+00001410: 616c 6174 696f 6e2c 2064 6f20 6e6f 7420  alation, do not 
+00001420: 666f 7267 6574 2074 6f20 7365 7420 7365  forget to set se
+00001430: 6375 7265 2070 6572 6d69 7373 696f 6e73  cure permissions
+00001440: 0a6f 6e20 626f 7267 6d61 7469 6320 636f  .on borgmatic co
+00001450: 6e66 6967 7572 6174 696f 6e20 6669 6c65  nfiguration file
+00001460: 7320 2860 6368 6d6f 6420 3036 3030 6029  s (`chmod 0600`)
+00001470: 2061 6e64 2073 6372 6970 7473 2028 6063   and scripts (`c
+00001480: 686d 6f64 2030 3730 3060 290a 696e 766f  hmod 0700`).invo
+00001490: 6b65 6420 6279 2068 6f6f 6b73 2e0a       ked by hooks..
```

### Comparing `borgmatic-1.7.9/docs/how-to/backup-to-a-removable-drive-or-an-intermittent-server.md` & `borgmatic-1.8.0/docs/how-to/backup-to-a-removable-drive-or-an-intermittent-server.md`

 * *Files 19% similar despite different names*

```diff
@@ -40,62 +40,66 @@
 
 So for instance, if you have an external drive that's only sometimes mounted,
 declare its repository in its own [separate configuration
 file](https://torsion.org/borgmatic/docs/how-to/make-per-application-backups/),
 say at `/etc/borgmatic.d/removable.yaml`:
 
 ```yaml
-location:
-    source_directories:
-        - /home
+source_directories:
+    - /home
 
-    repositories:
-        - /mnt/removable/backup.borg
+repositories:
+    - path: /mnt/removable/backup.borg
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+these options in the `location:` section of your configuration.
+
+<span class="minilink minilink-addedin">Prior to version 1.7.10</span> Omit
+the `path:` portion of the `repositories` list.
+
 Then, write a `before_backup` hook in that same configuration file that uses
 the external `findmnt` utility to see whether the drive is mounted before
 proceeding.
 
 ```yaml
-hooks:
-    before_backup:
-      - findmnt /mnt/removable > /dev/null || exit 75
+before_backup:
+    - findmnt /mnt/removable > /dev/null || exit 75
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put this
+option in the `hooks:` section of your configuration.
+
 What this does is check if the `findmnt` command errors when probing for a
 particular mount point. If it does error, then it returns exit code 75 to
 borgmatic. borgmatic logs the soft failure, skips all further actions in that
 configurable file, and proceeds onward to any other borgmatic configuration
 files you may have.
 
 Note that `before_backup` only runs on the `create` action. See below about
 optionally using `before_actions` instead.
 
 You can imagine a similar check for the sometimes-online server case:
 
 ```yaml
-location:
-    source_directories:
-        - /home
-
-    repositories:
-        - ssh://me@buddys-server.org/./backup.borg
-
-hooks:
-    before_backup:
-      - ping -q -c 1 buddys-server.org > /dev/null || exit 75
+source_directories:
+    - /home
+
+repositories:
+    - path: ssh://me@buddys-server.org/./backup.borg
+
+before_backup:
+    - ping -q -c 1 buddys-server.org > /dev/null || exit 75
 ```
 
 Or to only run backups if the battery level is high enough:
 
 ```yaml
-hooks:
-    before_backup:
-      - is_battery_percent_at_least.sh 25
+before_backup:
+    - is_battery_percent_at_least.sh 25
 ```
 
 (Writing the battery script is left as an exercise to the reader.)
 
 <span class="minilink minilink-addedin">New in version 1.7.0</span> The
 `before_actions` and `after_actions` hooks run before/after all the actions
 (like `create`, `prune`, etc.) for each repository. So if you'd like your soft
@@ -106,16 +110,16 @@
 ## Caveats and details
 
 There are some caveats you should be aware of with this feature.
 
  * You'll generally want to put a soft failure command in the `before_backup`
    hook, so as to gate whether the backup action occurs. While a soft failure is
    also supported in the `after_backup` hook, returning a soft failure there
-   won't prevent any actions from occuring, because they've already occurred!
-   Similiarly, you can return a soft failure from an `on_error` hook, but at
+   won't prevent any actions from occurring, because they've already occurred!
+   Similarly, you can return a soft failure from an `on_error` hook, but at
    that point it's too late to prevent the error.
  * Returning a soft failure does prevent further commands in the same hook from
    executing. So, like a standard error, it is an "early out". Unlike a standard
    error, borgmatic does not display it in angry red text or consider it a
    failure.
  * The soft failure only applies to the scope of a single borgmatic
    configuration file. So put anything that you don't want soft-failed, like
```

### Comparing `borgmatic-1.7.9/docs/how-to/backup-your-databases.md` & `borgmatic-1.8.0/docs/how-to/backup-your-databases.md`

 * *Files 10% similar despite different names*

```diff
@@ -14,151 +14,201 @@
 consistent snapshot that is more suited for backups.
 
 Fortunately, borgmatic includes built-in support for creating database dumps
 prior to running backups. For example, here is everything you need to dump and
 backup a couple of local PostgreSQL databases and a MySQL/MariaDB database.
 
 ```yaml
-hooks:
-    postgresql_databases:
-        - name: users
-        - name: orders
-    mysql_databases:
-        - name: posts
+postgresql_databases:
+    - name: users
+    - name: orders
+mysql_databases:
+    - name: posts
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+these and other database options in the `hooks:` section of your
+configuration.
+
 <span class="minilink minilink-addedin">New in version 1.5.22</span> You can
 also dump MongoDB databases. For example:
 
 ```yaml
-hooks:
-    mongodb_databases:
-        - name: messages
+mongodb_databases:
+    - name: messages
 ```
 
 <span class="minilink minilink-addedin">New in version 1.7.9</span>
 Additionally, you can dump SQLite databases. For example:
 
 ```yaml
-hooks:
-    sqlite_databases:
-        - name: mydb
-          path: /var/lib/sqlite3/mydb.sqlite
+sqlite_databases:
+    - name: mydb
+      path: /var/lib/sqlite3/mydb.sqlite
 ```
 
 As part of each backup, borgmatic streams a database dump for each configured
 database directly to Borg, so it's included in the backup without consuming
 additional disk space. (The exceptions are the PostgreSQL/MongoDB "directory"
 dump formats, which can't stream and therefore do consume temporary disk
 space. Additionally, prior to borgmatic 1.5.3, all database dumps consumed
 temporary disk space.)
 
 To support this, borgmatic creates temporary named pipes in `~/.borgmatic` by
 default. To customize this path, set the `borgmatic_source_directory` option
-in the `location` section of borgmatic's configuration.
+in borgmatic's configuration.
 
 Also note that using a database hook implicitly enables both the
 `read_special` and `one_file_system` configuration settings (even if they're
 disabled in your configuration) to support this dump and restore streaming.
 See Limitations below for more on this.
 
 Here's a more involved example that connects to remote databases:
 
 ```yaml
-hooks:
-    postgresql_databases:
-        - name: users
-          hostname: database1.example.org
-        - name: orders
-          hostname: database2.example.org
-          port: 5433
-          username: postgres
-          password: trustsome1
-          format: tar
-          options: "--role=someone"
-    mysql_databases:
-        - name: posts
-          hostname: database3.example.org
-          port: 3307
-          username: root
-          password: trustsome1
-          options: "--skip-comments"
-    mongodb_databases:
-        - name: messages
-          hostname: database4.example.org
-          port: 27018
-          username: dbuser
-          password: trustsome1
-          authentication_database: mongousers
-          options: "--ssl"
-    sqlite_databases:
-        - name: mydb
-          path: /var/lib/sqlite3/mydb.sqlite
+postgresql_databases:
+    - name: users
+      hostname: database1.example.org
+    - name: orders
+      hostname: database2.example.org
+      port: 5433
+      username: postgres
+      password: trustsome1
+      format: tar
+      options: "--role=someone"
+mysql_databases:
+    - name: posts
+      hostname: database3.example.org
+      port: 3307
+      username: root
+      password: trustsome1
+      options: "--skip-comments"
+mongodb_databases:
+    - name: messages
+      hostname: database4.example.org
+      port: 27018
+      username: dbuser
+      password: trustsome1
+      authentication_database: mongousers
+      options: "--ssl"
+sqlite_databases:
+    - name: mydb
+      path: /var/lib/sqlite3/mydb.sqlite
 ```
 
 See your [borgmatic configuration
 file](https://torsion.org/borgmatic/docs/reference/configuration/) for
 additional customization of the options passed to database commands (when
 listing databases, restoring databases, etc.).
 
 
 ### All databases
 
 If you want to dump all databases on a host, use `all` for the database name:
 
 ```yaml
-hooks:
-    postgresql_databases:
-        - name: all
-    mysql_databases:
-        - name: all
-    mongodb_databases:
-        - name: all
+postgresql_databases:
+    - name: all
+mysql_databases:
+    - name: all
+mongodb_databases:
+    - name: all
 ```
 
 Note that you may need to use a `username` of the `postgres` superuser for
 this to work with PostgreSQL.
 
 The SQLite hook in particular does not consider "all" a special database name.
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+these options in the `hooks:` section of your configuration.
+
 <span class="minilink minilink-addedin">New in version 1.7.6</span> With
 PostgreSQL and MySQL, you can optionally dump "all" databases to separate
 files instead of one combined dump file, allowing more convenient restores of
 individual databases. Enable this by specifying your desired database dump
 `format`:
 
 ```yaml
+postgresql_databases:
+    - name: all
+      format: custom
+mysql_databases:
+    - name: all
+      format: sql
+```
+
+### Containers
+
+If your database is running within a container and borgmatic is too, no
+problemconfigure borgmatic to connect to the container's name on its exposed
+port. For instance:
+
+```yaml
+postgresql_databases:
+    - name: users
+      hostname: your-database-container-name
+      port: 5433
+      username: postgres
+      password: trustsome1
+```
+
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+these options in the `hooks:` section of your configuration.
+
+But what if borgmatic is running on the host? You can still connect to a
+database container if its ports are properly exposed to the host. For
+instance, when running the database container, you can specify `--publish
+127.0.0.1:5433:5432` so that it exposes the container's port 5432 to port 5433
+on the host (only reachable on localhost, in this case). Or the same thing
+with Docker Compose:
+
+```yaml
+services:
+   your-database-container-name:
+       image: postgres
+       ports:
+           - 127.0.0.1:5433:5432
+```
+
+And then you can connect to the database from borgmatic running on the host:
+
+```yaml
 hooks:
     postgresql_databases:
-        - name: all
-          format: custom
-    mysql_databases:
-        - name: all
-          format: sql
+        - name: users
+          hostname: 127.0.0.1
+          port: 5433
+          username: postgres
+          password: trustsome1
 ```
 
+Alter the ports in these examples to suit your particular database system.
+
+
 ### No source directories
 
 <span class="minilink minilink-addedin">New in version 1.7.1</span> If you
 would like to backup databases only and not source directories, you can omit
 `source_directories` entirely.
 
-In older versions of borgmatic, instead specify an empty `source_directories`
-value, as it is a mandatory option prior to version 1.7.1:
+<span class="minilink minilink-addedin">Prior to version 1.7.1</span> In older
+versions of borgmatic, instead specify an empty `source_directories` value, as
+it is a mandatory option there:
 
 ```yaml
 location:
     source_directories: []
+
 hooks:
     mysql_databases:
         - name: all
 ```
 
 
-
 ### External passwords
 
 If you don't want to keep your database passwords in your borgmatic
 configuration file, you can instead pass them in via [environment
 variables](https://torsion.org/borgmatic/docs/how-to/provide-your-passwords/)
 or command-line [configuration
 overrides](https://torsion.org/borgmatic/docs/how-to/make-per-application-backups/#configuration-overrides).
@@ -227,28 +277,29 @@
 
 ### Repository selection
 
 If you have a single repository in your borgmatic configuration file(s), no
 problem: the `restore` action figures out which repository to use.
 
 But if you have multiple repositories configured, then you'll need to specify
-the repository path containing the archive to restore. Here's an example:
+the repository to use via the `--repository` flag. This can be done either
+with the repository's path or its label as configured in your borgmatic configuration file.
 
 ```bash
 borgmatic restore --repository repo.borg --archive host-2023-...
 ```
 
 ### Restore particular databases
 
 If you've backed up multiple databases into an archive, and you'd only like to
 restore one of them, use the `--database` flag to select one or more
 databases. For instance:
 
 ```bash
-borgmatic restore --archive host-2023-... --database users
+borgmatic restore --archive host-2023-... --database users --database orders
 ```
 
 <span class="minilink minilink-addedin">New in version 1.7.6</span> You can
 also restore individual databases even if you dumped them as "all"as long as
 you dumped them into separate files via use of the "format" option. See above
 for more information.
 
@@ -273,38 +324,51 @@
 
 <span class="minilink minilink-addedin">New in version 1.7.6</span> Restoring
 "all" databases restores each database found in the selected archive. That
 includes any combined dump file named "all" and any other individual database
 dumps found in the archive.
 
 
+### Restore particular schemas
+
+<span class="minilink minilink-addedin">New in version 1.7.13</span> With
+PostgreSQL and MongoDB, you can limit the restore to a single schema found
+within the database dump:
+
+```bash
+borgmatic restore --archive latest --database users --schema tentant1
+```
+
+
 ### Limitations
 
 There are a few important limitations with borgmatic's current database
 restoration feature that you should know about:
 
 1. You must restore as the same Unix user that created the archive containing
 the database dump. That's because the user's home directory path is encoded
 into the path of the database dump within the archive.
 2. As mentioned above, borgmatic can only restore a database that's defined in
 borgmatic's own configuration file. So include your configuration file in
 backups to avoid getting caught without a way to restore a database.
 3. borgmatic does not currently support backing up or restoring multiple
 databases that share the exact same name on different hosts.
-4. Because database hooks implicitly enable the `read_special` configuration
-setting to support dump and restore streaming, you'll need to ensure that any
-special files are excluded from backups (named pipes, block devices,
-character devices, and sockets) to prevent hanging. Try a command like
-`find /your/source/path -type b -or -type c -or -type p -or -type s` to find
-such files. Common directories to exclude are `/dev` and `/run`, but that may
-not be exhaustive. <span class="minilink minilink-addedin">New in version
+4. Because database hooks implicitly enable the `read_special` configuration,
+any special files are excluded from backups (named pipes, block devices,
+character devices, and sockets) to prevent hanging. Try a command like `find
+/your/source/path -type b -or -type c -or -type p -or -type s` to find such
+files. Common directories to exclude are `/dev` and `/run`, but that may not
+be exhaustive. <span class="minilink minilink-addedin">New in version
 1.7.3</span> When database hooks are enabled, borgmatic automatically excludes
-special files that may cause Borg to hang, so you no longer need to manually
-exclude them. (This includes symlinks with special files as a destination.) You
-can override/prevent this behavior by explicitly setting `read_special` to true.
+special files (and symlinks to special files) that may cause Borg to hang, so
+generally you no longer need to manually exclude them. There are potential
+edge cases though in which applications on your system create new special files
+*after* borgmatic constructs its exclude list, resulting in Borg hangs. If that
+occurs, you can resort to the manual excludes described above. And to opt out
+of the auto-exclude feature entirely, explicitly set `read_special` to true.
 
 
 ### Manual restoration
 
 If you prefer to restore a database without the help of borgmatic, first
 [extract](https://torsion.org/borgmatic/docs/how-to/extract-a-backup/) an
 archive containing a database dump.
@@ -330,27 +394,49 @@
 These hooks allows you to trigger arbitrary commands or scripts before and
 after backups. So if necessary, you can use these hooks to create database
 dumps with any database system.
 
 
 ## Troubleshooting
 
+### PostgreSQL/MySQL authentication errors
+
+With PostgreSQL and MySQL/MariaDB, if you're getting authentication errors
+when borgmatic tries to connect to your database, a natural reaction is to
+increase your borgmatic verbosity with `--verbosity 2` and go looking in the
+logs. You'll notice though that your database password does not show up in the
+logs. This is likely not the cause of the authentication problem unless you
+mistyped your password, however; borgmatic passes your password to the
+database via an environment variable that does not appear in the logs.
+
+The cause of an authentication error is often on the database sidein the
+configuration of which users are allowed to connect and how they are
+authenticated. For instance, with PostgreSQL, check your
+[pg_hba.conf](https://www.postgresql.org/docs/current/auth-pg-hba-conf.html)
+file for that configuration.
+
+Additionally, MySQL/MariaDB may be picking up some of your credentials from a
+defaults file like `~/.my.cnf`. If that's the case, then it's possible
+MySQL/MariaDB ends up using, say, a username from borgmatic's configuration
+and a password from `~/.my.cnf`. This may result in authentication errors if
+this combination of credentials is not what you intend.
+
+
 ### MySQL table lock errors
 
 If you encounter table lock errors during a database dump with MySQL/MariaDB,
 you may need to [use a
 transaction](https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html#option_mysqldump_single-transaction).
 You can add any additional flags to the `options:` in your database
 configuration. Here's an example:
 
 ```yaml
-hooks:
-    mysql_databases:
-        - name: posts
-          options: "--single-transaction --quick"
+mysql_databases:
+    - name: posts
+      options: "--single-transaction --quick"
 ```
 
 ### borgmatic hangs during backup
 
 See Limitations above about `read_special`. You may need to exclude certain
 paths with named pipes, block devices, character devices, or sockets on which
 borgmatic is hanging.
```

### Comparing `borgmatic-1.7.9/docs/how-to/deal-with-very-large-backups.md` & `borgmatic-1.8.0/docs/how-to/deal-with-very-large-backups.md`

 * *Files 19% similar despite different names*

```diff
@@ -53,34 +53,36 @@
 
 
 ### Consistency check configuration
 
 Another option is to customize your consistency checks. By default, if you
 omit consistency checks from configuration, borgmatic runs full-repository
 checks (`repository`) and per-archive checks (`archives`) within each
-repository, no more than once a month. This is equivalent to what `borg check`
-does if run without options.
+repository. (Although see below about check frequency.) This is equivalent to
+what `borg check` does if run without options.
 
 But if you find that archive checks are too slow, for example, you can
 configure borgmatic to run repository checks only. Configure this in the
 `consistency` section of borgmatic configuration:
 
 ```yaml
-consistency:
-    checks:
-        - name: repository
+checks:
+    - name: repository
 ```
 
-<span class="minilink minilink-addedin">Prior to version 1.6.2</span> `checks`
-was a plain list of strings without the `name:` part. For example:
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+this option in the `consistency:` section of your configuration.
+
+<span class="minilink minilink-addedin">Prior to version 1.6.2</span> The
+`checks` option was a plain list of strings without the `name:` part, and
+borgmatic ran each configured check every time checks were run. For example:
 
 ```yaml
-consistency:
-    checks:
-        - repository
+checks:
+    - repository
 ```
 
 
 Here are the available checks from fastest to slowest:
 
  * `repository`: Checks the consistency of the repository itself.
  * `archives`: Checks all of the archives in the repository.
@@ -90,34 +92,42 @@
 Note that the `data` check is a more thorough version of the `archives` check,
 so enabling the `data` check implicitly enables the `archives` check as well.
 
 See [Borg's check
 documentation](https://borgbackup.readthedocs.io/en/stable/usage/check.html)
 for more information.
 
+
 ### Check frequency
 
 <span class="minilink minilink-addedin">New in version 1.6.2</span> You can
 optionally configure checks to run on a periodic basis rather than every time
 borgmatic runs checks. For instance:
 
 ```yaml
-consistency:
-    checks:
-        - name: repository
-          frequency: 2 weeks
-        - name: archives
-          frequency: 1 month
+checks:
+    - name: repository
+      frequency: 2 weeks
+    - name: archives
+      frequency: 1 month
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+this option in the `consistency:` section of your configuration.
+
 This tells borgmatic to run the `repository` consistency check at most once
 every two weeks for a given repository and the `archives` check at most once a
 month. The `frequency` value is a number followed by a unit of time, e.g. "3
-days", "1 week", "2 months", etc. The `frequency` defaults to `always`, which
-means run this check every time checks run.
+days", "1 week", "2 months", etc.
+
+The `frequency` defaults to `always` for a check configured without a
+`frequency`, which means run this check every time checks run. But if you omit
+consistency checks from configuration entirely, borgmatic runs full-repository
+checks (`repository`) and per-archive checks (`archives`) within each
+repository, at most once a month.
 
 Unlike a real scheduler like cron, borgmatic only makes a best effort to run
 checks on the configured frequency. It compares that frequency with how long
 it's been since the last check for a given repository (as recorded in a file
 within `~/.borgmatic/checks`). If it hasn't been long enough, the check is
 skipped. And you still have to run `borgmatic check` (or `borgmatic` without
 actions) in order for checks to run, even when a `frequency` is configured!
@@ -126,44 +136,61 @@
 configured. Make sure you have the same check frequency configured in each
 thoughor the most frequently configured check will apply.
 
 If you want to temporarily ignore your configured frequencies, you can invoke
 `borgmatic check --force` to run checks unconditionally.
 
 
+### Running only checks
+
+<span class="minilink minilink-addedin">New in version 1.7.1</span> If you
+would like to only run consistency checks without creating backups (for
+instance with the `check` action on the command-line), you can omit
+the `source_directories` option entirely.
+
+<span class="minilink minilink-addedin">Prior to version 1.7.1</span> In older
+versions of borgmatic, instead specify an empty `source_directories` value, as
+it is a mandatory option there:
+
+```yaml
+location:
+    source_directories: []
+```
+
+
 ### Disabling checks
 
 If that's still too slow, you can disable consistency checks entirely,
 either for a single repository or for all repositories.
 
 Disabling all consistency checks looks like this:
 
 ```yaml
-consistency:
-    checks:
-        - name: disabled
+checks:
+    - name: disabled
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+this option in the `consistency:` section of your configuration.
+
 <span class="minilink minilink-addedin">Prior to version 1.6.2</span> `checks`
 was a plain list of strings without the `name:` part. For instance:
 
 ```yaml
-consistency:
-    checks:
-        - disabled
+checks:
+    - disabled
 ```
 
 If you have multiple repositories in your borgmatic configuration file,
 you can keep running consistency checks, but only against a subset of the
 repositories:
 
 ```yaml
-consistency:
-    check_repositories:
-        - path/of/repository_to_check.borg
+check_repositories:
+    - path/of/repository_to_check.borg
 ```
 
 Finally, you can override your configuration file's consistency checks, and
 run particular checks via the command-line. For instance:
 
 ```bash
 borgmatic check --only data --only extract
```

### Comparing `borgmatic-1.7.9/docs/how-to/extract-a-backup.md` & `borgmatic-1.8.0/docs/how-to/extract-a-backup.md`

 * *Files 3% similar despite different names*

```diff
@@ -47,28 +47,29 @@
 
 ## Repository selection
 
 If you have a single repository in your borgmatic configuration file(s), no
 problem: the `extract` action figures out which repository to use.
 
 But if you have multiple repositories configured, then you'll need to specify
-the repository path containing the archive to extract. Here's an example:
+the repository to use via the `--repository` flag. This can be done either
+with the repository's path or its label as configured in your borgmatic configuration file.
 
 ```bash
 borgmatic extract --repository repo.borg --archive host-2023-...
 ```
 
 ## Extract particular files
 
 Sometimes, you want to extract a single deleted file, rather than extracting
 everything from an archive. To do that, tack on one or more `--path` values.
 For instance:
 
 ```bash
-borgmatic extract --archive latest --path path/1 path/2
+borgmatic extract --archive latest --path path/1 --path path/2
 ```
 
 Note that the specified restore paths should not have a leading slash. Like a
 whole-archive extract, this also extracts into the current directory by
 default. So for example, if you happen to be in the directory `/var` and you
 run the `extract` command above, borgmatic will extract `/var/path/1` and
 `/var/path/2`.
```

### Comparing `borgmatic-1.7.9/docs/how-to/inspect-your-backups.md` & `borgmatic-1.8.0/docs/how-to/inspect-your-backups.md`

 * *Files 20% similar despite different names*

```diff
@@ -20,14 +20,23 @@
 
 Or, for even more progress and debug spew:
 
 ```bash
 borgmatic --verbosity 2
 ```
 
+The full set of verbosity levels are:
+
+ * `-2`: disable output entirely <span class="minilink minilink-addedin">New in borgmatic 1.7.14</span>
+ * `-1`: only show errors
+ * `0`: default output
+ * `1`: some additional output (informational level)
+ * `2`: lots of additional output (debug level)
+
+
 ## Backup summary
 
 If you're less concerned with progress during a backup, and you only want to
 see the summary of archive statistics at the end, you can use the stats
 option when performing a backup:
 
 ```bash
@@ -47,15 +56,15 @@
 ```
 
 You can change the output format of `borgmatic list` by specifying your own
 with `--format`. Refer to the [borg list --format
 documentation](https://borgbackup.readthedocs.io/en/stable/usage/list.html#the-format-specifier-syntax)
 for available values.
 
-*(No borgmatic `list` or `info` actions? Upgrade borgmatic!)*
+(No borgmatic `list` or `info` actions? Upgrade borgmatic!)
 
 <span class="minilink minilink-addedin">New in borgmatic version 1.7.0</span>
 There are also `rlist` and `rinfo` actions for displaying repository
 information with Borg 2.x:
 
 ```bash
 borgmatic rlist
@@ -107,15 +116,15 @@
 
 ## Logging
 
 By default, borgmatic logs to a local syslog-compatible daemon if one is
 present and borgmatic is running in a non-interactive console. Where those
 logs show up depends on your particular system. If you're using systemd, try
 running `journalctl -xe`. Otherwise, try viewing `/var/log/syslog` or
-similiar.
+similar.
 
 You can customize the log level used for syslog logging with the
 `--syslog-verbosity` flag, and this is independent from the console logging
 `--verbosity` flag described above. For instance, to get additional
 information about the progress of the backup as it proceeds:
 
 ```bash
@@ -150,9 +159,43 @@
 
 ```bash
 borgmatic --log-file /path/to/file.log
 ```
 
 Note that if you use the `--log-file` flag, you are responsible for rotating
 the log file so it doesn't grow too large, for example with
-[logrotate](https://wiki.archlinux.org/index.php/Logrotate). Also, there is a
-`--log-file-verbosity` flag to customize the log file's log level.
+[logrotate](https://wiki.archlinux.org/index.php/Logrotate).
+
+You can the `--log-file-verbosity` flag to customize the log file's log level:
+
+```bash
+borgmatic --log-file /path/to/file.log --log-file-verbosity 2
+```
+
+<span class="minilink minilink-addedin">New in version 1.7.11</span> Use the
+`--log-file-format` flag to override the default log message format. This
+format string can contain a series of named placeholders wrapped in curly
+brackets. For instance, the default log format is: `[{asctime}] {levelname}:
+{message}`. This means each log message is recorded as the log time (in square
+brackets), a logging level name, a colon, and the actual log message.
+
+So if you only want each log message to get logged *without* a timestamp or a
+logging level name:
+
+```bash
+borgmatic --log-file /path/to/file.log --log-file-format "{message}"
+```
+
+Here is a list of available placeholders:
+
+ * `{asctime}`: time the log message was created
+ * `{levelname}`: level of the log message (`INFO`, `DEBUG`, etc.)
+ * `{lineno}`: line number in the source file where the log message originated
+ * `{message}`: actual log message
+ * `{pathname}`: path of the source file where the log message originated
+
+See the [Python logging
+documentation](https://docs.python.org/3/library/logging.html#logrecord-attributes)
+for additional placeholders.
+
+Note that this `--log-file-format` flg only applies to the specified
+`--log-file` and not to syslog or other logging.
```

### Comparing `borgmatic-1.7.9/docs/how-to/make-backups-redundant.md` & `borgmatic-1.8.0/docs/how-to/make-backups-redundant.md`

 * *Files 11% similar despite different names*

```diff
@@ -8,37 +8,40 @@
 ## Multiple repositories
 
 If you really care about your data, you probably want more than one backup of
 it. borgmatic supports this in its configuration by specifying multiple backup
 repositories. Here's an example:
 
 ```yaml
-location:
-    # List of source directories to backup.
-    source_directories:
-        - /home
-        - /etc
-
-    # Paths of local or remote repositories to backup to.
-    repositories:
-        - ssh://1234@usw-s001.rsync.net/./backups.borg
-        - ssh://k8pDxu32@k8pDxu32.repo.borgbase.com/./repo
-        - /var/lib/backups/local.borg
+# List of source directories to backup.
+source_directories:
+    - /home
+    - /etc
+
+# Paths of local or remote repositories to backup to.
+repositories:
+    - path: ssh://k8pDxu32@k8pDxu32.repo.borgbase.com/./repo
+    - path: /var/lib/backups/local.borg
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+these options in the `location:` section of your configuration.
+
+<span class="minilink minilink-addedin">Prior to version 1.7.10</span> Omit
+the `path:` portion of the `repositories` list.
+
 When you run borgmatic with this configuration, it invokes Borg once for each
 configured repository in sequence. (So, not in parallel.) That meansin each
 repositoryborgmatic creates a single new backup archive containing all of
 your source directories.
 
 Here's a way of visualizing what borgmatic does with the above configuration:
 
-1. Backup `/home` and `/etc` to `1234@usw-s001.rsync.net:backups.borg`
-2. Backup `/home` and `/etc` to `k8pDxu32@k8pDxu32.repo.borgbase.com:repo`
-3. Backup `/home` and `/etc` to `/var/lib/backups/local.borg`
+1. Backup `/home` and `/etc` to `k8pDxu32@k8pDxu32.repo.borgbase.com:repo`
+2. Backup `/home` and `/etc` to `/var/lib/backups/local.borg`
 
 This gives you redundancy of your data across repositories and even
 potentially across providers.
 
 See [Borg repository URLs
 documentation](https://borgbackup.readthedocs.io/en/stable/usage/general.html#repository-urls)
 for more information on how to specify local and remote repository paths.
```

### Comparing `borgmatic-1.7.9/docs/how-to/monitor-your-backups.md` & `borgmatic-1.8.0/docs/how-to/monitor-your-backups.md`

 * *Files 9% similar despite different names*

```diff
@@ -69,15 +69,15 @@
 providers](https://torsion.org/borgmatic/#hosting-providers) include
 monitoring and alerting as part of their offering. This gives you a dashboard
 to check on all of your backups, and can alert you if the service doesn't hear
 from borgmatic for a configured interval.
 
 ### Consistency checks
 
-While not strictly part of monitoring, if you really want confidence that your
+While not strictly part of monitoring, if you want confidence that your
 backups are not only running but are restorable as well, you can configure
 particular [consistency
 checks](https://torsion.org/borgmatic/docs/how-to/deal-with-very-large-backups/#consistency-check-configuration)
 or even script full [extract
 tests](https://torsion.org/borgmatic/docs/how-to/extract-a-backup/).
 
 
@@ -85,27 +85,28 @@
 
 When an error occurs during a `create`, `prune`, `compact`, or `check` action,
 borgmatic can run configurable shell commands to fire off custom error
 notifications or take other actions, so you can get alerted as soon as
 something goes wrong. Here's a not-so-useful example:
 
 ```yaml
-hooks:
-    on_error:
-        - echo "Error while creating a backup or running a backup hook."
+on_error:
+    - echo "Error while creating a backup or running a backup hook."
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+this option in the `hooks:` section of your configuration.
+
 The `on_error` hook supports interpolating particular runtime variables into
 the hook command. Here's an example that assumes you provide a separate shell
 script to handle the alerting:
 
 ```yaml
-hooks:
-    on_error:
-        - send-text-message.sh "{configuration_filename}" "{repository}"
+on_error:
+    - send-text-message.sh "{configuration_filename}" "{repository}"
 ```
 
 In this example, when the error occurs, borgmatic interpolates runtime values
 into the hook command: the borgmatic configuration filename, and the path of
 the repository. Here's the full set of supported variables you can use here:
 
  * `configuration_filename`: borgmatic configuration filename in which the
@@ -131,19 +132,21 @@
 alerts when your cron jobs fail silently", and borgmatic has built-in
 integration with it. Once you create a Healthchecks account and project on
 their site, all you need to do is configure borgmatic with the unique "Ping
 URL" for your project. Here's an example:
 
 
 ```yaml
-hooks:
-    healthchecks:
-        ping_url: https://hc-ping.com/addffa72-da17-40ae-be9c-ff591afb942a
+healthchecks:
+    ping_url: https://hc-ping.com/addffa72-da17-40ae-be9c-ff591afb942a
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+this option in the `hooks:` section of your configuration.
+
 With this hook in place, borgmatic pings your Healthchecks project when a
 backup begins, ends, or errors. Specifically, after the <a
 href="https://torsion.org/borgmatic/docs/how-to/add-preparation-and-cleanup-steps-to-backups/">`before_backup`
 hooks</a> run, borgmatic lets Healthchecks know that it has started if any of
 the `create`, `prune`, `compact`, or `check` actions are run.
 
 Then, if the actions complete successfully, borgmatic notifies Healthchecks of
@@ -175,19 +178,21 @@
 for websites, services and APIs", and borgmatic has built-in
 integration with it. Once you create a Cronitor account and cron job monitor on
 their site, all you need to do is configure borgmatic with the unique "Ping
 API URL" for your monitor. Here's an example:
 
 
 ```yaml
-hooks:
-    cronitor:
-        ping_url: https://cronitor.link/d3x0c1
+cronitor:
+    ping_url: https://cronitor.link/d3x0c1
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+this option in the `hooks:` section of your configuration.
+
 With this hook in place, borgmatic pings your Cronitor monitor when a backup
 begins, ends, or errors. Specifically, after the <a
 href="https://torsion.org/borgmatic/docs/how-to/add-preparation-and-cleanup-steps-to-backups/">`before_backup`
 hooks</a> run, borgmatic lets Cronitor know that it has started if any of the
 `prune`, `compact`, `create`, or `check` actions are run. Then, if the actions
 complete successfully, borgmatic notifies Cronitor of the success after the
 `after_backup` hooks run. And if an error occurs during any action or hook,
@@ -204,19 +209,21 @@
 background jobs fail silently or run longer than expected", and borgmatic has
 built-in integration with it. Once you create a Cronhub account and monitor on
 their site, all you need to do is configure borgmatic with the unique "Ping
 URL" for your monitor. Here's an example:
 
 
 ```yaml
-hooks:
-    cronhub:
-        ping_url: https://cronhub.io/start/1f5e3410-254c-11e8-b61d-55875966d031
+cronhub:
+    ping_url: https://cronhub.io/start/1f5e3410-254c-11e8-b61d-55875966d031
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+this option in the `hooks:` section of your configuration.
+
 With this hook in place, borgmatic pings your Cronhub monitor when a backup
 begins, ends, or errors. Specifically, after the <a
 href="https://torsion.org/borgmatic/docs/how-to/add-preparation-and-cleanup-steps-to-backups/">`before_backup`
 hooks</a> run, borgmatic lets Cronhub know that it has started if any of the
 `prune`, `compact`, `create`, or `check` actions are run. Then, if the actions
 complete successfully, borgmatic notifies Cronhub of the success after the
 `after_backup` hooks run. And if an error occurs during any action or hook,
@@ -247,19 +254,21 @@
 to "borgmatic".
 
 Then, configure borgmatic with the unique "Integration Key" for your service.
 Here's an example:
 
 
 ```yaml
-hooks:
-    pagerduty:
-        integration_key: a177cad45bd374409f78906a810a3074
+pagerduty:
+    integration_key: a177cad45bd374409f78906a810a3074
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+this option in the `hooks:` section of your configuration.
+
 With this hook in place, borgmatic creates a PagerDuty event for your service
 whenever backups fail. Specifically, if an error occurs during a `create`,
 `prune`, `compact`, or `check` action, borgmatic sends an event to PagerDuty
 before the `on_error` hooks run. Note that borgmatic does not contact
 PagerDuty when a backup starts or ends without error.
 
 You can configure PagerDuty to notify you by a [variety of
@@ -287,39 +296,42 @@
 or, if none are provided, will use the default.
 
 An example configuration is shown here, with all the available options, including
 [priorities](https://ntfy.sh/docs/publish/#message-priority) and
 [tags](https://ntfy.sh/docs/publish/#tags-emojis):
 
 ```yaml
-hooks:
-    ntfy:
-        topic: my-unique-topic
-        server: https://ntfy.my-domain.com
-        start:
-            title: A Borgmatic backup started
-            message: Watch this space...
-            tags: borgmatic
-            priority: min
-        finish:
-            title: A Borgmatic backup completed successfully
-            message: Nice!
-            tags: borgmatic,+1
-            priority: min
-        fail:
-            title: A Borgmatic backup failed
-            message: You should probably fix it
-            tags: borgmatic,-1,skull
-            priority: max
-        states:
-            - start
-            - finish
-            - fail
+ntfy:
+    topic: my-unique-topic
+    server: https://ntfy.my-domain.com
+    start:
+        title: A Borgmatic backup started
+        message: Watch this space...
+        tags: borgmatic
+        priority: min
+    finish:
+        title: A Borgmatic backup completed successfully
+        message: Nice!
+        tags: borgmatic,+1
+        priority: min
+    fail:
+        title: A Borgmatic backup failed
+        message: You should probably fix it
+        tags: borgmatic,-1,skull
+        priority: max
+    states:
+        - start
+        - finish
+        - fail
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+the `ntfy:` option in the `hooks:` section of your configuration.
+
+
 ## Scripting borgmatic
 
 To consume the output of borgmatic in other software, you can include an
 optional `--json` flag with `create`, `rlist`, `rinfo`, or `info` to get the
 output formatted as JSON.
 
 Note that when you specify the `--json` flag, Borg's other non-JSON output is
```

### Comparing `borgmatic-1.7.9/docs/how-to/provide-your-passwords.md` & `borgmatic-1.8.0/docs/how-to/provide-your-passwords.md`

 * *Files 8% similar despite different names*

```diff
@@ -16,49 +16,52 @@
 <span class="minilink minilink-addedin">New in version 1.6.4</span> borgmatic
 supports interpolating arbitrary environment variables directly into option
 values in your configuration file. That means you can instruct borgmatic to
 pull your repository passphrase, your database passwords, or any other option
 values from environment variables. For instance:
 
 ```yaml
-storage:
-    encryption_passphrase: ${MY_PASSPHRASE}
+encryption_passphrase: ${MY_PASSPHRASE}
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+this option in the `storage:` section of your configuration.
+
 This uses the `MY_PASSPHRASE` environment variable as your encryption
 passphrase. Note that the `{` `}` brackets are required. `$MY_PASSPHRASE` by
 itself will not work.
 
 In the case of `encryption_passphrase` in particular, an alternate approach
 is to use Borg's `BORG_PASSPHRASE` environment variable, which doesn't even
 require setting an explicit `encryption_passphrase` value in borgmatic's
 configuration file.
 
 For [database
 configuration](https://torsion.org/borgmatic/docs/how-to/backup-your-databases/),
 the same approach applies. For example:
 
 ```yaml
-hooks:
-    postgresql_databases:
-        - name: users
-          password: ${MY_DATABASE_PASSWORD}
+postgresql_databases:
+    - name: users
+      password: ${MY_DATABASE_PASSWORD}
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> Put
+this option in the `hooks:` section of your configuration.
+
 This uses the `MY_DATABASE_PASSWORD` environment variable as your database
 password.
 
 
 ### Interpolation defaults
 
 If you'd like to set a default for your environment variables, you can do so with the following syntax:
 
 ```yaml
-storage:
-    encryption_passphrase: ${MY_PASSPHRASE:-defaultpass}
+encryption_passphrase: ${MY_PASSPHRASE:-defaultpass}
 ```
 
 Here, "`defaultpass`" is the default passphrase if the `MY_PASSPHRASE`
 environment variable is not set. Without a default, if the environment
 variable doesn't exist, borgmatic will error.
 
 
@@ -68,16 +71,15 @@
 pass the `--no-environment-interpolation` flag on the command-line.
 
 Or if you'd like to disable interpolation within a single option value, you
 can escape it with a backslash. For instance, if your password is literally
 `${A}@!`:
 
 ```yaml
-storage:
-    encryption_passphrase: \${A}@!
+encryption_passphrase: \${A}@!
 ```
 
 ### Related features
 
 Another way to override particular options within a borgmatic configuration
 file is to use a [configuration
 override](https://torsion.org/borgmatic/docs/how-to/make-per-application-backups/#configuration-overrides)
```

### Comparing `borgmatic-1.7.9/docs/how-to/set-up-backups.md` & `borgmatic-1.8.0/docs/how-to/set-up-backups.md`

 * *Files 3% similar despite different names*

```diff
@@ -160,771 +160,832 @@
 000009f0: 6572 2077 6179 7320 746f 2069 6e73 7461  er ways to insta
 00000a00: 6c6c 0a0a 4265 7369 6465 7320 7468 6520  ll..Besides the 
 00000a10: 6170 7072 6f61 6368 6573 2064 6573 6372  approaches descr
 00000a20: 6962 6564 2061 626f 7665 2c20 7468 6572  ibed above, ther
 00000a30: 6520 6172 6520 7365 7665 7261 6c20 6f74  e are several ot
 00000a40: 6865 7220 6f70 7469 6f6e 7320 666f 720a  her options for.
 00000a50: 696e 7374 616c 6c69 6e67 2062 6f72 676d  installing borgm
-00000a60: 6174 6963 3a0a 0a20 2a20 5b44 6f63 6b65  atic:.. * [Docke
-00000a70: 7220 696d 6167 6520 7769 7468 2073 6368  r image with sch
-00000a80: 6564 756c 6564 2062 6163 6b75 7073 5d28  eduled backups](
-00000a90: 6874 7470 733a 2f2f 6875 622e 646f 636b  https://hub.dock
-00000aa0: 6572 2e63 6f6d 2f72 2f62 3376 6973 2f62  er.com/r/b3vis/b
-00000ab0: 6f72 676d 6174 6963 2f29 2028 2b20 446f  orgmatic/) (+ Do
-00000ac0: 636b 6572 2043 6f6d 706f 7365 2066 696c  cker Compose fil
-00000ad0: 6573 290a 202a 205b 446f 636b 6572 2069  es). * [Docker i
-00000ae0: 6d61 6765 2077 6974 6820 6d75 6c74 692d  mage with multi-
-00000af0: 6172 6368 2061 6e64 2044 6f63 6b65 7220  arch and Docker 
-00000b00: 434c 4920 7375 7070 6f72 745d 2868 7474  CLI support](htt
-00000b10: 7073 3a2f 2f68 7562 2e64 6f63 6b65 722e  ps://hub.docker.
-00000b20: 636f 6d2f 722f 6d6f 6465 6d37 2f62 6f72  com/r/modem7/bor
-00000b30: 676d 6174 6963 2d64 6f63 6b65 722f 290a  gmatic-docker/).
-00000b40: 202a 205b 4465 6269 616e 5d28 6874 7470   * [Debian](http
-00000b50: 733a 2f2f 7472 6163 6b65 722e 6465 6269  s://tracker.debi
-00000b60: 616e 2e6f 7267 2f70 6b67 2f62 6f72 676d  an.org/pkg/borgm
-00000b70: 6174 6963 290a 202a 205b 5562 756e 7475  atic). * [Ubuntu
-00000b80: 5d28 6874 7470 733a 2f2f 6c61 756e 6368  ](https://launch
-00000b90: 7061 642e 6e65 742f 7562 756e 7475 2f2b  pad.net/ubuntu/+
-00000ba0: 736f 7572 6365 2f62 6f72 676d 6174 6963  source/borgmatic
-00000bb0: 290a 202a 205b 4665 646f 7261 206f 6666  ). * [Fedora off
-00000bc0: 6963 6961 6c5d 2868 7474 7073 3a2f 2f62  icial](https://b
-00000bd0: 6f64 6869 2e66 6564 6f72 6170 726f 6a65  odhi.fedoraproje
-00000be0: 6374 2e6f 7267 2f75 7064 6174 6573 2f3f  ct.org/updates/?
-00000bf0: 7365 6172 6368 3d62 6f72 676d 6174 6963  search=borgmatic
-00000c00: 290a 202a 205b 4665 646f 7261 2075 6e6f  ). * [Fedora uno
-00000c10: 6666 6963 6961 6c5d 2868 7474 7073 3a2f  fficial](https:/
-00000c20: 2f63 6f70 722e 6665 646f 7261 696e 6672  /copr.fedorainfr
-00000c30: 6163 6c6f 7564 2e6f 7267 2f63 6f70 7273  acloud.org/coprs
-00000c40: 2f68 6566 6665 722f 626f 7267 6d61 7469  /heffer/borgmati
-00000c50: 632f 290a 202a 205b 4172 6368 204c 696e  c/). * [Arch Lin
-00000c60: 7578 5d28 6874 7470 733a 2f2f 7777 772e  ux](https://www.
-00000c70: 6172 6368 6c69 6e75 782e 6f72 672f 7061  archlinux.org/pa
-00000c80: 636b 6167 6573 2f63 6f6d 6d75 6e69 7479  ckages/community
-00000c90: 2f61 6e79 2f62 6f72 676d 6174 6963 2f29  /any/borgmatic/)
-00000ca0: 0a20 2a20 5b41 6c70 696e 6520 4c69 6e75  . * [Alpine Linu
-00000cb0: 785d 2868 7474 7073 3a2f 2f70 6b67 732e  x](https://pkgs.
-00000cc0: 616c 7069 6e65 6c69 6e75 782e 6f72 672f  alpinelinux.org/
-00000cd0: 7061 636b 6167 6573 3f6e 616d 653d 626f  packages?name=bo
-00000ce0: 7267 6d61 7469 6329 0a20 2a20 5b4f 7065  rgmatic). * [Ope
-00000cf0: 6e42 5344 5d28 6874 7470 3a2f 2f70 6f72  nBSD](http://por
-00000d00: 7473 2e73 752f 7379 7375 7469 6c73 2f62  ts.su/sysutils/b
-00000d10: 6f72 676d 6174 6963 290a 202a 205b 6f70  orgmatic). * [op
-00000d20: 656e 5355 5345 5d28 6874 7470 733a 2f2f  enSUSE](https://
-00000d30: 736f 6674 7761 7265 2e6f 7065 6e73 7573  software.opensus
-00000d40: 652e 6f72 672f 7061 636b 6167 652f 626f  e.org/package/bo
-00000d50: 7267 6d61 7469 6329 0a20 2a20 5b6d 6163  rgmatic). * [mac
-00000d60: 4f53 2028 7669 6120 486f 6d65 6272 6577  OS (via Homebrew
-00000d70: 295d 2868 7474 7073 3a2f 2f66 6f72 6d75  )](https://formu
-00000d80: 6c61 652e 6272 6577 2e73 682f 666f 726d  lae.brew.sh/form
-00000d90: 756c 612f 626f 7267 6d61 7469 6329 0a20  ula/borgmatic). 
-00000da0: 2a20 5b6d 6163 4f53 2028 7669 6120 4d61  * [macOS (via Ma
-00000db0: 6350 6f72 7473 295d 2868 7474 7073 3a2f  cPorts)](https:/
-00000dc0: 2f70 6f72 7473 2e6d 6163 706f 7274 732e  /ports.macports.
-00000dd0: 6f72 672f 706f 7274 2f62 6f72 676d 6174  org/port/borgmat
-00000de0: 6963 2f29 0a20 2a20 5b41 6e73 6962 6c65  ic/). * [Ansible
-00000df0: 2072 6f6c 655d 2868 7474 7073 3a2f 2f67   role](https://g
-00000e00: 6974 6875 622e 636f 6d2f 626f 7267 6261  ithub.com/borgba
-00000e10: 7365 2f61 6e73 6962 6c65 2d72 6f6c 652d  se/ansible-role-
-00000e20: 626f 7267 6261 636b 7570 290a 202a 205b  borgbackup). * [
-00000e30: 7669 7274 7561 6c65 6e76 5d28 6874 7470  virtualenv](http
-00000e40: 733a 2f2f 7669 7274 7561 6c65 6e76 2e70  s://virtualenv.p
-00000e50: 7970 612e 696f 2f65 6e2f 7374 6162 6c65  ypa.io/en/stable
-00000e60: 2f29 0a0a 0a23 2320 486f 7374 696e 6720  /)...## Hosting 
-00000e70: 7072 6f76 6964 6572 730a 0a4e 6565 6420  providers..Need 
-00000e80: 736f 6d65 7768 6572 6520 746f 2073 746f  somewhere to sto
-00000e90: 7265 2079 6f75 7220 656e 6372 7970 7465  re your encrypte
-00000ea0: 6420 6f66 662d 7369 7465 2062 6163 6b75  d off-site backu
-00000eb0: 7073 3f20 5468 6520 666f 6c6c 6f77 696e  ps? The followin
-00000ec0: 6720 686f 7374 696e 670a 7072 6f76 6964  g hosting.provid
-00000ed0: 6572 7320 696e 636c 7564 6520 7370 6563  ers include spec
-00000ee0: 6966 6963 2073 7570 706f 7274 2066 6f72  ific support for
-00000ef0: 2042 6f72 672f 626f 7267 6d61 7469 63e2   Borg/borgmatic.
-00000f00: 8094 616e 6420 6675 6e64 2062 6f72 676d  ..and fund borgm
-00000f10: 6174 6963 0a64 6576 656c 6f70 6d65 6e74  atic.development
-00000f20: 2061 6e64 2068 6f73 7469 6e67 2077 6865   and hosting whe
-00000f30: 6e20 796f 7520 7573 6520 7468 6573 6520  n you use these 
-00000f40: 6c69 6e6b 7320 746f 2073 6967 6e20 7570  links to sign up
-00000f50: 2e20 2854 6865 7365 2061 7265 0a72 6566  . (These are.ref
-00000f60: 6572 7261 6c20 6c69 6e6b 732c 2062 7574  erral links, but
-00000f70: 2077 6974 686f 7574 2061 6e79 2074 7261   without any tra
-00000f80: 636b 696e 6720 7363 7269 7074 7320 6f72  cking scripts or
-00000f90: 2063 6f6f 6b69 6573 2e29 0a0a 3c75 6c3e   cookies.)..<ul>
-00000fa0: 0a20 3c6c 6920 636c 6173 733d 2272 6566  . <li class="ref
-00000fb0: 6572 7261 6c22 3e3c 6120 6872 6566 3d22  erral"><a href="
-00000fc0: 6874 7470 733a 2f2f 7777 772e 626f 7267  https://www.borg
-00000fd0: 6261 7365 2e63 6f6d 2f3f 7574 6d5f 736f  base.com/?utm_so
-00000fe0: 7572 6365 3d62 6f72 676d 6174 6963 223e  urce=borgmatic">
-00000ff0: 426f 7267 4261 7365 3c2f 613e 3a20 426f  BorgBase</a>: Bo
-00001000: 7267 2068 6f73 7469 6e67 2073 6572 7669  rg hosting servi
-00001010: 6365 2077 6974 6820 7375 7070 6f72 7420  ce with support 
-00001020: 666f 7220 6d6f 6e69 746f 7269 6e67 2c20  for monitoring, 
-00001030: 3246 412c 2061 6e64 2061 7070 656e 642d  2FA, and append-
-00001040: 6f6e 6c79 2072 6570 6f73 3c2f 6c69 3e0a  only repos</li>.
-00001050: 3c2f 756c 3e0a 0a41 6464 6974 696f 6e61  </ul>..Additiona
-00001060: 6c6c 792c 205b 7273 796e 632e 6e65 745d  lly, [rsync.net]
-00001070: 2868 7474 7073 3a2f 2f77 7777 2e72 7379  (https://www.rsy
-00001080: 6e63 2e6e 6574 2f70 726f 6475 6374 732f  nc.net/products/
-00001090: 626f 7267 2e68 746d 6c29 2061 6e64 0a5b  borg.html) and.[
-000010a0: 4865 747a 6e65 725d 2868 7474 7073 3a2f  Hetzner](https:/
-000010b0: 2f77 7777 2e68 6574 7a6e 6572 2e63 6f6d  /www.hetzner.com
-000010c0: 2f73 746f 7261 6765 2f73 746f 7261 6765  /storage/storage
-000010d0: 2d62 6f78 2920 6861 7665 2063 6f6d 7061  -box) have compa
-000010e0: 7469 626c 6520 7374 6f72 6167 650a 6f66  tible storage.of
-000010f0: 6665 7269 6e67 732c 2062 7574 2064 6f20  ferings, but do 
-00001100: 6e6f 7420 6375 7272 656e 746c 7920 6675  not currently fu
-00001110: 6e64 2062 6f72 676d 6174 6963 2064 6576  nd borgmatic dev
-00001120: 656c 6f70 6d65 6e74 206f 7220 686f 7374  elopment or host
-00001130: 696e 672e 0a0a 0a23 2320 436f 6e66 6967  ing....## Config
-00001140: 7572 6174 696f 6e0a 0a41 6674 6572 2079  uration..After y
-00001150: 6f75 2069 6e73 7461 6c6c 2062 6f72 676d  ou install borgm
-00001160: 6174 6963 2c20 6765 6e65 7261 7465 2061  atic, generate a
-00001170: 2073 616d 706c 6520 636f 6e66 6967 7572   sample configur
-00001180: 6174 696f 6e20 6669 6c65 3a0a 0a60 6060  ation file:..```
-00001190: 6261 7368 0a73 7564 6f20 6765 6e65 7261  bash.sudo genera
-000011a0: 7465 2d62 6f72 676d 6174 6963 2d63 6f6e  te-borgmatic-con
-000011b0: 6669 670a 6060 600a 0a49 6620 7468 6174  fig.```..If that
-000011c0: 2063 6f6d 6d61 6e64 2069 7320 6e6f 7420   command is not 
-000011d0: 666f 756e 642c 2074 6865 6e20 6974 206d  found, then it m
-000011e0: 6179 2062 6520 696e 7374 616c 6c65 6420  ay be installed 
-000011f0: 696e 2061 206c 6f63 6174 696f 6e20 7468  in a location th
-00001200: 6174 2773 0a6e 6f74 2069 6e20 796f 7572  at's.not in your
-00001210: 2073 7973 7465 6d20 6050 4154 4860 2028   system `PATH` (
-00001220: 7365 6520 6162 6f76 6529 2e20 5472 7920  see above). Try 
-00001230: 6c6f 6f6b 696e 6720 696e 2060 7e2f 2e6c  looking in `~/.l
-00001240: 6f63 616c 2f62 696e 2f60 2e0a 0a54 6869  ocal/bin/`...Thi
-00001250: 7320 6765 6e65 7261 7465 7320 6120 7361  s generates a sa
-00001260: 6d70 6c65 2063 6f6e 6669 6775 7261 7469  mple configurati
-00001270: 6f6e 2066 696c 6520 6174 2060 2f65 7463  on file at `/etc
-00001280: 2f62 6f72 676d 6174 6963 2f63 6f6e 6669  /borgmatic/confi
-00001290: 672e 7961 6d6c 6020 6279 0a64 6566 6175  g.yaml` by.defau
-000012a0: 6c74 2e20 4966 2079 6f75 2764 206c 696b  lt. If you'd lik
-000012b0: 6520 746f 2075 7365 2061 6e6f 7468 6572  e to use another
-000012c0: 2070 6174 682c 2075 7365 2074 6865 2060   path, use the `
-000012d0: 2d2d 6465 7374 696e 6174 696f 6e60 2066  --destination` f
-000012e0: 6c61 672c 2066 6f72 0a69 6e73 7461 6e63  lag, for.instanc
-000012f0: 653a 2060 2d2d 6465 7374 696e 6174 696f  e: `--destinatio
-00001300: 6e20 7e2f 2e63 6f6e 6669 672f 626f 7267  n ~/.config/borg
-00001310: 6d61 7469 632f 636f 6e66 6967 2e79 616d  matic/config.yam
-00001320: 6c60 2e0a 0a59 6f75 2073 686f 756c 6420  l`...You should 
-00001330: 6564 6974 2074 6865 2063 6f6e 6669 6775  edit the configu
-00001340: 7261 7469 6f6e 2066 696c 6520 746f 2073  ration file to s
-00001350: 7569 7420 796f 7572 206e 6565 6473 2c20  uit your needs, 
-00001360: 6173 2074 6865 2067 656e 6572 6174 6564  as the generated
-00001370: 0a76 616c 7565 7320 6172 6520 6f6e 6c79  .values are only
-00001380: 2072 6570 7265 7365 6e74 6174 6976 652e   representative.
-00001390: 2041 6c6c 206f 7074 696f 6e73 2061 7265   All options are
-000013a0: 206f 7074 696f 6e61 6c20 6578 6365 7074   optional except
-000013b0: 2077 6865 7265 0a69 6e64 6963 6174 6564   where.indicated
-000013c0: 2c20 736f 2066 6565 6c20 6672 6565 2074  , so feel free t
-000013d0: 6f20 6967 6e6f 7265 2061 6e79 7468 696e  o ignore anythin
-000013e0: 6720 796f 7520 646f 6e27 7420 6e65 6564  g you don't need
-000013f0: 2e0a 0a4e 6f74 6520 7468 6174 2074 6865  ...Note that the
-00001400: 2063 6f6e 6669 6775 7261 7469 6f6e 2066   configuration f
-00001410: 696c 6520 6973 206f 7267 616e 697a 6564  ile is organized
-00001420: 2069 6e74 6f20 6469 7374 696e 6374 2073   into distinct s
-00001430: 6563 7469 6f6e 732c 2065 6163 680a 7769  ections, each.wi
-00001440: 7468 2061 2073 6563 7469 6f6e 206e 616d  th a section nam
-00001450: 6520 6c69 6b65 2060 6c6f 6361 7469 6f6e  e like `location
-00001460: 3a60 206f 7220 6073 746f 7261 6765 3a60  :` or `storage:`
-00001470: 2e20 536f 2074 616b 6520 6361 7265 2074  . So take care t
-00001480: 6861 7420 6966 2079 6f75 0a75 6e63 6f6d  hat if you.uncom
-00001490: 6d65 6e74 2061 2070 6172 7469 6375 6c61  ment a particula
-000014a0: 7220 6f70 7469 6f6e 2c20 616c 736f 2075  r option, also u
-000014b0: 6e63 6f6d 6d65 6e74 2069 7473 2063 6f6e  ncomment its con
-000014c0: 7461 696e 696e 6720 7365 6374 696f 6e20  taining section 
-000014d0: 6e61 6d65 2c20 6f72 0a65 6c73 6520 626f  name, or.else bo
-000014e0: 7267 6d61 7469 6320 776f 6e27 7420 7265  rgmatic won't re
-000014f0: 636f 676e 697a 6520 7468 6520 6f70 7469  cognize the opti
-00001500: 6f6e 2e20 416c 736f 2062 6520 7375 7265  on. Also be sure
-00001510: 2074 6f20 7573 6520 7370 6163 6573 2072   to use spaces r
-00001520: 6174 6865 720a 7468 616e 2074 6162 7320  ather.than tabs 
-00001530: 666f 7220 696e 6465 6e74 6174 696f 6e3b  for indentation;
-00001540: 2059 414d 4c20 646f 6573 206e 6f74 2061   YAML does not a
-00001550: 6c6c 6f77 2074 6162 732e 0a0a 596f 7520  llow tabs...You 
-00001560: 6361 6e20 6765 7420 7468 6520 7361 6d65  can get the same
-00001570: 2073 616d 706c 6520 636f 6e66 6967 7572   sample configur
-00001580: 6174 696f 6e20 6669 6c65 2066 726f 6d20  ation file from 
-00001590: 7468 6520 5b63 6f6e 6669 6775 7261 7469  the [configurati
-000015a0: 6f6e 0a72 6566 6572 656e 6365 5d28 6874  on.reference](ht
-000015b0: 7470 733a 2f2f 746f 7273 696f 6e2e 6f72  tps://torsion.or
-000015c0: 672f 626f 7267 6d61 7469 632f 646f 6373  g/borgmatic/docs
-000015d0: 2f72 6566 6572 656e 6365 2f63 6f6e 6669  /reference/confi
-000015e0: 6775 7261 7469 6f6e 2f29 2c20 7468 650a  guration/), the.
-000015f0: 6175 7468 6f72 6974 6174 6976 6520 7365  authoritative se
-00001600: 7420 6f66 2061 6c6c 2063 6f6e 6669 6775  t of all configu
-00001610: 7261 7469 6f6e 206f 7074 696f 6e73 2e20  ration options. 
-00001620: 5468 6973 2069 7320 6861 6e64 7920 6966  This is handy if
-00001630: 2062 6f72 676d 6174 6963 2068 6173 0a61   borgmatic has.a
-00001640: 6464 6564 206e 6577 206f 7074 696f 6e73  dded new options
-00001650: 2073 696e 6365 2079 6f75 206f 7269 6769   since you origi
-00001660: 6e61 6c6c 7920 6372 6561 7465 6420 796f  nally created yo
-00001670: 7572 2063 6f6e 6669 6775 7261 7469 6f6e  ur configuration
-00001680: 2066 696c 652e 2041 6c73 6f0a 6368 6563   file. Also.chec
-00001690: 6b20 6f75 7420 686f 7720 746f 205b 7570  k out how to [up
-000016a0: 6772 6164 6520 796f 7572 0a63 6f6e 6669  grade your.confi
-000016b0: 6775 7261 7469 6f6e 5d28 6874 7470 733a  guration](https:
-000016c0: 2f2f 746f 7273 696f 6e2e 6f72 672f 626f  //torsion.org/bo
-000016d0: 7267 6d61 7469 632f 646f 6373 2f68 6f77  rgmatic/docs/how
-000016e0: 2d74 6f2f 7570 6772 6164 652f 2375 7067  -to/upgrade/#upg
-000016f0: 7261 6469 6e67 2d79 6f75 722d 636f 6e66  rading-your-conf
-00001700: 6967 7572 6174 696f 6e29 2e0a 0a0a 2323  iguration)....##
-00001710: 2320 456e 6372 7970 7469 6f6e 0a0a 4966  # Encryption..If
-00001720: 2079 6f75 2065 6e63 7279 7074 2079 6f75   you encrypt you
-00001730: 7220 426f 7267 2072 6570 6f73 6974 6f72  r Borg repositor
-00001740: 7920 7769 7468 2061 2070 6173 7370 6872  y with a passphr
-00001750: 6173 6520 6f72 2061 206b 6579 2066 696c  ase or a key fil
-00001760: 652c 2079 6f75 276c 6c0a 6569 7468 6572  e, you'll.either
-00001770: 206e 6565 6420 746f 2073 6574 2074 6865   need to set the
-00001780: 2062 6f72 676d 6174 6963 2060 656e 6372   borgmatic `encr
-00001790: 7970 7469 6f6e 5f70 6173 7370 6872 6173  yption_passphras
-000017a0: 6560 2063 6f6e 6669 6775 7261 7469 6f6e  e` configuration
-000017b0: 0a76 6172 6961 626c 6520 6f72 2073 6574  .variable or set
-000017c0: 2074 6865 2060 424f 5247 5f50 4153 5350   the `BORG_PASSP
-000017d0: 4852 4153 4560 2065 6e76 6972 6f6e 6d65  HRASE` environme
-000017e0: 6e74 2076 6172 6961 626c 652e 2053 6565  nt variable. See
-000017f0: 2074 6865 0a5b 7265 706f 7369 746f 7279   the.[repository
-00001800: 2065 6e63 7279 7074 696f 6e0a 7365 6374   encryption.sect
-00001810: 696f 6e5d 2868 7474 7073 3a2f 2f62 6f72  ion](https://bor
-00001820: 6762 6163 6b75 702e 7265 6164 7468 6564  gbackup.readthed
-00001830: 6f63 732e 696f 2f65 6e2f 7374 6162 6c65  ocs.io/en/stable
-00001840: 2f71 7569 636b 7374 6172 742e 6874 6d6c  /quickstart.html
-00001850: 2372 6570 6f73 6974 6f72 792d 656e 6372  #repository-encr
-00001860: 7970 7469 6f6e 290a 6f66 2074 6865 2042  yption).of the B
-00001870: 6f72 6720 5175 6963 6b20 5374 6172 7420  org Quick Start 
-00001880: 666f 7220 6d6f 7265 2069 6e66 6f2e 0a0a  for more info...
-00001890: 416c 7465 726e 6174 6976 656c 792c 2079  Alternatively, y
-000018a0: 6f75 2063 616e 2073 7065 6369 6679 2074  ou can specify t
-000018b0: 6865 2070 6173 7370 6872 6173 6520 7072  he passphrase pr
-000018c0: 6f67 7261 6d61 7469 6361 6c6c 7920 6279  ogramatically by
-000018d0: 2073 6574 7469 6e67 0a65 6974 6865 7220   setting.either 
-000018e0: 7468 6520 626f 7267 6d61 7469 6320 6065  the borgmatic `e
-000018f0: 6e63 7279 7074 696f 6e5f 7061 7373 636f  ncryption_passco
-00001900: 6d6d 616e 6460 2063 6f6e 6669 6775 7261  mmand` configura
-00001910: 7469 6f6e 2076 6172 6961 626c 6520 6f72  tion variable or
-00001920: 2074 6865 0a60 424f 5247 5f50 4153 5343   the.`BORG_PASSC
-00001930: 4f4d 4d41 4e44 6020 656e 7669 726f 6e6d  OMMAND` environm
-00001940: 656e 7420 7661 7269 6162 6c65 2e20 5365  ent variable. Se
-00001950: 6520 7468 6520 5b42 6f72 6720 5365 6375  e the [Borg Secu
-00001960: 7269 7479 0a46 4151 5d28 6874 7470 3a2f  rity.FAQ](http:/
-00001970: 2f62 6f72 6762 6163 6b75 702e 7265 6164  /borgbackup.read
-00001980: 7468 6564 6f63 732e 696f 2f65 6e2f 7374  thedocs.io/en/st
-00001990: 6162 6c65 2f66 6171 2e68 746d 6c23 686f  able/faq.html#ho
-000019a0: 772d 6361 6e2d 692d 7370 6563 6966 792d  w-can-i-specify-
-000019b0: 7468 652d 656e 6372 7970 7469 6f6e 2d70  the-encryption-p
-000019c0: 6173 7370 6872 6173 652d 7072 6f67 7261  assphrase-progra
-000019d0: 6d6d 6174 6963 616c 6c79 290a 666f 7220  mmatically).for 
-000019e0: 6d6f 7265 2069 6e66 6f2e 0a0a 0a23 2323  more info....###
-000019f0: 2052 6564 756e 6461 6e63 790a 0a49 6620   Redundancy..If 
-00001a00: 796f 7527 6420 6c69 6b65 2074 6f20 636f  you'd like to co
-00001a10: 6e66 6967 7572 6520 796f 7572 2062 6163  nfigure your bac
-00001a20: 6b75 7073 2074 6f20 676f 2074 6f20 6d75  kups to go to mu
-00001a30: 6c74 6970 6c65 2064 6966 6665 7265 6e74  ltiple different
-00001a40: 0a72 6570 6f73 6974 6f72 6965 732c 2073  .repositories, s
-00001a50: 6565 2074 6865 2064 6f63 756d 656e 7461  ee the documenta
-00001a60: 7469 6f6e 206f 6e20 686f 7720 746f 205b  tion on how to [
-00001a70: 6d61 6b65 2062 6163 6b75 7073 0a72 6564  make backups.red
-00001a80: 756e 6461 6e74 5d28 6874 7470 733a 2f2f  undant](https://
-00001a90: 746f 7273 696f 6e2e 6f72 672f 626f 7267  torsion.org/borg
-00001aa0: 6d61 7469 632f 646f 6373 2f68 6f77 2d74  matic/docs/how-t
-00001ab0: 6f2f 6d61 6b65 2d62 6163 6b75 7073 2d72  o/make-backups-r
-00001ac0: 6564 756e 6461 6e74 2f29 2e0a 0a0a 2323  edundant/)....##
-00001ad0: 2320 5661 6c69 6461 7469 6f6e 0a0a 4966  # Validation..If
-00001ae0: 2079 6f75 2764 206c 696b 6520 746f 2076   you'd like to v
-00001af0: 616c 6964 6174 6520 7468 6174 2079 6f75  alidate that you
-00001b00: 7220 626f 7267 6d61 7469 6320 636f 6e66  r borgmatic conf
-00001b10: 6967 7572 6174 696f 6e20 6973 2076 616c  iguration is val
-00001b20: 6964 2c20 7468 650a 666f 6c6c 6f77 696e  id, the.followin
-00001b30: 6720 636f 6d6d 616e 6420 6973 2061 7661  g command is ava
-00001b40: 696c 6162 6c65 2066 6f72 2074 6861 743a  ilable for that:
-00001b50: 0a0a 6060 6062 6173 680a 7375 646f 2076  ..```bash.sudo v
-00001b60: 616c 6964 6174 652d 626f 7267 6d61 7469  alidate-borgmati
-00001b70: 632d 636f 6e66 6967 0a60 6060 0a0a 5468  c-config.```..Th
-00001b80: 6973 2063 6f6d 6d61 6e64 2773 2065 7869  is command's exi
-00001b90: 7420 7374 6174 7573 2028 6024 3f60 2069  t status (`$?` i
-00001ba0: 6e20 4261 7368 2920 6973 207a 6572 6f20  n Bash) is zero 
-00001bb0: 7768 656e 2063 6f6e 6669 6775 7261 7469  when configurati
-00001bc0: 6f6e 2069 7320 7661 6c69 640a 616e 6420  on is valid.and 
-00001bd0: 6e6f 6e2d 7a65 726f 206f 7468 6572 7769  non-zero otherwi
-00001be0: 7365 2e0a 0a56 616c 6964 6174 696e 6720  se...Validating 
-00001bf0: 636f 6e66 6967 7572 6174 696f 6e20 6361  configuration ca
-00001c00: 6e20 6265 2075 7365 6675 6c20 6966 2079  n be useful if y
-00001c10: 6f75 2067 656e 6572 6174 6520 796f 7572  ou generate your
-00001c20: 2063 6f6e 6669 6775 7261 7469 6f6e 0a66   configuration.f
-00001c30: 696c 6573 2076 6961 2063 6f6e 6669 6775  iles via configu
-00001c40: 7261 7469 6f6e 206d 616e 6167 656d 656e  ration managemen
-00001c50: 742c 206f 7220 796f 7520 7761 6e74 2074  t, or you want t
-00001c60: 6f20 646f 7562 6c65 2063 6865 636b 2074  o double check t
-00001c70: 6861 7420 796f 7572 2068 616e 640a 6564  hat your hand.ed
-00001c80: 6974 7320 6172 6520 7661 6c69 642e 0a0a  its are valid...
-00001c90: 0a23 2320 5265 706f 7369 746f 7279 2063  .## Repository c
-00001ca0: 7265 6174 696f 6e0a 0a42 6566 6f72 6520  reation..Before 
-00001cb0: 796f 7520 6361 6e20 6372 6561 7465 2062  you can create b
-00001cc0: 6163 6b75 7073 2077 6974 6820 626f 7267  ackups with borg
-00001cd0: 6d61 7469 632c 2079 6f75 2066 6972 7374  matic, you first
-00001ce0: 206e 6565 6420 746f 2063 7265 6174 6520   need to create 
-00001cf0: 6120 426f 7267 0a72 6570 6f73 6974 6f72  a Borg.repositor
-00001d00: 7920 736f 2079 6f75 2068 6176 6520 6120  y so you have a 
-00001d10: 6465 7374 696e 6174 696f 6e20 666f 7220  destination for 
-00001d20: 796f 7572 2062 6163 6b75 7020 6172 6368  your backup arch
-00001d30: 6976 6573 2e20 2842 7574 2073 6b69 7020  ives. (But skip 
-00001d40: 7468 6973 0a73 7465 7020 6966 2079 6f75  this.step if you
-00001d50: 2061 6c72 6561 6479 2068 6176 6520 6120   already have a 
-00001d60: 426f 7267 2072 6570 6f73 6974 6f72 792e  Borg repository.
-00001d70: 2920 546f 2063 7265 6174 6520 6120 7265  ) To create a re
-00001d80: 706f 7369 746f 7279 2c20 7275 6e20 610a  pository, run a.
-00001d90: 636f 6d6d 616e 6420 6c69 6b65 2074 6865  command like the
-00001da0: 2066 6f6c 6c6f 7769 6e67 2077 6974 6820   following with 
-00001db0: 426f 7267 2031 2e78 3a0a 0a60 6060 6261  Borg 1.x:..```ba
-00001dc0: 7368 0a73 7564 6f20 626f 7267 6d61 7469  sh.sudo borgmati
-00001dd0: 6320 696e 6974 202d 2d65 6e63 7279 7074  c init --encrypt
-00001de0: 696f 6e20 7265 706f 6b65 790a 6060 600a  ion repokey.```.
-00001df0: 0a3c 7370 616e 2063 6c61 7373 3d22 6d69  .<span class="mi
-00001e00: 6e69 6c69 6e6b 206d 696e 696c 696e 6b2d  nilink minilink-
-00001e10: 6164 6465 6469 6e22 3e4e 6577 2069 6e20  addedin">New in 
-00001e20: 626f 7267 6d61 7469 6320 7665 7273 696f  borgmatic versio
-00001e30: 6e20 312e 372e 303c 2f73 7061 6e3e 0a4f  n 1.7.0</span>.O
-00001e40: 722c 2077 6974 6820 426f 7267 2032 2e78  r, with Borg 2.x
-00001e50: 3a0a 0a60 6060 6261 7368 0a73 7564 6f20  :..```bash.sudo 
-00001e60: 626f 7267 6d61 7469 6320 7263 7265 6174  borgmatic rcreat
-00001e70: 6520 2d2d 656e 6372 7970 7469 6f6e 2072  e --encryption r
-00001e80: 6570 6f6b 6579 2d61 6573 2d6f 6362 0a60  epokey-aes-ocb.`
-00001e90: 6060 0a0a 284e 6f74 6520 7468 6174 2060  ``..(Note that `
-00001ea0: 7265 706f 6b65 792d 6368 6163 6861 3230  repokey-chacha20
-00001eb0: 2d70 6f6c 7931 3330 3560 206d 6179 2062  -poly1305` may b
-00001ec0: 6520 6661 7374 6572 2074 6861 6e20 6072  e faster than `r
-00001ed0: 6570 6f6b 6579 2d61 6573 2d6f 6362 6020  epokey-aes-ocb` 
-00001ee0: 6f6e 0a63 6572 7461 696e 2070 6c61 7466  on.certain platf
-00001ef0: 6f72 6d73 206c 696b 6520 4152 4d36 342e  orms like ARM64.
-00001f00: 290a 0a54 6869 7320 7573 6573 2074 6865  )..This uses the
-00001f10: 2062 6f72 676d 6174 6963 2063 6f6e 6669   borgmatic confi
-00001f20: 6775 7261 7469 6f6e 2066 696c 6520 796f  guration file yo
-00001f30: 7520 6372 6561 7465 6420 6162 6f76 6520  u created above 
-00001f40: 746f 2064 6574 6572 6d69 6e65 0a77 6869  to determine.whi
-00001f50: 6368 206c 6f63 616c 206f 7220 7265 6d6f  ch local or remo
-00001f60: 7465 2072 6570 6f73 6974 6f72 7920 746f  te repository to
-00001f70: 2063 7265 6174 652c 2061 6e64 2065 6e63   create, and enc
-00001f80: 7279 7074 7320 6974 2077 6974 6820 7468  rypts it with th
-00001f90: 650a 656e 6372 7970 7469 6f6e 2070 6173  e.encryption pas
-00001fa0: 7370 6872 6173 6520 7370 6563 6966 6965  sphrase specifie
-00001fb0: 6420 7468 6572 6520 6966 206f 6e65 2069  d there if one i
-00001fc0: 7320 7072 6f76 6964 6564 2e20 5265 6164  s provided. Read
-00001fd0: 2061 626f 7574 205b 426f 7267 0a65 6e63   about [Borg.enc
-00001fe0: 7279 7074 696f 6e0a 6d6f 6465 735d 2868  ryption.modes](h
-00001ff0: 7474 7073 3a2f 2f62 6f72 6762 6163 6b75  ttps://borgbacku
-00002000: 702e 7265 6164 7468 6564 6f63 732e 696f  p.readthedocs.io
-00002010: 2f65 6e2f 7374 6162 6c65 2f75 7361 6765  /en/stable/usage
-00002020: 2f69 6e69 742e 6874 6d6c 2365 6e63 7279  /init.html#encry
-00002030: 7074 696f 6e2d 6d6f 6465 2d74 6c64 7229  ption-mode-tldr)
-00002040: 0a66 6f72 2074 6865 206d 656e 7520 6f66  .for the menu of
-00002050: 2061 7661 696c 6162 6c65 2065 6e63 7279   available encry
-00002060: 7074 696f 6e20 6d6f 6465 732e 0a0a 416c  ption modes...Al
-00002070: 736f 2c20 6f70 7469 6f6e 616c 6c79 2063  so, optionally c
-00002080: 6865 636b 206f 7574 2074 6865 205b 426f  heck out the [Bo
-00002090: 7267 2051 7569 636b 0a53 7461 7274 5d28  rg Quick.Start](
-000020a0: 6874 7470 733a 2f2f 626f 7267 6261 636b  https://borgback
-000020b0: 7570 2e72 6561 6474 6865 646f 6373 2e6f  up.readthedocs.o
-000020c0: 7267 2f65 6e2f 7374 6162 6c65 2f71 7569  rg/en/stable/qui
-000020d0: 636b 7374 6172 742e 6874 6d6c 2920 666f  ckstart.html) fo
-000020e0: 7220 6d6f 7265 0a62 6163 6b67 726f 756e  r more.backgroun
-000020f0: 6420 6162 6f75 7420 7265 706f 7369 746f  d about reposito
-00002100: 7279 2063 7265 6174 696f 6e2e 0a0a 4e6f  ry creation...No
-00002110: 7465 2074 6861 7420 626f 7267 6d61 7469  te that borgmati
-00002120: 6320 736b 6970 7320 7265 706f 7369 746f  c skips reposito
-00002130: 7279 2063 7265 6174 696f 6e20 6966 2074  ry creation if t
-00002140: 6865 2072 6570 6f73 6974 6f72 7920 616c  he repository al
-00002150: 7265 6164 790a 6578 6973 7473 2e20 5468  ready.exists. Th
-00002160: 6973 2073 7570 706f 7274 7320 7573 6520  is supports use 
-00002170: 6361 7365 7320 6c69 6b65 2065 6e73 7572  cases like ensur
-00002180: 696e 6720 6120 7265 706f 7369 746f 7279  ing a repository
-00002190: 2065 7869 7374 7320 7072 696f 7220 746f   exists prior to
-000021a0: 0a70 6572 666f 726d 696e 6720 6120 6261  .performing a ba
-000021b0: 636b 7570 2e0a 0a49 6620 7468 6520 7265  ckup...If the re
-000021c0: 706f 7369 746f 7279 2069 7320 6f6e 2061  pository is on a
-000021d0: 2072 656d 6f74 6520 686f 7374 2c20 6d61   remote host, ma
-000021e0: 6b65 2073 7572 6520 7468 6174 2079 6f75  ke sure that you
-000021f0: 7220 6c6f 6361 6c20 7573 6572 2068 6173  r local user has
-00002200: 0a6b 6579 2d62 6173 6564 2053 5348 2061  .key-based SSH a
-00002210: 6363 6573 7320 746f 2074 6865 2064 6573  ccess to the des
-00002220: 6972 6564 2075 7365 7220 6163 636f 756e  ired user accoun
-00002230: 7420 6f6e 2074 6865 2072 656d 6f74 6520  t on the remote 
-00002240: 686f 7374 2e0a 0a0a 2323 2042 6163 6b75  host....## Backu
-00002250: 7073 0a0a 4e6f 7720 7468 6174 2079 6f75  ps..Now that you
-00002260: 2776 6520 636f 6e66 6967 7572 6564 2062  've configured b
-00002270: 6f72 676d 6174 6963 2061 6e64 2063 7265  orgmatic and cre
-00002280: 6174 6564 2061 2072 6570 6f73 6974 6f72  ated a repositor
-00002290: 792c 2069 7427 7320 6120 676f 6f64 0a69  y, it's a good.i
-000022a0: 6465 6120 746f 2074 6573 7420 7468 6174  dea to test that
-000022b0: 2062 6f72 676d 6174 6963 2069 7320 776f   borgmatic is wo
-000022c0: 726b 696e 672e 2053 6f20 746f 2072 756e  rking. So to run
-000022d0: 2062 6f72 676d 6174 6963 2061 6e64 2073   borgmatic and s
-000022e0: 7461 7274 2061 0a62 6163 6b75 702c 2079  tart a.backup, y
-000022f0: 6f75 2063 616e 2069 6e76 6f6b 6520 6974  ou can invoke it
-00002300: 206c 696b 6520 7468 6973 3a0a 0a60 6060   like this:..```
-00002310: 6261 7368 0a73 7564 6f20 626f 7267 6d61  bash.sudo borgma
-00002320: 7469 6320 6372 6561 7465 202d 2d76 6572  tic create --ver
-00002330: 626f 7369 7479 2031 202d 2d6c 6973 7420  bosity 1 --list 
-00002340: 2d2d 7374 6174 730a 6060 600a 0a28 4e6f  --stats.```..(No
-00002350: 2062 6f72 676d 6174 6963 2060 2d2d 6c69   borgmatic `--li
-00002360: 7374 6020 666c 6167 3f20 5472 7920 602d  st` flag? Try `-
-00002370: 2d66 696c 6573 6020 696e 7374 6561 642c  -files` instead,
-00002380: 206c 6561 7665 2069 7420 6f75 742c 206f   leave it out, o
-00002390: 7220 7570 6772 6164 650a 626f 7267 6d61  r upgrade.borgma
-000023a0: 7469 6321 290a 0a54 6865 2060 2d2d 7665  tic!)..The `--ve
-000023b0: 7262 6f73 6974 7960 2066 6c61 6720 6d61  rbosity` flag ma
-000023c0: 6b65 7320 626f 7267 6d61 7469 6320 7368  kes borgmatic sh
-000023d0: 6f77 2074 6865 2073 7465 7073 2069 7427  ow the steps it'
-000023e0: 7320 7065 7266 6f72 6d69 6e67 2e20 5468  s performing. Th
-000023f0: 650a 602d 2d6c 6973 7460 2066 6c61 6720  e.`--list` flag 
-00002400: 6c69 7374 7320 6561 6368 2066 696c 6520  lists each file 
-00002410: 7468 6174 2773 206e 6577 206f 7220 6368  that's new or ch
-00002420: 616e 6765 6420 7369 6e63 6520 7468 6520  anged since the 
-00002430: 6c61 7374 2062 6163 6b75 702e 2041 6e64  last backup. And
-00002440: 0a60 2d2d 7374 6174 7360 2073 686f 7773  .`--stats` shows
-00002450: 2073 756d 6d61 7279 2069 6e66 6f72 6d61   summary informa
-00002460: 7469 6f6e 2061 626f 7574 2074 6865 2063  tion about the c
-00002470: 7265 6174 6564 2061 7263 6869 7665 2e20  reated archive. 
-00002480: 416c 6c20 6f66 2074 6865 7365 0a66 6c61  All of these.fla
-00002490: 6773 2061 7265 206f 7074 696f 6e61 6c2e  gs are optional.
-000024a0: 0a0a 4173 2074 6865 2063 6f6d 6d61 6e64  ..As the command
-000024b0: 2072 756e 732c 2079 6f75 2073 686f 756c   runs, you shoul
-000024c0: 6420 6579 6562 616c 6c20 7468 6520 6f75  d eyeball the ou
-000024d0: 7470 7574 2074 6f20 7365 6520 6966 2069  tput to see if i
-000024e0: 7420 6d61 7463 6865 7320 796f 7572 0a65  t matches your.e
-000024f0: 7870 6563 7461 7469 6f6e 7320 6261 7365  xpectations base
-00002500: 6420 6f6e 2079 6f75 7220 636f 6e66 6967  d on your config
-00002510: 7572 6174 696f 6e2e 0a0a 4966 2079 6f75  uration...If you
-00002520: 2764 206c 696b 6520 746f 2073 7065 6369  'd like to speci
-00002530: 6679 2061 6e20 616c 7465 726e 6174 6520  fy an alternate 
-00002540: 636f 6e66 6967 7572 6174 696f 6e20 6669  configuration fi
-00002550: 6c65 2070 6174 682c 2075 7365 2074 6865  le path, use the
-00002560: 0a60 2d2d 636f 6e66 6967 6020 666c 6167  .`--config` flag
-00002570: 2e0a 0a53 6565 2060 626f 7267 6d61 7469  ...See `borgmati
-00002580: 6320 2d2d 6865 6c70 6020 616e 6420 6062  c --help` and `b
-00002590: 6f72 676d 6174 6963 2063 7265 6174 6520  orgmatic create 
-000025a0: 2d2d 6865 6c70 6020 666f 7220 6d6f 7265  --help` for more
-000025b0: 2069 6e66 6f72 6d61 7469 6f6e 2e0a 0a0a   information....
-000025c0: 2323 2044 6566 6175 6c74 2061 6374 696f  ## Default actio
-000025d0: 6e73 0a0a 4966 2079 6f75 206f 6d69 7420  ns..If you omit 
-000025e0: 6063 7265 6174 6560 2061 6e64 206f 7468  `create` and oth
-000025f0: 6572 2061 6374 696f 6e73 2c20 626f 7267  er actions, borg
-00002600: 6d61 7469 6320 7275 6e73 2074 6872 6f75  matic runs throu
-00002610: 6768 2061 2073 6574 206f 660a 6465 6661  gh a set of.defa
-00002620: 756c 7420 6163 7469 6f6e 733a 2060 7072  ult actions: `pr
-00002630: 756e 6560 2061 6e79 206f 6c64 2062 6163  une` any old bac
-00002640: 6b75 7073 2061 7320 7065 7220 7468 6520  kups as per the 
-00002650: 636f 6e66 6967 7572 6564 2072 6574 656e  configured reten
-00002660: 7469 6f6e 0a70 6f6c 6963 792c 2060 636f  tion.policy, `co
-00002670: 6d70 6163 7460 2073 6567 6d65 6e74 7320  mpact` segments 
-00002680: 746f 2066 7265 6520 7570 2073 7061 6365  to free up space
-00002690: 2028 7769 7468 2042 6f72 6720 312e 322b   (with Borg 1.2+
-000026a0: 2c20 626f 7267 6d61 7469 630a 312e 352e  , borgmatic.1.5.
-000026b0: 3233 2b29 2c20 6063 7265 6174 6560 2061  23+), `create` a
-000026c0: 2062 6163 6b75 702c 202a 616e 642a 2060   backup, *and* `
-000026d0: 6368 6563 6b60 2062 6163 6b75 7073 2066  check` backups f
-000026e0: 6f72 2063 6f6e 7369 7374 656e 6379 2070  or consistency p
-000026f0: 726f 626c 656d 730a 6475 6520 746f 2074  roblems.due to t
-00002700: 6869 6e67 7320 6c69 6b65 2066 696c 6520  hings like file 
-00002710: 6461 6d61 6765 2e20 466f 7220 696e 7374  damage. For inst
-00002720: 616e 6365 3a0a 0a60 6060 6261 7368 0a73  ance:..```bash.s
-00002730: 7564 6f20 626f 7267 6d61 7469 6320 2d2d  udo borgmatic --
-00002740: 7665 7262 6f73 6974 7920 3120 2d2d 6c69  verbosity 1 --li
-00002750: 7374 202d 2d73 7461 7473 0a60 6060 0a0a  st --stats.```..
-00002760: 2323 2041 7574 6f70 696c 6f74 0a0a 5275  ## Autopilot..Ru
-00002770: 6e6e 696e 6720 6261 636b 7570 7320 6d61  nning backups ma
-00002780: 6e75 616c 6c79 2069 7320 676f 6f64 2066  nually is good f
-00002790: 6f72 2076 616c 6964 6174 696e 6720 796f  or validating yo
-000027a0: 7572 2063 6f6e 6669 6775 7261 7469 6f6e  ur configuration
-000027b0: 2c20 6275 7420 4927 6d0a 6775 6573 7369  , but I'm.guessi
-000027c0: 6e67 2074 6861 7420 796f 7520 7761 6e74  ng that you want
-000027d0: 2074 6f20 7275 6e20 626f 7267 6d61 7469   to run borgmati
-000027e0: 6320 6175 746f 6d61 7469 6361 6c6c 792c  c automatically,
-000027f0: 2073 6179 206f 6e63 6520 6120 6461 792e   say once a day.
-00002800: 2054 6f20 646f 0a74 6861 742c 2079 6f75   To do.that, you
-00002810: 2063 616e 2063 6f6e 6669 6775 7265 2061   can configure a
-00002820: 2073 6570 6172 6174 6520 6a6f 6220 7275   separate job ru
-00002830: 6e6e 6572 2074 6f20 696e 766f 6b65 2069  nner to invoke i
-00002840: 7420 7065 7269 6f64 6963 616c 6c79 2e0a  t periodically..
-00002850: 0a23 2323 2063 726f 6e0a 0a49 6620 796f  .### cron..If yo
-00002860: 7527 7265 2075 7369 6e67 2063 726f 6e2c  u're using cron,
-00002870: 2064 6f77 6e6c 6f61 6420 7468 6520 5b73   download the [s
-00002880: 616d 706c 6520 6372 6f6e 0a66 696c 655d  ample cron.file]
-00002890: 2868 7474 7073 3a2f 2f70 726f 6a65 6374  (https://project
-000028a0: 732e 746f 7273 696f 6e2e 6f72 672f 626f  s.torsion.org/bo
-000028b0: 7267 6d61 7469 632d 636f 6c6c 6563 7469  rgmatic-collecti
-000028c0: 7665 2f62 6f72 676d 6174 6963 2f73 7263  ve/borgmatic/src
-000028d0: 2f6d 6173 7465 722f 7361 6d70 6c65 2f63  /master/sample/c
-000028e0: 726f 6e2f 626f 7267 6d61 7469 6329 2e0a  ron/borgmatic)..
-000028f0: 5468 656e 2c20 6672 6f6d 2074 6865 2064  Then, from the d
-00002900: 6972 6563 746f 7279 2077 6865 7265 2079  irectory where y
-00002910: 6f75 2064 6f77 6e6c 6f61 6465 6420 6974  ou downloaded it
-00002920: 3a0a 0a60 6060 6261 7368 0a73 7564 6f20  :..```bash.sudo 
-00002930: 6d76 2062 6f72 676d 6174 6963 202f 6574  mv borgmatic /et
-00002940: 632f 6372 6f6e 2e64 2f62 6f72 676d 6174  c/cron.d/borgmat
-00002950: 6963 0a73 7564 6f20 6368 6d6f 6420 2b78  ic.sudo chmod +x
-00002960: 202f 6574 632f 6372 6f6e 2e64 2f62 6f72   /etc/cron.d/bor
-00002970: 676d 6174 6963 0a60 6060 0a0a 4966 2062  gmatic.```..If b
-00002980: 6f72 676d 6174 6963 2069 7320 696e 7374  orgmatic is inst
-00002990: 616c 6c65 6420 6174 2061 2064 6966 6665  alled at a diffe
-000029a0: 7265 6e74 206c 6f63 6174 696f 6e20 7468  rent location th
-000029b0: 616e 0a60 2f72 6f6f 742f 2e6c 6f63 616c  an.`/root/.local
-000029c0: 2f62 696e 2f62 6f72 676d 6174 6963 602c  /bin/borgmatic`,
-000029d0: 2065 6469 7420 7468 6520 6372 6f6e 2066   edit the cron f
-000029e0: 696c 6520 7769 7468 2074 6865 2063 6f72  ile with the cor
-000029f0: 7265 6374 2070 6174 682e 2059 6f75 0a63  rect path. You.c
-00002a00: 616e 2061 6c73 6f20 6d6f 6469 6679 2074  an also modify t
-00002a10: 6865 2063 726f 6e20 6669 6c65 2069 6620  he cron file if 
-00002a20: 796f 7527 6420 6c69 6b65 2074 6f20 7275  you'd like to ru
-00002a30: 6e20 626f 7267 6d61 7469 6320 6d6f 7265  n borgmatic more
-00002a40: 206f 7220 6c65 7373 0a66 7265 7175 656e   or less.frequen
-00002a50: 746c 792e 0a0a 2323 2320 7379 7374 656d  tly...### system
-00002a60: 640a 0a49 6620 796f 7527 7265 2075 7369  d..If you're usi
-00002a70: 6e67 2073 7973 7465 6d64 2069 6e73 7465  ng systemd inste
-00002a80: 6164 206f 6620 6372 6f6e 2074 6f20 7275  ad of cron to ru
-00002a90: 6e20 6a6f 6273 2c20 796f 7520 6361 6e20  n jobs, you can 
-00002aa0: 7374 696c 6c20 636f 6e66 6967 7572 650a  still configure.
-00002ab0: 626f 7267 6d61 7469 6320 746f 2072 756e  borgmatic to run
-00002ac0: 2061 7574 6f6d 6174 6963 616c 6c79 2e0a   automatically..
-00002ad0: 0a28 4966 2079 6f75 2069 6e73 7461 6c6c  .(If you install
-00002ae0: 6564 2062 6f72 676d 6174 6963 2066 726f  ed borgmatic fro
-00002af0: 6d20 5b4f 7468 6572 2077 6179 7320 746f  m [Other ways to
-00002b00: 0a69 6e73 7461 6c6c 5d28 6874 7470 733a  .install](https:
-00002b10: 2f2f 746f 7273 696f 6e2e 6f72 672f 626f  //torsion.org/bo
-00002b20: 7267 6d61 7469 632f 646f 6373 2f68 6f77  rgmatic/docs/how
-00002b30: 2d74 6f2f 7365 742d 7570 2d62 6163 6b75  -to/set-up-backu
-00002b40: 7073 2f23 6f74 6865 722d 7761 7973 2d74  ps/#other-ways-t
-00002b50: 6f2d 696e 7374 616c 6c29 2c0a 796f 7520  o-install),.you 
-00002b60: 6d61 7920 616c 7265 6164 7920 6861 7665  may already have
-00002b70: 2062 6f72 676d 6174 6963 2073 7973 7465   borgmatic syste
-00002b80: 6d64 2073 6572 7669 6365 2061 6e64 2074  md service and t
-00002b90: 696d 6572 2066 696c 6573 2e20 4966 2073  imer files. If s
-00002ba0: 6f2c 2079 6f75 206d 6179 0a62 6520 6162  o, you may.be ab
-00002bb0: 6c65 2074 6f20 736b 6970 2073 6f6d 6520  le to skip some 
-00002bc0: 6f66 2074 6865 2073 7465 7073 2062 656c  of the steps bel
-00002bd0: 6f77 2e29 0a0a 4669 7273 742c 2064 6f77  ow.)..First, dow
-00002be0: 6e6c 6f61 6420 7468 6520 5b73 616d 706c  nload the [sampl
-00002bf0: 6520 7379 7374 656d 6420 7365 7276 6963  e systemd servic
-00002c00: 650a 6669 6c65 5d28 6874 7470 733a 2f2f  e.file](https://
-00002c10: 7072 6f6a 6563 7473 2e74 6f72 7369 6f6e  projects.torsion
-00002c20: 2e6f 7267 2f62 6f72 676d 6174 6963 2d63  .org/borgmatic-c
-00002c30: 6f6c 6c65 6374 6976 652f 626f 7267 6d61  ollective/borgma
-00002c40: 7469 632f 7261 772f 6272 616e 6368 2f6d  tic/raw/branch/m
-00002c50: 6173 7465 722f 7361 6d70 6c65 2f73 7973  aster/sample/sys
-00002c60: 7465 6d64 2f62 6f72 676d 6174 6963 2e73  temd/borgmatic.s
-00002c70: 6572 7669 6365 290a 616e 6420 7468 6520  ervice).and the 
-00002c80: 5b73 616d 706c 6520 7379 7374 656d 6420  [sample systemd 
-00002c90: 7469 6d65 720a 6669 6c65 5d28 6874 7470  timer.file](http
-00002ca0: 733a 2f2f 7072 6f6a 6563 7473 2e74 6f72  s://projects.tor
-00002cb0: 7369 6f6e 2e6f 7267 2f62 6f72 676d 6174  sion.org/borgmat
-00002cc0: 6963 2d63 6f6c 6c65 6374 6976 652f 626f  ic-collective/bo
-00002cd0: 7267 6d61 7469 632f 7261 772f 6272 616e  rgmatic/raw/bran
-00002ce0: 6368 2f6d 6173 7465 722f 7361 6d70 6c65  ch/master/sample
-00002cf0: 2f73 7973 7465 6d64 2f62 6f72 676d 6174  /systemd/borgmat
-00002d00: 6963 2e74 696d 6572 292e 0a0a 5468 656e  ic.timer)...Then
-00002d10: 2c20 6672 6f6d 2074 6865 2064 6972 6563  , from the direc
-00002d20: 746f 7279 2077 6865 7265 2079 6f75 2064  tory where you d
-00002d30: 6f77 6e6c 6f61 6465 6420 7468 656d 3a0a  ownloaded them:.
-00002d40: 0a60 6060 6261 7368 0a73 7564 6f20 6d76  .```bash.sudo mv
-00002d50: 2062 6f72 676d 6174 6963 2e73 6572 7669   borgmatic.servi
-00002d60: 6365 2062 6f72 676d 6174 6963 2e74 696d  ce borgmatic.tim
-00002d70: 6572 202f 6574 632f 7379 7374 656d 642f  er /etc/systemd/
-00002d80: 7379 7374 656d 2f0a 7375 646f 2073 7973  system/.sudo sys
-00002d90: 7465 6d63 746c 2065 6e61 626c 6520 2d2d  temctl enable --
-00002da0: 6e6f 7720 626f 7267 6d61 7469 632e 7469  now borgmatic.ti
-00002db0: 6d65 720a 6060 600a 0a52 6576 6965 7720  mer.```..Review 
-00002dc0: 7468 6520 7365 6375 7269 7479 2073 6574  the security set
-00002dd0: 7469 6e67 7320 696e 2074 6865 2073 6572  tings in the ser
-00002de0: 7669 6365 2066 696c 6520 616e 6420 7570  vice file and up
-00002df0: 6461 7465 2074 6865 6d20 6173 206e 6565  date them as nee
-00002e00: 6465 642e 0a49 6620 6050 726f 7465 6374  ded..If `Protect
-00002e10: 5379 7374 656d 3d73 7472 6963 7460 2069  System=strict` i
-00002e20: 7320 656e 6162 6c65 6420 616e 6420 6c6f  s enabled and lo
-00002e30: 6361 6c20 7265 706f 7369 746f 7269 6573  cal repositories
-00002e40: 2061 7265 2075 7365 642c 2074 6865 6e0a   are used, then.
-00002e50: 7468 6520 7265 706f 7369 746f 7279 2070  the repository p
-00002e60: 6174 6820 6d75 7374 2062 6520 6164 6465  ath must be adde
-00002e70: 6420 746f 2074 6865 2060 5265 6164 5772  d to the `ReadWr
-00002e80: 6974 6550 6174 6873 6020 6c69 7374 2e0a  itePaths` list..
-00002e90: 0a46 6565 6c20 6672 6565 2074 6f20 6d6f  .Feel free to mo
-00002ea0: 6469 6679 2074 6865 2074 696d 6572 2066  dify the timer f
-00002eb0: 696c 6520 6261 7365 6420 6f6e 2068 6f77  ile based on how
-00002ec0: 2066 7265 7175 656e 746c 7920 796f 7527   frequently you'
-00002ed0: 6420 6c69 6b65 0a62 6f72 676d 6174 6963  d like.borgmatic
-00002ee0: 2074 6f20 7275 6e2e 0a0a 2323 2320 6c61   to run...### la
-00002ef0: 756e 6368 6420 696e 206d 6163 4f53 0a0a  unchd in macOS..
-00002f00: 4966 2079 6f75 2072 756e 2062 6f72 676d  If you run borgm
-00002f10: 6174 6963 2069 6e20 6d61 634f 5320 7769  atic in macOS wi
-00002f20: 7468 206c 6175 6e63 6864 2c20 796f 7520  th launchd, you 
-00002f30: 6d61 7920 656e 636f 756e 7465 7220 7065  may encounter pe
-00002f40: 726d 6973 7369 6f6e 730a 6973 7375 6573  rmissions.issues
-00002f50: 2077 6865 6e20 7265 6164 696e 6720 6669   when reading fi
-00002f60: 6c65 7320 746f 2062 6163 6b75 702e 2049  les to backup. I
-00002f70: 6620 7468 6174 2068 6170 7065 6e73 2074  f that happens t
-00002f80: 6f20 796f 752c 2079 6f75 206d 6179 2062  o you, you may b
-00002f90: 650a 696e 7465 7265 7374 6564 2069 6e20  e.interested in 
-00002fa0: 616e 205b 756e 6f66 6669 6369 616c 2077  an [unofficial w
-00002fb0: 6f72 6b2d 6172 6f75 6e64 2066 6f72 2046  ork-around for F
-00002fc0: 756c 6c20 4469 736b 0a41 6363 6573 735d  ull Disk.Access]
-00002fd0: 2868 7474 7073 3a2f 2f70 726f 6a65 6374  (https://project
-00002fe0: 732e 746f 7273 696f 6e2e 6f72 672f 626f  s.torsion.org/bo
-00002ff0: 7267 6d61 7469 632d 636f 6c6c 6563 7469  rgmatic-collecti
-00003000: 7665 2f62 6f72 676d 6174 6963 2f69 7373  ve/borgmatic/iss
-00003010: 7565 732f 3239 3329 2e0a 0a0a 2323 204e  ues/293)....## N
-00003020: 6963 6574 6965 730a 0a0a 2323 2320 5368  iceties...### Sh
-00003030: 656c 6c20 636f 6d70 6c65 7469 6f6e 0a0a  ell completion..
-00003040: 626f 7267 6d61 7469 6320 696e 636c 7564  borgmatic includ
-00003050: 6573 2061 2073 6865 6c6c 2063 6f6d 706c  es a shell compl
-00003060: 6574 696f 6e20 7363 7269 7074 2028 6375  etion script (cu
-00003070: 7272 656e 746c 7920 6f6e 6c79 2066 6f72  rrently only for
-00003080: 2042 6173 6829 2074 6f0a 7375 7070 6f72   Bash) to.suppor
-00003090: 7420 7461 622d 636f 6d70 6c65 7469 6e67  t tab-completing
-000030a0: 2062 6f72 676d 6174 6963 2063 6f6d 6d61   borgmatic comma
-000030b0: 6e64 2d6c 696e 6520 6163 7469 6f6e 7320  nd-line actions 
-000030c0: 616e 6420 666c 6167 732e 2044 6570 656e  and flags. Depen
-000030d0: 6469 6e67 206f 6e0a 686f 7720 796f 7520  ding on.how you 
-000030e0: 696e 7374 616c 6c65 6420 626f 7267 6d61  installed borgma
-000030f0: 7469 632c 2074 6869 7320 6d61 7920 6265  tic, this may be
-00003100: 2065 6e61 626c 6564 2062 7920 6465 6661   enabled by defa
-00003110: 756c 742e 2042 7574 2069 6620 6974 2773  ult. But if it's
-00003120: 206e 6f74 2c0a 7374 6172 7420 6279 2069   not,.start by i
-00003130: 6e73 7461 6c6c 696e 6720 7468 6520 6062  nstalling the `b
-00003140: 6173 682d 636f 6d70 6c65 7469 6f6e 6020  ash-completion` 
-00003150: 4c69 6e75 7820 7061 636b 6167 6520 6f72  Linux package or
-00003160: 2074 6865 0a5b 6062 6173 682d 636f 6d70   the.[`bash-comp
-00003170: 6c65 7469 6f6e 4032 605d 2868 7474 7073  letion@2`](https
-00003180: 3a2f 2f66 6f72 6d75 6c61 652e 6272 6577  ://formulae.brew
-00003190: 2e73 682f 666f 726d 756c 612f 6261 7368  .sh/formula/bash
-000031a0: 2d63 6f6d 706c 6574 696f 6e40 3229 0a6d  -completion@2).m
-000031b0: 6163 4f53 2048 6f6d 6562 7265 7720 666f  acOS Homebrew fo
-000031c0: 726d 756c 612e 2054 6865 6e2c 2069 6e73  rmula. Then, ins
-000031d0: 7461 6c6c 2074 6865 2073 6865 6c6c 2063  tall the shell c
-000031e0: 6f6d 706c 6574 696f 6e20 7363 7269 7074  ompletion script
-000031f0: 2067 6c6f 6261 6c6c 793a 0a0a 6060 6062   globally:..```b
-00003200: 6173 680a 7375 646f 2073 7520 2d63 2022  ash.sudo su -c "
-00003210: 626f 7267 6d61 7469 6320 2d2d 6261 7368  borgmatic --bash
-00003220: 2d63 6f6d 706c 6574 696f 6e20 3e20 2428  -completion > $(
-00003230: 706b 672d 636f 6e66 6967 202d 2d76 6172  pkg-config --var
-00003240: 6961 626c 653d 636f 6d70 6c65 7469 6f6e  iable=completion
-00003250: 7364 6972 2062 6173 682d 636f 6d70 6c65  sdir bash-comple
-00003260: 7469 6f6e 292f 626f 7267 6d61 7469 6322  tion)/borgmatic"
-00003270: 0a60 6060 0a0a 4966 2079 6f75 2064 6f6e  .```..If you don
-00003280: 2774 2068 6176 6520 6070 6b67 2d63 6f6e  't have `pkg-con
-00003290: 6669 6760 2069 6e73 7461 6c6c 6564 2c20  fig` installed, 
-000032a0: 796f 7520 6361 6e20 7472 7920 7468 6520  you can try the 
-000032b0: 666f 6c6c 6f77 696e 6720 7061 7468 0a69  following path.i
-000032c0: 6e73 7465 6164 3a0a 0a60 6060 6261 7368  nstead:..```bash
-000032d0: 0a73 7564 6f20 7375 202d 6320 2262 6f72  .sudo su -c "bor
-000032e0: 676d 6174 6963 202d 2d62 6173 682d 636f  gmatic --bash-co
-000032f0: 6d70 6c65 7469 6f6e 203e 202f 7573 722f  mpletion > /usr/
-00003300: 7368 6172 652f 6261 7368 2d63 6f6d 706c  share/bash-compl
-00003310: 6574 696f 6e2f 636f 6d70 6c65 7469 6f6e  etion/completion
-00003320: 732f 626f 7267 6d61 7469 6322 0a60 6060  s/borgmatic".```
-00003330: 0a0a 4f72 2c20 6966 2079 6f75 2764 206c  ..Or, if you'd l
-00003340: 696b 6520 746f 2069 6e73 7461 6c6c 2074  ike to install t
-00003350: 6865 2073 6372 6970 7420 666f 7220 6f6e  he script for on
-00003360: 6c79 2074 6865 2063 7572 7265 6e74 2075  ly the current u
-00003370: 7365 723a 0a0a 6060 6062 6173 680a 6d6b  ser:..```bash.mk
-00003380: 6469 7220 2d2d 7061 7265 6e74 7320 7e2f  dir --parents ~/
-00003390: 2e6c 6f63 616c 2f73 6861 7265 2f62 6173  .local/share/bas
-000033a0: 682d 636f 6d70 6c65 7469 6f6e 2f63 6f6d  h-completion/com
-000033b0: 706c 6574 696f 6e73 0a62 6f72 676d 6174  pletions.borgmat
-000033c0: 6963 202d 2d62 6173 682d 636f 6d70 6c65  ic --bash-comple
-000033d0: 7469 6f6e 203e 207e 2f2e 6c6f 6361 6c2f  tion > ~/.local/
-000033e0: 7368 6172 652f 6261 7368 2d63 6f6d 706c  share/bash-compl
-000033f0: 6574 696f 6e2f 636f 6d70 6c65 7469 6f6e  etion/completion
-00003400: 732f 626f 7267 6d61 7469 630a 6060 600a  s/borgmatic.```.
-00003410: 0a46 696e 616c 6c79 2c20 7265 7374 6172  .Finally, restar
-00003420: 7420 796f 7572 2073 6865 6c6c 2028 6065  t your shell (`e
-00003430: 7869 7460 2061 6e64 206f 7065 6e20 6120  xit` and open a 
-00003440: 6e65 7720 7368 656c 6c29 2073 6f20 7468  new shell) so th
-00003450: 6520 636f 6d70 6c65 7469 6f6e 730a 7461  e completions.ta
-00003460: 6b65 2065 6666 6563 742e 0a0a 0a23 2323  ke effect....###
-00003470: 2043 6f6c 6f72 6564 206f 7574 7075 740a   Colored output.
-00003480: 0a62 6f72 676d 6174 6963 2070 726f 6475  .borgmatic produ
-00003490: 6365 7320 636f 6c6f 7265 6420 7465 726d  ces colored term
-000034a0: 696e 616c 206f 7574 7075 7420 6279 2064  inal output by d
-000034b0: 6566 6175 6c74 2e20 4974 2069 7320 6469  efault. It is di
-000034c0: 7361 626c 6564 2077 6865 6e20 610a 6e6f  sabled when a.no
-000034d0: 6e2d 696e 7465 7261 6374 6976 6520 7465  n-interactive te
-000034e0: 726d 696e 616c 2069 7320 6465 7465 6374  rminal is detect
-000034f0: 6564 2028 6c69 6b65 2061 2063 726f 6e20  ed (like a cron 
-00003500: 6a6f 6229 2c20 6f72 2077 6865 6e20 796f  job), or when yo
-00003510: 7520 7573 6520 7468 650a 602d 2d6a 736f  u use the.`--jso
-00003520: 6e60 2066 6c61 672e 204f 7468 6572 7769  n` flag. Otherwi
-00003530: 7365 2c20 796f 7520 6361 6e20 6469 7361  se, you can disa
-00003540: 626c 6520 6974 2062 7920 7061 7373 696e  ble it by passin
-00003550: 6720 7468 6520 602d 2d6e 6f2d 636f 6c6f  g the `--no-colo
-00003560: 7260 2066 6c61 672c 0a73 6574 7469 6e67  r` flag,.setting
-00003570: 2074 6865 2065 6e76 6972 6f6e 6d65 6e74   the environment
-00003580: 2076 6172 6961 626c 6520 6050 595f 434f   variable `PY_CO
-00003590: 4c4f 5253 3d46 616c 7365 602c 206f 7220  LORS=False`, or 
-000035a0: 7365 7474 696e 6720 7468 6520 6063 6f6c  setting the `col
-000035b0: 6f72 600a 6f70 7469 6f6e 2074 6f20 6066  or`.option to `f
-000035c0: 616c 7365 6020 696e 2074 6865 2060 6f75  alse` in the `ou
-000035d0: 7470 7574 6020 7365 6374 696f 6e20 6f66  tput` section of
-000035e0: 2063 6f6e 6669 6775 7261 7469 6f6e 2e0a   configuration..
-000035f0: 0a0a 2323 2054 726f 7562 6c65 7368 6f6f  ..## Troubleshoo
-00003600: 7469 6e67 0a0a 2323 2320 2266 6f75 6e64  ting..### "found
-00003610: 2063 6861 7261 6374 6572 2074 6861 7420   character that 
-00003620: 6361 6e6e 6f74 2073 7461 7274 2061 6e79  cannot start any
-00003630: 2074 6f6b 656e 2220 6572 726f 720a 0a49   token" error..I
-00003640: 6620 796f 7520 7275 6e20 626f 7267 6d61  f you run borgma
-00003650: 7469 6320 616e 6420 7365 6520 616e 2065  tic and see an e
-00003660: 7272 6f72 206c 6f6f 6b69 6e67 2073 6f6d  rror looking som
-00003670: 6574 6869 6e67 206c 696b 6520 7468 6973  ething like this
-00003680: 2c20 6974 2070 726f 6261 626c 790a 6d65  , it probably.me
-00003690: 616e 7320 796f 7527 7665 2075 7365 6420  ans you've used 
-000036a0: 7461 6273 2069 6e73 7465 6164 206f 6620  tabs instead of 
-000036b0: 7370 6163 6573 3a0a 0a60 6060 0a74 6573  spaces:..```.tes
-000036c0: 742e 7961 6d6c 3a20 4572 726f 7220 7061  t.yaml: Error pa
-000036d0: 7273 696e 6720 636f 6e66 6967 7572 6174  rsing configurat
-000036e0: 696f 6e20 6669 6c65 0a41 6e20 6572 726f  ion file.An erro
-000036f0: 7220 6f63 6375 7272 6564 2077 6869 6c65  r occurred while
-00003700: 2070 6172 7369 6e67 2061 2063 6f6e 6669   parsing a confi
-00003710: 6775 7261 7469 6f6e 2066 696c 6520 6174  guration file at
-00003720: 2063 6f6e 6669 672e 7961 6d6c 3a0a 7768   config.yaml:.wh
-00003730: 696c 6520 7363 616e 6e69 6e67 2066 6f72  ile scanning for
-00003740: 2074 6865 206e 6578 7420 746f 6b65 6e0a   the next token.
-00003750: 666f 756e 6420 6368 6172 6163 7465 7220  found character 
-00003760: 7468 6174 2063 616e 6e6f 7420 7374 6172  that cannot star
-00003770: 7420 616e 7920 746f 6b65 6e0a 2020 696e  t any token.  in
-00003780: 2022 636f 6e66 6967 2e79 616d 6c22 2c20   "config.yaml", 
-00003790: 6c69 6e65 2032 3330 2c20 636f 6c75 6d6e  line 230, column
-000037a0: 2031 0a60 6060 0a0a 5941 4d4c 2064 6f65   1.```..YAML doe
-000037b0: 7320 6e6f 7420 616c 6c6f 7720 7461 6273  s not allow tabs
-000037c0: 2e20 536f 2074 6f20 6669 7820 7468 6973  . So to fix this
-000037d0: 2c20 7265 706c 6163 6520 616e 7920 7461  , replace any ta
-000037e0: 6273 2069 6e20 796f 7572 0a63 6f6e 6669  bs in your.confi
-000037f0: 6775 7261 7469 6f6e 2066 696c 6520 7769  guration file wi
-00003800: 7468 2074 6865 2072 6571 7569 7369 7465  th the requisite
-00003810: 206e 756d 6265 7220 6f66 2073 7061 6365   number of space
-00003820: 732e 0a0a 2323 2320 6c69 6279 616d 6c20  s...### libyaml 
-00003830: 636f 6d70 696c 6174 696f 6e20 6572 726f  compilation erro
-00003840: 7273 0a0a 626f 7267 6d61 7469 6320 6465  rs..borgmatic de
-00003850: 7065 6e64 7320 6f6e 2061 2050 7974 686f  pends on a Pytho
-00003860: 6e20 5941 4d4c 206c 6962 7261 7279 2028  n YAML library (
-00003870: 7275 616d 656c 2e79 616d 6c29 2074 6861  ruamel.yaml) tha
-00003880: 7420 7769 6c6c 206f 7074 696f 6e61 6c6c  t will optionall
-00003890: 790a 7573 6520 6120 4320 5941 4d4c 206c  y.use a C YAML l
-000038a0: 6962 7261 7279 2028 6c69 6279 616d 6c29  ibrary (libyaml)
-000038b0: 2069 6620 7072 6573 656e 742e 2042 7574   if present. But
-000038c0: 2069 6620 6974 2773 206e 6f74 2069 6e73   if it's not ins
-000038d0: 7461 6c6c 6564 2c20 7468 656e 0a77 6865  talled, then.whe
-000038e0: 6e20 696e 7374 616c 6c69 6e67 206f 7220  n installing or 
-000038f0: 7570 6772 6164 696e 6720 626f 7267 6d61  upgrading borgma
-00003900: 7469 632c 2079 6f75 206d 6179 2073 6565  tic, you may see
-00003910: 2065 7272 6f72 7320 6162 6f75 7420 636f   errors about co
-00003920: 6d70 696c 696e 6720 7468 650a 5941 4d4c  mpiling the.YAML
-00003930: 206c 6962 7261 7279 2e20 4966 2073 6f2c   library. If so,
-00003940: 206e 6f74 2074 6f20 776f 7272 792e 2062   not to worry. b
-00003950: 6f72 676d 6174 6963 2073 686f 756c 6420  orgmatic should 
-00003960: 696e 7374 616c 6c20 616e 6420 6675 6e63  install and func
-00003970: 7469 6f6e 0a63 6f72 7265 6374 6c79 2065  tion.correctly e
-00003980: 7665 6e20 7769 7468 6f75 7420 7468 6520  ven without the 
-00003990: 4320 5941 4d4c 206c 6962 7261 7279 2e20  C YAML library. 
-000039a0: 416e 6420 626f 7267 6d61 7469 6320 776f  And borgmatic wo
-000039b0: 6e27 7420 6265 2061 6e79 2066 6173 7465  n't be any faste
-000039c0: 720a 7769 7468 2074 6865 2043 206c 6962  r.with the C lib
-000039d0: 7261 7279 2070 7265 7365 6e74 2c20 736f  rary present, so
-000039e0: 2079 6f75 2064 6f6e 2774 206e 6565 6420   you don't need 
-000039f0: 746f 2067 6f20 6f75 7420 6f66 2079 6f75  to go out of you
-00003a00: 7220 7761 7920 746f 2069 6e73 7461 6c6c  r way to install
-00003a10: 0a69 742e 0a                             .it..
+00000a60: 6174 6963 3a0a 0a20 2a20 5b63 6f6e 7461  atic:.. * [conta
+00000a70: 696e 6572 2069 6d61 6765 2077 6974 6820  iner image with 
+00000a80: 7363 6865 6475 6c65 6420 6261 636b 7570  scheduled backup
+00000a90: 735d 2868 7474 7073 3a2f 2f68 7562 2e64  s](https://hub.d
+00000aa0: 6f63 6b65 722e 636f 6d2f 722f 6233 7669  ocker.com/r/b3vi
+00000ab0: 732f 626f 7267 6d61 7469 632f 2920 282b  s/borgmatic/) (+
+00000ac0: 2044 6f63 6b65 7220 436f 6d70 6f73 6520   Docker Compose 
+00000ad0: 6669 6c65 7329 0a20 2a20 5b63 6f6e 7461  files). * [conta
+00000ae0: 696e 6572 2069 6d61 6765 2077 6974 6820  iner image with 
+00000af0: 6d75 6c74 692d 6172 6368 2061 6e64 2044  multi-arch and D
+00000b00: 6f63 6b65 7220 434c 4920 7375 7070 6f72  ocker CLI suppor
+00000b10: 745d 2868 7474 7073 3a2f 2f68 7562 2e64  t](https://hub.d
+00000b20: 6f63 6b65 722e 636f 6d2f 722f 6d6f 6465  ocker.com/r/mode
+00000b30: 6d37 2f62 6f72 676d 6174 6963 2d64 6f63  m7/borgmatic-doc
+00000b40: 6b65 722f 290a 202a 205b 4465 6269 616e  ker/). * [Debian
+00000b50: 5d28 6874 7470 733a 2f2f 7472 6163 6b65  ](https://tracke
+00000b60: 722e 6465 6269 616e 2e6f 7267 2f70 6b67  r.debian.org/pkg
+00000b70: 2f62 6f72 676d 6174 6963 290a 202a 205b  /borgmatic). * [
+00000b80: 5562 756e 7475 5d28 6874 7470 733a 2f2f  Ubuntu](https://
+00000b90: 6c61 756e 6368 7061 642e 6e65 742f 7562  launchpad.net/ub
+00000ba0: 756e 7475 2f2b 736f 7572 6365 2f62 6f72  untu/+source/bor
+00000bb0: 676d 6174 6963 290a 202a 205b 4665 646f  gmatic). * [Fedo
+00000bc0: 7261 206f 6666 6963 6961 6c5d 2868 7474  ra official](htt
+00000bd0: 7073 3a2f 2f62 6f64 6869 2e66 6564 6f72  ps://bodhi.fedor
+00000be0: 6170 726f 6a65 6374 2e6f 7267 2f75 7064  aproject.org/upd
+00000bf0: 6174 6573 2f3f 7365 6172 6368 3d62 6f72  ates/?search=bor
+00000c00: 676d 6174 6963 290a 202a 205b 4665 646f  gmatic). * [Fedo
+00000c10: 7261 2075 6e6f 6666 6963 6961 6c5d 2868  ra unofficial](h
+00000c20: 7474 7073 3a2f 2f63 6f70 722e 6665 646f  ttps://copr.fedo
+00000c30: 7261 696e 6672 6163 6c6f 7564 2e6f 7267  rainfracloud.org
+00000c40: 2f63 6f70 7273 2f68 6566 6665 722f 626f  /coprs/heffer/bo
+00000c50: 7267 6d61 7469 632f 290a 202a 205b 4765  rgmatic/). * [Ge
+00000c60: 6e74 6f6f 5d28 6874 7470 733a 2f2f 7061  ntoo](https://pa
+00000c70: 636b 6167 6573 2e67 656e 746f 6f2e 6f72  ckages.gentoo.or
+00000c80: 672f 7061 636b 6167 6573 2f61 7070 2d62  g/packages/app-b
+00000c90: 6163 6b75 702f 626f 7267 6d61 7469 6329  ackup/borgmatic)
+00000ca0: 0a20 2a20 5b41 7263 6820 4c69 6e75 785d  . * [Arch Linux]
+00000cb0: 2868 7474 7073 3a2f 2f61 7263 686c 696e  (https://archlin
+00000cc0: 7578 2e6f 7267 2f70 6163 6b61 6765 732f  ux.org/packages/
+00000cd0: 6578 7472 612f 616e 792f 626f 7267 6d61  extra/any/borgma
+00000ce0: 7469 632f 290a 202a 205b 416c 7069 6e65  tic/). * [Alpine
+00000cf0: 204c 696e 7578 5d28 6874 7470 733a 2f2f   Linux](https://
+00000d00: 706b 6773 2e61 6c70 696e 656c 696e 7578  pkgs.alpinelinux
+00000d10: 2e6f 7267 2f70 6163 6b61 6765 733f 6e61  .org/packages?na
+00000d20: 6d65 3d62 6f72 676d 6174 6963 290a 202a  me=borgmatic). *
+00000d30: 205b 4f70 656e 4253 445d 2868 7474 7073   [OpenBSD](https
+00000d40: 3a2f 2f6f 7065 6e70 6f72 7473 2e70 6c2f  ://openports.pl/
+00000d50: 7061 7468 2f73 7973 7574 696c 732f 626f  path/sysutils/bo
+00000d60: 7267 6d61 7469 6329 0a20 2a20 5b6f 7065  rgmatic). * [ope
+00000d70: 6e53 5553 455d 2868 7474 7073 3a2f 2f73  nSUSE](https://s
+00000d80: 6f66 7477 6172 652e 6f70 656e 7375 7365  oftware.opensuse
+00000d90: 2e6f 7267 2f70 6163 6b61 6765 2f62 6f72  .org/package/bor
+00000da0: 676d 6174 6963 290a 202a 205b 6d61 634f  gmatic). * [macO
+00000db0: 5320 2876 6961 2048 6f6d 6562 7265 7729  S (via Homebrew)
+00000dc0: 5d28 6874 7470 733a 2f2f 666f 726d 756c  ](https://formul
+00000dd0: 6165 2e62 7265 772e 7368 2f66 6f72 6d75  ae.brew.sh/formu
+00000de0: 6c61 2f62 6f72 676d 6174 6963 290a 202a  la/borgmatic). *
+00000df0: 205b 6d61 634f 5320 2876 6961 204d 6163   [macOS (via Mac
+00000e00: 506f 7274 7329 5d28 6874 7470 733a 2f2f  Ports)](https://
+00000e10: 706f 7274 732e 6d61 6370 6f72 7473 2e6f  ports.macports.o
+00000e20: 7267 2f70 6f72 742f 626f 7267 6d61 7469  rg/port/borgmati
+00000e30: 632f 290a 202a 205b 4e69 784f 535d 2868  c/). * [NixOS](h
+00000e40: 7474 7073 3a2f 2f73 6561 7263 682e 6e69  ttps://search.ni
+00000e50: 786f 732e 6f72 672f 7061 636b 6167 6573  xos.org/packages
+00000e60: 3f73 686f 773d 626f 7267 6d61 7469 6326  ?show=borgmatic&
+00000e70: 736f 7274 3d72 656c 6576 616e 6365 2674  sort=relevance&t
+00000e80: 7970 653d 7061 636b 6167 6573 2671 7565  ype=packages&que
+00000e90: 7279 3d62 6f72 676d 6174 6963 290a 202a  ry=borgmatic). *
+00000ea0: 205b 416e 7369 626c 6520 726f 6c65 5d28   [Ansible role](
+00000eb0: 6874 7470 733a 2f2f 6769 7468 7562 2e63  https://github.c
+00000ec0: 6f6d 2f62 6f72 6762 6173 652f 616e 7369  om/borgbase/ansi
+00000ed0: 626c 652d 726f 6c65 2d62 6f72 6762 6163  ble-role-borgbac
+00000ee0: 6b75 7029 0a20 2a20 5b55 6e72 6169 645d  kup). * [Unraid]
+00000ef0: 2868 7474 7073 3a2f 2f75 6e72 6169 642e  (https://unraid.
+00000f00: 6e65 742f 636f 6d6d 756e 6974 792f 6170  net/community/ap
+00000f10: 7073 3f71 3d62 6f72 676d 6174 6963 2372  ps?q=borgmatic#r
+00000f20: 290a 0a0a 2323 2048 6f73 7469 6e67 2070  )...## Hosting p
+00000f30: 726f 7669 6465 7273 0a0a 4e65 6564 2073  roviders..Need s
+00000f40: 6f6d 6577 6865 7265 2074 6f20 7374 6f72  omewhere to stor
+00000f50: 6520 796f 7572 2065 6e63 7279 7074 6564  e your encrypted
+00000f60: 206f 6666 2d73 6974 6520 6261 636b 7570   off-site backup
+00000f70: 733f 2054 6865 2066 6f6c 6c6f 7769 6e67  s? The following
+00000f80: 2068 6f73 7469 6e67 0a70 726f 7669 6465   hosting.provide
+00000f90: 7273 2069 6e63 6c75 6465 2073 7065 6369  rs include speci
+00000fa0: 6669 6320 7375 7070 6f72 7420 666f 7220  fic support for 
+00000fb0: 426f 7267 2f62 6f72 676d 6174 6963 e280  Borg/borgmatic..
+00000fc0: 9461 6e64 2066 756e 6420 626f 7267 6d61  .and fund borgma
+00000fd0: 7469 630a 6465 7665 6c6f 706d 656e 7420  tic.development 
+00000fe0: 616e 6420 686f 7374 696e 6720 7768 656e  and hosting when
+00000ff0: 2079 6f75 2075 7365 2074 6865 7365 2072   you use these r
+00001000: 6566 6572 7261 6c20 6c69 6e6b 7320 746f  eferral links to
+00001010: 2073 6967 6e20 7570 3a0a 0a3c 756c 3e0a   sign up:..<ul>.
+00001020: 203c 6c69 2063 6c61 7373 3d22 7265 6665   <li class="refe
+00001030: 7272 616c 223e 3c61 2068 7265 663d 2268  rral"><a href="h
+00001040: 7474 7073 3a2f 2f77 7777 2e62 6f72 6762  ttps://www.borgb
+00001050: 6173 652e 636f 6d2f 3f75 746d 5f73 6f75  ase.com/?utm_sou
+00001060: 7263 653d 626f 7267 6d61 7469 6322 3e42  rce=borgmatic">B
+00001070: 6f72 6742 6173 653c 2f61 3e3a 2042 6f72  orgBase</a>: Bor
+00001080: 6720 686f 7374 696e 6720 7365 7276 6963  g hosting servic
+00001090: 6520 7769 7468 2073 7570 706f 7274 2066  e with support f
+000010a0: 6f72 206d 6f6e 6974 6f72 696e 672c 2032  or monitoring, 2
+000010b0: 4641 2c20 616e 6420 6170 7065 6e64 2d6f  FA, and append-o
+000010c0: 6e6c 7920 7265 706f 733c 2f6c 693e 0a20  nly repos</li>. 
+000010d0: 3c6c 6920 636c 6173 733d 2272 6566 6572  <li class="refer
+000010e0: 7261 6c22 3e3c 6120 6872 6566 3d22 6874  ral"><a href="ht
+000010f0: 7470 733a 2f2f 6865 747a 6e65 722e 636c  tps://hetzner.cl
+00001100: 6f75 642f 3f72 6566 3d76 3964 4f4a 3938  oud/?ref=v9dOJ98
+00001110: 4963 3949 3822 3e48 6574 7a6e 6572 3c2f  Ic9I8">Hetzner</
+00001120: 613e 3a20 4120 2273 746f 7261 6765 2062  a>: A "storage b
+00001130: 6f78 2220 7468 6174 2069 6e63 6c75 6465  ox" that include
+00001140: 7320 7375 7070 6f72 7420 666f 7220 426f  s support for Bo
+00001150: 7267 3c2f 6c69 3e0a 3c2f 756c 3e0a 0a41  rg</li>.</ul>..A
+00001160: 6464 6974 696f 6e61 6c6c 792c 2072 7379  dditionally, rsy
+00001170: 6e63 2e6e 6574 2068 6173 2061 2063 6f6d  nc.net has a com
+00001180: 7061 7469 626c 6520 7374 6f72 6167 6520  patible storage 
+00001190: 6f66 6665 7269 6e67 2c20 6275 7420 646f  offering, but do
+000011a0: 6573 206e 6f74 2066 756e 640a 626f 7267  es not fund.borg
+000011b0: 6d61 7469 6320 6465 7665 6c6f 706d 656e  matic developmen
+000011c0: 7420 6f72 2068 6f73 7469 6e67 2e0a 0a0a  t or hosting....
+000011d0: 2323 2043 6f6e 6669 6775 7261 7469 6f6e  ## Configuration
+000011e0: 0a0a 4166 7465 7220 796f 7520 696e 7374  ..After you inst
+000011f0: 616c 6c20 626f 7267 6d61 7469 632c 2067  all borgmatic, g
+00001200: 656e 6572 6174 6520 6120 7361 6d70 6c65  enerate a sample
+00001210: 2063 6f6e 6669 6775 7261 7469 6f6e 2066   configuration f
+00001220: 696c 653a 0a0a 6060 6062 6173 680a 7375  ile:..```bash.su
+00001230: 646f 2062 6f72 676d 6174 6963 2063 6f6e  do borgmatic con
+00001240: 6669 6720 6765 6e65 7261 7465 0a60 6060  fig generate.```
+00001250: 0a0a 3c73 7061 6e20 636c 6173 733d 226d  ..<span class="m
+00001260: 696e 696c 696e 6b20 6d69 6e69 6c69 6e6b  inilink minilink
+00001270: 2d61 6464 6564 696e 223e 5072 696f 7220  -addedin">Prior 
+00001280: 746f 2076 6572 7369 6f6e 2031 2e37 2e31  to version 1.7.1
+00001290: 353c 2f73 7061 6e3e 0a47 656e 6572 6174  5</span>.Generat
+000012a0: 6520 6120 636f 6e66 6967 7572 6174 696f  e a configuratio
+000012b0: 6e20 6669 6c65 2077 6974 6820 7468 6973  n file with this
+000012c0: 2063 6f6d 6d61 6e64 2069 6e73 7465 6164   command instead
+000012d0: 3a0a 0a60 6060 6261 7368 0a73 7564 6f20  :..```bash.sudo 
+000012e0: 6765 6e65 7261 7465 2d62 6f72 676d 6174  generate-borgmat
+000012f0: 6963 2d63 6f6e 6669 670a 6060 600a 0a49  ic-config.```..I
+00001300: 6620 6e65 6974 6865 7220 636f 6d6d 616e  f neither comman
+00001310: 6420 6973 2066 6f75 6e64 2c20 7468 656e  d is found, then
+00001320: 2062 6f72 676d 6174 6963 206d 6179 2062   borgmatic may b
+00001330: 6520 696e 7374 616c 6c65 6420 696e 2061  e installed in a
+00001340: 206c 6f63 6174 696f 6e0a 7468 6174 2773   location.that's
+00001350: 206e 6f74 2069 6e20 796f 7572 2073 7973   not in your sys
+00001360: 7465 6d20 6050 4154 4860 2028 7365 6520  tem `PATH` (see 
+00001370: 6162 6f76 6529 2e20 5472 7920 6c6f 6f6b  above). Try look
+00001380: 696e 6720 696e 2060 7e2f 2e6c 6f63 616c  ing in `~/.local
+00001390: 2f62 696e 2f60 2e0a 0a54 6865 2063 6f6d  /bin/`...The com
+000013a0: 6d61 6e64 2067 656e 6572 6174 6573 2061  mand generates a
+000013b0: 2073 616d 706c 6520 636f 6e66 6967 7572   sample configur
+000013c0: 6174 696f 6e20 6669 6c65 2061 740a 602f  ation file at.`/
+000013d0: 6574 632f 626f 7267 6d61 7469 632f 636f  etc/borgmatic/co
+000013e0: 6e66 6967 2e79 616d 6c60 2062 7920 6465  nfig.yaml` by de
+000013f0: 6661 756c 742e 2049 6620 796f 7527 6420  fault. If you'd 
+00001400: 6c69 6b65 2074 6f20 7573 6520 616e 6f74  like to use anot
+00001410: 6865 7220 7061 7468 2c0a 7573 6520 7468  her path,.use th
+00001420: 6520 602d 2d64 6573 7469 6e61 7469 6f6e  e `--destination
+00001430: 6020 666c 6167 2c20 666f 7220 696e 7374  ` flag, for inst
+00001440: 616e 6365 3a20 602d 2d64 6573 7469 6e61  ance: `--destina
+00001450: 7469 6f6e 0a7e 2f2e 636f 6e66 6967 2f62  tion.~/.config/b
+00001460: 6f72 676d 6174 6963 2f63 6f6e 6669 672e  orgmatic/config.
+00001470: 7961 6d6c 602e 0a0a 596f 7520 7368 6f75  yaml`...You shou
+00001480: 6c64 2065 6469 7420 7468 6520 636f 6e66  ld edit the conf
+00001490: 6967 7572 6174 696f 6e20 6669 6c65 2074  iguration file t
+000014a0: 6f20 7375 6974 2079 6f75 7220 6e65 6564  o suit your need
+000014b0: 732c 2061 7320 7468 6520 6765 6e65 7261  s, as the genera
+000014c0: 7465 640a 7661 6c75 6573 2061 7265 206f  ted.values are o
+000014d0: 6e6c 7920 7265 7072 6573 656e 7461 7469  nly representati
+000014e0: 7665 2e20 416c 6c20 6f70 7469 6f6e 7320  ve. All options 
+000014f0: 6172 6520 6f70 7469 6f6e 616c 2065 7863  are optional exc
+00001500: 6570 7420 7768 6572 650a 696e 6469 6361  ept where.indica
+00001510: 7465 642c 2073 6f20 6665 656c 2066 7265  ted, so feel fre
+00001520: 6520 746f 2069 676e 6f72 6520 616e 7974  e to ignore anyt
+00001530: 6869 6e67 2079 6f75 2064 6f6e 2774 206e  hing you don't n
+00001540: 6565 642e 2042 6520 7375 7265 2074 6f20  eed. Be sure to 
+00001550: 7573 650a 7370 6163 6573 2072 6174 6865  use.spaces rathe
+00001560: 7220 7468 616e 2074 6162 7320 666f 7220  r than tabs for 
+00001570: 696e 6465 6e74 6174 696f 6e3b 2059 414d  indentation; YAM
+00001580: 4c20 646f 6573 206e 6f74 2061 6c6c 6f77  L does not allow
+00001590: 2074 6162 732e 0a0a 3c73 7061 6e20 636c   tabs...<span cl
+000015a0: 6173 733d 226d 696e 696c 696e 6b20 6d69  ass="minilink mi
+000015b0: 6e69 6c69 6e6b 2d61 6464 6564 696e 223e  nilink-addedin">
+000015c0: 5072 696f 7220 746f 2076 6572 7369 6f6e  Prior to version
+000015d0: 2031 2e38 2e30 3c2f 7370 616e 3e20 5468   1.8.0</span> Th
+000015e0: 650a 636f 6e66 6967 7572 6174 696f 6e20  e.configuration 
+000015f0: 6669 6c65 2077 6173 206f 7267 616e 697a  file was organiz
+00001600: 6564 2069 6e74 6f20 6469 7374 696e 6374  ed into distinct
+00001610: 2073 6563 7469 6f6e 732c 2065 6163 6820   sections, each 
+00001620: 7769 7468 2061 2073 6563 7469 6f6e 0a6e  with a section.n
+00001630: 616d 6520 6c69 6b65 2060 6c6f 6361 7469  ame like `locati
+00001640: 6f6e 3a60 206f 7220 6073 746f 7261 6765  on:` or `storage
+00001650: 3a60 2e20 536f 2069 6e20 6f6c 6465 7220  :`. So in older 
+00001660: 7665 7273 696f 6e73 206f 6620 626f 7267  versions of borg
+00001670: 6d61 7469 632c 2074 616b 650a 6361 7265  matic, take.care
+00001680: 2074 6861 7420 6966 2079 6f75 2075 6e63   that if you unc
+00001690: 6f6d 6d65 6e74 2061 2070 6172 7469 6375  omment a particu
+000016a0: 6c61 7220 6f70 7469 6f6e 2c20 616c 736f  lar option, also
+000016b0: 2075 6e63 6f6d 6d65 6e74 2069 7473 2063   uncomment its c
+000016c0: 6f6e 7461 696e 696e 670a 7365 6374 696f  ontaining.sectio
+000016d0: 6e20 6e61 6d65 e280 946f 7220 656c 7365  n name...or else
+000016e0: 2062 6f72 676d 6174 6963 2077 6f6e 2774   borgmatic won't
+000016f0: 2072 6563 6f67 6e69 7a65 2074 6865 206f   recognize the o
+00001700: 7074 696f 6e2e 0a0a 596f 7520 6361 6e20  ption...You can 
+00001710: 6765 7420 7468 6520 7361 6d65 2073 616d  get the same sam
+00001720: 706c 6520 636f 6e66 6967 7572 6174 696f  ple configuratio
+00001730: 6e20 6669 6c65 2066 726f 6d20 7468 6520  n file from the 
+00001740: 5b63 6f6e 6669 6775 7261 7469 6f6e 0a72  [configuration.r
+00001750: 6566 6572 656e 6365 5d28 6874 7470 733a  eference](https:
+00001760: 2f2f 746f 7273 696f 6e2e 6f72 672f 626f  //torsion.org/bo
+00001770: 7267 6d61 7469 632f 646f 6373 2f72 6566  rgmatic/docs/ref
+00001780: 6572 656e 6365 2f63 6f6e 6669 6775 7261  erence/configura
+00001790: 7469 6f6e 2f29 2c20 7468 650a 6175 7468  tion/), the.auth
+000017a0: 6f72 6974 6174 6976 6520 7365 7420 6f66  oritative set of
+000017b0: 2061 6c6c 2063 6f6e 6669 6775 7261 7469   all configurati
+000017c0: 6f6e 206f 7074 696f 6e73 2e20 5468 6973  on options. This
+000017d0: 2069 7320 6861 6e64 7920 6966 2062 6f72   is handy if bor
+000017e0: 676d 6174 6963 2068 6173 0a61 6464 6564  gmatic has.added
+000017f0: 206e 6577 206f 7074 696f 6e73 2073 696e   new options sin
+00001800: 6365 2079 6f75 206f 7269 6769 6e61 6c6c  ce you originall
+00001810: 7920 6372 6561 7465 6420 796f 7572 2063  y created your c
+00001820: 6f6e 6669 6775 7261 7469 6f6e 2066 696c  onfiguration fil
+00001830: 652e 2041 6c73 6f0a 6368 6563 6b20 6f75  e. Also.check ou
+00001840: 7420 686f 7720 746f 205b 7570 6772 6164  t how to [upgrad
+00001850: 6520 796f 7572 0a63 6f6e 6669 6775 7261  e your.configura
+00001860: 7469 6f6e 5d28 6874 7470 733a 2f2f 746f  tion](https://to
+00001870: 7273 696f 6e2e 6f72 672f 626f 7267 6d61  rsion.org/borgma
+00001880: 7469 632f 646f 6373 2f68 6f77 2d74 6f2f  tic/docs/how-to/
+00001890: 7570 6772 6164 652f 2375 7067 7261 6469  upgrade/#upgradi
+000018a0: 6e67 2d79 6f75 722d 636f 6e66 6967 7572  ng-your-configur
+000018b0: 6174 696f 6e29 2e0a 0a0a 2323 2320 456e  ation)....### En
+000018c0: 6372 7970 7469 6f6e 0a0a 4966 2079 6f75  cryption..If you
+000018d0: 2065 6e63 7279 7074 2079 6f75 7220 426f   encrypt your Bo
+000018e0: 7267 2072 6570 6f73 6974 6f72 7920 7769  rg repository wi
+000018f0: 7468 2061 2070 6173 7370 6872 6173 6520  th a passphrase 
+00001900: 6f72 2061 206b 6579 2066 696c 652c 2079  or a key file, y
+00001910: 6f75 276c 6c0a 6569 7468 6572 206e 6565  ou'll.either nee
+00001920: 6420 746f 2073 6574 2074 6865 2062 6f72  d to set the bor
+00001930: 676d 6174 6963 2060 656e 6372 7970 7469  gmatic `encrypti
+00001940: 6f6e 5f70 6173 7370 6872 6173 6560 2063  on_passphrase` c
+00001950: 6f6e 6669 6775 7261 7469 6f6e 0a76 6172  onfiguration.var
+00001960: 6961 626c 6520 6f72 2073 6574 2074 6865  iable or set the
+00001970: 2060 424f 5247 5f50 4153 5350 4852 4153   `BORG_PASSPHRAS
+00001980: 4560 2065 6e76 6972 6f6e 6d65 6e74 2076  E` environment v
+00001990: 6172 6961 626c 652e 2053 6565 2074 6865  ariable. See the
+000019a0: 0a5b 7265 706f 7369 746f 7279 2065 6e63  .[repository enc
+000019b0: 7279 7074 696f 6e0a 7365 6374 696f 6e5d  ryption.section]
+000019c0: 2868 7474 7073 3a2f 2f62 6f72 6762 6163  (https://borgbac
+000019d0: 6b75 702e 7265 6164 7468 6564 6f63 732e  kup.readthedocs.
+000019e0: 696f 2f65 6e2f 7374 6162 6c65 2f71 7569  io/en/stable/qui
+000019f0: 636b 7374 6172 742e 6874 6d6c 2372 6570  ckstart.html#rep
+00001a00: 6f73 6974 6f72 792d 656e 6372 7970 7469  ository-encrypti
+00001a10: 6f6e 290a 6f66 2074 6865 2042 6f72 6720  on).of the Borg 
+00001a20: 5175 6963 6b20 5374 6172 7420 666f 7220  Quick Start for 
+00001a30: 6d6f 7265 2069 6e66 6f2e 0a0a 416c 7465  more info...Alte
+00001a40: 726e 6174 6976 656c 792c 2079 6f75 2063  rnatively, you c
+00001a50: 616e 2073 7065 6369 6679 2074 6865 2070  an specify the p
+00001a60: 6173 7370 6872 6173 6520 7072 6f67 7261  assphrase progra
+00001a70: 6d6d 6174 6963 616c 6c79 2062 7920 7365  mmatically by se
+00001a80: 7474 696e 670a 6569 7468 6572 2074 6865  tting.either the
+00001a90: 2062 6f72 676d 6174 6963 2060 656e 6372   borgmatic `encr
+00001aa0: 7970 7469 6f6e 5f70 6173 7363 6f6d 6d61  yption_passcomma
+00001ab0: 6e64 6020 636f 6e66 6967 7572 6174 696f  nd` configuratio
+00001ac0: 6e20 7661 7269 6162 6c65 206f 7220 7468  n variable or th
+00001ad0: 650a 6042 4f52 475f 5041 5353 434f 4d4d  e.`BORG_PASSCOMM
+00001ae0: 414e 4460 2065 6e76 6972 6f6e 6d65 6e74  AND` environment
+00001af0: 2076 6172 6961 626c 652e 2053 6565 2074   variable. See t
+00001b00: 6865 205b 426f 7267 2053 6563 7572 6974  he [Borg Securit
+00001b10: 790a 4641 515d 2868 7474 703a 2f2f 626f  y.FAQ](http://bo
+00001b20: 7267 6261 636b 7570 2e72 6561 6474 6865  rgbackup.readthe
+00001b30: 646f 6373 2e69 6f2f 656e 2f73 7461 626c  docs.io/en/stabl
+00001b40: 652f 6661 712e 6874 6d6c 2368 6f77 2d63  e/faq.html#how-c
+00001b50: 616e 2d69 2d73 7065 6369 6679 2d74 6865  an-i-specify-the
+00001b60: 2d65 6e63 7279 7074 696f 6e2d 7061 7373  -encryption-pass
+00001b70: 7068 7261 7365 2d70 726f 6772 616d 6d61  phrase-programma
+00001b80: 7469 6361 6c6c 7929 0a66 6f72 206d 6f72  tically).for mor
+00001b90: 6520 696e 666f 2e0a 0a0a 2323 2320 5265  e info....### Re
+00001ba0: 6475 6e64 616e 6379 0a0a 4966 2079 6f75  dundancy..If you
+00001bb0: 2764 206c 696b 6520 746f 2063 6f6e 6669  'd like to confi
+00001bc0: 6775 7265 2079 6f75 7220 6261 636b 7570  gure your backup
+00001bd0: 7320 746f 2067 6f20 746f 206d 756c 7469  s to go to multi
+00001be0: 706c 6520 6469 6666 6572 656e 740a 7265  ple different.re
+00001bf0: 706f 7369 746f 7269 6573 2c20 7365 6520  positories, see 
+00001c00: 7468 6520 646f 6375 6d65 6e74 6174 696f  the documentatio
+00001c10: 6e20 6f6e 2068 6f77 2074 6f20 5b6d 616b  n on how to [mak
+00001c20: 6520 6261 636b 7570 730a 7265 6475 6e64  e backups.redund
+00001c30: 616e 745d 2868 7474 7073 3a2f 2f74 6f72  ant](https://tor
+00001c40: 7369 6f6e 2e6f 7267 2f62 6f72 676d 6174  sion.org/borgmat
+00001c50: 6963 2f64 6f63 732f 686f 772d 746f 2f6d  ic/docs/how-to/m
+00001c60: 616b 652d 6261 636b 7570 732d 7265 6475  ake-backups-redu
+00001c70: 6e64 616e 742f 292e 0a0a 0a23 2323 2056  ndant/)....### V
+00001c80: 616c 6964 6174 696f 6e0a 0a49 6620 796f  alidation..If yo
+00001c90: 7527 6420 6c69 6b65 2074 6f20 7661 6c69  u'd like to vali
+00001ca0: 6461 7465 2074 6861 7420 796f 7572 2062  date that your b
+00001cb0: 6f72 676d 6174 6963 2063 6f6e 6669 6775  orgmatic configu
+00001cc0: 7261 7469 6f6e 2069 7320 7661 6c69 642c  ration is valid,
+00001cd0: 2074 6865 0a66 6f6c 6c6f 7769 6e67 2063   the.following c
+00001ce0: 6f6d 6d61 6e64 2069 7320 6176 6169 6c61  ommand is availa
+00001cf0: 626c 6520 666f 7220 7468 6174 3a0a 0a60  ble for that:..`
+00001d00: 6060 6261 7368 0a73 7564 6f20 626f 7267  ``bash.sudo borg
+00001d10: 6d61 7469 6320 636f 6e66 6967 2076 616c  matic config val
+00001d20: 6964 6174 650a 6060 600a 0a3c 7370 616e  idate.```..<span
+00001d30: 2063 6c61 7373 3d22 6d69 6e69 6c69 6e6b   class="minilink
+00001d40: 206d 696e 696c 696e 6b2d 6164 6465 6469   minilink-addedi
+00001d50: 6e22 3e50 7269 6f72 2074 6f20 7665 7273  n">Prior to vers
+00001d60: 696f 6e20 312e 372e 3135 3c2f 7370 616e  ion 1.7.15</span
+00001d70: 3e0a 5661 6c69 6461 7465 2061 2063 6f6e  >.Validate a con
+00001d80: 6669 6775 7261 7469 6f6e 2066 696c 6520  figuration file 
+00001d90: 7769 7468 2074 6869 7320 636f 6d6d 616e  with this comman
+00001da0: 6420 696e 7374 6561 643a 0a0a 6060 6062  d instead:..```b
+00001db0: 6173 680a 7375 646f 2076 616c 6964 6174  ash.sudo validat
+00001dc0: 652d 626f 7267 6d61 7469 632d 636f 6e66  e-borgmatic-conf
+00001dd0: 6967 0a60 6060 0a0a 596f 7527 6c6c 206e  ig.```..You'll n
+00001de0: 6565 6420 746f 2073 7065 6369 6679 2079  eed to specify y
+00001df0: 6f75 7220 636f 6e66 6967 7572 6174 696f  our configuratio
+00001e00: 6e20 6669 6c65 2077 6974 6820 602d 2d63  n file with `--c
+00001e10: 6f6e 6669 6760 2069 6620 6974 2773 206e  onfig` if it's n
+00001e20: 6f74 2069 6e0a 6120 6465 6661 756c 7420  ot in.a default 
+00001e30: 6c6f 6361 7469 6f6e 2e0a 0a54 6869 7320  location...This 
+00001e40: 636f 6d6d 616e 6427 7320 6578 6974 2073  command's exit s
+00001e50: 7461 7475 7320 2860 243f 6020 696e 2042  tatus (`$?` in B
+00001e60: 6173 6829 2069 7320 7a65 726f 2077 6865  ash) is zero whe
+00001e70: 6e20 636f 6e66 6967 7572 6174 696f 6e20  n configuration 
+00001e80: 6973 2076 616c 6964 0a61 6e64 206e 6f6e  is valid.and non
+00001e90: 2d7a 6572 6f20 6f74 6865 7277 6973 652e  -zero otherwise.
+00001ea0: 0a0a 5661 6c69 6461 7469 6e67 2063 6f6e  ..Validating con
+00001eb0: 6669 6775 7261 7469 6f6e 2063 616e 2062  figuration can b
+00001ec0: 6520 7573 6566 756c 2069 6620 796f 7520  e useful if you 
+00001ed0: 6765 6e65 7261 7465 2079 6f75 7220 636f  generate your co
+00001ee0: 6e66 6967 7572 6174 696f 6e0a 6669 6c65  nfiguration.file
+00001ef0: 7320 7669 6120 636f 6e66 6967 7572 6174  s via configurat
+00001f00: 696f 6e20 6d61 6e61 6765 6d65 6e74 2c20  ion management, 
+00001f10: 6f72 2079 6f75 2077 616e 7420 746f 2064  or you want to d
+00001f20: 6f75 626c 6520 6368 6563 6b20 7468 6174  ouble check that
+00001f30: 2079 6f75 7220 6861 6e64 0a65 6469 7473   your hand.edits
+00001f40: 2061 7265 2076 616c 6964 2e0a 0a0a 2323   are valid....##
+00001f50: 2052 6570 6f73 6974 6f72 7920 6372 6561   Repository crea
+00001f60: 7469 6f6e 0a0a 4265 666f 7265 2079 6f75  tion..Before you
+00001f70: 2063 616e 2063 7265 6174 6520 6261 636b   can create back
+00001f80: 7570 7320 7769 7468 2062 6f72 676d 6174  ups with borgmat
+00001f90: 6963 2c20 796f 7520 6669 7273 7420 6e65  ic, you first ne
+00001fa0: 6564 2074 6f20 6372 6561 7465 2061 2042  ed to create a B
+00001fb0: 6f72 670a 7265 706f 7369 746f 7279 2073  org.repository s
+00001fc0: 6f20 796f 7520 6861 7665 2061 2064 6573  o you have a des
+00001fd0: 7469 6e61 7469 6f6e 2066 6f72 2079 6f75  tination for you
+00001fe0: 7220 6261 636b 7570 2061 7263 6869 7665  r backup archive
+00001ff0: 732e 2028 4275 7420 736b 6970 2074 6869  s. (But skip thi
+00002000: 730a 7374 6570 2069 6620 796f 7520 616c  s.step if you al
+00002010: 7265 6164 7920 6861 7665 2061 2042 6f72  ready have a Bor
+00002020: 6720 7265 706f 7369 746f 7279 2e29 2054  g repository.) T
+00002030: 6f20 6372 6561 7465 2061 2072 6570 6f73  o create a repos
+00002040: 6974 6f72 792c 2072 756e 2061 0a63 6f6d  itory, run a.com
+00002050: 6d61 6e64 206c 696b 6520 7468 6520 666f  mand like the fo
+00002060: 6c6c 6f77 696e 6720 7769 7468 2042 6f72  llowing with Bor
+00002070: 6720 312e 783a 0a0a 6060 6062 6173 680a  g 1.x:..```bash.
+00002080: 7375 646f 2062 6f72 676d 6174 6963 2069  sudo borgmatic i
+00002090: 6e69 7420 2d2d 656e 6372 7970 7469 6f6e  nit --encryption
+000020a0: 2072 6570 6f6b 6579 0a60 6060 0a0a 3c73   repokey.```..<s
+000020b0: 7061 6e20 636c 6173 733d 226d 696e 696c  pan class="minil
+000020c0: 696e 6b20 6d69 6e69 6c69 6e6b 2d61 6464  ink minilink-add
+000020d0: 6564 696e 223e 4e65 7720 696e 2062 6f72  edin">New in bor
+000020e0: 676d 6174 6963 2076 6572 7369 6f6e 2031  gmatic version 1
+000020f0: 2e37 2e30 3c2f 7370 616e 3e0a 4f72 2c20  .7.0</span>.Or, 
+00002100: 7769 7468 2042 6f72 6720 322e 783a 0a0a  with Borg 2.x:..
+00002110: 6060 6062 6173 680a 7375 646f 2062 6f72  ```bash.sudo bor
+00002120: 676d 6174 6963 2072 6372 6561 7465 202d  gmatic rcreate -
+00002130: 2d65 6e63 7279 7074 696f 6e20 7265 706f  -encryption repo
+00002140: 6b65 792d 6165 732d 6f63 620a 6060 600a  key-aes-ocb.```.
+00002150: 0a28 4e6f 7465 2074 6861 7420 6072 6570  .(Note that `rep
+00002160: 6f6b 6579 2d63 6861 6368 6132 302d 706f  okey-chacha20-po
+00002170: 6c79 3133 3035 6020 6d61 7920 6265 2066  ly1305` may be f
+00002180: 6173 7465 7220 7468 616e 2060 7265 706f  aster than `repo
+00002190: 6b65 792d 6165 732d 6f63 6260 206f 6e0a  key-aes-ocb` on.
+000021a0: 6365 7274 6169 6e20 706c 6174 666f 726d  certain platform
+000021b0: 7320 6c69 6b65 2041 524d 3634 2e29 0a0a  s like ARM64.)..
+000021c0: 5468 6973 2075 7365 7320 7468 6520 626f  This uses the bo
+000021d0: 7267 6d61 7469 6320 636f 6e66 6967 7572  rgmatic configur
+000021e0: 6174 696f 6e20 6669 6c65 2079 6f75 2063  ation file you c
+000021f0: 7265 6174 6564 2061 626f 7665 2074 6f20  reated above to 
+00002200: 6465 7465 726d 696e 650a 7768 6963 6820  determine.which 
+00002210: 6c6f 6361 6c20 6f72 2072 656d 6f74 6520  local or remote 
+00002220: 7265 706f 7369 746f 7279 2074 6f20 6372  repository to cr
+00002230: 6561 7465 2c20 616e 6420 656e 6372 7970  eate, and encryp
+00002240: 7473 2069 7420 7769 7468 2074 6865 0a65  ts it with the.e
+00002250: 6e63 7279 7074 696f 6e20 7061 7373 7068  ncryption passph
+00002260: 7261 7365 2073 7065 6369 6669 6564 2074  rase specified t
+00002270: 6865 7265 2069 6620 6f6e 6520 6973 2070  here if one is p
+00002280: 726f 7669 6465 642e 2052 6561 6420 6162  rovided. Read ab
+00002290: 6f75 7420 5b42 6f72 670a 656e 6372 7970  out [Borg.encryp
+000022a0: 7469 6f6e 0a6d 6f64 6573 5d28 6874 7470  tion.modes](http
+000022b0: 733a 2f2f 626f 7267 6261 636b 7570 2e72  s://borgbackup.r
+000022c0: 6561 6474 6865 646f 6373 2e69 6f2f 656e  eadthedocs.io/en
+000022d0: 2f73 7461 626c 652f 7573 6167 652f 696e  /stable/usage/in
+000022e0: 6974 2e68 746d 6c23 656e 6372 7970 7469  it.html#encrypti
+000022f0: 6f6e 2d6d 6f64 652d 746c 6472 290a 666f  on-mode-tldr).fo
+00002300: 7220 7468 6520 6d65 6e75 206f 6620 6176  r the menu of av
+00002310: 6169 6c61 626c 6520 656e 6372 7970 7469  ailable encrypti
+00002320: 6f6e 206d 6f64 6573 2e0a 0a41 6c73 6f2c  on modes...Also,
+00002330: 206f 7074 696f 6e61 6c6c 7920 6368 6563   optionally chec
+00002340: 6b20 6f75 7420 7468 6520 5b42 6f72 6720  k out the [Borg 
+00002350: 5175 6963 6b0a 5374 6172 745d 2868 7474  Quick.Start](htt
+00002360: 7073 3a2f 2f62 6f72 6762 6163 6b75 702e  ps://borgbackup.
+00002370: 7265 6164 7468 6564 6f63 732e 6f72 672f  readthedocs.org/
+00002380: 656e 2f73 7461 626c 652f 7175 6963 6b73  en/stable/quicks
+00002390: 7461 7274 2e68 746d 6c29 2066 6f72 206d  tart.html) for m
+000023a0: 6f72 650a 6261 636b 6772 6f75 6e64 2061  ore.background a
+000023b0: 626f 7574 2072 6570 6f73 6974 6f72 7920  bout repository 
+000023c0: 6372 6561 7469 6f6e 2e0a 0a4e 6f74 6520  creation...Note 
+000023d0: 7468 6174 2062 6f72 676d 6174 6963 2073  that borgmatic s
+000023e0: 6b69 7073 2072 6570 6f73 6974 6f72 7920  kips repository 
+000023f0: 6372 6561 7469 6f6e 2069 6620 7468 6520  creation if the 
+00002400: 7265 706f 7369 746f 7279 2061 6c72 6561  repository alrea
+00002410: 6479 0a65 7869 7374 732e 2054 6869 7320  dy.exists. This 
+00002420: 7375 7070 6f72 7473 2075 7365 2063 6173  supports use cas
+00002430: 6573 206c 696b 6520 656e 7375 7269 6e67  es like ensuring
+00002440: 2061 2072 6570 6f73 6974 6f72 7920 6578   a repository ex
+00002450: 6973 7473 2070 7269 6f72 2074 6f0a 7065  ists prior to.pe
+00002460: 7266 6f72 6d69 6e67 2061 2062 6163 6b75  rforming a backu
+00002470: 702e 0a0a 4966 2074 6865 2072 6570 6f73  p...If the repos
+00002480: 6974 6f72 7920 6973 206f 6e20 6120 7265  itory is on a re
+00002490: 6d6f 7465 2068 6f73 742c 206d 616b 6520  mote host, make 
+000024a0: 7375 7265 2074 6861 7420 796f 7572 206c  sure that your l
+000024b0: 6f63 616c 2075 7365 7220 6861 730a 6b65  ocal user has.ke
+000024c0: 792d 6261 7365 6420 5353 4820 6163 6365  y-based SSH acce
+000024d0: 7373 2074 6f20 7468 6520 6465 7369 7265  ss to the desire
+000024e0: 6420 7573 6572 2061 6363 6f75 6e74 206f  d user account o
+000024f0: 6e20 7468 6520 7265 6d6f 7465 2068 6f73  n the remote hos
+00002500: 742e 0a0a 0a23 2320 4261 636b 7570 730a  t....## Backups.
+00002510: 0a4e 6f77 2074 6861 7420 796f 7527 7665  .Now that you've
+00002520: 2063 6f6e 6669 6775 7265 6420 626f 7267   configured borg
+00002530: 6d61 7469 6320 616e 6420 6372 6561 7465  matic and create
+00002540: 6420 6120 7265 706f 7369 746f 7279 2c20  d a repository, 
+00002550: 6974 2773 2061 2067 6f6f 640a 6964 6561  it's a good.idea
+00002560: 2074 6f20 7465 7374 2074 6861 7420 626f   to test that bo
+00002570: 7267 6d61 7469 6320 6973 2077 6f72 6b69  rgmatic is worki
+00002580: 6e67 2e20 536f 2074 6f20 7275 6e20 626f  ng. So to run bo
+00002590: 7267 6d61 7469 6320 616e 6420 7374 6172  rgmatic and star
+000025a0: 7420 610a 6261 636b 7570 2c20 796f 7520  t a.backup, you 
+000025b0: 6361 6e20 696e 766f 6b65 2069 7420 6c69  can invoke it li
+000025c0: 6b65 2074 6869 733a 0a0a 6060 6062 6173  ke this:..```bas
+000025d0: 680a 7375 646f 2062 6f72 676d 6174 6963  h.sudo borgmatic
+000025e0: 2063 7265 6174 6520 2d2d 7665 7262 6f73   create --verbos
+000025f0: 6974 7920 3120 2d2d 6c69 7374 202d 2d73  ity 1 --list --s
+00002600: 7461 7473 0a60 6060 0a0a 284e 6f20 626f  tats.```..(No bo
+00002610: 7267 6d61 7469 6320 602d 2d6c 6973 7460  rgmatic `--list`
+00002620: 2066 6c61 673f 2054 7279 2060 2d2d 6669   flag? Try `--fi
+00002630: 6c65 7360 2069 6e73 7465 6164 2c20 6c65  les` instead, le
+00002640: 6176 6520 6974 206f 7574 2c20 6f72 2075  ave it out, or u
+00002650: 7067 7261 6465 0a62 6f72 676d 6174 6963  pgrade.borgmatic
+00002660: 2129 0a0a 5468 6520 602d 2d76 6572 626f  !)..The `--verbo
+00002670: 7369 7479 6020 666c 6167 206d 616b 6573  sity` flag makes
+00002680: 2062 6f72 676d 6174 6963 2073 686f 7720   borgmatic show 
+00002690: 7468 6520 7374 6570 7320 6974 2773 2070  the steps it's p
+000026a0: 6572 666f 726d 696e 672e 2054 6865 0a60  erforming. The.`
+000026b0: 2d2d 6c69 7374 6020 666c 6167 206c 6973  --list` flag lis
+000026c0: 7473 2065 6163 6820 6669 6c65 2074 6861  ts each file tha
+000026d0: 7427 7320 6e65 7720 6f72 2063 6861 6e67  t's new or chang
+000026e0: 6564 2073 696e 6365 2074 6865 206c 6173  ed since the las
+000026f0: 7420 6261 636b 7570 2e20 416e 640a 602d  t backup. And.`-
+00002700: 2d73 7461 7473 6020 7368 6f77 7320 7375  -stats` shows su
+00002710: 6d6d 6172 7920 696e 666f 726d 6174 696f  mmary informatio
+00002720: 6e20 6162 6f75 7420 7468 6520 6372 6561  n about the crea
+00002730: 7465 6420 6172 6368 6976 652e 2041 6c6c  ted archive. All
+00002740: 206f 6620 7468 6573 650a 666c 6167 7320   of these.flags 
+00002750: 6172 6520 6f70 7469 6f6e 616c 2e0a 0a41  are optional...A
+00002760: 7320 7468 6520 636f 6d6d 616e 6420 7275  s the command ru
+00002770: 6e73 2c20 796f 7520 7368 6f75 6c64 2065  ns, you should e
+00002780: 7965 6261 6c6c 2074 6865 206f 7574 7075  yeball the outpu
+00002790: 7420 746f 2073 6565 2069 6620 6974 206d  t to see if it m
+000027a0: 6174 6368 6573 2079 6f75 720a 6578 7065  atches your.expe
+000027b0: 6374 6174 696f 6e73 2062 6173 6564 206f  ctations based o
+000027c0: 6e20 796f 7572 2063 6f6e 6669 6775 7261  n your configura
+000027d0: 7469 6f6e 2e0a 0a49 6620 796f 7527 6420  tion...If you'd 
+000027e0: 6c69 6b65 2074 6f20 7370 6563 6966 7920  like to specify 
+000027f0: 616e 2061 6c74 6572 6e61 7465 2063 6f6e  an alternate con
+00002800: 6669 6775 7261 7469 6f6e 2066 696c 6520  figuration file 
+00002810: 7061 7468 2c20 7573 6520 7468 650a 602d  path, use the.`-
+00002820: 2d63 6f6e 6669 6760 2066 6c61 672e 0a0a  -config` flag...
+00002830: 5365 6520 6062 6f72 676d 6174 6963 202d  See `borgmatic -
+00002840: 2d68 656c 7060 2061 6e64 2060 626f 7267  -help` and `borg
+00002850: 6d61 7469 6320 6372 6561 7465 202d 2d68  matic create --h
+00002860: 656c 7060 2066 6f72 206d 6f72 6520 696e  elp` for more in
+00002870: 666f 726d 6174 696f 6e2e 0a0a 0a23 2320  formation....## 
+00002880: 4465 6661 756c 7420 6163 7469 6f6e 730a  Default actions.
+00002890: 0a49 6620 796f 7520 6f6d 6974 2060 6372  .If you omit `cr
+000028a0: 6561 7465 6020 616e 6420 6f74 6865 7220  eate` and other 
+000028b0: 6163 7469 6f6e 732c 2062 6f72 676d 6174  actions, borgmat
+000028c0: 6963 2072 756e 7320 7468 726f 7567 6820  ic runs through 
+000028d0: 6120 7365 7420 6f66 0a64 6566 6175 6c74  a set of.default
+000028e0: 2061 6374 696f 6e73 3a20 6070 7275 6e65   actions: `prune
+000028f0: 6020 616e 7920 6f6c 6420 6261 636b 7570  ` any old backup
+00002900: 7320 6173 2070 6572 2074 6865 2063 6f6e  s as per the con
+00002910: 6669 6775 7265 6420 7265 7465 6e74 696f  figured retentio
+00002920: 6e0a 706f 6c69 6379 2c20 6063 6f6d 7061  n.policy, `compa
+00002930: 6374 6020 7365 676d 656e 7473 2074 6f20  ct` segments to 
+00002940: 6672 6565 2075 7020 7370 6163 6520 2877  free up space (w
+00002950: 6974 6820 426f 7267 2031 2e32 2b2c 2062  ith Borg 1.2+, b
+00002960: 6f72 676d 6174 6963 0a31 2e35 2e32 332b  orgmatic.1.5.23+
+00002970: 292c 2060 6372 6561 7465 6020 6120 6261  ), `create` a ba
+00002980: 636b 7570 2c20 2a61 6e64 2a20 6063 6865  ckup, *and* `che
+00002990: 636b 6020 6261 636b 7570 7320 666f 7220  ck` backups for 
+000029a0: 636f 6e73 6973 7465 6e63 7920 7072 6f62  consistency prob
+000029b0: 6c65 6d73 0a64 7565 2074 6f20 7468 696e  lems.due to thin
+000029c0: 6773 206c 696b 6520 6669 6c65 2064 616d  gs like file dam
+000029d0: 6167 652e 2046 6f72 2069 6e73 7461 6e63  age. For instanc
+000029e0: 653a 0a0a 6060 6062 6173 680a 7375 646f  e:..```bash.sudo
+000029f0: 2062 6f72 676d 6174 6963 202d 2d76 6572   borgmatic --ver
+00002a00: 626f 7369 7479 2031 202d 2d6c 6973 7420  bosity 1 --list 
+00002a10: 2d2d 7374 6174 730a 6060 600a 0a23 2320  --stats.```..## 
+00002a20: 4175 746f 7069 6c6f 740a 0a52 756e 6e69  Autopilot..Runni
+00002a30: 6e67 2062 6163 6b75 7073 206d 616e 7561  ng backups manua
+00002a40: 6c6c 7920 6973 2067 6f6f 6420 666f 7220  lly is good for 
+00002a50: 7661 6c69 6461 7469 6e67 2079 6f75 7220  validating your 
+00002a60: 636f 6e66 6967 7572 6174 696f 6e2c 2062  configuration, b
+00002a70: 7574 2049 276d 0a67 7565 7373 696e 6720  ut I'm.guessing 
+00002a80: 7468 6174 2079 6f75 2077 616e 7420 746f  that you want to
+00002a90: 2072 756e 2062 6f72 676d 6174 6963 2061   run borgmatic a
+00002aa0: 7574 6f6d 6174 6963 616c 6c79 2c20 7361  utomatically, sa
+00002ab0: 7920 6f6e 6365 2061 2064 6179 2e20 546f  y once a day. To
+00002ac0: 2064 6f0a 7468 6174 2c20 796f 7520 6361   do.that, you ca
+00002ad0: 6e20 636f 6e66 6967 7572 6520 6120 7365  n configure a se
+00002ae0: 7061 7261 7465 206a 6f62 2072 756e 6e65  parate job runne
+00002af0: 7220 746f 2069 6e76 6f6b 6520 6974 2070  r to invoke it p
+00002b00: 6572 696f 6469 6361 6c6c 792e 0a0a 2323  eriodically...##
+00002b10: 2320 6372 6f6e 0a0a 4966 2079 6f75 2772  # cron..If you'r
+00002b20: 6520 7573 696e 6720 6372 6f6e 2c20 646f  e using cron, do
+00002b30: 776e 6c6f 6164 2074 6865 205b 7361 6d70  wnload the [samp
+00002b40: 6c65 2063 726f 6e0a 6669 6c65 5d28 6874  le cron.file](ht
+00002b50: 7470 733a 2f2f 7072 6f6a 6563 7473 2e74  tps://projects.t
+00002b60: 6f72 7369 6f6e 2e6f 7267 2f62 6f72 676d  orsion.org/borgm
+00002b70: 6174 6963 2d63 6f6c 6c65 6374 6976 652f  atic-collective/
+00002b80: 626f 7267 6d61 7469 632f 7372 632f 6d61  borgmatic/src/ma
+00002b90: 696e 2f73 616d 706c 652f 6372 6f6e 2f62  in/sample/cron/b
+00002ba0: 6f72 676d 6174 6963 292e 0a54 6865 6e2c  orgmatic)..Then,
+00002bb0: 2066 726f 6d20 7468 6520 6469 7265 6374   from the direct
+00002bc0: 6f72 7920 7768 6572 6520 796f 7520 646f  ory where you do
+00002bd0: 776e 6c6f 6164 6564 2069 743a 0a0a 6060  wnloaded it:..``
+00002be0: 6062 6173 680a 7375 646f 206d 7620 626f  `bash.sudo mv bo
+00002bf0: 7267 6d61 7469 6320 2f65 7463 2f63 726f  rgmatic /etc/cro
+00002c00: 6e2e 642f 626f 7267 6d61 7469 630a 7375  n.d/borgmatic.su
+00002c10: 646f 2063 686d 6f64 202b 7820 2f65 7463  do chmod +x /etc
+00002c20: 2f63 726f 6e2e 642f 626f 7267 6d61 7469  /cron.d/borgmati
+00002c30: 630a 6060 600a 0a49 6620 626f 7267 6d61  c.```..If borgma
+00002c40: 7469 6320 6973 2069 6e73 7461 6c6c 6564  tic is installed
+00002c50: 2061 7420 6120 6469 6666 6572 656e 7420   at a different 
+00002c60: 6c6f 6361 7469 6f6e 2074 6861 6e0a 602f  location than.`/
+00002c70: 726f 6f74 2f2e 6c6f 6361 6c2f 6269 6e2f  root/.local/bin/
+00002c80: 626f 7267 6d61 7469 6360 2c20 6564 6974  borgmatic`, edit
+00002c90: 2074 6865 2063 726f 6e20 6669 6c65 2077   the cron file w
+00002ca0: 6974 6820 7468 6520 636f 7272 6563 7420  ith the correct 
+00002cb0: 7061 7468 2e20 596f 750a 6361 6e20 616c  path. You.can al
+00002cc0: 736f 206d 6f64 6966 7920 7468 6520 6372  so modify the cr
+00002cd0: 6f6e 2066 696c 6520 6966 2079 6f75 2764  on file if you'd
+00002ce0: 206c 696b 6520 746f 2072 756e 2062 6f72   like to run bor
+00002cf0: 676d 6174 6963 206d 6f72 6520 6f72 206c  gmatic more or l
+00002d00: 6573 730a 6672 6571 7565 6e74 6c79 2e0a  ess.frequently..
+00002d10: 0a23 2323 2073 7973 7465 6d64 0a0a 4966  .### systemd..If
+00002d20: 2079 6f75 2772 6520 7573 696e 6720 7379   you're using sy
+00002d30: 7374 656d 6420 696e 7374 6561 6420 6f66  stemd instead of
+00002d40: 2063 726f 6e20 746f 2072 756e 206a 6f62   cron to run job
+00002d50: 732c 2079 6f75 2063 616e 2073 7469 6c6c  s, you can still
+00002d60: 2063 6f6e 6669 6775 7265 0a62 6f72 676d   configure.borgm
+00002d70: 6174 6963 2074 6f20 7275 6e20 6175 746f  atic to run auto
+00002d80: 6d61 7469 6361 6c6c 792e 0a0a 2849 6620  matically...(If 
+00002d90: 796f 7520 696e 7374 616c 6c65 6420 626f  you installed bo
+00002da0: 7267 6d61 7469 6320 6672 6f6d 205b 4f74  rgmatic from [Ot
+00002db0: 6865 7220 7761 7973 2074 6f0a 696e 7374  her ways to.inst
+00002dc0: 616c 6c5d 2868 7474 7073 3a2f 2f74 6f72  all](https://tor
+00002dd0: 7369 6f6e 2e6f 7267 2f62 6f72 676d 6174  sion.org/borgmat
+00002de0: 6963 2f64 6f63 732f 686f 772d 746f 2f73  ic/docs/how-to/s
+00002df0: 6574 2d75 702d 6261 636b 7570 732f 236f  et-up-backups/#o
+00002e00: 7468 6572 2d77 6179 732d 746f 2d69 6e73  ther-ways-to-ins
+00002e10: 7461 6c6c 292c 0a79 6f75 206d 6179 2061  tall),.you may a
+00002e20: 6c72 6561 6479 2068 6176 6520 626f 7267  lready have borg
+00002e30: 6d61 7469 6320 7379 7374 656d 6420 7365  matic systemd se
+00002e40: 7276 6963 6520 616e 6420 7469 6d65 7220  rvice and timer 
+00002e50: 6669 6c65 732e 2049 6620 736f 2c20 796f  files. If so, yo
+00002e60: 7520 6d61 790a 6265 2061 626c 6520 746f  u may.be able to
+00002e70: 2073 6b69 7020 736f 6d65 206f 6620 7468   skip some of th
+00002e80: 6520 7374 6570 7320 6265 6c6f 772e 290a  e steps below.).
+00002e90: 0a46 6972 7374 2c20 646f 776e 6c6f 6164  .First, download
+00002ea0: 2074 6865 205b 7361 6d70 6c65 2073 7973   the [sample sys
+00002eb0: 7465 6d64 2073 6572 7669 6365 0a66 696c  temd service.fil
+00002ec0: 655d 2868 7474 7073 3a2f 2f70 726f 6a65  e](https://proje
+00002ed0: 6374 732e 746f 7273 696f 6e2e 6f72 672f  cts.torsion.org/
+00002ee0: 626f 7267 6d61 7469 632d 636f 6c6c 6563  borgmatic-collec
+00002ef0: 7469 7665 2f62 6f72 676d 6174 6963 2f72  tive/borgmatic/r
+00002f00: 6177 2f62 7261 6e63 682f 6d61 696e 2f73  aw/branch/main/s
+00002f10: 616d 706c 652f 7379 7374 656d 642f 626f  ample/systemd/bo
+00002f20: 7267 6d61 7469 632e 7365 7276 6963 6529  rgmatic.service)
+00002f30: 0a61 6e64 2074 6865 205b 7361 6d70 6c65  .and the [sample
+00002f40: 2073 7973 7465 6d64 2074 696d 6572 0a66   systemd timer.f
+00002f50: 696c 655d 2868 7474 7073 3a2f 2f70 726f  ile](https://pro
+00002f60: 6a65 6374 732e 746f 7273 696f 6e2e 6f72  jects.torsion.or
+00002f70: 672f 626f 7267 6d61 7469 632d 636f 6c6c  g/borgmatic-coll
+00002f80: 6563 7469 7665 2f62 6f72 676d 6174 6963  ective/borgmatic
+00002f90: 2f72 6177 2f62 7261 6e63 682f 6d61 696e  /raw/branch/main
+00002fa0: 2f73 616d 706c 652f 7379 7374 656d 642f  /sample/systemd/
+00002fb0: 626f 7267 6d61 7469 632e 7469 6d65 7229  borgmatic.timer)
+00002fc0: 2e0a 0a54 6865 6e2c 2066 726f 6d20 7468  ...Then, from th
+00002fd0: 6520 6469 7265 6374 6f72 7920 7768 6572  e directory wher
+00002fe0: 6520 796f 7520 646f 776e 6c6f 6164 6564  e you downloaded
+00002ff0: 2074 6865 6d3a 0a0a 6060 6062 6173 680a   them:..```bash.
+00003000: 7375 646f 206d 7620 626f 7267 6d61 7469  sudo mv borgmati
+00003010: 632e 7365 7276 6963 6520 626f 7267 6d61  c.service borgma
+00003020: 7469 632e 7469 6d65 7220 2f65 7463 2f73  tic.timer /etc/s
+00003030: 7973 7465 6d64 2f73 7973 7465 6d2f 0a73  ystemd/system/.s
+00003040: 7564 6f20 7379 7374 656d 6374 6c20 656e  udo systemctl en
+00003050: 6162 6c65 202d 2d6e 6f77 2062 6f72 676d  able --now borgm
+00003060: 6174 6963 2e74 696d 6572 0a60 6060 0a0a  atic.timer.```..
+00003070: 5265 7669 6577 2074 6865 2073 6563 7572  Review the secur
+00003080: 6974 7920 7365 7474 696e 6773 2069 6e20  ity settings in 
+00003090: 7468 6520 7365 7276 6963 6520 6669 6c65  the service file
+000030a0: 2061 6e64 2075 7064 6174 6520 7468 656d   and update them
+000030b0: 2061 7320 6e65 6564 6564 2e0a 4966 2060   as needed..If `
+000030c0: 5072 6f74 6563 7453 7973 7465 6d3d 7374  ProtectSystem=st
+000030d0: 7269 6374 6020 6973 2065 6e61 626c 6564  rict` is enabled
+000030e0: 2061 6e64 206c 6f63 616c 2072 6570 6f73   and local repos
+000030f0: 6974 6f72 6965 7320 6172 6520 7573 6564  itories are used
+00003100: 2c20 7468 656e 0a74 6865 2072 6570 6f73  , then.the repos
+00003110: 6974 6f72 7920 7061 7468 206d 7573 7420  itory path must 
+00003120: 6265 2061 6464 6564 2074 6f20 7468 6520  be added to the 
+00003130: 6052 6561 6457 7269 7465 5061 7468 7360  `ReadWritePaths`
+00003140: 206c 6973 742e 0a0a 4665 656c 2066 7265   list...Feel fre
+00003150: 6520 746f 206d 6f64 6966 7920 7468 6520  e to modify the 
+00003160: 7469 6d65 7220 6669 6c65 2062 6173 6564  timer file based
+00003170: 206f 6e20 686f 7720 6672 6571 7565 6e74   on how frequent
+00003180: 6c79 2079 6f75 2764 206c 696b 650a 626f  ly you'd like.bo
+00003190: 7267 6d61 7469 6320 746f 2072 756e 2e0a  rgmatic to run..
+000031a0: 0a23 2323 206c 6175 6e63 6864 2069 6e20  .### launchd in 
+000031b0: 6d61 634f 530a 0a49 6620 796f 7520 7275  macOS..If you ru
+000031c0: 6e20 626f 7267 6d61 7469 6320 696e 206d  n borgmatic in m
+000031d0: 6163 4f53 2077 6974 6820 6c61 756e 6368  acOS with launch
+000031e0: 642c 2079 6f75 206d 6179 2065 6e63 6f75  d, you may encou
+000031f0: 6e74 6572 2070 6572 6d69 7373 696f 6e73  nter permissions
+00003200: 0a69 7373 7565 7320 7768 656e 2072 6561  .issues when rea
+00003210: 6469 6e67 2066 696c 6573 2074 6f20 6261  ding files to ba
+00003220: 636b 7570 2e20 4966 2074 6861 7420 6861  ckup. If that ha
+00003230: 7070 656e 7320 746f 2079 6f75 2c20 796f  ppens to you, yo
+00003240: 7520 6d61 7920 6265 0a69 6e74 6572 6573  u may be.interes
+00003250: 7465 6420 696e 2061 6e20 5b75 6e6f 6666  ted in an [unoff
+00003260: 6963 6961 6c20 776f 726b 2d61 726f 756e  icial work-aroun
+00003270: 6420 666f 7220 4675 6c6c 2044 6973 6b0a  d for Full Disk.
+00003280: 4163 6365 7373 5d28 6874 7470 733a 2f2f  Access](https://
+00003290: 7072 6f6a 6563 7473 2e74 6f72 7369 6f6e  projects.torsion
+000032a0: 2e6f 7267 2f62 6f72 676d 6174 6963 2d63  .org/borgmatic-c
+000032b0: 6f6c 6c65 6374 6976 652f 626f 7267 6d61  ollective/borgma
+000032c0: 7469 632f 6973 7375 6573 2f32 3933 292e  tic/issues/293).
+000032d0: 0a0a 0a23 2320 4e69 6365 7469 6573 0a0a  ...## Niceties..
+000032e0: 0a23 2323 2053 6865 6c6c 2063 6f6d 706c  .### Shell compl
+000032f0: 6574 696f 6e0a 0a62 6f72 676d 6174 6963  etion..borgmatic
+00003300: 2069 6e63 6c75 6465 7320 6120 7368 656c   includes a shel
+00003310: 6c20 636f 6d70 6c65 7469 6f6e 2073 6372  l completion scr
+00003320: 6970 7420 2863 7572 7265 6e74 6c79 206f  ipt (currently o
+00003330: 6e6c 7920 666f 7220 4261 7368 2061 6e64  nly for Bash and
+00003340: 2046 6973 6829 2074 6f0a 7375 7070 6f72   Fish) to.suppor
+00003350: 7420 7461 622d 636f 6d70 6c65 7469 6e67  t tab-completing
+00003360: 2062 6f72 676d 6174 6963 2063 6f6d 6d61   borgmatic comma
+00003370: 6e64 2d6c 696e 6520 6163 7469 6f6e 7320  nd-line actions 
+00003380: 616e 6420 666c 6167 732e 2044 6570 656e  and flags. Depen
+00003390: 6469 6e67 206f 6e0a 686f 7720 796f 7520  ding on.how you 
+000033a0: 696e 7374 616c 6c65 6420 626f 7267 6d61  installed borgma
+000033b0: 7469 632c 2074 6869 7320 6d61 7920 6265  tic, this may be
+000033c0: 2065 6e61 626c 6564 2062 7920 6465 6661   enabled by defa
+000033d0: 756c 742e 0a0a 2323 2323 2042 6173 680a  ult...#### Bash.
+000033e0: 0a49 6620 636f 6d70 6c65 7469 6f6e 7320  .If completions 
+000033f0: 6172 656e 2774 2065 6e61 626c 6564 2c20  aren't enabled, 
+00003400: 7374 6172 7420 6279 2069 6e73 7461 6c6c  start by install
+00003410: 696e 6720 7468 6520 6062 6173 682d 636f  ing the `bash-co
+00003420: 6d70 6c65 7469 6f6e 6020 4c69 6e75 7820  mpletion` Linux 
+00003430: 7061 636b 6167 6520 6f72 2074 6865 0a5b  package or the.[
+00003440: 6062 6173 682d 636f 6d70 6c65 7469 6f6e  `bash-completion
+00003450: 4032 605d 2868 7474 7073 3a2f 2f66 6f72  @2`](https://for
+00003460: 6d75 6c61 652e 6272 6577 2e73 682f 666f  mulae.brew.sh/fo
+00003470: 726d 756c 612f 6261 7368 2d63 6f6d 706c  rmula/bash-compl
+00003480: 6574 696f 6e40 3229 0a6d 6163 4f53 2048  etion@2).macOS H
+00003490: 6f6d 6562 7265 7720 666f 726d 756c 612e  omebrew formula.
+000034a0: 2054 6865 6e2c 2069 6e73 7461 6c6c 2074   Then, install t
+000034b0: 6865 2073 6865 6c6c 2063 6f6d 706c 6574  he shell complet
+000034c0: 696f 6e20 7363 7269 7074 2067 6c6f 6261  ion script globa
+000034d0: 6c6c 793a 0a0a 6060 6062 6173 680a 7375  lly:..```bash.su
+000034e0: 646f 2073 7520 2d63 2022 626f 7267 6d61  do su -c "borgma
+000034f0: 7469 6320 2d2d 6261 7368 2d63 6f6d 706c  tic --bash-compl
+00003500: 6574 696f 6e20 3e20 2428 706b 672d 636f  etion > $(pkg-co
+00003510: 6e66 6967 202d 2d76 6172 6961 626c 653d  nfig --variable=
+00003520: 636f 6d70 6c65 7469 6f6e 7364 6972 2062  completionsdir b
+00003530: 6173 682d 636f 6d70 6c65 7469 6f6e 292f  ash-completion)/
+00003540: 626f 7267 6d61 7469 6322 0a60 6060 0a0a  borgmatic".```..
+00003550: 4966 2079 6f75 2064 6f6e 2774 2068 6176  If you don't hav
+00003560: 6520 6070 6b67 2d63 6f6e 6669 6760 2069  e `pkg-config` i
+00003570: 6e73 7461 6c6c 6564 2c20 796f 7520 6361  nstalled, you ca
+00003580: 6e20 7472 7920 7468 6520 666f 6c6c 6f77  n try the follow
+00003590: 696e 6720 7061 7468 0a69 6e73 7465 6164  ing path.instead
+000035a0: 3a0a 0a60 6060 6261 7368 0a73 7564 6f20  :..```bash.sudo 
+000035b0: 7375 202d 6320 2262 6f72 676d 6174 6963  su -c "borgmatic
+000035c0: 202d 2d62 6173 682d 636f 6d70 6c65 7469   --bash-completi
+000035d0: 6f6e 203e 202f 7573 722f 7368 6172 652f  on > /usr/share/
+000035e0: 6261 7368 2d63 6f6d 706c 6574 696f 6e2f  bash-completion/
+000035f0: 636f 6d70 6c65 7469 6f6e 732f 626f 7267  completions/borg
+00003600: 6d61 7469 6322 0a60 6060 0a0a 4f72 2c20  matic".```..Or, 
+00003610: 6966 2079 6f75 2764 206c 696b 6520 746f  if you'd like to
+00003620: 2069 6e73 7461 6c6c 2074 6865 2073 6372   install the scr
+00003630: 6970 7420 666f 7220 6f6e 6c79 2074 6865  ipt for only the
+00003640: 2063 7572 7265 6e74 2075 7365 723a 0a0a   current user:..
+00003650: 6060 6062 6173 680a 6d6b 6469 7220 2d2d  ```bash.mkdir --
+00003660: 7061 7265 6e74 7320 7e2f 2e6c 6f63 616c  parents ~/.local
+00003670: 2f73 6861 7265 2f62 6173 682d 636f 6d70  /share/bash-comp
+00003680: 6c65 7469 6f6e 2f63 6f6d 706c 6574 696f  letion/completio
+00003690: 6e73 0a62 6f72 676d 6174 6963 202d 2d62  ns.borgmatic --b
+000036a0: 6173 682d 636f 6d70 6c65 7469 6f6e 203e  ash-completion >
+000036b0: 207e 2f2e 6c6f 6361 6c2f 7368 6172 652f   ~/.local/share/
+000036c0: 6261 7368 2d63 6f6d 706c 6574 696f 6e2f  bash-completion/
+000036d0: 636f 6d70 6c65 7469 6f6e 732f 626f 7267  completions/borg
+000036e0: 6d61 7469 630a 6060 600a 0a46 696e 616c  matic.```..Final
+000036f0: 6c79 2c20 7265 7374 6172 7420 796f 7572  ly, restart your
+00003700: 2073 6865 6c6c 2028 6065 7869 7460 2061   shell (`exit` a
+00003710: 6e64 206f 7065 6e20 6120 6e65 7720 7368  nd open a new sh
+00003720: 656c 6c29 2073 6f20 7468 6520 636f 6d70  ell) so the comp
+00003730: 6c65 7469 6f6e 730a 7461 6b65 2065 6666  letions.take eff
+00003740: 6563 742e 0a0a 2323 2323 2066 6973 680a  ect...#### fish.
+00003750: 0a54 6f20 6164 6420 636f 6d70 6c65 7469  .To add completi
+00003760: 6f6e 7320 666f 7220 6669 7368 2c20 696e  ons for fish, in
+00003770: 7374 616c 6c20 7468 6520 636f 6d70 6c65  stall the comple
+00003780: 7469 6f6e 7320 6669 6c65 2067 6c6f 6261  tions file globa
+00003790: 6c6c 793a 0a0a 6060 6066 6973 680a 626f  lly:..```fish.bo
+000037a0: 7267 6d61 7469 6320 2d2d 6669 7368 2d63  rgmatic --fish-c
+000037b0: 6f6d 706c 6574 696f 6e20 7c20 7375 646f  ompletion | sudo
+000037c0: 2074 6565 202f 7573 722f 7368 6172 652f   tee /usr/share/
+000037d0: 6669 7368 2f76 656e 646f 725f 636f 6d70  fish/vendor_comp
+000037e0: 6c65 7469 6f6e 732e 642f 626f 7267 6d61  letions.d/borgma
+000037f0: 7469 632e 6669 7368 0a73 6f75 7263 6520  tic.fish.source 
+00003800: 2f75 7372 2f73 6861 7265 2f66 6973 682f  /usr/share/fish/
+00003810: 7665 6e64 6f72 5f63 6f6d 706c 6574 696f  vendor_completio
+00003820: 6e73 2e64 2f62 6f72 676d 6174 6963 2e66  ns.d/borgmatic.f
+00003830: 6973 680a 6060 600a 0a23 2323 2043 6f6c  ish.```..### Col
+00003840: 6f72 6564 206f 7574 7075 740a 0a62 6f72  ored output..bor
+00003850: 676d 6174 6963 2070 726f 6475 6365 7320  gmatic produces 
+00003860: 636f 6c6f 7265 6420 7465 726d 696e 616c  colored terminal
+00003870: 206f 7574 7075 7420 6279 2064 6566 6175   output by defau
+00003880: 6c74 2e20 4974 2069 7320 6469 7361 626c  lt. It is disabl
+00003890: 6564 2077 6865 6e20 610a 6e6f 6e2d 696e  ed when a.non-in
+000038a0: 7465 7261 6374 6976 6520 7465 726d 696e  teractive termin
+000038b0: 616c 2069 7320 6465 7465 6374 6564 2028  al is detected (
+000038c0: 6c69 6b65 2061 2063 726f 6e20 6a6f 6229  like a cron job)
+000038d0: 2c20 6f72 2077 6865 6e20 796f 7520 7573  , or when you us
+000038e0: 6520 7468 650a 602d 2d6a 736f 6e60 2066  e the.`--json` f
+000038f0: 6c61 672e 204f 7468 6572 7769 7365 2c20  lag. Otherwise, 
+00003900: 796f 7520 6361 6e20 6469 7361 626c 6520  you can disable 
+00003910: 6974 2062 7920 7061 7373 696e 6720 7468  it by passing th
+00003920: 6520 602d 2d6e 6f2d 636f 6c6f 7260 2066  e `--no-color` f
+00003930: 6c61 672c 0a73 6574 7469 6e67 2074 6865  lag,.setting the
+00003940: 2065 6e76 6972 6f6e 6d65 6e74 2076 6172   environment var
+00003950: 6961 626c 6520 6050 595f 434f 4c4f 5253  iable `PY_COLORS
+00003960: 3d46 616c 7365 602c 206f 7220 7365 7474  =False`, or sett
+00003970: 696e 6720 7468 6520 6063 6f6c 6f72 600a  ing the `color`.
+00003980: 6f70 7469 6f6e 2074 6f20 6066 616c 7365  option to `false
+00003990: 6020 696e 2074 6865 2060 6f75 7470 7574  ` in the `output
+000039a0: 6020 7365 6374 696f 6e20 6f66 2063 6f6e  ` section of con
+000039b0: 6669 6775 7261 7469 6f6e 2e0a 0a0a 2323  figuration....##
+000039c0: 2054 726f 7562 6c65 7368 6f6f 7469 6e67   Troubleshooting
+000039d0: 0a0a 2323 2320 2266 6f75 6e64 2063 6861  ..### "found cha
+000039e0: 7261 6374 6572 2074 6861 7420 6361 6e6e  racter that cann
+000039f0: 6f74 2073 7461 7274 2061 6e79 2074 6f6b  ot start any tok
+00003a00: 656e 2220 6572 726f 720a 0a49 6620 796f  en" error..If yo
+00003a10: 7520 7275 6e20 626f 7267 6d61 7469 6320  u run borgmatic 
+00003a20: 616e 6420 7365 6520 616e 2065 7272 6f72  and see an error
+00003a30: 206c 6f6f 6b69 6e67 2073 6f6d 6574 6869   looking somethi
+00003a40: 6e67 206c 696b 6520 7468 6973 2c20 6974  ng like this, it
+00003a50: 2070 726f 6261 626c 790a 6d65 616e 7320   probably.means 
+00003a60: 796f 7527 7665 2075 7365 6420 7461 6273  you've used tabs
+00003a70: 2069 6e73 7465 6164 206f 6620 7370 6163   instead of spac
+00003a80: 6573 3a0a 0a60 6060 0a74 6573 742e 7961  es:..```.test.ya
+00003a90: 6d6c 3a20 4572 726f 7220 7061 7273 696e  ml: Error parsin
+00003aa0: 6720 636f 6e66 6967 7572 6174 696f 6e20  g configuration 
+00003ab0: 6669 6c65 0a41 6e20 6572 726f 7220 6f63  file.An error oc
+00003ac0: 6375 7272 6564 2077 6869 6c65 2070 6172  curred while par
+00003ad0: 7369 6e67 2061 2063 6f6e 6669 6775 7261  sing a configura
+00003ae0: 7469 6f6e 2066 696c 6520 6174 2063 6f6e  tion file at con
+00003af0: 6669 672e 7961 6d6c 3a0a 7768 696c 6520  fig.yaml:.while 
+00003b00: 7363 616e 6e69 6e67 2066 6f72 2074 6865  scanning for the
+00003b10: 206e 6578 7420 746f 6b65 6e0a 666f 756e   next token.foun
+00003b20: 6420 6368 6172 6163 7465 7220 7468 6174  d character that
+00003b30: 2063 616e 6e6f 7420 7374 6172 7420 616e   cannot start an
+00003b40: 7920 746f 6b65 6e0a 2020 696e 2022 636f  y token.  in "co
+00003b50: 6e66 6967 2e79 616d 6c22 2c20 6c69 6e65  nfig.yaml", line
+00003b60: 2032 3330 2c20 636f 6c75 6d6e 2031 0a60   230, column 1.`
+00003b70: 6060 0a0a 5941 4d4c 2064 6f65 7320 6e6f  ``..YAML does no
+00003b80: 7420 616c 6c6f 7720 7461 6273 2e20 536f  t allow tabs. So
+00003b90: 2074 6f20 6669 7820 7468 6973 2c20 7265   to fix this, re
+00003ba0: 706c 6163 6520 616e 7920 7461 6273 2069  place any tabs i
+00003bb0: 6e20 796f 7572 0a63 6f6e 6669 6775 7261  n your.configura
+00003bc0: 7469 6f6e 2066 696c 6520 7769 7468 2074  tion file with t
+00003bd0: 6865 2072 6571 7569 7369 7465 206e 756d  he requisite num
+00003be0: 6265 7220 6f66 2073 7061 6365 732e 0a0a  ber of spaces...
+00003bf0: 2323 2320 6c69 6279 616d 6c20 636f 6d70  ### libyaml comp
+00003c00: 696c 6174 696f 6e20 6572 726f 7273 0a0a  ilation errors..
+00003c10: 626f 7267 6d61 7469 6320 6465 7065 6e64  borgmatic depend
+00003c20: 7320 6f6e 2061 2050 7974 686f 6e20 5941  s on a Python YA
+00003c30: 4d4c 206c 6962 7261 7279 2028 7275 616d  ML library (ruam
+00003c40: 656c 2e79 616d 6c29 2074 6861 7420 7769  el.yaml) that wi
+00003c50: 6c6c 206f 7074 696f 6e61 6c6c 790a 7573  ll optionally.us
+00003c60: 6520 6120 4320 5941 4d4c 206c 6962 7261  e a C YAML libra
+00003c70: 7279 2028 6c69 6279 616d 6c29 2069 6620  ry (libyaml) if 
+00003c80: 7072 6573 656e 742e 2042 7574 2069 6620  present. But if 
+00003c90: 6974 2773 206e 6f74 2069 6e73 7461 6c6c  it's not install
+00003ca0: 6564 2c20 7468 656e 0a77 6865 6e20 696e  ed, then.when in
+00003cb0: 7374 616c 6c69 6e67 206f 7220 7570 6772  stalling or upgr
+00003cc0: 6164 696e 6720 626f 7267 6d61 7469 632c  ading borgmatic,
+00003cd0: 2079 6f75 206d 6179 2073 6565 2065 7272   you may see err
+00003ce0: 6f72 7320 6162 6f75 7420 636f 6d70 696c  ors about compil
+00003cf0: 696e 6720 7468 650a 5941 4d4c 206c 6962  ing the.YAML lib
+00003d00: 7261 7279 2e20 4966 2073 6f2c 206e 6f74  rary. If so, not
+00003d10: 2074 6f20 776f 7272 792e 2062 6f72 676d   to worry. borgm
+00003d20: 6174 6963 2073 686f 756c 6420 696e 7374  atic should inst
+00003d30: 616c 6c20 616e 6420 6675 6e63 7469 6f6e  all and function
+00003d40: 0a63 6f72 7265 6374 6c79 2065 7665 6e20  .correctly even 
+00003d50: 7769 7468 6f75 7420 7468 6520 4320 5941  without the C YA
+00003d60: 4d4c 206c 6962 7261 7279 2e20 416e 6420  ML library. And 
+00003d70: 626f 7267 6d61 7469 6320 776f 6e27 7420  borgmatic won't 
+00003d80: 6265 2061 6e79 2066 6173 7465 720a 7769  be any faster.wi
+00003d90: 7468 2074 6865 2043 206c 6962 7261 7279  th the C library
+00003da0: 2070 7265 7365 6e74 2c20 736f 2079 6f75   present, so you
+00003db0: 2064 6f6e 2774 206e 6565 6420 746f 2067   don't need to g
+00003dc0: 6f20 6f75 7420 6f66 2079 6f75 7220 7761  o out of your wa
+00003dd0: 7920 746f 2069 6e73 7461 6c6c 0a69 742e  y to install.it.
+00003de0: 0a                                       .
```

### Comparing `borgmatic-1.7.9/docs/how-to/upgrade.md` & `borgmatic-1.8.0/docs/how-to/upgrade.md`

 * *Files 8% similar despite different names*

```diff
@@ -25,61 +25,66 @@
 The borgmatic configuration file format is almost always backwards-compatible
 from release to release without any changes, but you may still want to update
 your configuration file when you upgrade to take advantage of new
 configuration options. This is completely optional. If you prefer, you can add
 new configuration options manually.
 
 If you do want to upgrade your configuration file to include new options, use
-the `generate-borgmatic-config` script with its optional `--source` flag that
+the `borgmatic config generate` action with its optional `--source` flag that
 takes the path to your original configuration file. If provided with this
-path, `generate-borgmatic-config` merges your original configuration into the
+path, `borgmatic config generate` merges your original configuration into the
 generated configuration file, so you get all the newest options and comments.
 
 Here's an example:
 
 ```bash
-generate-borgmatic-config --source config.yaml --destination config-new.yaml
+borgmatic config generate --source config.yaml --destination config-new.yaml
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.7.15</span> The
+command to generate configuration files was `generate-borgmatic-config`
+instead of `borgmatic config generate`.
+
 New options start as commented out, so you can edit the file and decide
 whether you want to use each one.
 
 There are a few caveats to this process. First, when generating the new
-configuration file, `generate-borgmatic-config` replaces any comments you've
+configuration file, `borgmatic config generate` replaces any comments you've
 written in your original configuration file with the newest generated
 comments. Second, the script adds back any options you had originally deleted,
 although it does so with the options commented out. And finally, any YAML
 includes you've used in the source configuration get flattened out into a
 single generated file.
 
-As a safety measure, `generate-borgmatic-config` refuses to modify
+As a safety measure, `borgmatic config generate` refuses to modify
 configuration files in-place. So it's up to you to review the generated file
 and, if desired, replace your original configuration file with it.
 
 
 ### Upgrading from borgmatic 1.0.x
 
 borgmatic changed its configuration file format in version 1.1.0 from
 INI-style to YAML. This better supports validation, and has a more natural way
 to express lists of values. To upgrade your existing configuration, first
-upgrade to the new version of borgmatic.
+upgrade to the last version of borgmatic to support converting configuration:
+borgmatic 1.7.14.
 
 As of version 1.1.0, borgmatic no longer supports Python 2. If you were
 already running borgmatic with Python 3, then you can upgrade borgmatic
 in-place:
 
 ```bash
-sudo pip3 install --user --upgrade borgmatic
+sudo pip3 install --user --upgrade borgmatic==1.7.14
 ```
 
 But if you were running borgmatic with Python 2, uninstall and reinstall instead:
 
 ```bash
 sudo pip uninstall borgmatic
-sudo pip3 install --user borgmatic
+sudo pip3 install --user borgmatic==1.7.14
 ```
 
 The pip binary names for different versions of Python can differ, so the above
 commands may need some tweaking to work on your machine.
 
 
 Once borgmatic is upgraded, run:
@@ -89,37 +94,20 @@
 ```
 
 That will generate a new YAML configuration file at /etc/borgmatic/config.yaml
 (by default) using the values from both your existing configuration and
 excludes files. The new version of borgmatic will consume the YAML
 configuration file instead of the old one.
 
-
-### Upgrading from atticmatic
-
-You can ignore this section if you're not an atticmatic user (the former name
-of borgmatic).
-
-borgmatic only supports Borg now and no longer supports Attic. So if you're
-an Attic user, consider switching to Borg. See the [Borg upgrade
-command](https://borgbackup.readthedocs.io/en/stable/usage.html#borg-upgrade)
-for more information. Then, follow the instructions above about setting up
-your borgmatic configuration files.
-
-If you were already using Borg with atticmatic, then you can upgrade
-from atticmatic to borgmatic by running the following commands:
+Now you can upgrade to a newer version of borgmatic:
 
 ```bash
-sudo pip3 uninstall atticmatic
 sudo pip3 install --user borgmatic
 ```
 
-That's it! borgmatic will continue using your /etc/borgmatic configuration
-files.
-
 
 ## Upgrading Borg
 
 To upgrade to a new version of Borg, you can generally install a new version
 the same way you installed the previous version, paying attention to any
 instructions included with each Borg release changelog linked from the
 [releases page](https://github.com/borgbackup/borg/releases). Some more major
@@ -139,27 +127,31 @@
 in-place; you'll create a new repository with a copy of your old repository's
 data.
 
 Let's say your original borgmatic repository configuration file looks something
 like this:
 
 ```yaml
-location:
-    repositories:
-        - original.borg
+repositories:
+    - path: original.borg
 ```
 
 Change it to a new (not yet created) repository path:
 
 ```yaml
-location:
-    repositories:
-        - upgraded.borg
+repositories:
+    - path: upgraded.borg
 ```
 
+<span class="minilink minilink-addedin">Prior to version 1.8.0</span> This
+option was found in the `location:` section of your configuration.
+
+<span class="minilink minilink-addedin">Prior to version 1.7.10</span> Omit
+the `path:` portion of the `repositories` list.
+
 Then, run the `rcreate` action (formerly `init`) to create that new Borg 2
 repository:
 
 ```bash
 borgmatic rcreate --verbosity 1 --encryption repokey-blake2-aes-ocb \
     --source-repository original.borg --repository upgraded.borg
 ```
```

### Comparing `borgmatic-1.7.9/docs/static/borgbase.png` & `borgmatic-1.8.0/docs/static/borgbase.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/borgmatic.png` & `borgmatic-1.8.0/docs/static/borgmatic.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/borgmatic.svg` & `borgmatic-1.8.0/docs/static/borgmatic.svg`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/cronhub.png` & `borgmatic-1.8.0/docs/static/cronhub.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/cronitor.png` & `borgmatic-1.8.0/docs/static/cronitor.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/healthchecks.png` & `borgmatic-1.8.0/docs/static/healthchecks.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/mariadb.png` & `borgmatic-1.8.0/docs/static/mariadb.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/mongodb.png` & `borgmatic-1.8.0/docs/static/mongodb.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/mysql.png` & `borgmatic-1.8.0/docs/static/mysql.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/ntfy.png` & `borgmatic-1.8.0/docs/static/ntfy.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/pagerduty.png` & `borgmatic-1.8.0/docs/static/pagerduty.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/postgresql.png` & `borgmatic-1.8.0/docs/static/postgresql.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/docs/static/sqlite.png` & `borgmatic-1.8.0/docs/static/sqlite.png`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/sample/systemd/borgmatic.service` & `borgmatic-1.8.0/sample/systemd/borgmatic.service`

 * *Files 9% similar despite different names*

```diff
@@ -57,8 +57,8 @@
 # Prevent rate limiting of borgmatic log events. If you are using an older version of systemd that
 # doesn't support this (pre-240 or so), you may have to remove this option.
 LogRateLimitIntervalSec=0
 
 # Delay start to prevent backups running during boot. Note that systemd-inhibit requires dbus and
 # dbus-user-session to be installed.
 ExecStartPre=sleep 1m
-ExecStart=systemd-inhibit --who="borgmatic" --what="sleep:shutdown" --why="Prevent interrupting scheduled backup" /root/.local/bin/borgmatic --verbosity -1 --syslog-verbosity 1
+ExecStart=systemd-inhibit --who="borgmatic" --what="sleep:shutdown" --why="Prevent interrupting scheduled backup" /root/.local/bin/borgmatic --verbosity -2 --syslog-verbosity 1
```

### Comparing `borgmatic-1.7.9/scripts/find-unsupported-borg-options` & `borgmatic-1.8.0/scripts/find-unsupported-borg-options`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/scripts/release` & `borgmatic-1.8.0/scripts/release`

 * *Files 12% similar despite different names*

```diff
@@ -31,24 +31,22 @@
 git push origin $version
 git push github $version
 
 # Build borgmatic and publish to pypi.
 rm -fr dist
 python3 setup.py bdist_wheel
 python3 setup.py sdist
-gpg --detach-sign --armor dist/borgmatic-*.tar.gz
-gpg --detach-sign --armor dist/borgmatic-*-py3-none-any.whl
-twine upload -r pypi --username __token__ dist/borgmatic-*.tar.gz dist/borgmatic-*.tar.gz.asc
-twine upload -r pypi --username __token__ dist/borgmatic-*-py3-none-any.whl dist/borgmatic-*-py3-none-any.whl.asc
+twine upload -r pypi --username __token__ dist/borgmatic-*.tar.gz
+twine upload -r pypi --username __token__ dist/borgmatic-*-py3-none-any.whl
 
 # Set release changelogs on projects.torsion.org and GitHub.
 release_changelog="$(cat NEWS | sed '/^$/q' | grep -v '^\S')"
 escaped_release_changelog="$(echo "$release_changelog" | sed -z 's/\n/\\n/g' | sed -z 's/\"/\\"/g')"
 curl --silent --request POST \
     "https://projects.torsion.org/api/v1/repos/borgmatic-collective/borgmatic/releases" \
     --header "Authorization: token $projects_token" \
     --header "Accept: application/json" \
     --header "Content-Type: application/json" \
     --data "{\"body\": \"$escaped_release_changelog\", \"draft\": false, \"name\": \"borgmatic $version\", \"prerelease\": false, \"tag_name\": \"$version\"}"
 
-github-release create --token="$github_token" --owner=witten --repo=borgmatic --tag="$version" \
+github-release create --token="$github_token" --owner=witten --repo=borgmatic --tag="$version" --target_commit="main" \
     --name="borgmatic $version" --body="$release_changelog"
```

### Comparing `borgmatic-1.7.9/setup.py` & `borgmatic-1.8.0/setup.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from setuptools import find_packages, setup
 
-VERSION = '1.7.9'
+VERSION = '1.8.0'
 
 
 setup(
     name='borgmatic',
     version=VERSION,
     description='Simple, configuration-driven backup software for servers and workstations',
     author='Dan Helfman',
@@ -19,23 +19,23 @@
         'Topic :: Security :: Cryptography',
         'Topic :: System :: Archiving :: Backup',
     ],
     packages=find_packages(exclude=['tests*']),
     entry_points={
         'console_scripts': [
             'borgmatic = borgmatic.commands.borgmatic:main',
-            'upgrade-borgmatic-config = borgmatic.commands.convert_config:main',
             'generate-borgmatic-config = borgmatic.commands.generate_config:main',
             'validate-borgmatic-config = borgmatic.commands.validate_config:main',
         ]
     },
     obsoletes=['atticmatic'],
     install_requires=(
         'colorama>=0.4.1,<0.5',
         'jsonschema',
+        'packaging',
         'requests',
         'ruamel.yaml>0.15.0,<0.18.0',
         'setuptools',
     ),
     include_package_data=True,
     python_requires='>=3.7',
 )
```

### Comparing `borgmatic-1.7.9/tests/end-to-end/test_borgmatic.py` & `borgmatic-1.8.0/tests/end-to-end/test_borgmatic.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,28 +8,25 @@
 
 def generate_configuration(config_path, repository_path):
     '''
     Generate borgmatic configuration into a file at the config path, and update the defaults so as
     to work for testing (including injecting the given repository path and tacking on an encryption
     passphrase).
     '''
-    subprocess.check_call(
-        'generate-borgmatic-config --destination {}'.format(config_path).split(' ')
-    )
+    subprocess.check_call(f'borgmatic config generate --destination {config_path}'.split(' '))
     config = (
         open(config_path)
         .read()
         .replace('ssh://user@backupserver/./sourcehostname.borg', repository_path)
-        .replace('- ssh://user@backupserver/./{fqdn}', '')
-        .replace('- /var/local/backups/local.borg', '')
-        .replace('- /home/user/path with spaces', '')
-        .replace('- /home', '- {}'.format(config_path))
+        .replace('- path: /mnt/backup', '')
+        .replace('label: local', '')
+        .replace('- /home', f'- {config_path}')
         .replace('- /etc', '')
         .replace('- /var/log/syslog*', '')
-        + 'storage:\n    encryption_passphrase: "test"'
+        + 'encryption_passphrase: "test"'
     )
     config_file = open(config_path, 'w')
     config_file.write(config)
     config_file.close()
 
 
 def test_borgmatic_command():
@@ -43,41 +40,39 @@
     os.chdir(extract_path)
 
     try:
         config_path = os.path.join(temporary_directory, 'test.yaml')
         generate_configuration(config_path, repository_path)
 
         subprocess.check_call(
-            'borgmatic -v 2 --config {} init --encryption repokey'.format(config_path).split(' ')
+            f'borgmatic -v 2 --config {config_path} rcreate --encryption repokey'.split(' ')
         )
 
         # Run borgmatic to generate a backup archive, and then list it to make sure it exists.
-        subprocess.check_call('borgmatic --config {}'.format(config_path).split(' '))
+        subprocess.check_call(f'borgmatic --config {config_path}'.split(' '))
         output = subprocess.check_output(
-            'borgmatic --config {} list --json'.format(config_path).split(' ')
+            f'borgmatic --config {config_path} list --json'.split(' ')
         ).decode(sys.stdout.encoding)
         parsed_output = json.loads(output)
 
         assert len(parsed_output) == 1
         assert len(parsed_output[0]['archives']) == 1
         archive_name = parsed_output[0]['archives'][0]['archive']
 
         # Extract the created archive into the current (temporary) directory, and confirm that the
         # extracted file looks right.
         output = subprocess.check_output(
-            'borgmatic --config {} extract --archive {}'.format(config_path, archive_name).split(
-                ' '
-            )
+            f'borgmatic --config {config_path} extract --archive {archive_name}'.split(' '),
         ).decode(sys.stdout.encoding)
         extracted_config_path = os.path.join(extract_path, config_path)
         assert open(extracted_config_path).read() == open(config_path).read()
 
         # Exercise the info action.
         output = subprocess.check_output(
-            'borgmatic --config {} info --json'.format(config_path).split(' ')
+            f'borgmatic --config {config_path} info --json'.split(' '),
         ).decode(sys.stdout.encoding)
         parsed_output = json.loads(output)
 
         assert len(parsed_output) == 1
         assert 'repository' in parsed_output[0]
     finally:
         os.chdir(original_working_directory)
```

### Comparing `borgmatic-1.7.9/tests/end-to-end/test_generate_config.py` & `borgmatic-1.8.0/tests/end-to-end/test_generate_config.py`

 * *Files 24% similar despite different names*

```diff
@@ -4,13 +4,13 @@
 
 
 def test_generate_borgmatic_config_with_merging_succeeds():
     with tempfile.TemporaryDirectory() as temporary_directory:
         config_path = os.path.join(temporary_directory, 'test.yaml')
         new_config_path = os.path.join(temporary_directory, 'new.yaml')
 
-        subprocess.check_call(f'generate-borgmatic-config --destination {config_path}'.split(' '))
+        subprocess.check_call(f'borgmatic config generate --destination {config_path}'.split(' '))
         subprocess.check_call(
-            f'generate-borgmatic-config --source {config_path} --destination {new_config_path}'.split(
+            f'borgmatic config generate --source {config_path} --destination {new_config_path}'.split(
                 ' '
             )
         )
```

### Comparing `borgmatic-1.7.9/tests/end-to-end/test_override.py` & `borgmatic-1.8.0/tests/end-to-end/test_override.py`

 * *Files 4% similar despite different names*

```diff
@@ -6,28 +6,26 @@
 
 def generate_configuration(config_path, repository_path):
     '''
     Generate borgmatic configuration into a file at the config path, and update the defaults so as
     to work for testing (including injecting the given repository path and tacking on an encryption
     passphrase).
     '''
-    subprocess.check_call(
-        'generate-borgmatic-config --destination {}'.format(config_path).split(' ')
-    )
+    subprocess.check_call(f'borgmatic config generate --destination {config_path}'.split(' '))
     config = (
         open(config_path)
         .read()
         .replace('ssh://user@backupserver/./sourcehostname.borg', repository_path)
-        .replace('- ssh://user@backupserver/./{fqdn}', '')
+        .replace('- ssh://user@backupserver/./{fqdn}', '')  # noqa: FS003
         .replace('- /var/local/backups/local.borg', '')
         .replace('- /home/user/path with spaces', '')
-        .replace('- /home', '- {}'.format(config_path))
+        .replace('- /home', f'- {config_path}')
         .replace('- /etc', '')
         .replace('- /var/log/syslog*', '')
-        + 'storage:\n    encryption_passphrase: "test"'
+        + 'encryption_passphrase: "test"'
     )
     config_file = open(config_path, 'w')
     config_file.write(config)
     config_file.close()
 
 
 def test_override_get_normalized():
@@ -37,15 +35,15 @@
     original_working_directory = os.getcwd()
 
     try:
         config_path = os.path.join(temporary_directory, 'test.yaml')
         generate_configuration(config_path, repository_path)
 
         subprocess.check_call(
-            f'borgmatic -v 2 --config {config_path} init --encryption repokey'.split(' ')
+            f'borgmatic -v 2 --config {config_path} rcreate --encryption repokey'.split(' ')
         )
 
         # Run borgmatic with an override structured for an outdated config file format. If
         # normalization is working, it should get normalized and shouldn't error.
         subprocess.check_call(
             f'borgmatic create --config {config_path} --override hooks.healthchecks=http://localhost:8888/someuuid'.split(
                 ' '
```

### Comparing `borgmatic-1.7.9/tests/integration/borg/test_feature.py` & `borgmatic-1.8.0/tests/integration/borg/test_feature.py`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/tests/integration/commands/test_arguments.py` & `borgmatic-1.8.0/tests/integration/commands/test_arguments.py`

 * *Files 12% similar despite different names*

```diff
@@ -8,96 +8,116 @@
     config_paths = ['default']
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(config_paths)
 
     arguments = module.parse_arguments()
 
     global_arguments = arguments['global']
     assert global_arguments.config_paths == config_paths
-    assert global_arguments.excludes_filename is None
     assert global_arguments.verbosity == 0
     assert global_arguments.syslog_verbosity == 0
     assert global_arguments.log_file_verbosity == 0
 
 
-def test_parse_arguments_with_multiple_config_paths_parses_as_list():
+def test_parse_arguments_with_multiple_config_flags_parses_as_list():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
-    arguments = module.parse_arguments('--config', 'myconfig', 'otherconfig')
+    arguments = module.parse_arguments('--config', 'myconfig', '--config', 'otherconfig')
 
     global_arguments = arguments['global']
     assert global_arguments.config_paths == ['myconfig', 'otherconfig']
     assert global_arguments.verbosity == 0
     assert global_arguments.syslog_verbosity == 0
     assert global_arguments.log_file_verbosity == 0
 
 
+def test_parse_arguments_with_action_after_config_path_omits_action():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    arguments = module.parse_arguments('--config', 'myconfig', 'list', '--json')
+
+    global_arguments = arguments['global']
+    assert global_arguments.config_paths == ['myconfig']
+    assert 'list' in arguments
+    assert arguments['list'].json
+
+
+def test_parse_arguments_with_action_after_config_path_omits_aliased_action():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    arguments = module.parse_arguments('--config', 'myconfig', 'init', '--encryption', 'repokey')
+
+    global_arguments = arguments['global']
+    assert global_arguments.config_paths == ['myconfig']
+    assert 'rcreate' in arguments
+    assert arguments['rcreate'].encryption_mode == 'repokey'
+
+
+def test_parse_arguments_with_action_and_positional_arguments_after_config_path_omits_action_and_arguments():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    arguments = module.parse_arguments('--config', 'myconfig', 'borg', 'key', 'export')
+
+    global_arguments = arguments['global']
+    assert global_arguments.config_paths == ['myconfig']
+    assert 'borg' in arguments
+    assert arguments['borg'].options == ['key', 'export']
+
+
 def test_parse_arguments_with_verbosity_overrides_default():
     config_paths = ['default']
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(config_paths)
 
     arguments = module.parse_arguments('--verbosity', '1')
 
     global_arguments = arguments['global']
     assert global_arguments.config_paths == config_paths
-    assert global_arguments.excludes_filename is None
     assert global_arguments.verbosity == 1
     assert global_arguments.syslog_verbosity == 0
     assert global_arguments.log_file_verbosity == 0
 
 
 def test_parse_arguments_with_syslog_verbosity_overrides_default():
     config_paths = ['default']
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(config_paths)
 
     arguments = module.parse_arguments('--syslog-verbosity', '2')
 
     global_arguments = arguments['global']
     assert global_arguments.config_paths == config_paths
-    assert global_arguments.excludes_filename is None
     assert global_arguments.verbosity == 0
     assert global_arguments.syslog_verbosity == 2
 
 
 def test_parse_arguments_with_log_file_verbosity_overrides_default():
     config_paths = ['default']
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(config_paths)
 
     arguments = module.parse_arguments('--log-file-verbosity', '-1')
 
     global_arguments = arguments['global']
     assert global_arguments.config_paths == config_paths
-    assert global_arguments.excludes_filename is None
     assert global_arguments.verbosity == 0
     assert global_arguments.syslog_verbosity == 0
     assert global_arguments.log_file_verbosity == -1
 
 
 def test_parse_arguments_with_single_override_parses():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     arguments = module.parse_arguments('--override', 'foo.bar=baz')
 
     global_arguments = arguments['global']
     assert global_arguments.overrides == ['foo.bar=baz']
 
 
-def test_parse_arguments_with_multiple_overrides_parses():
-    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
-
-    arguments = module.parse_arguments('--override', 'foo.bar=baz', 'foo.quux=7')
-
-    global_arguments = arguments['global']
-    assert global_arguments.overrides == ['foo.bar=baz', 'foo.quux=7']
-
-
-def test_parse_arguments_with_multiple_overrides_and_flags_parses():
+def test_parse_arguments_with_multiple_overrides_flags_parses():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     arguments = module.parse_arguments(
-        '--override', 'foo.bar=baz', '--override', 'foo.quux=7', 'this.that=8'
+        '--override', 'foo.bar=baz', '--override', 'foo.quux=7', '--override', 'this.that=8'
     )
 
     global_arguments = arguments['global']
     assert global_arguments.overrides == ['foo.bar=baz', 'foo.quux=7', 'this.that=8']
 
 
 def test_parse_arguments_with_list_json_overrides_default():
@@ -190,32 +210,25 @@
     arguments = module.parse_arguments('create', 'check')
 
     assert 'prune' not in arguments
     assert 'create' in arguments
     assert 'check' in arguments
 
 
-def test_parse_arguments_with_invalid_arguments_exits():
-    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
-
-    with pytest.raises(SystemExit):
-        module.parse_arguments('--posix-me-harder')
-
-
-def test_parse_arguments_disallows_deprecated_excludes_option():
+def test_parse_arguments_disallows_invalid_argument():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     with pytest.raises(ValueError):
-        module.parse_arguments('--config', 'myconfig', '--excludes', 'myexcludes')
+        module.parse_arguments('--posix-me-harder')
 
 
 def test_parse_arguments_disallows_encryption_mode_without_init():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
-    with pytest.raises(SystemExit):
+    with pytest.raises(ValueError):
         module.parse_arguments('--config', 'myconfig', '--encryption', 'repokey')
 
 
 def test_parse_arguments_allows_encryption_mode_with_init():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     module.parse_arguments('--config', 'myconfig', 'init', '--encryption', 'repokey')
@@ -227,22 +240,22 @@
     with pytest.raises(SystemExit):
         module.parse_arguments('--config', 'myconfig', 'init')
 
 
 def test_parse_arguments_disallows_append_only_without_init():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
-    with pytest.raises(SystemExit):
+    with pytest.raises(ValueError):
         module.parse_arguments('--config', 'myconfig', '--append-only')
 
 
 def test_parse_arguments_disallows_storage_quota_without_init():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
-    with pytest.raises(SystemExit):
+    with pytest.raises(ValueError):
         module.parse_arguments('--config', 'myconfig', '--storage-quota', '5G')
 
 
 def test_parse_arguments_allows_init_and_prune():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     module.parse_arguments('--config', 'myconfig', 'init', '--encryption', 'repokey', 'prune')
@@ -283,25 +296,32 @@
 
     module.parse_arguments('--config', 'myconfig', 'list', '--repository', 'test.borg')
 
 
 def test_parse_arguments_disallows_archive_unless_action_consumes_it():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
-    with pytest.raises(SystemExit):
+    with pytest.raises(ValueError):
         module.parse_arguments('--config', 'myconfig', '--archive', 'test')
 
 
 def test_parse_arguments_disallows_paths_unless_action_consumes_it():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
-    with pytest.raises(SystemExit):
+    with pytest.raises(ValueError):
         module.parse_arguments('--config', 'myconfig', '--path', 'test')
 
 
+def test_parse_arguments_disallows_other_actions_with_config_bootstrap():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    with pytest.raises(ValueError):
+        module.parse_arguments('config', 'bootstrap', '--repository', 'test.borg', 'list')
+
+
 def test_parse_arguments_allows_archive_with_extract():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     module.parse_arguments('--config', 'myconfig', 'extract', '--archive', 'test')
 
 
 def test_parse_arguments_allows_archive_with_mount():
@@ -369,15 +389,15 @@
 
     module.parse_arguments('--progress', 'extract', '--archive', 'test', 'list')
 
 
 def test_parse_arguments_disallows_progress_without_create():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
-    with pytest.raises(SystemExit):
+    with pytest.raises(ValueError):
         module.parse_arguments('--progress', 'list')
 
 
 def test_parse_arguments_with_stats_and_create_flags_does_not_raise():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     module.parse_arguments('--stats', 'create', 'list')
@@ -388,15 +408,15 @@
 
     module.parse_arguments('--stats', 'prune', 'list')
 
 
 def test_parse_arguments_with_stats_flag_but_no_create_or_prune_flag_raises_value_error():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
-    with pytest.raises(SystemExit):
+    with pytest.raises(ValueError):
         module.parse_arguments('--stats', 'list')
 
 
 def test_parse_arguments_with_list_and_create_flags_does_not_raise():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     module.parse_arguments('--list', 'create')
@@ -418,14 +438,21 @@
 def test_parse_arguments_disallows_list_with_progress_for_create_action():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     with pytest.raises(ValueError):
         module.parse_arguments('create', '--list', '--progress')
 
 
+def test_parse_arguments_disallows_list_with_json_for_create_action():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    with pytest.raises(ValueError):
+        module.parse_arguments('create', '--list', '--json')
+
+
 def test_parse_arguments_allows_json_with_list_or_info():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     module.parse_arguments('list', '--json')
     module.parse_arguments('info', '--json')
 
 
@@ -461,14 +488,28 @@
             '--archive',
             'foo',
             '--match-archives',
             'sh:*bar',
         )
 
 
+def test_parse_arguments_disallows_list_with_both_prefix_and_match_archives():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    with pytest.raises(ValueError):
+        module.parse_arguments('list', '--prefix', 'foo', '--match-archives', 'sh:*bar')
+
+
+def test_parse_arguments_disallows_rlist_with_both_prefix_and_match_archives():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    with pytest.raises(ValueError):
+        module.parse_arguments('rlist', '--prefix', 'foo', '--match-archives', 'sh:*bar')
+
+
 def test_parse_arguments_disallows_info_with_both_archive_and_match_archives():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     with pytest.raises(ValueError):
         module.parse_arguments('info', '--archive', 'foo', '--match-archives', 'sh:*bar')
 
 
@@ -498,7 +539,80 @@
     module.parse_arguments('extract', '--archive', 'check')
 
 
 def test_parse_arguments_extract_with_check_only_extract_does_not_raise():
     flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
 
     module.parse_arguments('extract', '--archive', 'name', 'check', '--only', 'extract')
+
+
+def test_parse_arguments_bootstrap_without_config_errors():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    with pytest.raises(ValueError):
+        module.parse_arguments('bootstrap')
+
+
+def test_parse_arguments_config_with_no_subaction_errors():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    with pytest.raises(ValueError):
+        module.parse_arguments('config')
+
+
+def test_parse_arguments_config_with_help_shows_config_help(capsys):
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    with pytest.raises(SystemExit) as exit:
+        module.parse_arguments('config', '--help')
+
+    assert exit.value.code == 0
+    captured = capsys.readouterr()
+    assert 'global arguments:' not in captured.out
+    assert 'config arguments:' in captured.out
+    assert 'config sub-actions:' in captured.out
+
+
+def test_parse_arguments_config_with_subaction_but_missing_flags_errors():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    with pytest.raises(SystemExit) as exit:
+        module.parse_arguments('config', 'bootstrap')
+
+    assert exit.value.code == 2
+
+
+def test_parse_arguments_config_with_subaction_and_help_shows_subaction_help(capsys):
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    with pytest.raises(SystemExit) as exit:
+        module.parse_arguments('config', 'bootstrap', '--help')
+
+    assert exit.value.code == 0
+    captured = capsys.readouterr()
+    assert 'config bootstrap arguments:' in captured.out
+
+
+def test_parse_arguments_config_with_subaction_and_required_flags_does_not_raise():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    module.parse_arguments('config', 'bootstrap', '--repository', 'repo.borg')
+
+
+def test_parse_arguments_config_with_subaction_and_global_flags_at_start_does_not_raise():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    module.parse_arguments('--verbosity', '1', 'config', 'bootstrap', '--repository', 'repo.borg')
+
+
+def test_parse_arguments_config_with_subaction_and_global_flags_at_end_does_not_raise():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    module.parse_arguments('config', 'bootstrap', '--repository', 'repo.borg', '--verbosity', '1')
+
+
+def test_parse_arguments_config_with_subaction_and_explicit_config_file_does_not_raise():
+    flexmock(module.collect).should_receive('get_default_config_paths').and_return(['default'])
+
+    module.parse_arguments(
+        'config', 'bootstrap', '--repository', 'repo.borg', '--config', 'test.yaml'
+    )
```

### Comparing `borgmatic-1.7.9/tests/integration/config/test_generate.py` & `borgmatic-1.8.0/tests/integration/config/test_generate.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,86 +9,84 @@
 
 
 def test_insert_newline_before_comment_does_not_raise():
     field_name = 'foo'
     config = module.yaml.comments.CommentedMap([(field_name, 33)])
     config.yaml_set_comment_before_after_key(key=field_name, before='Comment')
 
-    module._insert_newline_before_comment(config, field_name)
+    module.insert_newline_before_comment(config, field_name)
 
 
 def test_comment_out_line_skips_blank_line():
     line = '    \n'
 
-    assert module._comment_out_line(line) == line
+    assert module.comment_out_line(line) == line
 
 
 def test_comment_out_line_skips_already_commented_out_line():
     line = '    # foo'
 
-    assert module._comment_out_line(line) == line
+    assert module.comment_out_line(line) == line
 
 
 def test_comment_out_line_comments_section_name():
     line = 'figgy-pudding:'
 
-    assert module._comment_out_line(line) == '# ' + line
+    assert module.comment_out_line(line) == '# ' + line
 
 
 def test_comment_out_line_comments_indented_option():
     line = '    enabled: true'
 
-    assert module._comment_out_line(line) == '    # enabled: true'
+    assert module.comment_out_line(line) == '    # enabled: true'
 
 
 def test_comment_out_line_comments_twice_indented_option():
     line = '        - item'
 
-    assert module._comment_out_line(line) == '        # - item'
+    assert module.comment_out_line(line) == '        # - item'
 
 
 def test_comment_out_optional_configuration_comments_optional_config_only():
     # The "# COMMENT_OUT" comment is a sentinel used to express that the following key is optional.
     # It's stripped out of the final output.
-    flexmock(module)._comment_out_line = lambda line: '# ' + line
+    flexmock(module).comment_out_line = lambda line: '# ' + line
     config = '''
 # COMMENT_OUT
 foo:
     # COMMENT_OUT
     bar:
         - baz
         - quux
 
-location:
-    repositories:
-        - one
-        - two
+repositories:
+    - one
+    - two
 
-    # This comment should be kept.
-    # COMMENT_OUT
-    other: thing
+# This comment should be kept.
+# COMMENT_OUT
+other: thing
     '''
 
     # flake8: noqa
     expected_config = '''
 # foo:
 #     bar:
 #         - baz
 #         - quux
 
-location:
-    repositories:
-        - one
-        - two
+repositories:
+    - one
+    - two
 
-    # This comment should be kept.
-#     other: thing
+# This comment should be kept.
+# other: thing
     '''
 
-    assert module._comment_out_optional_configuration(config.strip()) == expected_config.strip()
+    assert module.comment_out_optional_configuration(config.strip()) == expected_config.strip()
 
 
 def test_render_configuration_converts_configuration_to_yaml_string():
     yaml_string = module.render_configuration({'foo': 'bar'})
 
     assert yaml_string == 'foo: bar\n'
 
@@ -200,29 +198,42 @@
     module.remove_commented_out_sentinel(config, 'unknown')
 
 
 def test_generate_sample_configuration_does_not_raise():
     builtins = flexmock(sys.modules['builtins'])
     builtins.should_receive('open').with_args('schema.yaml').and_return('')
     flexmock(module.yaml).should_receive('round_trip_load')
-    flexmock(module).should_receive('_schema_to_sample_configuration')
+    flexmock(module).should_receive('schema_to_sample_configuration')
     flexmock(module).should_receive('merge_source_configuration_into_destination')
     flexmock(module).should_receive('render_configuration')
-    flexmock(module).should_receive('_comment_out_optional_configuration')
+    flexmock(module).should_receive('comment_out_optional_configuration')
     flexmock(module).should_receive('write_configuration')
 
-    module.generate_sample_configuration(None, 'dest.yaml', 'schema.yaml')
+    module.generate_sample_configuration(False, None, 'dest.yaml', 'schema.yaml')
 
 
 def test_generate_sample_configuration_with_source_filename_does_not_raise():
     builtins = flexmock(sys.modules['builtins'])
     builtins.should_receive('open').with_args('schema.yaml').and_return('')
     flexmock(module.yaml).should_receive('round_trip_load')
     flexmock(module.load).should_receive('load_configuration')
     flexmock(module.normalize).should_receive('normalize')
-    flexmock(module).should_receive('_schema_to_sample_configuration')
+    flexmock(module).should_receive('schema_to_sample_configuration')
     flexmock(module).should_receive('merge_source_configuration_into_destination')
     flexmock(module).should_receive('render_configuration')
-    flexmock(module).should_receive('_comment_out_optional_configuration')
+    flexmock(module).should_receive('comment_out_optional_configuration')
     flexmock(module).should_receive('write_configuration')
 
-    module.generate_sample_configuration('source.yaml', 'dest.yaml', 'schema.yaml')
+    module.generate_sample_configuration(False, 'source.yaml', 'dest.yaml', 'schema.yaml')
+
+
+def test_generate_sample_configuration_with_dry_run_does_not_write_file():
+    builtins = flexmock(sys.modules['builtins'])
+    builtins.should_receive('open').with_args('schema.yaml').and_return('')
+    flexmock(module.yaml).should_receive('round_trip_load')
+    flexmock(module).should_receive('schema_to_sample_configuration')
+    flexmock(module).should_receive('merge_source_configuration_into_destination')
+    flexmock(module).should_receive('render_configuration')
+    flexmock(module).should_receive('comment_out_optional_configuration')
+    flexmock(module).should_receive('write_configuration').never()
+
+    module.generate_sample_configuration(True, None, 'dest.yaml', 'schema.yaml')
```

### Comparing `borgmatic-1.7.9/tests/integration/config/test_override.py` & `borgmatic-1.8.0/tests/integration/config/test_override.py`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/tests/integration/config/test_validate.py` & `borgmatic-1.8.0/tests/integration/config/test_validate.py`

 * *Files 20% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 
 import pytest
 from flexmock import flexmock
 
 from borgmatic.config import validate as module
 
 
-def test_schema_filename_returns_plausable_path():
+def test_schema_filename_returns_plausible_path():
     schema_path = module.schema_filename()
 
     assert schema_path.endswith('/schema.yaml')
 
 
 def mock_config_and_schema(config_yaml, schema_yaml=None):
     '''
@@ -36,107 +36,99 @@
     builtins.should_receive('open').with_args('/tmp/config.yaml').and_return(config_stream)
     builtins.should_receive('open').with_args('/tmp/schema.yaml').and_return(schema_stream)
 
 
 def test_parse_configuration_transforms_file_into_mapping():
     mock_config_and_schema(
         '''
-        location:
-            source_directories:
-                - /home
-                - /etc
+        source_directories:
+            - /home
+            - /etc
 
-            repositories:
-                - hostname.borg
+        repositories:
+            - path: hostname.borg
 
-        retention:
-            keep_minutely: 60
-            keep_hourly: 24
-            keep_daily: 7
-
-        consistency:
-            checks:
-                - name: repository
-                - name: archives
+        keep_minutely: 60
+        keep_hourly: 24
+        keep_daily: 7
+
+        checks:
+            - name: repository
+            - name: archives
         '''
     )
 
     config, logs = module.parse_configuration('/tmp/config.yaml', '/tmp/schema.yaml')
 
     assert config == {
-        'location': {'source_directories': ['/home', '/etc'], 'repositories': ['hostname.borg']},
-        'retention': {'keep_daily': 7, 'keep_hourly': 24, 'keep_minutely': 60},
-        'consistency': {'checks': [{'name': 'repository'}, {'name': 'archives'}]},
+        'source_directories': ['/home', '/etc'],
+        'repositories': [{'path': 'hostname.borg'}],
+        'keep_daily': 7,
+        'keep_hourly': 24,
+        'keep_minutely': 60,
+        'checks': [{'name': 'repository'}, {'name': 'archives'}],
     }
     assert logs == []
 
 
 def test_parse_configuration_passes_through_quoted_punctuation():
     escaped_punctuation = string.punctuation.replace('\\', r'\\').replace('"', r'\"')
 
     mock_config_and_schema(
         f'''
-        location:
-            source_directories:
-                - "/home/{escaped_punctuation}"
+        source_directories:
+            - "/home/{escaped_punctuation}"
 
-            repositories:
-                - test.borg
+        repositories:
+            - path: test.borg
         '''
     )
 
     config, logs = module.parse_configuration('/tmp/config.yaml', '/tmp/schema.yaml')
 
     assert config == {
-        'location': {
-            'source_directories': [f'/home/{string.punctuation}'],
-            'repositories': ['test.borg'],
-        }
+        'source_directories': [f'/home/{string.punctuation}'],
+        'repositories': [{'path': 'test.borg'}],
     }
     assert logs == []
 
 
 def test_parse_configuration_with_schema_lacking_examples_does_not_raise():
     mock_config_and_schema(
         '''
-        location:
-            source_directories:
-                - /home
+        source_directories:
+            - /home
 
-            repositories:
-                - hostname.borg
+        repositories:
+            - path: hostname.borg
         ''',
         '''
         map:
-            location:
+            source_directories:
+                required: true
+                seq:
+                    - type: scalar
+            repositories:
                 required: true
-                map:
-                    source_directories:
-                        required: true
-                        seq:
-                            - type: scalar
-                    repositories:
-                        required: true
-                        seq:
-                            - type: scalar
+                seq:
+                    - type: scalar
         ''',
     )
 
     module.parse_configuration('/tmp/config.yaml', '/tmp/schema.yaml')
 
 
 def test_parse_configuration_inlines_include():
     mock_config_and_schema(
         '''
-        location:
-            source_directories:
-                - /home
+        source_directories:
+            - /home
 
-            repositories:
-                - hostname.borg
+        repositories:
+            - path: hostname.borg
 
         retention:
             !include include.yaml
         '''
     )
     builtins = flexmock(sys.modules['builtins'])
     include_file = io.StringIO(
@@ -147,33 +139,33 @@
     )
     include_file.name = 'include.yaml'
     builtins.should_receive('open').with_args('/tmp/include.yaml').and_return(include_file)
 
     config, logs = module.parse_configuration('/tmp/config.yaml', '/tmp/schema.yaml')
 
     assert config == {
-        'location': {'source_directories': ['/home'], 'repositories': ['hostname.borg']},
-        'retention': {'keep_daily': 7, 'keep_hourly': 24},
+        'source_directories': ['/home'],
+        'repositories': [{'path': 'hostname.borg'}],
+        'keep_daily': 7,
+        'keep_hourly': 24,
     }
-    assert logs == []
+    assert len(logs) == 1
 
 
 def test_parse_configuration_merges_include():
     mock_config_and_schema(
         '''
-        location:
-            source_directories:
-                - /home
+        source_directories:
+            - /home
 
-            repositories:
-                - hostname.borg
+        repositories:
+            - path: hostname.borg
 
-        retention:
-            keep_daily: 1
-            <<: !include include.yaml
+        keep_daily: 1
+        <<: !include include.yaml
         '''
     )
     builtins = flexmock(sys.modules['builtins'])
     include_file = io.StringIO(
         '''
         keep_daily: 7
         keep_hourly: 24
@@ -181,16 +173,18 @@
     )
     include_file.name = 'include.yaml'
     builtins.should_receive('open').with_args('/tmp/include.yaml').and_return(include_file)
 
     config, logs = module.parse_configuration('/tmp/config.yaml', '/tmp/schema.yaml')
 
     assert config == {
-        'location': {'source_directories': ['/home'], 'repositories': ['hostname.borg']},
-        'retention': {'keep_daily': 1, 'keep_hourly': 24},
+        'source_directories': ['/home'],
+        'repositories': [{'path': 'hostname.borg'}],
+        'keep_daily': 1,
+        'keep_hourly': 24,
     }
     assert logs == []
 
 
 def test_parse_configuration_raises_for_missing_config_file():
     with pytest.raises(FileNotFoundError):
         module.parse_configuration('/tmp/config.yaml', '/tmp/schema.yaml')
@@ -211,70 +205,64 @@
     with pytest.raises(ValueError):
         module.parse_configuration('/tmp/config.yaml', '/tmp/schema.yaml')
 
 
 def test_parse_configuration_raises_for_validation_error():
     mock_config_and_schema(
         '''
-        location:
-            source_directories: yes
-            repositories:
-                - hostname.borg
+        source_directories: yes
+        repositories:
+            - path: hostname.borg
         '''
     )
 
     with pytest.raises(module.Validation_error):
         module.parse_configuration('/tmp/config.yaml', '/tmp/schema.yaml')
 
 
 def test_parse_configuration_applies_overrides():
     mock_config_and_schema(
         '''
-        location:
-            source_directories:
-                - /home
+        source_directories:
+            - /home
 
-            repositories:
-                - hostname.borg
+        repositories:
+            - path: hostname.borg
 
-            local_path: borg1
+        local_path: borg1
         '''
     )
 
     config, logs = module.parse_configuration(
         '/tmp/config.yaml', '/tmp/schema.yaml', overrides=['location.local_path=borg2']
     )
 
     assert config == {
-        'location': {
-            'source_directories': ['/home'],
-            'repositories': ['hostname.borg'],
-            'local_path': 'borg2',
-        }
+        'source_directories': ['/home'],
+        'repositories': [{'path': 'hostname.borg'}],
+        'local_path': 'borg2',
     }
     assert logs == []
 
 
 def test_parse_configuration_applies_normalization():
     mock_config_and_schema(
         '''
         location:
             source_directories:
                 - /home
 
             repositories:
-                - hostname.borg
+                - path: hostname.borg
 
             exclude_if_present: .nobackup
         '''
     )
 
     config, logs = module.parse_configuration('/tmp/config.yaml', '/tmp/schema.yaml')
 
     assert config == {
-        'location': {
-            'source_directories': ['/home'],
-            'repositories': ['hostname.borg'],
-            'exclude_if_present': ['.nobackup'],
-        }
+        'source_directories': ['/home'],
+        'repositories': [{'path': 'hostname.borg'}],
+        'exclude_if_present': ['.nobackup'],
     }
-    assert logs == []
+    assert logs
```

### Comparing `borgmatic-1.7.9/tests/integration/hooks/test_healthchecks.py` & `borgmatic-1.8.0/tests/integration/hooks/test_healthchecks.py`

 * *Files 7% similar despite different names*

```diff
@@ -6,19 +6,19 @@
 
 
 def test_destroy_monitor_removes_healthchecks_handler():
     logger = logging.getLogger()
     original_handlers = list(logger.handlers)
     logger.addHandler(module.Forgetful_buffering_handler(byte_capacity=100, log_level=1))
 
-    module.destroy_monitor(flexmock(), flexmock(), flexmock(), flexmock())
+    module.destroy_monitor(flexmock(), flexmock(), flexmock(), flexmock(), flexmock())
 
     assert logger.handlers == original_handlers
 
 
 def test_destroy_monitor_without_healthchecks_handler_does_not_raise():
     logger = logging.getLogger()
     original_handlers = list(logger.handlers)
 
-    module.destroy_monitor(flexmock(), flexmock(), flexmock(), flexmock())
+    module.destroy_monitor(flexmock(), flexmock(), flexmock(), flexmock(), flexmock())
 
     assert logger.handlers == original_handlers
```

### Comparing `borgmatic-1.7.9/tests/integration/test_execute.py` & `borgmatic-1.8.0/tests/integration/test_execute.py`

 * *Files 1% similar despite different names*

```diff
@@ -134,24 +134,24 @@
 
 def test_log_outputs_kills_other_processes_when_one_errors():
     flexmock(module.logger).should_receive('log')
     flexmock(module).should_receive('command_for_process').and_return('grep')
 
     process = subprocess.Popen(['grep'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
     flexmock(module).should_receive('exit_code_indicates_error').with_args(
-        process, None, 'borg'
+        ['grep'], None, 'borg'
     ).and_return(False)
     flexmock(module).should_receive('exit_code_indicates_error').with_args(
-        process, 2, 'borg'
+        ['grep'], 2, 'borg'
     ).and_return(True)
     other_process = subprocess.Popen(
         ['sleep', '2'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT
     )
     flexmock(module).should_receive('exit_code_indicates_error').with_args(
-        other_process, None, 'borg'
+        ['sleep', '2'], None, 'borg'
     ).and_return(False)
     flexmock(module).should_receive('output_buffer_for_process').with_args(process, ()).and_return(
         process.stdout
     )
     flexmock(module).should_receive('output_buffer_for_process').with_args(
         other_process, ()
     ).and_return(other_process.stdout)
@@ -235,29 +235,28 @@
         exclude_stdouts=(process.stdout,),
         output_log_level=logging.INFO,
         borg_local_path='borg',
     )
 
 
 def test_log_outputs_truncates_long_error_output():
-    flexmock(module).ERROR_OUTPUT_MAX_LINE_COUNT = 0
     flexmock(module.logger).should_receive('log')
     flexmock(module).should_receive('command_for_process').and_return('grep')
 
     process = subprocess.Popen(['grep'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
     flexmock(module).should_receive('exit_code_indicates_error').with_args(
-        process, None, 'borg'
+        ['grep'], None, 'borg'
     ).and_return(False)
     flexmock(module).should_receive('exit_code_indicates_error').with_args(
-        process, 2, 'borg'
+        ['grep'], 2, 'borg'
     ).and_return(True)
     flexmock(module).should_receive('output_buffer_for_process').and_return(process.stdout)
 
     with pytest.raises(subprocess.CalledProcessError) as error:
-        module.log_outputs(
+        flexmock(module, ERROR_OUTPUT_MAX_LINE_COUNT=0).log_outputs(
             (process,), exclude_stdouts=(), output_log_level=logging.INFO, borg_local_path='borg'
         )
 
     assert error.value.returncode == 2
     assert error.value.output.startswith('...')
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_borg.py` & `borgmatic-1.8.0/tests/unit/actions/test_borg.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,14 +9,15 @@
     flexmock(module.borgmatic.borg.rlist).should_receive('resolve_archive_name').and_return(
         flexmock()
     )
     flexmock(module.borgmatic.borg.borg).should_receive('run_arbitrary_borg')
     borg_arguments = flexmock(repository=flexmock(), archive=flexmock(), options=flexmock())
 
     module.run_borg(
-        repository='repo',
-        storage={},
+        repository={'path': 'repos'},
+        config={},
         local_borg_version=None,
+        global_arguments=flexmock(log_json=False),
         borg_arguments=borg_arguments,
         local_path=None,
         remote_path=None,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_break_lock.py` & `borgmatic-1.8.0/tests/unit/actions/test_break_lock.py`

 * *Files 11% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 def test_run_break_lock_does_not_raise():
     flexmock(module.logger).answer = lambda message: None
     flexmock(module.borgmatic.config.validate).should_receive('repositories_match').and_return(True)
     flexmock(module.borgmatic.borg.break_lock).should_receive('break_lock')
     break_lock_arguments = flexmock(repository=flexmock())
 
     module.run_break_lock(
-        repository='repo',
-        storage={},
+        repository={'path': 'repo'},
+        config={},
         local_borg_version=None,
         break_lock_arguments=break_lock_arguments,
+        global_arguments=flexmock(),
         local_path=None,
         remote_path=None,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_check.py` & `borgmatic-1.8.0/tests/unit/actions/test_check.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,32 +1,30 @@
 from flexmock import flexmock
 
 from borgmatic.actions import check as module
 
 
 def test_run_check_calls_hooks_for_configured_repository():
     flexmock(module.logger).answer = lambda message: None
-    flexmock(module.borgmatic.config.checks).should_receive(
-        'repository_enabled_for_checks'
-    ).and_return(True)
     flexmock(module.borgmatic.config.validate).should_receive('repositories_match').never()
     flexmock(module.borgmatic.borg.check).should_receive('check_archives').once()
     flexmock(module.borgmatic.hooks.command).should_receive('execute_hook').times(2)
     check_arguments = flexmock(
-        repository=None, progress=flexmock(), repair=flexmock(), only=flexmock(), force=flexmock(),
+        repository=None,
+        progress=flexmock(),
+        repair=flexmock(),
+        only=flexmock(),
+        force=flexmock(),
     )
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_check(
         config_filename='test.yaml',
-        repository='repo',
-        location={'repositories': ['repo']},
-        storage={},
-        consistency={},
-        hooks={},
+        repository={'path': 'repo'},
+        config={'repositories': ['repo']},
         hook_context={},
         local_borg_version=None,
         check_arguments=check_arguments,
         global_arguments=global_arguments,
         local_path=None,
         remote_path=None,
     )
@@ -45,19 +43,16 @@
         only=flexmock(),
         force=flexmock(),
     )
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_check(
         config_filename='test.yaml',
-        repository=flexmock(),
-        location={'repositories': ['repo']},
-        storage={},
-        consistency={},
-        hooks={},
+        repository={'path': 'repo'},
+        config={'repositories': ['repo']},
         hook_context={},
         local_borg_version=None,
         check_arguments=check_arguments,
         global_arguments=global_arguments,
         local_path=None,
         remote_path=None,
     )
@@ -76,19 +71,16 @@
         only=flexmock(),
         force=flexmock(),
     )
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_check(
         config_filename='test.yaml',
-        repository='repo',
-        location={'repositories': ['repo']},
-        storage={},
-        consistency={},
-        hooks={},
+        repository={'path': 'repo'},
+        config={'repositories': ['repo']},
         hook_context={},
         local_borg_version=None,
         check_arguments=check_arguments,
         global_arguments=global_arguments,
         local_path=None,
         remote_path=None,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_compact.py` & `borgmatic-1.8.0/tests/unit/actions/test_compact.py`

 * *Files 11% similar despite different names*

```diff
@@ -12,18 +12,16 @@
     compact_arguments = flexmock(
         repository=None, progress=flexmock(), cleanup_commits=flexmock(), threshold=flexmock()
     )
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_compact(
         config_filename='test.yaml',
-        repository='repo',
-        storage={},
-        retention={},
-        hooks={},
+        repository={'path': 'repo'},
+        config={},
         hook_context={},
         local_borg_version=None,
         compact_arguments=compact_arguments,
         global_arguments=global_arguments,
         dry_run_label='',
         local_path=None,
         remote_path=None,
@@ -40,18 +38,16 @@
     compact_arguments = flexmock(
         repository=flexmock(), progress=flexmock(), cleanup_commits=flexmock(), threshold=flexmock()
     )
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_compact(
         config_filename='test.yaml',
-        repository='repo',
-        storage={},
-        retention={},
-        hooks={},
+        repository={'path': 'repo'},
+        config={},
         hook_context={},
         local_borg_version=None,
         compact_arguments=compact_arguments,
         global_arguments=global_arguments,
         dry_run_label='',
         local_path=None,
         remote_path=None,
@@ -68,18 +64,16 @@
     compact_arguments = flexmock(
         repository=flexmock(), progress=flexmock(), cleanup_commits=flexmock(), threshold=flexmock()
     )
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_compact(
         config_filename='test.yaml',
-        repository='repo',
-        storage={},
-        retention={},
-        hooks={},
+        repository={'path': 'repo'},
+        config={},
         hook_context={},
         local_borg_version=None,
         compact_arguments=compact_arguments,
         global_arguments=global_arguments,
         dry_run_label='',
         local_path=None,
         remote_path=None,
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_export_tar.py` & `borgmatic-1.8.0/tests/unit/actions/test_export_tar.py`

 * *Files 10% similar despite different names*

```diff
@@ -15,15 +15,15 @@
         tar_filter=flexmock(),
         list_files=flexmock(),
         strip_components=flexmock(),
     )
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_export_tar(
-        repository='repo',
-        storage={},
+        repository={'path': 'repo'},
+        config={},
         local_borg_version=None,
         export_tar_arguments=export_tar_arguments,
         global_arguments=global_arguments,
         local_path=None,
         remote_path=None,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_extract.py` & `borgmatic-1.8.0/tests/unit/actions/test_extract.py`

 * *Files 13% similar despite different names*

```diff
@@ -16,18 +16,16 @@
         archive=flexmock(),
         repository='repo',
     )
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_extract(
         config_filename='test.yaml',
-        repository='repo',
-        location={'repositories': ['repo']},
-        storage={},
-        hooks={},
+        repository={'path': 'repo'},
+        config={'repositories': ['repo']},
         hook_context={},
         local_borg_version=None,
         extract_arguments=extract_arguments,
         global_arguments=global_arguments,
         local_path=None,
         remote_path=None,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_info.py` & `borgmatic-1.8.0/tests/unit/actions/test_info.py`

 * *Files 9% similar despite different names*

```diff
@@ -5,20 +5,24 @@
 
 def test_run_info_does_not_raise():
     flexmock(module.logger).answer = lambda message: None
     flexmock(module.borgmatic.config.validate).should_receive('repositories_match').and_return(True)
     flexmock(module.borgmatic.borg.rlist).should_receive('resolve_archive_name').and_return(
         flexmock()
     )
+    flexmock(module.borgmatic.actions.arguments).should_receive('update_arguments').and_return(
+        flexmock()
+    )
     flexmock(module.borgmatic.borg.info).should_receive('display_archives_info')
     info_arguments = flexmock(repository=flexmock(), archive=flexmock(), json=flexmock())
 
     list(
         module.run_info(
-            repository='repo',
-            storage={},
+            repository={'path': 'repo'},
+            config={},
             local_borg_version=None,
             info_arguments=info_arguments,
+            global_arguments=flexmock(log_json=False),
             local_path=None,
             remote_path=None,
         )
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_list.py` & `borgmatic-1.8.0/tests/unit/actions/test_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,20 +5,24 @@
 
 def test_run_list_does_not_raise():
     flexmock(module.logger).answer = lambda message: None
     flexmock(module.borgmatic.config.validate).should_receive('repositories_match').and_return(True)
     flexmock(module.borgmatic.borg.rlist).should_receive('resolve_archive_name').and_return(
         flexmock()
     )
+    flexmock(module.borgmatic.actions.arguments).should_receive('update_arguments').and_return(
+        flexmock()
+    )
     flexmock(module.borgmatic.borg.list).should_receive('list_archive')
     list_arguments = flexmock(repository=flexmock(), archive=flexmock(), json=flexmock())
 
     list(
         module.run_list(
-            repository='repo',
-            storage={},
+            repository={'path': 'repo'},
+            config={},
             local_borg_version=None,
             list_arguments=list_arguments,
+            global_arguments=flexmock(log_json=False),
             local_path=None,
             remote_path=None,
         )
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_mount.py` & `borgmatic-1.8.0/tests/unit/actions/test_mount.py`

 * *Files 26% similar despite different names*

```diff
@@ -13,14 +13,15 @@
         mount_point=flexmock(),
         paths=flexmock(),
         foreground=flexmock(),
         options=flexmock(),
     )
 
     module.run_mount(
-        repository='repo',
-        storage={},
+        repository={'path': 'repo'},
+        config={},
         local_borg_version=None,
         mount_arguments=mount_arguments,
+        global_arguments=flexmock(log_json=False),
         local_path=None,
         remote_path=None,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_prune.py` & `borgmatic-1.8.0/tests/unit/actions/test_prune.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,18 +9,16 @@
     flexmock(module.borgmatic.borg.prune).should_receive('prune_archives').once()
     flexmock(module.borgmatic.hooks.command).should_receive('execute_hook').times(2)
     prune_arguments = flexmock(repository=None, stats=flexmock(), list_archives=flexmock())
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_prune(
         config_filename='test.yaml',
-        repository='repo',
-        storage={},
-        retention={},
-        hooks={},
+        repository={'path': 'repo'},
+        config={},
         hook_context={},
         local_borg_version=None,
         prune_arguments=prune_arguments,
         global_arguments=global_arguments,
         dry_run_label='',
         local_path=None,
         remote_path=None,
@@ -34,18 +32,16 @@
     ).once().and_return(True)
     flexmock(module.borgmatic.borg.prune).should_receive('prune_archives').once()
     prune_arguments = flexmock(repository=flexmock(), stats=flexmock(), list_archives=flexmock())
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_prune(
         config_filename='test.yaml',
-        repository='repo',
-        storage={},
-        retention={},
-        hooks={},
+        repository={'path': 'repo'},
+        config={},
         hook_context={},
         local_borg_version=None,
         prune_arguments=prune_arguments,
         global_arguments=global_arguments,
         dry_run_label='',
         local_path=None,
         remote_path=None,
@@ -60,17 +56,15 @@
     flexmock(module.borgmatic.borg.prune).should_receive('prune_archives').never()
     prune_arguments = flexmock(repository=flexmock(), stats=flexmock(), list_archives=flexmock())
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_prune(
         config_filename='test.yaml',
         repository='repo',
-        storage={},
-        retention={},
-        hooks={},
+        config={},
         hook_context={},
         local_borg_version=None,
         prune_arguments=prune_arguments,
         global_arguments=global_arguments,
         dry_run_label='',
         local_path=None,
         remote_path=None,
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_rcreate.py` & `borgmatic-1.8.0/tests/unit/actions/test_rcreate.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,16 +14,16 @@
         copy_crypt_key=flexmock(),
         append_only=flexmock(),
         storage_quota=flexmock(),
         make_parent_dirs=flexmock(),
     )
 
     module.run_rcreate(
-        repository='repo',
-        storage={},
+        repository={'path': 'repo'},
+        config={},
         local_borg_version=None,
         rcreate_arguments=arguments,
         global_arguments=flexmock(dry_run=False),
         local_path=None,
         remote_path=None,
     )
 
@@ -41,15 +41,15 @@
         copy_crypt_key=flexmock(),
         append_only=flexmock(),
         storage_quota=flexmock(),
         make_parent_dirs=flexmock(),
     )
 
     module.run_rcreate(
-        repository='repo',
-        storage={},
+        repository={'path': 'repo'},
+        config={},
         local_borg_version=None,
         rcreate_arguments=arguments,
         global_arguments=flexmock(dry_run=False),
         local_path=None,
         remote_path=None,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_restore.py` & `borgmatic-1.8.0/tests/unit/actions/test_restore.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,55 +2,55 @@
 from flexmock import flexmock
 
 import borgmatic.actions.restore as module
 
 
 def test_get_configured_database_matches_database_by_name():
     assert module.get_configured_database(
-        hooks={
+        config={
             'other_databases': [{'name': 'other'}],
             'postgresql_databases': [{'name': 'foo'}, {'name': 'bar'}],
         },
         archive_database_names={'postgresql_databases': ['other', 'foo', 'bar']},
         hook_name='postgresql_databases',
         database_name='bar',
     ) == ('postgresql_databases', {'name': 'bar'})
 
 
 def test_get_configured_database_matches_nothing_when_database_name_not_configured():
     assert module.get_configured_database(
-        hooks={'postgresql_databases': [{'name': 'foo'}, {'name': 'bar'}]},
+        config={'postgresql_databases': [{'name': 'foo'}, {'name': 'bar'}]},
         archive_database_names={'postgresql_databases': ['foo']},
         hook_name='postgresql_databases',
         database_name='quux',
     ) == (None, None)
 
 
 def test_get_configured_database_matches_nothing_when_database_name_not_in_archive():
     assert module.get_configured_database(
-        hooks={'postgresql_databases': [{'name': 'foo'}, {'name': 'bar'}]},
+        config={'postgresql_databases': [{'name': 'foo'}, {'name': 'bar'}]},
         archive_database_names={'postgresql_databases': ['bar']},
         hook_name='postgresql_databases',
         database_name='foo',
     ) == (None, None)
 
 
 def test_get_configured_database_matches_database_by_configuration_database_name():
     assert module.get_configured_database(
-        hooks={'postgresql_databases': [{'name': 'all'}, {'name': 'bar'}]},
+        config={'postgresql_databases': [{'name': 'all'}, {'name': 'bar'}]},
         archive_database_names={'postgresql_databases': ['foo']},
         hook_name='postgresql_databases',
         database_name='foo',
         configuration_database_name='all',
     ) == ('postgresql_databases', {'name': 'all'})
 
 
 def test_get_configured_database_with_unspecified_hook_matches_database_by_name():
     assert module.get_configured_database(
-        hooks={
+        config={
             'other_databases': [{'name': 'other'}],
             'postgresql_databases': [{'name': 'foo'}, {'name': 'bar'}],
         },
         archive_database_names={'postgresql_databases': ['other', 'foo', 'bar']},
         hook_name=module.UNSPECIFIED_HOOK,
         database_name='bar',
     ) == ('postgresql_databases', {'name': 'bar'})
@@ -63,19 +63,19 @@
             '.borgmatic/postgresql_databases/localhost/foo',
             '.borgmatic/postgresql_databases/localhost/bar',
             '.borgmatic/mysql_databases/localhost/quux',
         ]
     )
 
     archive_database_names = module.collect_archive_database_names(
-        repository='repo',
+        repository={'path': 'repo'},
         archive='archive',
-        location={'borgmatic_source_directory': '.borgmatic'},
-        storage=flexmock(),
+        config={'borgmatic_source_directory': '.borgmatic'},
         local_borg_version=flexmock(),
+        global_arguments=flexmock(log_json=False),
         local_path=flexmock(),
         remote_path=flexmock(),
     )
 
     assert archive_database_names == {
         'postgresql_databases': ['foo', 'bar'],
         'mysql_databases': ['quux'],
@@ -88,19 +88,19 @@
         [
             '.borgmatic/postgresql_databases/localhost/foo/table1',
             '.borgmatic/postgresql_databases/localhost/foo/table2',
         ]
     )
 
     archive_database_names = module.collect_archive_database_names(
-        repository='repo',
+        repository={'path': 'repo'},
         archive='archive',
-        location={'borgmatic_source_directory': '.borgmatic'},
-        storage=flexmock(),
+        config={'borgmatic_source_directory': '.borgmatic'},
         local_borg_version=flexmock(),
+        global_arguments=flexmock(log_json=False),
         local_path=flexmock(),
         remote_path=flexmock(),
     )
 
     assert archive_database_names == {
         'postgresql_databases': ['foo'],
     }
@@ -109,19 +109,19 @@
 def test_collect_archive_database_names_skips_bad_archive_paths():
     flexmock(module.borgmatic.hooks.dump).should_receive('make_database_dump_path').and_return('')
     flexmock(module.borgmatic.borg.list).should_receive('capture_archive_listing').and_return(
         ['.borgmatic/postgresql_databases/localhost/foo', '.borgmatic/invalid', 'invalid/as/well']
     )
 
     archive_database_names = module.collect_archive_database_names(
-        repository='repo',
+        repository={'path': 'repo'},
         archive='archive',
-        location={'borgmatic_source_directory': '.borgmatic'},
-        storage=flexmock(),
+        config={'borgmatic_source_directory': '.borgmatic'},
         local_borg_version=flexmock(),
+        global_arguments=flexmock(log_json=False),
         local_path=flexmock(),
         remote_path=flexmock(),
     )
 
     assert archive_database_names == {
         'postgresql_databases': ['foo'],
     }
@@ -144,25 +144,27 @@
         )
 
 
 def test_find_databases_to_restore_without_requested_names_finds_all_archive_databases():
     archive_database_names = {'postresql_databases': ['foo', 'bar']}
 
     restore_names = module.find_databases_to_restore(
-        requested_database_names=[], archive_database_names=archive_database_names,
+        requested_database_names=[],
+        archive_database_names=archive_database_names,
     )
 
     assert restore_names == archive_database_names
 
 
 def test_find_databases_to_restore_with_all_in_requested_names_finds_all_archive_databases():
     archive_database_names = {'postresql_databases': ['foo', 'bar']}
 
     restore_names = module.find_databases_to_restore(
-        requested_database_names=['all'], archive_database_names=archive_database_names,
+        requested_database_names=['all'],
+        archive_database_names=archive_database_names,
     )
 
     assert restore_names == archive_database_names
 
 
 def test_find_databases_to_restore_with_all_in_requested_names_plus_additional_requested_names_omits_duplicates():
     archive_database_names = {'postresql_databases': ['foo', 'bar']}
@@ -190,15 +192,17 @@
         found_names=['foo', 'bar'],
     )
 
 
 def test_ensure_databases_found_with_no_databases_raises():
     with pytest.raises(ValueError):
         module.ensure_databases_found(
-            restore_names={'postgresql_databases': []}, remaining_restore_names={}, found_names=[],
+            restore_names={'postgresql_databases': []},
+            remaining_restore_names={},
+            found_names=[],
         )
 
 
 def test_ensure_databases_found_with_missing_databases_raises():
     with pytest.raises(ValueError):
         module.ensure_databases_found(
             restore_names={'postgresql_databases': ['foo']},
@@ -220,47 +224,53 @@
     flexmock(module).should_receive('collect_archive_database_names').and_return(flexmock())
     flexmock(module).should_receive('find_databases_to_restore').and_return(restore_names)
     flexmock(module).should_receive('get_configured_database').and_return(
         ('postgresql_databases', {'name': 'foo'})
     ).and_return(('postgresql_databases', {'name': 'bar'}))
     flexmock(module).should_receive('restore_single_database').with_args(
         repository=object,
-        location=object,
-        storage=object,
-        hooks=object,
+        config=object,
         local_borg_version=object,
         global_arguments=object,
         local_path=object,
         remote_path=object,
         archive_name=object,
         hook_name='postgresql_databases',
-        database={'name': 'foo'},
+        database={'name': 'foo', 'schemas': None},
+        connection_params=object,
     ).once()
     flexmock(module).should_receive('restore_single_database').with_args(
         repository=object,
-        location=object,
-        storage=object,
-        hooks=object,
+        config=object,
         local_borg_version=object,
         global_arguments=object,
         local_path=object,
         remote_path=object,
         archive_name=object,
         hook_name='postgresql_databases',
-        database={'name': 'bar'},
+        database={'name': 'bar', 'schemas': None},
+        connection_params=object,
     ).once()
     flexmock(module).should_receive('ensure_databases_found')
 
     module.run_restore(
-        repository='repo',
-        location=flexmock(),
-        storage=flexmock(),
-        hooks=flexmock(),
+        repository={'path': 'repo'},
+        config=flexmock(),
         local_borg_version=flexmock(),
-        restore_arguments=flexmock(repository='repo', archive='archive', databases=flexmock()),
+        restore_arguments=flexmock(
+            repository='repo',
+            archive='archive',
+            databases=flexmock(),
+            schemas=None,
+            hostname=None,
+            port=None,
+            username=None,
+            password=None,
+            restore_path=None,
+        ),
         global_arguments=flexmock(dry_run=False),
         local_path=flexmock(),
         remote_path=flexmock(),
     )
 
 
 def test_run_restore_bails_for_non_matching_repository():
@@ -269,18 +279,16 @@
     )
     flexmock(module.borgmatic.hooks.dispatch).should_receive(
         'call_hooks_even_if_unconfigured'
     ).never()
     flexmock(module).should_receive('restore_single_database').never()
 
     module.run_restore(
-        repository='repo',
-        location=flexmock(),
-        storage=flexmock(),
-        hooks=flexmock(),
+        repository={'path': 'repo'},
+        config=flexmock(),
         local_borg_version=flexmock(),
         restore_arguments=flexmock(repository='repo', archive='archive', databases=flexmock()),
         global_arguments=flexmock(dry_run=False),
         local_path=flexmock(),
         remote_path=flexmock(),
     )
 
@@ -294,67 +302,73 @@
     flexmock(module.borgmatic.hooks.dispatch).should_receive('call_hooks_even_if_unconfigured')
     flexmock(module.borgmatic.borg.rlist).should_receive('resolve_archive_name').and_return(
         flexmock()
     )
     flexmock(module).should_receive('collect_archive_database_names').and_return(flexmock())
     flexmock(module).should_receive('find_databases_to_restore').and_return(restore_names)
     flexmock(module).should_receive('get_configured_database').with_args(
-        hooks=object,
+        config=object,
         archive_database_names=object,
         hook_name='postgresql_databases',
         database_name='foo',
     ).and_return(('postgresql_databases', {'name': 'foo'}))
     flexmock(module).should_receive('get_configured_database').with_args(
-        hooks=object,
+        config=object,
         archive_database_names=object,
         hook_name='postgresql_databases',
         database_name='bar',
     ).and_return((None, None))
     flexmock(module).should_receive('get_configured_database').with_args(
-        hooks=object,
+        config=object,
         archive_database_names=object,
         hook_name='postgresql_databases',
         database_name='bar',
         configuration_database_name='all',
     ).and_return(('postgresql_databases', {'name': 'bar'}))
     flexmock(module).should_receive('restore_single_database').with_args(
         repository=object,
-        location=object,
-        storage=object,
-        hooks=object,
+        config=object,
         local_borg_version=object,
         global_arguments=object,
         local_path=object,
         remote_path=object,
         archive_name=object,
         hook_name='postgresql_databases',
-        database={'name': 'foo'},
+        database={'name': 'foo', 'schemas': None},
+        connection_params=object,
     ).once()
     flexmock(module).should_receive('restore_single_database').with_args(
         repository=object,
-        location=object,
-        storage=object,
-        hooks=object,
+        config=object,
         local_borg_version=object,
         global_arguments=object,
         local_path=object,
         remote_path=object,
         archive_name=object,
         hook_name='postgresql_databases',
-        database={'name': 'bar'},
+        database={'name': 'bar', 'schemas': None},
+        connection_params=object,
     ).once()
     flexmock(module).should_receive('ensure_databases_found')
 
     module.run_restore(
-        repository='repo',
-        location=flexmock(),
-        storage=flexmock(),
-        hooks=flexmock(),
+        repository={'path': 'repo'},
+        config=flexmock(),
         local_borg_version=flexmock(),
-        restore_arguments=flexmock(repository='repo', archive='archive', databases=flexmock()),
+        restore_arguments=flexmock(
+            repository='repo',
+            archive='archive',
+            databases=flexmock(),
+            schemas=None,
+            hostname=None,
+            port=None,
+            username=None,
+            password=None,
+            restore_path=None,
+        ),
         global_arguments=flexmock(dry_run=False),
         local_path=flexmock(),
         remote_path=flexmock(),
     )
 
 
 def test_run_restore_skips_missing_database():
@@ -366,67 +380,73 @@
     flexmock(module.borgmatic.hooks.dispatch).should_receive('call_hooks_even_if_unconfigured')
     flexmock(module.borgmatic.borg.rlist).should_receive('resolve_archive_name').and_return(
         flexmock()
     )
     flexmock(module).should_receive('collect_archive_database_names').and_return(flexmock())
     flexmock(module).should_receive('find_databases_to_restore').and_return(restore_names)
     flexmock(module).should_receive('get_configured_database').with_args(
-        hooks=object,
+        config=object,
         archive_database_names=object,
         hook_name='postgresql_databases',
         database_name='foo',
     ).and_return(('postgresql_databases', {'name': 'foo'}))
     flexmock(module).should_receive('get_configured_database').with_args(
-        hooks=object,
+        config=object,
         archive_database_names=object,
         hook_name='postgresql_databases',
         database_name='bar',
     ).and_return((None, None))
     flexmock(module).should_receive('get_configured_database').with_args(
-        hooks=object,
+        config=object,
         archive_database_names=object,
         hook_name='postgresql_databases',
         database_name='bar',
         configuration_database_name='all',
     ).and_return((None, None))
     flexmock(module).should_receive('restore_single_database').with_args(
         repository=object,
-        location=object,
-        storage=object,
-        hooks=object,
+        config=object,
         local_borg_version=object,
         global_arguments=object,
         local_path=object,
         remote_path=object,
         archive_name=object,
         hook_name='postgresql_databases',
-        database={'name': 'foo'},
+        database={'name': 'foo', 'schemas': None},
+        connection_params=object,
     ).once()
     flexmock(module).should_receive('restore_single_database').with_args(
         repository=object,
-        location=object,
-        storage=object,
-        hooks=object,
+        config=object,
         local_borg_version=object,
         global_arguments=object,
         local_path=object,
         remote_path=object,
         archive_name=object,
         hook_name='postgresql_databases',
-        database={'name': 'bar'},
+        database={'name': 'bar', 'schemas': None},
+        connection_params=object,
     ).never()
     flexmock(module).should_receive('ensure_databases_found')
 
     module.run_restore(
-        repository='repo',
-        location=flexmock(),
-        storage=flexmock(),
-        hooks=flexmock(),
+        repository={'path': 'repo'},
+        config=flexmock(),
         local_borg_version=flexmock(),
-        restore_arguments=flexmock(repository='repo', archive='archive', databases=flexmock()),
+        restore_arguments=flexmock(
+            repository='repo',
+            archive='archive',
+            databases=flexmock(),
+            schemas=None,
+            hostname=None,
+            port=None,
+            username=None,
+            password=None,
+            restore_path=None,
+        ),
         global_arguments=flexmock(dry_run=False),
         local_path=flexmock(),
         remote_path=flexmock(),
     )
 
 
 def test_run_restore_restores_databases_from_different_hooks():
@@ -439,57 +459,63 @@
     flexmock(module.borgmatic.hooks.dispatch).should_receive('call_hooks_even_if_unconfigured')
     flexmock(module.borgmatic.borg.rlist).should_receive('resolve_archive_name').and_return(
         flexmock()
     )
     flexmock(module).should_receive('collect_archive_database_names').and_return(flexmock())
     flexmock(module).should_receive('find_databases_to_restore').and_return(restore_names)
     flexmock(module).should_receive('get_configured_database').with_args(
-        hooks=object,
+        config=object,
         archive_database_names=object,
         hook_name='postgresql_databases',
         database_name='foo',
     ).and_return(('postgresql_databases', {'name': 'foo'}))
     flexmock(module).should_receive('get_configured_database').with_args(
-        hooks=object,
+        config=object,
         archive_database_names=object,
         hook_name='mysql_databases',
         database_name='bar',
     ).and_return(('mysql_databases', {'name': 'bar'}))
     flexmock(module).should_receive('restore_single_database').with_args(
         repository=object,
-        location=object,
-        storage=object,
-        hooks=object,
+        config=object,
         local_borg_version=object,
         global_arguments=object,
         local_path=object,
         remote_path=object,
         archive_name=object,
         hook_name='postgresql_databases',
-        database={'name': 'foo'},
+        database={'name': 'foo', 'schemas': None},
+        connection_params=object,
     ).once()
     flexmock(module).should_receive('restore_single_database').with_args(
         repository=object,
-        location=object,
-        storage=object,
-        hooks=object,
+        config=object,
         local_borg_version=object,
         global_arguments=object,
         local_path=object,
         remote_path=object,
         archive_name=object,
         hook_name='mysql_databases',
-        database={'name': 'bar'},
+        database={'name': 'bar', 'schemas': None},
+        connection_params=object,
     ).once()
     flexmock(module).should_receive('ensure_databases_found')
 
     module.run_restore(
-        repository='repo',
-        location=flexmock(),
-        storage=flexmock(),
-        hooks=flexmock(),
+        repository={'path': 'repo'},
+        config=flexmock(),
         local_borg_version=flexmock(),
-        restore_arguments=flexmock(repository='repo', archive='archive', databases=flexmock()),
+        restore_arguments=flexmock(
+            repository='repo',
+            archive='archive',
+            databases=flexmock(),
+            schemas=None,
+            hostname=None,
+            port=None,
+            username=None,
+            password=None,
+            restore_path=None,
+        ),
         global_arguments=flexmock(dry_run=False),
         local_path=flexmock(),
         remote_path=flexmock(),
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/actions/test_transfer.py` & `borgmatic-1.8.0/tests/unit/actions/test_transfer.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 def test_run_transfer_does_not_raise():
     flexmock(module.logger).answer = lambda message: None
     flexmock(module.borgmatic.borg.transfer).should_receive('transfer_archives')
     transfer_arguments = flexmock()
     global_arguments = flexmock(monitoring_verbosity=1, dry_run=False)
 
     module.run_transfer(
-        repository='repo',
-        storage={},
+        repository={'path': 'repo'},
+        config={},
         local_borg_version=None,
         transfer_arguments=transfer_arguments,
         global_arguments=global_arguments,
         local_path=None,
         remote_path=None,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_borg.py` & `borgmatic-1.8.0/tests/unit/borg/test_rinfo.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,295 +1,308 @@
 import logging
 
 from flexmock import flexmock
 
-from borgmatic.borg import borg as module
+from borgmatic.borg import rinfo as module
 
 from ..test_verbosity import insert_logging_mock
 
 
-def test_run_arbitrary_borg_calls_borg_with_parameters():
+def test_display_repository_info_calls_borg_with_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    flexmock(module.flags).should_receive('make_flags').and_return(())
-    flexmock(module.environment).should_receive('make_environment')
-    flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'break-lock', 'repo'),
-        output_log_level=module.borgmatic.logger.ANSWER,
-        borg_local_path='borg',
-        extra_environment=None,
-    )
-
-    module.run_arbitrary_borg(
-        repository='repo', storage_config={}, local_borg_version='1.2.3', options=['break-lock'],
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
     )
-
-
-def test_run_arbitrary_borg_with_log_info_calls_borg_with_info_parameter():
-    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
-    flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'break-lock', 'repo', '--info'),
+        ('borg', 'rinfo', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     )
-    insert_logging_mock(logging.INFO)
 
-    module.run_arbitrary_borg(
-        repository='repo', storage_config={}, local_borg_version='1.2.3', options=['break-lock'],
+    module.display_repository_info(
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        rinfo_arguments=flexmock(json=False),
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_run_arbitrary_borg_with_log_debug_calls_borg_with_debug_parameter():
+def test_display_repository_info_without_borg_features_calls_borg_with_info_sub_command():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
+    flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'break-lock', 'repo', '--debug', '--show-rc'),
+        ('borg', 'info', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     )
-    insert_logging_mock(logging.DEBUG)
 
-    module.run_arbitrary_borg(
-        repository='repo', storage_config={}, local_borg_version='1.2.3', options=['break-lock'],
+    module.display_repository_info(
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        rinfo_arguments=flexmock(json=False),
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_run_arbitrary_borg_with_lock_wait_calls_borg_with_lock_wait_parameters():
+def test_display_repository_info_with_log_info_calls_borg_with_info_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    storage_config = {'lock_wait': 5}
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    flexmock(module.flags).should_receive('make_flags').and_return(()).and_return(
-        ('--lock-wait', '5')
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
     )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'break-lock', 'repo', '--lock-wait', '5'),
+        ('borg', 'rinfo', '--info', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     )
-
-    module.run_arbitrary_borg(
-        repository='repo',
-        storage_config=storage_config,
-        local_borg_version='1.2.3',
-        options=['break-lock'],
+    insert_logging_mock(logging.INFO)
+    module.display_repository_info(
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        rinfo_arguments=flexmock(json=False),
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_run_arbitrary_borg_with_archive_calls_borg_with_archive_parameter():
+def test_display_repository_info_with_log_info_and_json_suppresses_most_borg_output():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
     )
-    flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.environment).should_receive('make_environment')
-    flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'break-lock', 'repo::archive'),
-        output_log_level=module.borgmatic.logger.ANSWER,
-        borg_local_path='borg',
+    flexmock(module).should_receive('execute_command_and_capture_output').with_args(
+        ('borg', 'rinfo', '--json', '--repo', 'repo'),
         extra_environment=None,
-    )
-
-    module.run_arbitrary_borg(
-        repository='repo',
-        storage_config={},
-        local_borg_version='1.2.3',
-        options=['break-lock'],
-        archive='archive',
-    )
-
+        borg_local_path='borg',
+    ).and_return('[]')
 
-def test_run_arbitrary_borg_with_local_path_calls_borg_via_local_path():
-    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
-    flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    flexmock(module.flags).should_receive('make_flags').and_return(())
-    flexmock(module.environment).should_receive('make_environment')
-    flexmock(module).should_receive('execute_command').with_args(
-        ('borg1', 'break-lock', 'repo'),
-        output_log_level=module.borgmatic.logger.ANSWER,
-        borg_local_path='borg1',
-        extra_environment=None,
+    insert_logging_mock(logging.INFO)
+    json_output = module.display_repository_info(
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        rinfo_arguments=flexmock(json=True),
+        global_arguments=flexmock(log_json=False),
     )
 
-    module.run_arbitrary_borg(
-        repository='repo',
-        storage_config={},
-        local_borg_version='1.2.3',
-        options=['break-lock'],
-        local_path='borg1',
-    )
+    assert json_output == '[]'
 
 
-def test_run_arbitrary_borg_with_remote_path_calls_borg_with_remote_path_parameters():
+def test_display_repository_info_with_log_debug_calls_borg_with_debug_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    flexmock(module.flags).should_receive('make_flags').and_return(
-        ('--remote-path', 'borg1')
-    ).and_return(())
-    flexmock(module.environment).should_receive('make_environment')
-    flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'break-lock', 'repo', '--remote-path', 'borg1'),
-        output_log_level=module.borgmatic.logger.ANSWER,
-        borg_local_path='borg',
-        extra_environment=None,
-    )
-
-    module.run_arbitrary_borg(
-        repository='repo',
-        storage_config={},
-        local_borg_version='1.2.3',
-        options=['break-lock'],
-        remote_path='borg1',
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
     )
-
-
-def test_run_arbitrary_borg_passes_borg_specific_parameters_to_borg():
-    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
-    flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'list', 'repo', '--progress'),
+        ('borg', 'rinfo', '--debug', '--show-rc', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     )
+    insert_logging_mock(logging.DEBUG)
 
-    module.run_arbitrary_borg(
-        repository='repo',
-        storage_config={},
-        local_borg_version='1.2.3',
-        options=['list', '--progress'],
+    module.display_repository_info(
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        rinfo_arguments=flexmock(json=False),
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_run_arbitrary_borg_omits_dash_dash_in_parameters_passed_to_borg():
+def test_display_repository_info_with_log_debug_and_json_suppresses_most_borg_output():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
     flexmock(module.environment).should_receive('make_environment')
-    flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'break-lock', 'repo'),
-        output_log_level=module.borgmatic.logger.ANSWER,
-        borg_local_path='borg',
+    flexmock(module).should_receive('execute_command_and_capture_output').with_args(
+        ('borg', 'rinfo', '--json', '--repo', 'repo'),
         extra_environment=None,
-    )
+        borg_local_path='borg',
+    ).and_return('[]')
 
-    module.run_arbitrary_borg(
-        repository='repo',
-        storage_config={},
-        local_borg_version='1.2.3',
-        options=['--', 'break-lock'],
+    insert_logging_mock(logging.DEBUG)
+    json_output = module.display_repository_info(
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        rinfo_arguments=flexmock(json=True),
+        global_arguments=flexmock(log_json=False),
     )
 
+    assert json_output == '[]'
+
 
-def test_run_arbitrary_borg_without_borg_specific_parameters_does_not_raise():
+def test_display_repository_info_with_json_calls_borg_with_json_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_flags').never()
-    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
     flexmock(module.environment).should_receive('make_environment')
-    flexmock(module).should_receive('execute_command').with_args(
-        ('borg',),
-        output_log_level=module.borgmatic.logger.ANSWER,
-        borg_local_path='borg',
+    flexmock(module).should_receive('execute_command_and_capture_output').with_args(
+        ('borg', 'rinfo', '--json', '--repo', 'repo'),
         extra_environment=None,
-    )
+        borg_local_path='borg',
+    ).and_return('[]')
 
-    module.run_arbitrary_borg(
-        repository='repo', storage_config={}, local_borg_version='1.2.3', options=[],
+    json_output = module.display_repository_info(
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        rinfo_arguments=flexmock(json=True),
+        global_arguments=flexmock(log_json=False),
     )
 
+    assert json_output == '[]'
 
-def test_run_arbitrary_borg_passes_key_sub_command_to_borg_before_repository():
+
+def test_display_repository_info_with_local_path_calls_borg_via_local_path():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'key', 'export', 'repo'),
+        ('borg1', 'rinfo', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
-        borg_local_path='borg',
+        borg_local_path='borg1',
         extra_environment=None,
     )
 
-    module.run_arbitrary_borg(
-        repository='repo', storage_config={}, local_borg_version='1.2.3', options=['key', 'export'],
+    module.display_repository_info(
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        rinfo_arguments=flexmock(json=False),
+        global_arguments=flexmock(log_json=False),
+        local_path='borg1',
     )
 
 
-def test_run_arbitrary_borg_passes_debug_sub_command_to_borg_before_repository():
+def test_display_repository_info_with_remote_path_calls_borg_with_remote_path_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'debug', 'dump-manifest', 'repo', 'path'),
+        ('borg', 'rinfo', '--remote-path', 'borg1', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     )
 
-    module.run_arbitrary_borg(
-        repository='repo',
-        storage_config={},
-        local_borg_version='1.2.3',
-        options=['debug', 'dump-manifest', 'path'],
+    module.display_repository_info(
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        rinfo_arguments=flexmock(json=False),
+        global_arguments=flexmock(log_json=False),
+        remote_path='borg1',
     )
 
 
-def test_run_arbitrary_borg_with_debug_info_command_does_not_pass_borg_repository():
+def test_display_repository_info_with_log_json_calls_borg_with_log_json_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_flags').never()
-    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'debug', 'info'),
+        ('borg', 'rinfo', '--log-json', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     )
 
-    module.run_arbitrary_borg(
-        repository='repo', storage_config={}, local_borg_version='1.2.3', options=['debug', 'info'],
+    module.display_repository_info(
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        rinfo_arguments=flexmock(json=False),
+        global_arguments=flexmock(log_json=True),
     )
 
 
-def test_run_arbitrary_borg_with_debug_convert_profile_command_does_not_pass_borg_repository():
+def test_display_repository_info_with_lock_wait_calls_borg_with_lock_wait_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_flags').never()
-    flexmock(module.flags).should_receive('make_flags').and_return(())
+    config = {'lock_wait': 5}
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'debug', 'convert-profile', 'in', 'out'),
+        ('borg', 'rinfo', '--lock-wait', '5', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     )
 
-    module.run_arbitrary_borg(
-        repository='repo',
-        storage_config={},
-        local_borg_version='1.2.3',
-        options=['debug', 'convert-profile', 'in', 'out'],
+    module.display_repository_info(
+        repository_path='repo',
+        config=config,
+        local_borg_version='2.3.4',
+        rinfo_arguments=flexmock(json=False),
+        global_arguments=flexmock(log_json=False),
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_break_lock.py` & `borgmatic-1.8.0/tests/unit/borg/test_break_lock.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,65 +6,98 @@
 
 from ..test_verbosity import insert_logging_mock
 
 
 def insert_execute_command_mock(command):
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        command, borg_local_path='borg', extra_environment=None,
+        command,
+        borg_local_path='borg',
+        extra_environment=None,
     ).once()
 
 
 def test_break_lock_calls_borg_with_required_flags():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(('borg', 'break-lock', 'repo'))
 
     module.break_lock(
-        repository='repo', storage_config={}, local_borg_version='1.2.3',
+        repository_path='repo',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_break_lock_calls_borg_with_remote_path_flags():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(('borg', 'break-lock', '--remote-path', 'borg1', 'repo'))
 
     module.break_lock(
-        repository='repo', storage_config={}, local_borg_version='1.2.3', remote_path='borg1',
+        repository_path='repo',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        remote_path='borg1',
     )
 
 
 def test_break_lock_calls_borg_with_umask_flags():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(('borg', 'break-lock', '--umask', '0770', 'repo'))
 
     module.break_lock(
-        repository='repo', storage_config={'umask': '0770'}, local_borg_version='1.2.3',
+        repository_path='repo',
+        config={'umask': '0770'},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+    )
+
+
+def test_break_lock_calls_borg_with_log_json_flags():
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
+    insert_execute_command_mock(('borg', 'break-lock', '--log-json', 'repo'))
+
+    module.break_lock(
+        repository_path='repo',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=True),
     )
 
 
 def test_break_lock_calls_borg_with_lock_wait_flags():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(('borg', 'break-lock', '--lock-wait', '5', 'repo'))
 
     module.break_lock(
-        repository='repo', storage_config={'lock_wait': '5'}, local_borg_version='1.2.3',
+        repository_path='repo',
+        config={'lock_wait': '5'},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_break_lock_with_log_info_calls_borg_with_info_parameter():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(('borg', 'break-lock', '--info', 'repo'))
     insert_logging_mock(logging.INFO)
 
     module.break_lock(
-        repository='repo', storage_config={}, local_borg_version='1.2.3',
+        repository_path='repo',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_break_lock_with_log_debug_calls_borg_with_debug_flags():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(('borg', 'break-lock', '--debug', '--show-rc', 'repo'))
     insert_logging_mock(logging.DEBUG)
 
     module.break_lock(
-        repository='repo', storage_config={}, local_borg_version='1.2.3',
+        repository_path='repo',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_compact.py` & `borgmatic-1.8.0/tests/unit/borg/test_compact.py`

 * *Files 19% similar despite different names*

```diff
@@ -21,134 +21,177 @@
 
 
 def test_compact_segments_calls_borg_with_parameters():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(COMPACT_COMMAND + ('repo',), logging.INFO)
 
     module.compact_segments(
-        dry_run=False, repository='repo', storage_config={}, local_borg_version='1.2.3'
+        dry_run=False,
+        repository_path='repo',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_compact_segments_with_log_info_calls_borg_with_info_parameter():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(COMPACT_COMMAND + ('--info', 'repo'), logging.INFO)
     insert_logging_mock(logging.INFO)
 
     module.compact_segments(
-        repository='repo', storage_config={}, local_borg_version='1.2.3', dry_run=False
+        repository_path='repo',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        dry_run=False,
     )
 
 
 def test_compact_segments_with_log_debug_calls_borg_with_debug_parameter():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(COMPACT_COMMAND + ('--debug', '--show-rc', 'repo'), logging.INFO)
     insert_logging_mock(logging.DEBUG)
 
     module.compact_segments(
-        repository='repo', storage_config={}, local_borg_version='1.2.3', dry_run=False
+        repository_path='repo',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        dry_run=False,
     )
 
 
 def test_compact_segments_with_dry_run_skips_borg_call():
     flexmock(module).should_receive('execute_command').never()
 
     module.compact_segments(
-        repository='repo', storage_config={}, local_borg_version='1.2.3', dry_run=True
+        repository_path='repo',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        dry_run=True,
     )
 
 
 def test_compact_segments_with_local_path_calls_borg_via_local_path():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(('borg1',) + COMPACT_COMMAND[1:] + ('repo',), logging.INFO)
 
     module.compact_segments(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
         local_path='borg1',
     )
 
 
 def test_compact_segments_with_remote_path_calls_borg_with_remote_path_parameters():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(COMPACT_COMMAND + ('--remote-path', 'borg1', 'repo'), logging.INFO)
 
     module.compact_segments(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
         remote_path='borg1',
     )
 
 
 def test_compact_segments_with_progress_calls_borg_with_progress_parameter():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(COMPACT_COMMAND + ('--progress', 'repo'), logging.INFO)
 
     module.compact_segments(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
         progress=True,
     )
 
 
 def test_compact_segments_with_cleanup_commits_calls_borg_with_cleanup_commits_parameter():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(COMPACT_COMMAND + ('--cleanup-commits', 'repo'), logging.INFO)
 
     module.compact_segments(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
         cleanup_commits=True,
     )
 
 
 def test_compact_segments_with_threshold_calls_borg_with_threshold_parameter():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(COMPACT_COMMAND + ('--threshold', '20', 'repo'), logging.INFO)
 
     module.compact_segments(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
         threshold=20,
     )
 
 
 def test_compact_segments_with_umask_calls_borg_with_umask_parameters():
-    storage_config = {'umask': '077'}
+    config = {'umask': '077'}
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(COMPACT_COMMAND + ('--umask', '077', 'repo'), logging.INFO)
 
     module.compact_segments(
-        dry_run=False, repository='repo', storage_config=storage_config, local_borg_version='1.2.3'
+        dry_run=False,
+        repository_path='repo',
+        config=config,
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+    )
+
+
+def test_compact_segments_with_log_json_calls_borg_with_log_json_parameters():
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
+    insert_execute_command_mock(COMPACT_COMMAND + ('--log-json', 'repo'), logging.INFO)
+
+    module.compact_segments(
+        dry_run=False,
+        repository_path='repo',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=True),
     )
 
 
 def test_compact_segments_with_lock_wait_calls_borg_with_lock_wait_parameters():
-    storage_config = {'lock_wait': 5}
+    config = {'lock_wait': 5}
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(COMPACT_COMMAND + ('--lock-wait', '5', 'repo'), logging.INFO)
 
     module.compact_segments(
-        dry_run=False, repository='repo', storage_config=storage_config, local_borg_version='1.2.3'
+        dry_run=False,
+        repository_path='repo',
+        config=config,
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_compact_segments_with_extra_borg_options_calls_borg_with_extra_options():
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(COMPACT_COMMAND + ('--extra', '--options', 'repo'), logging.INFO)
 
     module.compact_segments(
         dry_run=False,
-        repository='repo',
-        storage_config={'extra_borg_options': {'compact': '--extra --options'}},
+        repository_path='repo',
+        config={'extra_borg_options': {'compact': '--extra --options'}},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_create.py` & `borgmatic-1.8.0/tests/unit/borg/test_create.py`

 * *Files 3% similar despite different names*

```diff
@@ -166,124 +166,119 @@
         ).and_return(flexmock(close=lambda: None))
 
     module.ensure_files_readable(*filename_lists)
 
 
 def test_make_pattern_flags_includes_pattern_filename_when_given():
     pattern_flags = module.make_pattern_flags(
-        location_config={'patterns': ['R /', '- /var']}, pattern_filename='/tmp/patterns'
+        config={'patterns': ['R /', '- /var']}, pattern_filename='/tmp/patterns'
     )
 
     assert pattern_flags == ('--patterns-from', '/tmp/patterns')
 
 
 def test_make_pattern_flags_includes_patterns_from_filenames_when_in_config():
-    pattern_flags = module.make_pattern_flags(
-        location_config={'patterns_from': ['patterns', 'other']}
-    )
+    pattern_flags = module.make_pattern_flags(config={'patterns_from': ['patterns', 'other']})
 
     assert pattern_flags == ('--patterns-from', 'patterns', '--patterns-from', 'other')
 
 
 def test_make_pattern_flags_includes_both_filenames_when_patterns_given_and_patterns_from_in_config():
     pattern_flags = module.make_pattern_flags(
-        location_config={'patterns_from': ['patterns']}, pattern_filename='/tmp/patterns'
+        config={'patterns_from': ['patterns']}, pattern_filename='/tmp/patterns'
     )
 
     assert pattern_flags == ('--patterns-from', 'patterns', '--patterns-from', '/tmp/patterns')
 
 
 def test_make_pattern_flags_considers_none_patterns_from_filenames_as_empty():
-    pattern_flags = module.make_pattern_flags(location_config={'patterns_from': None})
+    pattern_flags = module.make_pattern_flags(config={'patterns_from': None})
 
     assert pattern_flags == ()
 
 
 def test_make_exclude_flags_includes_exclude_patterns_filename_when_given():
     exclude_flags = module.make_exclude_flags(
-        location_config={'exclude_patterns': ['*.pyc', '/var']}, exclude_filename='/tmp/excludes'
+        config={'exclude_patterns': ['*.pyc', '/var']}, exclude_filename='/tmp/excludes'
     )
 
     assert exclude_flags == ('--exclude-from', '/tmp/excludes')
 
 
 def test_make_exclude_flags_includes_exclude_from_filenames_when_in_config():
-
-    exclude_flags = module.make_exclude_flags(
-        location_config={'exclude_from': ['excludes', 'other']}
-    )
+    exclude_flags = module.make_exclude_flags(config={'exclude_from': ['excludes', 'other']})
 
     assert exclude_flags == ('--exclude-from', 'excludes', '--exclude-from', 'other')
 
 
 def test_make_exclude_flags_includes_both_filenames_when_patterns_given_and_exclude_from_in_config():
     exclude_flags = module.make_exclude_flags(
-        location_config={'exclude_from': ['excludes']}, exclude_filename='/tmp/excludes'
+        config={'exclude_from': ['excludes']}, exclude_filename='/tmp/excludes'
     )
 
     assert exclude_flags == ('--exclude-from', 'excludes', '--exclude-from', '/tmp/excludes')
 
 
 def test_make_exclude_flags_considers_none_exclude_from_filenames_as_empty():
-    exclude_flags = module.make_exclude_flags(location_config={'exclude_from': None})
+    exclude_flags = module.make_exclude_flags(config={'exclude_from': None})
 
     assert exclude_flags == ()
 
 
 def test_make_exclude_flags_includes_exclude_caches_when_true_in_config():
-    exclude_flags = module.make_exclude_flags(location_config={'exclude_caches': True})
+    exclude_flags = module.make_exclude_flags(config={'exclude_caches': True})
 
     assert exclude_flags == ('--exclude-caches',)
 
 
 def test_make_exclude_flags_does_not_include_exclude_caches_when_false_in_config():
-    exclude_flags = module.make_exclude_flags(location_config={'exclude_caches': False})
+    exclude_flags = module.make_exclude_flags(config={'exclude_caches': False})
 
     assert exclude_flags == ()
 
 
 def test_make_exclude_flags_includes_exclude_if_present_when_in_config():
     exclude_flags = module.make_exclude_flags(
-        location_config={'exclude_if_present': ['exclude_me', 'also_me']}
+        config={'exclude_if_present': ['exclude_me', 'also_me']}
     )
 
     assert exclude_flags == (
         '--exclude-if-present',
         'exclude_me',
         '--exclude-if-present',
         'also_me',
     )
 
 
 def test_make_exclude_flags_includes_keep_exclude_tags_when_true_in_config():
-    exclude_flags = module.make_exclude_flags(location_config={'keep_exclude_tags': True})
+    exclude_flags = module.make_exclude_flags(config={'keep_exclude_tags': True})
 
     assert exclude_flags == ('--keep-exclude-tags',)
 
 
 def test_make_exclude_flags_does_not_include_keep_exclude_tags_when_false_in_config():
-    exclude_flags = module.make_exclude_flags(location_config={'keep_exclude_tags': False})
+    exclude_flags = module.make_exclude_flags(config={'keep_exclude_tags': False})
 
     assert exclude_flags == ()
 
 
 def test_make_exclude_flags_includes_exclude_nodump_when_true_in_config():
-    exclude_flags = module.make_exclude_flags(location_config={'exclude_nodump': True})
+    exclude_flags = module.make_exclude_flags(config={'exclude_nodump': True})
 
     assert exclude_flags == ('--exclude-nodump',)
 
 
 def test_make_exclude_flags_does_not_include_exclude_nodump_when_false_in_config():
-    exclude_flags = module.make_exclude_flags(location_config={'exclude_nodump': False})
+    exclude_flags = module.make_exclude_flags(config={'exclude_nodump': False})
 
     assert exclude_flags == ()
 
 
 def test_make_exclude_flags_is_empty_when_config_has_no_excludes():
-    exclude_flags = module.make_exclude_flags(location_config={})
+    exclude_flags = module.make_exclude_flags(config={})
 
     assert exclude_flags == ()
 
 
 def test_make_list_filter_flags_with_debug_and_feature_available_includes_plus_and_minus():
     flexmock(module.logger).should_receive('isEnabledFor').and_return(True)
     flexmock(module.feature).should_receive('available').and_return(True)
@@ -446,15 +441,35 @@
         local_path=None,
         working_directory=None,
         borg_environment=None,
         skip_directories=flexmock(),
     ) == ('/foo', '/baz')
 
 
-DEFAULT_ARCHIVE_NAME = '{hostname}-{now:%Y-%m-%dT%H:%M:%S.%f}'
+def test_collect_special_file_paths_omits_exclude_no_dump_flag_from_command():
+    flexmock(module).should_receive('execute_command_and_capture_output').with_args(
+        ('borg', 'create', '--dry-run', '--list'),
+        capture_stderr=True,
+        working_directory=None,
+        extra_environment=None,
+        borg_local_path='borg',
+    ).and_return('Processing files ...\n- /foo\n+ /bar\n- /baz').once()
+    flexmock(module).should_receive('special_file').and_return(True)
+    flexmock(module).should_receive('any_parent_directories').and_return(False)
+
+    module.collect_special_file_paths(
+        ('borg', 'create', '--exclude-nodump'),
+        local_path='borg',
+        working_directory=None,
+        borg_environment=None,
+        skip_directories=flexmock(),
+    )
+
+
+DEFAULT_ARCHIVE_NAME = '{hostname}-{now:%Y-%m-%dT%H:%M:%S.%f}'  # noqa: FS003
 REPO_ARCHIVE_WITH_PATHS = (f'repo::{DEFAULT_ARCHIVE_NAME}', 'foo', 'bar')
 
 
 def test_create_archive_calls_borg_with_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -481,22 +496,22 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_calls_borg_with_environment():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -524,22 +539,22 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=environment,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_patterns_calls_borg_with_patterns_including_converted_source_directories():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     pattern_flags = ('--patterns-from', 'patterns')
@@ -569,22 +584,70 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'patterns': ['pattern'],
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
+    )
+
+
+def test_create_archive_with_sources_and_used_config_paths_calls_borg_with_sources_and_config_paths():
+    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
+    flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
+    flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
+    flexmock(module).should_receive('deduplicate_directories').and_return(
+        ('foo', 'bar', '/etc/borgmatic/config.yaml')
+    )
+    flexmock(module).should_receive('map_directories_to_devices').and_return({})
+    flexmock(module).should_receive('expand_directories').with_args([]).and_return(())
+    flexmock(module).should_receive('expand_directories').with_args(
+        ('foo', 'bar', '/etc/borgmatic/config.yaml')
+    ).and_return(('foo', 'bar', '/etc/borgmatic/config.yaml'))
+    flexmock(module).should_receive('expand_directories').with_args([]).and_return(())
+    flexmock(module).should_receive('pattern_root_directories').and_return([])
+    flexmock(module.os.path).should_receive('expanduser').and_raise(TypeError)
+    flexmock(module).should_receive('expand_home_directories').and_return(())
+    flexmock(module).should_receive('write_pattern_file').and_return(None)
+    flexmock(module).should_receive('make_list_filter_flags').and_return('FOO')
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module).should_receive('ensure_files_readable')
+    flexmock(module).should_receive('make_pattern_flags').and_return(())
+    flexmock(module).should_receive('make_exclude_flags').and_return(())
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        (f'repo::{DEFAULT_ARCHIVE_NAME}',)
+    )
+    environment = {'BORG_THINGY': 'YUP'}
+    flexmock(module.environment).should_receive('make_environment').and_return(environment)
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'create') + REPO_ARCHIVE_WITH_PATHS + ('/etc/borgmatic/config.yaml',),
+        output_log_level=logging.INFO,
+        output_file=None,
+        borg_local_path='borg',
+        working_directory=None,
+        extra_environment=environment,
+    )
+
+    module.create_archive(
+        dry_run=False,
+        repository_path='repo',
+        config={
+            'source_directories': ['foo', 'bar'],
+            'repositories': ['repo'],
+        },
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=['/etc/borgmatic/config.yaml']),
     )
 
 
 def test_create_archive_with_exclude_patterns_calls_borg_with_excludes():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     exclude_flags = ('--exclude-from', 'excludes')
@@ -614,22 +677,22 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': ['exclude'],
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_log_info_calls_borg_with_info_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -657,22 +720,22 @@
         working_directory=None,
         extra_environment=None,
     )
     insert_logging_mock(logging.INFO)
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_log_info_and_json_suppresses_most_borg_output():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -692,27 +755,28 @@
         (f'repo::{DEFAULT_ARCHIVE_NAME}',)
     )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command_and_capture_output').with_args(
         ('borg', 'create') + REPO_ARCHIVE_WITH_PATHS + ('--json',),
         working_directory=None,
         extra_environment=None,
+        borg_local_path='borg',
     )
     insert_logging_mock(logging.INFO)
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         json=True,
     )
 
 
 def test_create_archive_with_log_debug_calls_borg_with_debug_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -741,22 +805,22 @@
         working_directory=None,
         extra_environment=None,
     )
     insert_logging_mock(logging.DEBUG)
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_log_debug_and_json_suppresses_most_borg_output():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -776,27 +840,28 @@
         (f'repo::{DEFAULT_ARCHIVE_NAME}',)
     )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command_and_capture_output').with_args(
         ('borg', 'create') + REPO_ARCHIVE_WITH_PATHS + ('--json',),
         working_directory=None,
         extra_environment=None,
+        borg_local_path='borg',
     )
     insert_logging_mock(logging.DEBUG)
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         json=True,
     )
 
 
 def test_create_archive_with_dry_run_calls_borg_with_dry_run_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -824,22 +889,22 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=True,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_stats_and_dry_run_calls_borg_without_stats_parameter():
     # --dry-run and --stats are mutually exclusive, see:
     # https://borgbackup.readthedocs.io/en/stable/usage/create.html#description
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
@@ -869,22 +934,22 @@
         working_directory=None,
         extra_environment=None,
     )
     insert_logging_mock(logging.INFO)
 
     module.create_archive(
         dry_run=True,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         stats=True,
     )
 
 
 def test_create_archive_with_checkpoint_interval_calls_borg_with_checkpoint_interval_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -912,22 +977,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
+            'checkpoint_interval': 600,
         },
-        storage_config={'checkpoint_interval': 600},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_checkpoint_volume_calls_borg_with_checkpoint_volume_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -954,22 +1020,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
+            'checkpoint_volume': 1024,
         },
-        storage_config={'checkpoint_volume': 1024},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_chunker_params_calls_borg_with_chunker_params_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -996,22 +1063,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
+            'chunker_params': '1,2,3,4',
         },
-        storage_config={'chunker_params': '1,2,3,4'},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_compression_calls_borg_with_compression_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -1038,27 +1106,29 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
+            'compression': 'rle',
         },
-        storage_config={'compression': 'rle'},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 @pytest.mark.parametrize(
-    'feature_available,option_flag', ((True, '--upload-ratelimit'), (False, '--remote-ratelimit')),
+    'feature_available,option_flag',
+    ((True, '--upload-ratelimit'), (False, '--remote-ratelimit')),
 )
 def test_create_archive_with_upload_rate_limit_calls_borg_with_upload_ratelimit_parameters(
     feature_available, option_flag
 ):
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -1085,22 +1155,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
+            'upload_rate_limit': 100,
         },
-        storage_config={'upload_rate_limit': 100},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_working_directory_calls_borg_with_working_directory():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -1129,23 +1200,23 @@
         borg_local_path='borg',
         working_directory='/working/dir',
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'working_directory': '/working/dir',
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_one_file_system_calls_borg_with_one_file_system_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -1172,28 +1243,29 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'one_file_system': True,
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 @pytest.mark.parametrize(
-    'feature_available,option_flag', ((True, '--numeric-ids'), (False, '--numeric-owner')),
+    'feature_available,option_flag',
+    ((True, '--numeric-ids'), (False, '--numeric-owner')),
 )
 def test_create_archive_with_numeric_ids_calls_borg_with_numeric_ids_parameter(
     feature_available, option_flag
 ):
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -1220,23 +1292,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'numeric_ids': True,
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_read_special_calls_borg_with_read_special_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -1273,29 +1345,34 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'read_special': True,
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 @pytest.mark.parametrize(
     'option_name,option_value',
-    (('ctime', True), ('ctime', False), ('birthtime', True), ('birthtime', False),),
+    (
+        ('ctime', True),
+        ('ctime', False),
+        ('birthtime', True),
+        ('birthtime', False),
+    ),
 )
 def test_create_archive_with_basic_option_calls_borg_with_corresponding_parameter(
     option_name, option_value
 ):
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     option_flag = '--no' + option_name.replace('', '') if option_value is False else None
@@ -1323,23 +1400,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             option_name: option_value,
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 @pytest.mark.parametrize(
     'option_value,feature_available,option_flag',
     (
         (True, True, '--atime'),
@@ -1377,23 +1454,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'atime': option_value,
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 @pytest.mark.parametrize(
     'option_value,feature_available,option_flag',
     (
         (True, True, None),
@@ -1431,23 +1508,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'flags': option_value,
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_files_cache_calls_borg_with_files_cache_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -1474,23 +1551,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'files_cache': 'ctime,size',
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_local_path_calls_borg_via_local_path():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -1517,22 +1594,22 @@
         borg_local_path='borg1',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         local_path='borg1',
     )
 
 
 def test_create_archive_with_remote_path_calls_borg_with_remote_path_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -1560,22 +1637,22 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         remote_path='borg1',
     )
 
 
 def test_create_archive_with_umask_calls_borg_with_umask_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -1603,22 +1680,65 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
+            'umask': 740,
         },
-        storage_config={'umask': 740},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
+    )
+
+
+def test_create_archive_with_log_json_calls_borg_with_log_json_parameters():
+    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
+    flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
+    flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
+    flexmock(module).should_receive('deduplicate_directories').and_return(('foo', 'bar'))
+    flexmock(module).should_receive('map_directories_to_devices').and_return({})
+    flexmock(module).should_receive('expand_directories').and_return(())
+    flexmock(module).should_receive('pattern_root_directories').and_return([])
+    flexmock(module.os.path).should_receive('expanduser').and_raise(TypeError)
+    flexmock(module).should_receive('expand_home_directories').and_return(())
+    flexmock(module).should_receive('write_pattern_file').and_return(None)
+    flexmock(module).should_receive('make_list_filter_flags').and_return('FOO')
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module).should_receive('ensure_files_readable')
+    flexmock(module).should_receive('make_pattern_flags').and_return(())
+    flexmock(module).should_receive('make_exclude_flags').and_return(())
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        (f'repo::{DEFAULT_ARCHIVE_NAME}',)
+    )
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'create', '--log-json') + REPO_ARCHIVE_WITH_PATHS,
+        output_log_level=logging.INFO,
+        output_file=None,
+        borg_local_path='borg',
+        working_directory=None,
+        extra_environment=None,
+    )
+
+    module.create_archive(
+        dry_run=False,
+        repository_path='repo',
+        config={
+            'source_directories': ['foo', 'bar'],
+            'repositories': ['repo'],
+            'exclude_patterns': None,
+        },
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=True, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_lock_wait_calls_borg_with_lock_wait_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -1645,22 +1765,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
+            'lock_wait': 5,
         },
-        storage_config={'lock_wait': 5},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_stats_calls_borg_with_stats_parameter_and_answer_output_log_level():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -1687,22 +1808,22 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         stats=True,
     )
 
 
 def test_create_archive_with_files_calls_borg_with_list_parameter_and_answer_output_log_level():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -1730,22 +1851,22 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         list_files=True,
     )
 
 
 def test_create_archive_with_progress_and_log_info_calls_borg_with_progress_parameter_and_no_list():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -1763,33 +1884,38 @@
     flexmock(module).should_receive('make_pattern_flags').and_return(())
     flexmock(module).should_receive('make_exclude_flags').and_return(())
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         (f'repo::{DEFAULT_ARCHIVE_NAME}',)
     )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'create') + REPO_ARCHIVE_WITH_PATHS + ('--info', '--progress',),
+        ('borg', 'create')
+        + REPO_ARCHIVE_WITH_PATHS
+        + (
+            '--info',
+            '--progress',
+        ),
         output_log_level=logging.INFO,
         output_file=module.DO_NOT_CAPTURE,
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
     insert_logging_mock(logging.INFO)
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         progress=True,
     )
 
 
 def test_create_archive_with_progress_calls_borg_with_progress_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -1817,22 +1943,22 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         progress=True,
     )
 
 
 def test_create_archive_with_progress_and_stream_processes_calls_borg_with_progress_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -1877,22 +2003,22 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         progress=True,
         stream_processes=processes,
     )
 
 
 def test_create_archive_with_stream_processes_ignores_read_special_false_and_logs_warnings():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
@@ -1940,23 +2066,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
             'read_special': False,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         stream_processes=processes,
     )
 
 
 def test_create_archive_with_stream_processes_adds_special_files_to_excludes():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -2008,22 +2134,22 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         stream_processes=processes,
     )
 
 
 def test_create_archive_with_stream_processes_and_read_special_does_not_add_special_files_to_excludes():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -2071,23 +2197,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
             'read_special': True,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         stream_processes=processes,
     )
 
 
 def test_create_archive_with_json_calls_borg_with_json_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -2108,26 +2234,27 @@
         (f'repo::{DEFAULT_ARCHIVE_NAME}',)
     )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command_and_capture_output').with_args(
         ('borg', 'create') + REPO_ARCHIVE_WITH_PATHS + ('--json',),
         working_directory=None,
         extra_environment=None,
+        borg_local_path='borg',
     ).and_return('[]')
 
     json_output = module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         json=True,
     )
 
     assert json_output == '[]'
 
 
 def test_create_archive_with_stats_and_json_calls_borg_without_stats_parameter():
@@ -2150,26 +2277,27 @@
         (f'repo::{DEFAULT_ARCHIVE_NAME}',)
     )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command_and_capture_output').with_args(
         ('borg', 'create') + REPO_ARCHIVE_WITH_PATHS + ('--json',),
         working_directory=None,
         extra_environment=None,
+        borg_local_path='borg',
     ).and_return('[]')
 
     json_output = module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         json=True,
         stats=True,
     )
 
     assert json_output == '[]'
 
 
@@ -2190,33 +2318,33 @@
     flexmock(module).should_receive('make_pattern_flags').and_return(())
     flexmock(module).should_receive('make_exclude_flags').and_return(())
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         (f'repo::{DEFAULT_ARCHIVE_NAME}',)
     )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'create', 'repo::{}'.format(DEFAULT_ARCHIVE_NAME), 'foo', 'food'),
+        ('borg', 'create', f'repo::{DEFAULT_ARCHIVE_NAME}', 'foo', 'food'),
         output_log_level=logging.INFO,
         output_file=None,
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
     flexmock(module.glob).should_receive('glob').with_args('foo*').and_return(['foo', 'food'])
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo*'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_non_matching_source_directories_glob_passes_through():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -2233,33 +2361,33 @@
     flexmock(module).should_receive('make_pattern_flags').and_return(())
     flexmock(module).should_receive('make_exclude_flags').and_return(())
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         (f'repo::{DEFAULT_ARCHIVE_NAME}',)
     )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'create', 'repo::{}'.format(DEFAULT_ARCHIVE_NAME), 'foo*'),
+        ('borg', 'create', f'repo::{DEFAULT_ARCHIVE_NAME}', 'foo*'),
         output_log_level=logging.INFO,
         output_file=None,
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
     flexmock(module.glob).should_receive('glob').with_args('foo*').and_return([])
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo*'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_glob_calls_borg_with_expanded_directories():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -2276,32 +2404,32 @@
     flexmock(module).should_receive('make_pattern_flags').and_return(())
     flexmock(module).should_receive('make_exclude_flags').and_return(())
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         (f'repo::{DEFAULT_ARCHIVE_NAME}',)
     )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'create', 'repo::{}'.format(DEFAULT_ARCHIVE_NAME), 'foo', 'food'),
+        ('borg', 'create', f'repo::{DEFAULT_ARCHIVE_NAME}', 'foo', 'food'),
         output_log_level=logging.INFO,
         output_file=None,
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo*'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_archive_name_format_calls_borg_with_archive_name():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -2328,29 +2456,30 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
+            'archive_name_format': 'ARCHIVE_NAME',
         },
-        storage_config={'archive_name_format': 'ARCHIVE_NAME'},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_archive_name_format_accepts_borg_placeholders():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    repository_archive_pattern = 'repo::Documents_{hostname}-{now}'
+    repository_archive_pattern = 'repo::Documents_{hostname}-{now}'  # noqa: FS003
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
     flexmock(module).should_receive('deduplicate_directories').and_return(('foo', 'bar'))
     flexmock(module).should_receive('map_directories_to_devices').and_return({})
     flexmock(module).should_receive('expand_directories').and_return(())
     flexmock(module).should_receive('pattern_root_directories').and_return([])
     flexmock(module.os.path).should_receive('expanduser').and_raise(TypeError)
     flexmock(module).should_receive('expand_home_directories').and_return(())
@@ -2371,29 +2500,30 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
+            'archive_name_format': 'Documents_{hostname}-{now}',  # noqa: FS003
         },
-        storage_config={'archive_name_format': 'Documents_{hostname}-{now}'},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_repository_accepts_borg_placeholders():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    repository_archive_pattern = '{fqdn}::Documents_{hostname}-{now}'
+    repository_archive_pattern = '{fqdn}::Documents_{hostname}-{now}'  # noqa: FS003
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
     flexmock(module).should_receive('deduplicate_directories').and_return(('foo', 'bar'))
     flexmock(module).should_receive('map_directories_to_devices').and_return({})
     flexmock(module).should_receive('expand_directories').and_return(())
     flexmock(module).should_receive('pattern_root_directories').and_return([])
     flexmock(module.os.path).should_receive('expanduser').and_raise(TypeError)
     flexmock(module).should_receive('expand_home_directories').and_return(())
@@ -2414,22 +2544,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='{fqdn}',
-        location_config={
+        repository_path='{fqdn}',  # noqa: FS003
+        config={
             'source_directories': ['foo', 'bar'],
-            'repositories': ['{fqdn}'],
+            'repositories': ['{fqdn}'],  # noqa: FS003
             'exclude_patterns': None,
+            'archive_name_format': 'Documents_{hostname}-{now}',  # noqa: FS003
         },
-        storage_config={'archive_name_format': 'Documents_{hostname}-{now}'},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_extra_borg_options_calls_borg_with_extra_options():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
@@ -2456,22 +2587,23 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
+            'extra_borg_options': {'create': '--extra --options'},
         },
-        storage_config={'extra_borg_options': {'create': '--extra --options'}},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
     )
 
 
 def test_create_archive_with_stream_processes_calls_borg_with_processes_and_read_special():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     processes = flexmock()
@@ -2516,17 +2648,64 @@
         borg_local_path='borg',
         working_directory=None,
         extra_environment=None,
     )
 
     module.create_archive(
         dry_run=False,
-        repository='repo',
-        location_config={
+        repository_path='repo',
+        config={
             'source_directories': ['foo', 'bar'],
             'repositories': ['repo'],
             'exclude_patterns': None,
         },
-        storage_config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False, used_config_paths=[]),
         stream_processes=processes,
     )
+
+
+def test_create_archive_with_non_existent_directory_and_source_directories_must_exist_raises_error():
+    '''
+    If a source directory doesn't exist and source_directories_must_exist is True, raise an error.
+    '''
+    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
+    flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
+    flexmock(module).should_receive('collect_borgmatic_source_directories').and_return([])
+    flexmock(module).should_receive('check_all_source_directories_exist').and_raise(ValueError)
+
+    with pytest.raises(ValueError):
+        module.create_archive(
+            dry_run=False,
+            repository_path='repo',
+            config={
+                'source_directories': ['foo', 'bar'],
+                'repositories': ['repo'],
+                'exclude_patterns': None,
+                'source_directories_must_exist': True,
+            },
+            local_borg_version='1.2.3',
+            global_arguments=flexmock(log_json=False, used_config_paths=[]),
+        )
+
+
+def test_check_all_source_directories_exist_with_glob_and_tilde_directories():
+    flexmock(module).should_receive('expand_directory').with_args('foo*').and_return(
+        ('foo', 'food')
+    )
+    flexmock(module).should_receive('expand_directory').with_args('~/bar').and_return(
+        ('/root/bar',)
+    )
+    flexmock(module.os.path).should_receive('exists').and_return(False)
+    flexmock(module.os.path).should_receive('exists').with_args('foo').and_return(True)
+    flexmock(module.os.path).should_receive('exists').with_args('food').and_return(True)
+    flexmock(module.os.path).should_receive('exists').with_args('/root/bar').and_return(True)
+
+    module.check_all_source_directories_exist(['foo*', '~/bar'])
+
+
+def test_check_all_source_directories_exist_with_non_existent_directory_raises():
+    flexmock(module).should_receive('expand_directory').with_args('foo').and_return(('foo',))
+    flexmock(module.os.path).should_receive('exists').and_return(False)
+
+    with pytest.raises(ValueError):
+        module.check_all_source_directories_exist(['foo'])
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_environment.py` & `borgmatic-1.8.0/tests/unit/borg/test_environment.py`

 * *Files 14% similar despite different names*

```diff
@@ -21,14 +21,26 @@
 
 def test_make_environment_without_configuration_should_only_set_default_environment():
     environment = module.make_environment({})
 
     assert environment == {
         'BORG_RELOCATED_REPO_ACCESS_IS_OK': 'no',
         'BORG_UNKNOWN_UNENCRYPTED_REPO_ACCESS_IS_OK': 'no',
+        'BORG_CHECK_I_KNOW_WHAT_I_AM_DOING': 'NO',
     }
 
 
 def test_make_environment_with_relocated_repo_access_should_override_default():
     environment = module.make_environment({'relocated_repo_access_is_ok': True})
 
     assert environment.get('BORG_RELOCATED_REPO_ACCESS_IS_OK') == 'yes'
+
+
+def test_make_environment_check_i_know_what_i_am_doing_should_override_default():
+    environment = module.make_environment({'check_i_know_what_i_am_doing': True})
+
+    assert environment.get('BORG_CHECK_I_KNOW_WHAT_I_AM_DOING') == 'YES'
+
+
+def test_make_environment_with_integer_variable_value():
+    environment = module.make_environment({'borg_files_cache_ttl': 40})
+    assert environment.get('BORG_FILES_CACHE_TTL') == '40'
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_export_tar.py` & `borgmatic-1.8.0/tests/unit/borg/test_borg.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,306 +1,271 @@
 import logging
 
 from flexmock import flexmock
 
-from borgmatic.borg import export_tar as module
+from borgmatic.borg import borg as module
 
 from ..test_verbosity import insert_logging_mock
 
 
-def insert_execute_command_mock(
-    command, output_log_level=logging.INFO, borg_local_path='borg', capture=True
-):
-    flexmock(module.environment).should_receive('make_environment')
-    flexmock(module).should_receive('execute_command').with_args(
-        command,
-        output_file=None if capture else module.DO_NOT_CAPTURE,
-        output_log_level=output_log_level,
-        borg_local_path=borg_local_path,
-        extra_environment=None,
-    ).once()
-
-
-def test_export_tar_archive_calls_borg_with_path_parameters():
+def test_run_arbitrary_borg_calls_borg_with_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
-    )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    insert_execute_command_mock(
-        ('borg', 'export-tar', 'repo::archive', 'test.tar', 'path1', 'path2')
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'break-lock', '::'),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': ''},
     )
 
-    module.export_tar_archive(
-        dry_run=False,
-        repository='repo',
-        archive='archive',
-        paths=['path1', 'path2'],
-        destination_path='test.tar',
-        storage_config={},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
+        options=['break-lock', '::'],
     )
 
 
-def test_export_tar_archive_calls_borg_with_local_path_parameters():
+def test_run_arbitrary_borg_with_log_info_calls_borg_with_info_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
-    )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    insert_execute_command_mock(
-        ('borg1', 'export-tar', 'repo::archive', 'test.tar'), borg_local_path='borg1'
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'break-lock', '--info', '::'),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': ''},
     )
+    insert_logging_mock(logging.INFO)
 
-    module.export_tar_archive(
-        dry_run=False,
-        repository='repo',
-        archive='archive',
-        paths=None,
-        destination_path='test.tar',
-        storage_config={},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
-        local_path='borg1',
+        options=['break-lock', '::'],
     )
 
 
-def test_export_tar_archive_calls_borg_with_remote_path_parameters():
+def test_run_arbitrary_borg_with_log_debug_calls_borg_with_debug_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
-    )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    insert_execute_command_mock(
-        ('borg', 'export-tar', '--remote-path', 'borg1', 'repo::archive', 'test.tar')
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'break-lock', '--debug', '--show-rc', '::'),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': ''},
     )
+    insert_logging_mock(logging.DEBUG)
 
-    module.export_tar_archive(
-        dry_run=False,
-        repository='repo',
-        archive='archive',
-        paths=None,
-        destination_path='test.tar',
-        storage_config={},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
-        remote_path='borg1',
+        options=['break-lock', '::'],
     )
 
 
-def test_export_tar_archive_calls_borg_with_umask_parameters():
+def test_run_arbitrary_borg_with_lock_wait_calls_borg_with_lock_wait_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
+    config = {'lock_wait': 5}
+    flexmock(module.flags).should_receive('make_flags').and_return(()).and_return(
+        ('--lock-wait', '5')
     )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    insert_execute_command_mock(
-        ('borg', 'export-tar', '--umask', '0770', 'repo::archive', 'test.tar')
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'break-lock', '--lock-wait', '5', '::'),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': ''},
     )
 
-    module.export_tar_archive(
-        dry_run=False,
-        repository='repo',
-        archive='archive',
-        paths=None,
-        destination_path='test.tar',
-        storage_config={'umask': '0770'},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config=config,
         local_borg_version='1.2.3',
+        options=['break-lock', '::'],
     )
 
 
-def test_export_tar_archive_calls_borg_with_lock_wait_parameters():
+def test_run_arbitrary_borg_with_archive_calls_borg_with_archive_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
-    )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    insert_execute_command_mock(
-        ('borg', 'export-tar', '--lock-wait', '5', 'repo::archive', 'test.tar')
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'break-lock', '::$ARCHIVE'),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': 'archive'},
     )
 
-    module.export_tar_archive(
-        dry_run=False,
-        repository='repo',
-        archive='archive',
-        paths=None,
-        destination_path='test.tar',
-        storage_config={'lock_wait': '5'},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
-    )
-
-
-def test_export_tar_archive_with_log_info_calls_borg_with_info_parameter():
-    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
-    flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
-    )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    insert_execute_command_mock(('borg', 'export-tar', '--info', 'repo::archive', 'test.tar'))
-    insert_logging_mock(logging.INFO)
-
-    module.export_tar_archive(
-        dry_run=False,
-        repository='repo',
+        options=['break-lock', '::$ARCHIVE'],
         archive='archive',
-        paths=None,
-        destination_path='test.tar',
-        storage_config={},
-        local_borg_version='1.2.3',
     )
 
 
-def test_export_tar_archive_with_log_debug_calls_borg_with_debug_parameters():
+def test_run_arbitrary_borg_with_local_path_calls_borg_via_local_path():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
-    )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    insert_execute_command_mock(
-        ('borg', 'export-tar', '--debug', '--show-rc', 'repo::archive', 'test.tar')
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg1', 'break-lock', '::'),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg1',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': ''},
     )
-    insert_logging_mock(logging.DEBUG)
 
-    module.export_tar_archive(
-        dry_run=False,
-        repository='repo',
-        archive='archive',
-        paths=None,
-        destination_path='test.tar',
-        storage_config={},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
+        options=['break-lock', '::'],
+        local_path='borg1',
     )
 
 
-def test_export_tar_archive_calls_borg_with_dry_run_parameter():
+def test_run_arbitrary_borg_with_remote_path_calls_borg_with_remote_path_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
+    flexmock(module.flags).should_receive('make_flags').and_return(
+        ('--remote-path', 'borg1')
+    ).and_return(())
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'break-lock', '--remote-path', 'borg1', '::'),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': ''},
     )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    flexmock(module).should_receive('execute_command').never()
 
-    module.export_tar_archive(
-        dry_run=True,
-        repository='repo',
-        archive='archive',
-        paths=None,
-        destination_path='test.tar',
-        storage_config={},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
+        options=['break-lock', '::'],
+        remote_path='borg1',
     )
 
 
-def test_export_tar_archive_calls_borg_with_tar_filter_parameters():
+def test_run_arbitrary_borg_passes_borg_specific_flags_to_borg():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
-    )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    insert_execute_command_mock(
-        ('borg', 'export-tar', '--tar-filter', 'bzip2', 'repo::archive', 'test.tar')
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'list', '--progress', '::'),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': ''},
     )
 
-    module.export_tar_archive(
-        dry_run=False,
-        repository='repo',
-        archive='archive',
-        paths=None,
-        destination_path='test.tar',
-        storage_config={},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
-        tar_filter='bzip2',
+        options=['list', '--progress', '::'],
     )
 
 
-def test_export_tar_archive_calls_borg_with_list_parameter():
+def test_run_arbitrary_borg_omits_dash_dash_in_flags_passed_to_borg():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
-    )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    insert_execute_command_mock(
-        ('borg', 'export-tar', '--list', 'repo::archive', 'test.tar'),
-        output_log_level=logging.ANSWER,
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'break-lock', '::'),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': ''},
     )
 
-    module.export_tar_archive(
-        dry_run=False,
-        repository='repo',
-        archive='archive',
-        paths=None,
-        destination_path='test.tar',
-        storage_config={},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
-        list_files=True,
+        options=['--', 'break-lock', '::'],
     )
 
 
-def test_export_tar_archive_calls_borg_with_strip_components_parameter():
+def test_run_arbitrary_borg_without_borg_specific_flags_does_not_raise():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
-    )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    insert_execute_command_mock(
-        ('borg', 'export-tar', '--strip-components', '5', 'repo::archive', 'test.tar')
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg',),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': ''},
     )
 
-    module.export_tar_archive(
-        dry_run=False,
-        repository='repo',
-        archive='archive',
-        paths=None,
-        destination_path='test.tar',
-        storage_config={},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
-        strip_components=5,
+        options=[],
     )
 
 
-def test_export_tar_archive_skips_abspath_for_remote_repository_parameter():
+def test_run_arbitrary_borg_passes_key_sub_command_to_borg_before_injected_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('server:repo::archive',)
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'key', 'export', '--info', '::'),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': ''},
     )
-    flexmock(module.os.path).should_receive('abspath').never()
-    insert_execute_command_mock(('borg', 'export-tar', 'server:repo::archive', 'test.tar'))
+    insert_logging_mock(logging.INFO)
 
-    module.export_tar_archive(
-        dry_run=False,
-        repository='server:repo',
-        archive='archive',
-        paths=None,
-        destination_path='test.tar',
-        storage_config={},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
+        options=['key', 'export', '::'],
     )
 
 
-def test_export_tar_archive_calls_borg_with_stdout_destination_path():
+def test_run_arbitrary_borg_passes_debug_sub_command_to_borg_before_injected_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
-        ('repo::archive',)
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'debug', 'dump-manifest', '--info', '::', 'path'),
+        output_file=module.borgmatic.execute.DO_NOT_CAPTURE,
+        borg_local_path='borg',
+        shell=True,
+        extra_environment={'BORG_REPO': 'repo', 'ARCHIVE': ''},
     )
-    flexmock(module.os.path).should_receive('abspath').and_return('repo')
-    insert_execute_command_mock(('borg', 'export-tar', 'repo::archive', '-'), capture=False)
+    insert_logging_mock(logging.INFO)
 
-    module.export_tar_archive(
-        dry_run=False,
-        repository='repo',
-        archive='archive',
-        paths=None,
-        destination_path='-',
-        storage_config={},
+    module.run_arbitrary_borg(
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
+        options=['debug', 'dump-manifest', '::', 'path'],
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_extract.py` & `borgmatic-1.8.0/tests/unit/borg/test_extract.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,311 +7,404 @@
 
 from ..test_verbosity import insert_logging_mock
 
 
 def insert_execute_command_mock(command, working_directory=None):
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        command, working_directory=working_directory, extra_environment=None,
+        command,
+        working_directory=working_directory,
+        extra_environment=None,
     ).once()
 
 
 def test_extract_last_archive_dry_run_calls_borg_with_last_archive():
     flexmock(module.rlist).should_receive('resolve_archive_name').and_return('archive')
     insert_execute_command_mock(('borg', 'extract', '--dry-run', 'repo::archive'))
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
 
     module.extract_last_archive_dry_run(
-        storage_config={}, local_borg_version='1.2.3', repository='repo', lock_wait=None
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        repository_path='repo',
+        lock_wait=None,
     )
 
 
 def test_extract_last_archive_dry_run_without_any_archives_should_not_raise():
     flexmock(module.rlist).should_receive('resolve_archive_name').and_raise(ValueError)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(('repo',))
 
     module.extract_last_archive_dry_run(
-        storage_config={}, local_borg_version='1.2.3', repository='repo', lock_wait=None
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        repository_path='repo',
+        lock_wait=None,
     )
 
 
 def test_extract_last_archive_dry_run_with_log_info_calls_borg_with_info_parameter():
     flexmock(module.rlist).should_receive('resolve_archive_name').and_return('archive')
     insert_execute_command_mock(('borg', 'extract', '--dry-run', '--info', 'repo::archive'))
     insert_logging_mock(logging.INFO)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
 
     module.extract_last_archive_dry_run(
-        storage_config={}, local_borg_version='1.2.3', repository='repo', lock_wait=None
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        repository_path='repo',
+        lock_wait=None,
     )
 
 
 def test_extract_last_archive_dry_run_with_log_debug_calls_borg_with_debug_parameter():
     flexmock(module.rlist).should_receive('resolve_archive_name').and_return('archive')
     insert_execute_command_mock(
         ('borg', 'extract', '--dry-run', '--debug', '--show-rc', '--list', 'repo::archive')
     )
     insert_logging_mock(logging.DEBUG)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
 
     module.extract_last_archive_dry_run(
-        storage_config={}, local_borg_version='1.2.3', repository='repo', lock_wait=None
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        repository_path='repo',
+        lock_wait=None,
     )
 
 
 def test_extract_last_archive_dry_run_calls_borg_via_local_path():
     flexmock(module.rlist).should_receive('resolve_archive_name').and_return('archive')
     insert_execute_command_mock(('borg1', 'extract', '--dry-run', 'repo::archive'))
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
 
     module.extract_last_archive_dry_run(
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
-        repository='repo',
+        global_arguments=flexmock(log_json=False),
+        repository_path='repo',
         lock_wait=None,
         local_path='borg1',
     )
 
 
-def test_extract_last_archive_dry_run_calls_borg_with_remote_path_parameters():
+def test_extract_last_archive_dry_run_calls_borg_with_remote_path_flags():
     flexmock(module.rlist).should_receive('resolve_archive_name').and_return('archive')
     insert_execute_command_mock(
         ('borg', 'extract', '--dry-run', '--remote-path', 'borg1', 'repo::archive')
     )
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
 
     module.extract_last_archive_dry_run(
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
-        repository='repo',
+        global_arguments=flexmock(log_json=False),
+        repository_path='repo',
         lock_wait=None,
         remote_path='borg1',
     )
 
 
-def test_extract_last_archive_dry_run_calls_borg_with_lock_wait_parameters():
+def test_extract_last_archive_dry_run_calls_borg_with_log_json_flag():
+    flexmock(module.rlist).should_receive('resolve_archive_name').and_return('archive')
+    insert_execute_command_mock(('borg', 'extract', '--dry-run', '--log-json', 'repo::archive'))
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+
+    module.extract_last_archive_dry_run(
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=True),
+        repository_path='repo',
+        lock_wait=None,
+    )
+
+
+def test_extract_last_archive_dry_run_calls_borg_with_lock_wait_flags():
     flexmock(module.rlist).should_receive('resolve_archive_name').and_return('archive')
     insert_execute_command_mock(
         ('borg', 'extract', '--dry-run', '--lock-wait', '5', 'repo::archive')
     )
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
 
     module.extract_last_archive_dry_run(
-        storage_config={}, local_borg_version='1.2.3', repository='repo', lock_wait=5
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        repository_path='repo',
+        lock_wait=5,
     )
 
 
-def test_extract_archive_calls_borg_with_path_parameters():
+def test_extract_archive_calls_borg_with_path_flags():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     insert_execute_command_mock(('borg', 'extract', 'repo::archive', 'path1', 'path2'))
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=False,
         repository='repo',
         archive='archive',
         paths=['path1', 'path2'],
-        location_config={},
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_extract_archive_calls_borg_with_remote_path_parameters():
+def test_extract_archive_calls_borg_with_remote_path_flags():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     insert_execute_command_mock(('borg', 'extract', '--remote-path', 'borg1', 'repo::archive'))
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=False,
         repository='repo',
         archive='archive',
         paths=None,
-        location_config={},
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
         remote_path='borg1',
     )
 
 
 @pytest.mark.parametrize(
-    'feature_available,option_flag', ((True, '--numeric-ids'), (False, '--numeric-owner'),),
+    'feature_available,option_flag',
+    (
+        (True, '--numeric-ids'),
+        (False, '--numeric-owner'),
+    ),
 )
 def test_extract_archive_calls_borg_with_numeric_ids_parameter(feature_available, option_flag):
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     insert_execute_command_mock(('borg', 'extract', option_flag, 'repo::archive'))
     flexmock(module.feature).should_receive('available').and_return(feature_available)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=False,
         repository='repo',
         archive='archive',
         paths=None,
-        location_config={'numeric_ids': True},
-        storage_config={},
+        config={'numeric_ids': True},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_extract_archive_calls_borg_with_umask_parameters():
+def test_extract_archive_calls_borg_with_umask_flags():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     insert_execute_command_mock(('borg', 'extract', '--umask', '0770', 'repo::archive'))
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
+
+    module.extract_archive(
+        dry_run=False,
+        repository='repo',
+        archive='archive',
+        paths=None,
+        config={'umask': '0770'},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+    )
+
+
+def test_extract_archive_calls_borg_with_log_json_flags():
+    flexmock(module.os.path).should_receive('abspath').and_return('repo')
+    insert_execute_command_mock(('borg', 'extract', '--log-json', 'repo::archive'))
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
 
     module.extract_archive(
         dry_run=False,
         repository='repo',
         archive='archive',
         paths=None,
-        location_config={},
-        storage_config={'umask': '0770'},
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=True),
     )
 
 
-def test_extract_archive_calls_borg_with_lock_wait_parameters():
+def test_extract_archive_calls_borg_with_lock_wait_flags():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     insert_execute_command_mock(('borg', 'extract', '--lock-wait', '5', 'repo::archive'))
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=False,
         repository='repo',
         archive='archive',
         paths=None,
-        location_config={},
-        storage_config={'lock_wait': '5'},
+        config={'lock_wait': '5'},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_extract_archive_with_log_info_calls_borg_with_info_parameter():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     insert_execute_command_mock(('borg', 'extract', '--info', 'repo::archive'))
     insert_logging_mock(logging.INFO)
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=False,
         repository='repo',
         archive='archive',
         paths=None,
-        location_config={},
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_extract_archive_with_log_debug_calls_borg_with_debug_parameters():
+def test_extract_archive_with_log_debug_calls_borg_with_debug_flags():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     insert_execute_command_mock(
         ('borg', 'extract', '--debug', '--list', '--show-rc', 'repo::archive')
     )
     insert_logging_mock(logging.DEBUG)
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=False,
         repository='repo',
         archive='archive',
         paths=None,
-        location_config={},
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_extract_archive_calls_borg_with_dry_run_parameter():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     insert_execute_command_mock(('borg', 'extract', '--dry-run', 'repo::archive'))
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=True,
         repository='repo',
         archive='archive',
         paths=None,
-        location_config={},
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_extract_archive_calls_borg_with_destination_path():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     insert_execute_command_mock(('borg', 'extract', 'repo::archive'), working_directory='/dest')
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=False,
         repository='repo',
         archive='archive',
         paths=None,
-        location_config={},
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
         destination_path='/dest',
     )
 
 
 def test_extract_archive_calls_borg_with_strip_components():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     insert_execute_command_mock(('borg', 'extract', '--strip-components', '5', 'repo::archive'))
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=False,
         repository='repo',
         archive='archive',
         paths=None,
-        location_config={},
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
         strip_components=5,
     )
 
 
 def test_extract_archive_calls_borg_with_strip_components_calculated_from_all():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     insert_execute_command_mock(
@@ -325,44 +418,50 @@
             'foo/bar.txt',
         )
     )
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=False,
         repository='repo',
         archive='archive',
         paths=['foo/bar/baz.txt', 'foo/bar.txt'],
-        location_config={},
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
         strip_components='all',
     )
 
 
 def test_extract_archive_with_strip_components_all_and_no_paths_raises():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
     flexmock(module).should_receive('execute_command').never()
 
     with pytest.raises(ValueError):
         module.extract_archive(
             dry_run=False,
             repository='repo',
             archive='archive',
             paths=None,
-            location_config={},
-            storage_config={},
+            config={},
             local_borg_version='1.2.3',
+            global_arguments=flexmock(log_json=False),
             strip_components='all',
         )
 
 
 def test_extract_archive_calls_borg_with_progress_parameter():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
     flexmock(module.environment).should_receive('make_environment')
@@ -372,39 +471,42 @@
         working_directory=None,
         extra_environment=None,
     ).once()
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=False,
         repository='repo',
         archive='archive',
         paths=None,
-        location_config={},
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
         progress=True,
     )
 
 
 def test_extract_archive_with_progress_and_extract_to_stdout_raises():
     flexmock(module).should_receive('execute_command').never()
 
     with pytest.raises(ValueError):
         module.extract_archive(
             dry_run=False,
             repository='repo',
             archive='archive',
             paths=None,
-            location_config={},
-            storage_config={},
+            config={},
             local_borg_version='1.2.3',
+            global_arguments=flexmock(log_json=False),
             progress=True,
             extract_to_stdout=True,
         )
 
 
 def test_extract_archive_calls_borg_with_stdout_parameter_and_returns_process():
     flexmock(module.os.path).should_receive('abspath').and_return('repo')
@@ -417,43 +519,51 @@
         run_to_completion=False,
         extra_environment=None,
     ).and_return(process).once()
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     assert (
         module.extract_archive(
             dry_run=False,
             repository='repo',
             archive='archive',
             paths=None,
-            location_config={},
-            storage_config={},
+            config={},
             local_borg_version='1.2.3',
+            global_arguments=flexmock(log_json=False),
             extract_to_stdout=True,
         )
         == process
     )
 
 
 def test_extract_archive_skips_abspath_for_remote_repository():
     flexmock(module.os.path).should_receive('abspath').never()
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'extract', 'server:repo::archive'), working_directory=None, extra_environment=None,
+        ('borg', 'extract', 'server:repo::archive'),
+        working_directory=None,
+        extra_environment=None,
     ).once()
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('server:repo::archive',)
     )
+    flexmock(module.borgmatic.config.validate).should_receive(
+        'normalize_repository_path'
+    ).and_return('repo')
 
     module.extract_archive(
         dry_run=False,
         repository='server:repo',
         archive='archive',
         paths=None,
-        location_config={},
-        storage_config={},
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_flags.py` & `borgmatic-1.8.0/tests/unit/borg/test_flags.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+import pytest
 from flexmock import flexmock
 
 from borgmatic.borg import flags as module
 
 
 def test_make_flags_formats_string_value():
     assert module.make_flags('foo', 'bar') == ('--foo', 'bar')
@@ -46,33 +47,103 @@
 
     assert module.make_flags_from_arguments(arguments, excludes=('baz', 'other')) == ('foo', 'bar')
 
 
 def test_make_repository_flags_with_borg_features_includes_repo_flag():
     flexmock(module.feature).should_receive('available').and_return(True)
 
-    assert module.make_repository_flags(repository='repo', local_borg_version='1.2.3') == (
+    assert module.make_repository_flags(repository_path='repo', local_borg_version='1.2.3') == (
         '--repo',
         'repo',
     )
 
 
 def test_make_repository_flags_without_borg_features_includes_omits_flag():
     flexmock(module.feature).should_receive('available').and_return(False)
 
-    assert module.make_repository_flags(repository='repo', local_borg_version='1.2.3') == ('repo',)
+    assert module.make_repository_flags(repository_path='repo', local_borg_version='1.2.3') == (
+        'repo',
+    )
 
 
 def test_make_repository_archive_flags_with_borg_features_separates_repository_and_archive():
     flexmock(module.feature).should_receive('available').and_return(True)
 
     assert module.make_repository_archive_flags(
-        repository='repo', archive='archive', local_borg_version='1.2.3'
-    ) == ('--repo', 'repo', 'archive',)
+        repository_path='repo', archive='archive', local_borg_version='1.2.3'
+    ) == (
+        '--repo',
+        'repo',
+        'archive',
+    )
 
 
 def test_make_repository_archive_flags_with_borg_features_joins_repository_and_archive():
     flexmock(module.feature).should_receive('available').and_return(False)
 
     assert module.make_repository_archive_flags(
-        repository='repo', archive='archive', local_borg_version='1.2.3'
+        repository_path='repo', archive='archive', local_borg_version='1.2.3'
     ) == ('repo::archive',)
+
+
+@pytest.mark.parametrize(
+    'match_archives, archive_name_format,feature_available,expected_result',
+    (
+        (None, None, True, ()),
+        (None, '', True, ()),
+        (
+            're:foo-.*',
+            '{hostname}-{now}',
+            True,
+            ('--match-archives', 're:foo-.*'),
+        ),  # noqa: FS003
+        (
+            'sh:foo-*',
+            '{hostname}-{now}',
+            False,
+            ('--glob-archives', 'foo-*'),
+        ),  # noqa: FS003
+        (
+            'foo-*',
+            '{hostname}-{now}',
+            False,
+            ('--glob-archives', 'foo-*'),
+        ),  # noqa: FS003
+        (
+            None,
+            '{hostname}-docs-{now}',  # noqa: FS003
+            True,
+            ('--match-archives', 'sh:{hostname}-docs-*'),  # noqa: FS003
+        ),
+        (
+            None,
+            '{utcnow}-docs-{user}',  # noqa: FS003
+            True,
+            ('--match-archives', 'sh:*-docs-{user}'),  # noqa: FS003
+        ),
+        (None, '{fqdn}-{pid}', True, ('--match-archives', 'sh:{fqdn}-*')),  # noqa: FS003
+        (
+            None,
+            'stuff-{now:%Y-%m-%dT%H:%M:%S.%f}',  # noqa: FS003
+            True,
+            ('--match-archives', 'sh:stuff-*'),
+        ),
+        (
+            None,
+            '{hostname}-docs-{now}',  # noqa: FS003
+            False,
+            ('--glob-archives', '{hostname}-docs-*'),  # noqa: FS003
+        ),
+        (None, '{utcnow}-docs-{user}', False, ('--glob-archives', '*-docs-{user}')),  # noqa: FS003
+    ),
+)
+def test_make_match_archives_flags_makes_flags_with_globs(
+    match_archives, archive_name_format, feature_available, expected_result
+):
+    flexmock(module.feature).should_receive('available').and_return(feature_available)
+
+    assert (
+        module.make_match_archives_flags(
+            match_archives, archive_name_format, local_borg_version=flexmock()
+        )
+        == expected_result
+    )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_info.py` & `borgmatic-1.8.0/tests/unit/borg/test_transfer.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,291 +1,480 @@
 import logging
 
 import pytest
 from flexmock import flexmock
 
-from borgmatic.borg import info as module
+from borgmatic.borg import transfer as module
 
 from ..test_verbosity import insert_logging_mock
 
 
-def test_display_archives_info_calls_borg_with_parameters():
+def test_transfer_archives_calls_borg_with_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'info', '--repo', 'repo'),
+        ('borg', 'transfer', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
         borg_local_path='borg',
         extra_environment=None,
     )
 
-    module.display_archives_info(
-        repository='repo',
-        storage_config={},
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive=None, json=False, prefix=None),
+        transfer_arguments=flexmock(
+            archive=None, progress=None, match_archives=None, source_repository=None
+        ),
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_display_archives_info_with_log_info_calls_borg_with_info_parameter():
+def test_transfer_archives_with_dry_run_calls_borg_with_dry_run_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.flags).should_receive('make_flags').with_args('dry-run', True).and_return(
+        ('--dry-run',)
+    )
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'info', '--info', '--repo', 'repo'),
+        ('borg', 'transfer', '--repo', 'repo', '--dry-run'),
         output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
         borg_local_path='borg',
         extra_environment=None,
     )
-    insert_logging_mock(logging.INFO)
-    module.display_archives_info(
-        repository='repo',
-        storage_config={},
+
+    module.transfer_archives(
+        dry_run=True,
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive=None, json=False, prefix=None),
+        transfer_arguments=flexmock(
+            archive=None, progress=None, match_archives=None, source_repository=None
+        ),
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_display_archives_info_with_log_info_and_json_suppresses_most_borg_output():
+def test_transfer_archives_with_log_info_calls_borg_with_info_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.flags).should_receive('make_flags').and_return(())
-    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(('--json',))
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
+    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
     flexmock(module.environment).should_receive('make_environment')
-    flexmock(module).should_receive('execute_command_and_capture_output').with_args(
-        ('borg', 'info', '--json', '--repo', 'repo'), extra_environment=None,
-    ).and_return('[]')
-
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'transfer', '--info', '--repo', 'repo'),
+        output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
+        borg_local_path='borg',
+        extra_environment=None,
+    )
     insert_logging_mock(logging.INFO)
-    json_output = module.display_archives_info(
-        repository='repo',
-        storage_config={},
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive=None, json=True, prefix=None),
+        transfer_arguments=flexmock(
+            archive=None, progress=None, match_archives=None, source_repository=None
+        ),
+        global_arguments=flexmock(log_json=False),
     )
 
-    assert json_output == '[]'
-
 
-def test_display_archives_info_with_log_debug_calls_borg_with_debug_parameter():
+def test_transfer_archives_with_log_debug_calls_borg_with_debug_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'info', '--debug', '--show-rc', '--repo', 'repo'),
+        ('borg', 'transfer', '--debug', '--show-rc', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
         borg_local_path='borg',
         extra_environment=None,
     )
     insert_logging_mock(logging.DEBUG)
 
-    module.display_archives_info(
-        repository='repo',
-        storage_config={},
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive=None, json=False, prefix=None),
+        transfer_arguments=flexmock(
+            archive=None, progress=None, match_archives=None, source_repository=None
+        ),
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_display_archives_info_with_log_debug_and_json_suppresses_most_borg_output():
+def test_transfer_archives_with_archive_calls_borg_with_match_archives_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.flags).should_receive('make_flags').and_return(())
-    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(('--json',))
+    flexmock(module.flags).should_receive('make_match_archives_flags').with_args(
+        'archive', 'bar-{now}', '2.3.4'  # noqa: FS003
+    ).and_return(('--match-archives', 'archive'))
+    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
     flexmock(module.environment).should_receive('make_environment')
-    flexmock(module).should_receive('execute_command_and_capture_output').with_args(
-        ('borg', 'info', '--json', '--repo', 'repo'), extra_environment=None,
-    ).and_return('[]')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'transfer', '--match-archives', 'archive', '--repo', 'repo'),
+        output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
+        borg_local_path='borg',
+        extra_environment=None,
+    )
 
-    insert_logging_mock(logging.DEBUG)
-    json_output = module.display_archives_info(
-        repository='repo',
-        storage_config={},
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={'archive_name_format': 'bar-{now}'},  # noqa: FS003
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive=None, json=True, prefix=None),
+        transfer_arguments=flexmock(
+            archive='archive', progress=None, match_archives=None, source_repository=None
+        ),
+        global_arguments=flexmock(log_json=False),
     )
 
-    assert json_output == '[]'
 
-
-def test_display_archives_info_with_json_calls_borg_with_json_parameter():
+def test_transfer_archives_with_match_archives_calls_borg_with_match_archives_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.flags).should_receive('make_flags').and_return(())
-    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(('--json',))
+    flexmock(module.flags).should_receive('make_match_archives_flags').with_args(
+        'sh:foo*', 'bar-{now}', '2.3.4'  # noqa: FS003
+    ).and_return(('--match-archives', 'sh:foo*'))
+    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
     flexmock(module.environment).should_receive('make_environment')
-    flexmock(module).should_receive('execute_command_and_capture_output').with_args(
-        ('borg', 'info', '--json', '--repo', 'repo'), extra_environment=None,
-    ).and_return('[]')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'transfer', '--match-archives', 'sh:foo*', '--repo', 'repo'),
+        output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
+        borg_local_path='borg',
+        extra_environment=None,
+    )
 
-    json_output = module.display_archives_info(
-        repository='repo',
-        storage_config={},
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={'archive_name_format': 'bar-{now}'},  # noqa: FS003
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive=None, json=True, prefix=None),
+        transfer_arguments=flexmock(
+            archive=None, progress=None, match_archives='sh:foo*', source_repository=None
+        ),
+        global_arguments=flexmock(log_json=False),
     )
 
-    assert json_output == '[]'
-
 
-def test_display_archives_info_with_archive_calls_borg_with_match_archives_parameter():
+def test_transfer_archives_with_archive_name_format_calls_borg_with_match_archives_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.flags).should_receive('make_flags').and_return(())
-    flexmock(module.flags).should_receive('make_flags').with_args(
-        'match-archives', 'archive'
-    ).and_return(('--match-archives', 'archive'))
+    flexmock(module.flags).should_receive('make_match_archives_flags').with_args(
+        None, 'bar-{now}', '2.3.4'  # noqa: FS003
+    ).and_return(('--match-archives', 'sh:bar-*'))
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'info', '--repo', 'repo', '--match-archives', 'archive'),
+        ('borg', 'transfer', '--match-archives', 'sh:bar-*', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
         borg_local_path='borg',
         extra_environment=None,
     )
 
-    module.display_archives_info(
-        repository='repo',
-        storage_config={},
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={'archive_name_format': 'bar-{now}'},  # noqa: FS003
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive='archive', json=False, prefix=None),
+        transfer_arguments=flexmock(
+            archive=None, progress=None, match_archives=None, source_repository=None
+        ),
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_display_archives_info_with_local_path_calls_borg_via_local_path():
+def test_transfer_archives_with_local_path_calls_borg_via_local_path():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg1', 'info', '--repo', 'repo'),
+        ('borg2', 'transfer', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
-        borg_local_path='borg1',
+        output_file=None,
+        borg_local_path='borg2',
         extra_environment=None,
     )
 
-    module.display_archives_info(
-        repository='repo',
-        storage_config={},
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive=None, json=False, prefix=None),
-        local_path='borg1',
+        transfer_arguments=flexmock(
+            archive=None, progress=None, match_archives=None, source_repository=None
+        ),
+        global_arguments=flexmock(log_json=False),
+        local_path='borg2',
     )
 
 
-def test_display_archives_info_with_remote_path_calls_borg_with_remote_path_parameters():
+def test_transfer_archives_with_remote_path_calls_borg_with_remote_path_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags').with_args(
-        'remote-path', 'borg1'
-    ).and_return(('--remote-path', 'borg1'))
+        'remote-path', 'borg2'
+    ).and_return(('--remote-path', 'borg2'))
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'info', '--remote-path', 'borg1', '--repo', 'repo'),
+        ('borg', 'transfer', '--remote-path', 'borg2', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
         borg_local_path='borg',
         extra_environment=None,
     )
 
-    module.display_archives_info(
-        repository='repo',
-        storage_config={},
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive=None, json=False, prefix=None),
-        remote_path='borg1',
+        transfer_arguments=flexmock(
+            archive=None, progress=None, match_archives=None, source_repository=None
+        ),
+        global_arguments=flexmock(log_json=False),
+        remote_path='borg2',
     )
 
 
-def test_display_archives_info_with_lock_wait_calls_borg_with_lock_wait_parameters():
+def test_transfer_archives_with_log_json_calls_borg_with_log_json_flags():
+    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
+    flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.flags).should_receive('make_flags').with_args('log-json', True).and_return(
+        ('--log-json',)
+    )
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
+    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'transfer', '--log-json', '--repo', 'repo'),
+        output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
+        borg_local_path='borg',
+        extra_environment=None,
+    )
+
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        transfer_arguments=flexmock(
+            archive=None, progress=None, match_archives=None, source_repository=None
+        ),
+        global_arguments=flexmock(log_json=True),
+    )
+
+
+def test_transfer_archives_with_lock_wait_calls_borg_with_lock_wait_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags').with_args('lock-wait', 5).and_return(
         ('--lock-wait', '5')
     )
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
-    storage_config = {'lock_wait': 5}
+    config = {'lock_wait': 5}
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'info', '--lock-wait', '5', '--repo', 'repo'),
+        ('borg', 'transfer', '--lock-wait', '5', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
         borg_local_path='borg',
         extra_environment=None,
     )
 
-    module.display_archives_info(
-        repository='repo',
-        storage_config=storage_config,
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config=config,
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive=None, json=False, prefix=None),
+        transfer_arguments=flexmock(
+            archive=None, progress=None, match_archives=None, source_repository=None
+        ),
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_display_archives_info_with_prefix_calls_borg_with_match_archives_parameters():
+def test_transfer_archives_with_progress_calls_borg_with_progress_flag():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.flags).should_receive('make_flags').and_return(())
-    flexmock(module.flags).should_receive('make_flags').with_args(
-        'match-archives', 'sh:foo*'
-    ).and_return(('--match-archives', 'sh:foo*'))
-    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
+    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(('--progress',))
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'info', '--match-archives', 'sh:foo*', '--repo', 'repo'),
+        ('borg', 'transfer', '--progress', '--repo', 'repo'),
         output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=module.DO_NOT_CAPTURE,
         borg_local_path='borg',
         extra_environment=None,
     )
 
-    module.display_archives_info(
-        repository='repo',
-        storage_config={},
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive=None, json=False, prefix='foo'),
+        transfer_arguments=flexmock(
+            archive=None, progress=True, match_archives=None, source_repository=None
+        ),
+        global_arguments=flexmock(log_json=False),
     )
 
 
-@pytest.mark.parametrize('argument_name', ('match_archives', 'sort_by', 'first', 'last'))
-def test_display_archives_info_passes_through_arguments_to_borg(argument_name):
+@pytest.mark.parametrize('argument_name', ('upgrader', 'sort_by', 'first', 'last'))
+def test_transfer_archives_passes_through_arguments_to_borg(argument_name):
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flag_name = f"--{argument_name.replace('_', ' ')}"
     flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(
         (flag_name, 'value')
     )
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        ('borg', 'info', flag_name, 'value', '--repo', 'repo'),
+        ('borg', 'transfer', flag_name, 'value', '--repo', 'repo'),
+        output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
+        borg_local_path='borg',
+        extra_environment=None,
+    )
+
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        transfer_arguments=flexmock(
+            archive=None,
+            progress=None,
+            match_archives=None,
+            source_repository=None,
+            **{argument_name: 'value'},
+        ),
+        global_arguments=flexmock(log_json=False),
+    )
+
+
+def test_transfer_archives_with_source_repository_calls_borg_with_other_repo_flags():
+    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.flags).should_receive('make_flags').with_args('other-repo', 'other').and_return(
+        ('--other-repo', 'other')
+    )
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
+    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        ('borg', 'transfer', '--repo', 'repo', '--other-repo', 'other'),
         output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
         borg_local_path='borg',
         extra_environment=None,
     )
 
-    module.display_archives_info(
-        repository='repo',
-        storage_config={},
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
-        info_arguments=flexmock(archive=None, json=False, prefix=None, **{argument_name: 'value'}),
+        transfer_arguments=flexmock(
+            archive=None, progress=None, match_archives=None, source_repository='other'
+        ),
+        global_arguments=flexmock(log_json=False),
+    )
+
+
+def test_transfer_archives_with_date_based_matching_calls_borg_with_date_based_flags():
+    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
+    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(
+        ('--newer', '1d', '--newest', '1y', '--older', '1m', '--oldest', '1w')
+    )
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        (
+            'borg',
+            'transfer',
+            '--newer',
+            '1d',
+            '--newest',
+            '1y',
+            '--older',
+            '1m',
+            '--oldest',
+            '1w',
+            '--repo',
+            'repo',
+        ),
+        output_log_level=module.borgmatic.logger.ANSWER,
+        output_file=None,
+        borg_local_path='borg',
+        extra_environment=None,
+    )
+
+    module.transfer_archives(
+        dry_run=False,
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
+        transfer_arguments=flexmock(
+            archive=None,
+            progress=None,
+            source_repository='other',
+            newer='1d',
+            newest='1y',
+            older='1m',
+            oldest='1w',
+        ),
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_list.py` & `borgmatic-1.8.0/tests/unit/borg/test_list.py`

 * *Files 18% similar despite different names*

```diff
@@ -12,181 +12,212 @@
 def test_make_list_command_includes_log_info():
     insert_logging_mock(logging.INFO)
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=flexmock(archive=None, paths=None, json=False),
+        global_arguments=flexmock(log_json=False),
     )
 
     assert command == ('borg', 'list', '--info', 'repo')
 
 
 def test_make_list_command_includes_json_but_not_info():
     insert_logging_mock(logging.INFO)
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(('--json',))
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=flexmock(archive=None, paths=None, json=True),
+        global_arguments=flexmock(log_json=False),
     )
 
     assert command == ('borg', 'list', '--json', 'repo')
 
 
 def test_make_list_command_includes_log_debug():
     insert_logging_mock(logging.DEBUG)
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=flexmock(archive=None, paths=None, json=False),
+        global_arguments=flexmock(log_json=False),
     )
 
     assert command == ('borg', 'list', '--debug', '--show-rc', 'repo')
 
 
 def test_make_list_command_includes_json_but_not_debug():
     insert_logging_mock(logging.DEBUG)
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(('--json',))
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=flexmock(archive=None, paths=None, json=True),
+        global_arguments=flexmock(log_json=False),
     )
 
     assert command == ('borg', 'list', '--json', 'repo')
 
 
 def test_make_list_command_includes_json():
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(('--json',))
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=flexmock(archive=None, paths=None, json=True),
+        global_arguments=flexmock(log_json=False),
     )
 
     assert command == ('borg', 'list', '--json', 'repo')
 
 
+def test_make_list_command_includes_log_json():
+    flexmock(module.flags).should_receive('make_flags').and_return(()).and_return(('--log-json',))
+    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
+
+    command = module.make_list_command(
+        repository_path='repo',
+        config={},
+        local_borg_version='1.2.3',
+        list_arguments=flexmock(archive=None, paths=None, json=False),
+        global_arguments=flexmock(log_json=True),
+    )
+
+    assert command == ('borg', 'list', '--log-json', 'repo')
+
+
 def test_make_list_command_includes_lock_wait():
     flexmock(module.flags).should_receive('make_flags').and_return(()).and_return(
         ('--lock-wait', '5')
     )
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={'lock_wait': 5},
+        repository_path='repo',
+        config={'lock_wait': 5},
         local_borg_version='1.2.3',
         list_arguments=flexmock(archive=None, paths=None, json=False),
+        global_arguments=flexmock(log_json=False),
     )
 
     assert command == ('borg', 'list', '--lock-wait', '5', 'repo')
 
 
 def test_make_list_command_includes_archive():
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=flexmock(archive='archive', paths=None, json=False),
+        global_arguments=flexmock(log_json=False),
     )
 
     assert command == ('borg', 'list', 'repo::archive')
 
 
 def test_make_list_command_includes_archive_and_path():
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=flexmock(archive='archive', paths=['var/lib'], json=False),
+        global_arguments=flexmock(log_json=False),
     )
 
     assert command == ('borg', 'list', 'repo::archive', 'var/lib')
 
 
 def test_make_list_command_includes_local_path():
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=flexmock(archive=None, paths=None, json=False),
+        global_arguments=flexmock(log_json=False),
         local_path='borg2',
     )
 
     assert command == ('borg2', 'list', 'repo')
 
 
 def test_make_list_command_includes_remote_path():
-    flexmock(module.flags).should_receive('make_flags').and_return(
-        ('--remote-path', 'borg2')
-    ).and_return(())
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.flags).should_receive('make_flags').with_args(
+        'remote-path', 'borg2'
+    ).and_return(('--remote-path', 'borg2'))
+    flexmock(module.flags).should_receive('make_flags').with_args('log-json', True).and_return(
+        ('--log-json')
+    )
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(())
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=flexmock(archive=None, paths=None, json=False),
+        global_arguments=flexmock(log_json=False),
         remote_path='borg2',
     )
 
     assert command == ('borg', 'list', '--remote-path', 'borg2', 'repo')
 
 
 def test_make_list_command_includes_short():
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(('--short',))
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=flexmock(archive=None, paths=None, json=False, short=True),
+        global_arguments=flexmock(log_json=False),
     )
 
     assert command == ('borg', 'list', '--short', 'repo')
 
 
 @pytest.mark.parametrize(
     'argument_name',
@@ -206,25 +237,26 @@
     flexmock(module.flags).should_receive('make_flags').and_return(())
     flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(
         (f"--{argument_name.replace('_', '-')}", 'value')
     )
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
 
     command = module.make_list_command(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=flexmock(
             archive=None,
             paths=None,
             json=False,
             find_paths=None,
             format=None,
             **{argument_name: 'value'},
         ),
+        global_arguments=flexmock(log_json=False),
     )
 
     assert command == ('borg', 'list', '--' + argument_name.replace('_', '-'), 'value', 'repo')
 
 
 def test_make_find_paths_considers_none_as_empty_paths():
     assert module.make_find_paths(None) == ()
@@ -255,77 +287,82 @@
 
 def test_capture_archive_listing_does_not_raise():
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command_and_capture_output').and_return('')
     flexmock(module).should_receive('make_list_command')
 
     module.capture_archive_listing(
-        repository='repo',
+        repository_path='repo',
         archive='archive',
-        storage_config=flexmock(),
+        config=flexmock(),
         local_borg_version=flexmock(),
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_list_archive_calls_borg_with_parameters():
+def test_list_archive_calls_borg_with_flags():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.logger).answer = lambda message: None
     list_arguments = argparse.Namespace(
         archive='archive',
         paths=None,
         json=False,
         find_paths=None,
         prefix=None,
         match_archives=None,
         sort_by=None,
         first=None,
         last=None,
     )
+    global_arguments = flexmock(log_json=False)
 
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module).should_receive('make_list_command').with_args(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=list_arguments,
+        global_arguments=global_arguments,
         local_path='borg',
         remote_path=None,
     ).and_return(('borg', 'list', 'repo::archive'))
     flexmock(module).should_receive('make_find_paths').and_return(())
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
         ('borg', 'list', 'repo::archive'),
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     ).once()
 
     module.list_archive(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=list_arguments,
+        global_arguments=global_arguments,
     )
 
 
 def test_list_archive_with_archive_and_json_errors():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.logger).answer = lambda message: None
     list_arguments = argparse.Namespace(archive='archive', paths=None, json=True, find_paths=None)
 
     flexmock(module.feature).should_receive('available').and_return(False)
 
     with pytest.raises(ValueError):
         module.list_archive(
-            repository='repo',
-            storage_config={},
+            repository_path='repo',
+            config={},
             local_borg_version='1.2.3',
             list_arguments=list_arguments,
+            global_arguments=flexmock(log_json=False),
         )
 
 
 def test_list_archive_calls_borg_with_local_path():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.logger).answer = lambda message: None
@@ -336,38 +373,41 @@
         find_paths=None,
         prefix=None,
         match_archives=None,
         sort_by=None,
         first=None,
         last=None,
     )
+    global_arguments = flexmock(log_json=False)
 
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module).should_receive('make_list_command').with_args(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=list_arguments,
+        global_arguments=global_arguments,
         local_path='borg2',
         remote_path=None,
     ).and_return(('borg2', 'list', 'repo::archive'))
     flexmock(module).should_receive('make_find_paths').and_return(())
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
         ('borg2', 'list', 'repo::archive'),
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg2',
         extra_environment=None,
     ).once()
 
     module.list_archive(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=list_arguments,
+        global_arguments=global_arguments,
         local_path='borg2',
     )
 
 
 def test_list_archive_calls_borg_multiple_times_with_find_paths():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
@@ -383,15 +423,17 @@
         first=None,
         last=None,
     )
 
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.rlist).should_receive('make_rlist_command').and_return(('borg', 'list', 'repo'))
     flexmock(module).should_receive('execute_command_and_capture_output').with_args(
-        ('borg', 'list', 'repo'), extra_environment=None,
+        ('borg', 'list', 'repo'),
+        extra_environment=None,
+        borg_local_path='borg',
     ).and_return('archive1\narchive2').once()
     flexmock(module).should_receive('make_list_command').and_return(
         ('borg', 'list', 'repo::archive1')
     ).and_return(('borg', 'list', 'repo::archive2'))
     flexmock(module).should_receive('make_find_paths').and_return(glob_paths)
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
@@ -404,18 +446,19 @@
         ('borg', 'list', 'repo::archive2') + glob_paths,
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     ).once()
 
     module.list_archive(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=list_arguments,
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_list_archive_calls_borg_with_archive():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.logger).answer = lambda message: None
@@ -426,38 +469,41 @@
         find_paths=None,
         prefix=None,
         match_archives=None,
         sort_by=None,
         first=None,
         last=None,
     )
+    global_arguments = flexmock(log_json=False)
 
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module).should_receive('make_list_command').with_args(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=list_arguments,
+        global_arguments=global_arguments,
         local_path='borg',
         remote_path=None,
     ).and_return(('borg', 'list', 'repo::archive'))
     flexmock(module).should_receive('make_find_paths').and_return(())
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
         ('borg', 'list', 'repo::archive'),
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     ).once()
 
     module.list_archive(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=list_arguments,
+        global_arguments=global_arguments,
     )
 
 
 def test_list_archive_without_archive_delegates_to_list_repository():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.logger).answer = lambda message: None
@@ -476,18 +522,19 @@
 
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.rlist).should_receive('list_repository')
     flexmock(module.environment).should_receive('make_environment').never()
     flexmock(module).should_receive('execute_command').never()
 
     module.list_archive(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=list_arguments,
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_list_archive_with_borg_features_without_archive_delegates_to_list_repository():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.logger).answer = lambda message: None
@@ -506,71 +553,91 @@
 
     flexmock(module.feature).should_receive('available').and_return(True)
     flexmock(module.rlist).should_receive('list_repository')
     flexmock(module.environment).should_receive('make_environment').never()
     flexmock(module).should_receive('execute_command').never()
 
     module.list_archive(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=list_arguments,
+        global_arguments=flexmock(log_json=False),
     )
 
 
 @pytest.mark.parametrize(
-    'archive_filter_flag', ('prefix', 'match_archives', 'sort_by', 'first', 'last',),
+    'archive_filter_flag',
+    (
+        'prefix',
+        'match_archives',
+        'sort_by',
+        'first',
+        'last',
+    ),
 )
-def test_list_archive_with_archive_ignores_archive_filter_flag(archive_filter_flag,):
+def test_list_archive_with_archive_ignores_archive_filter_flag(
+    archive_filter_flag,
+):
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.logger).answer = lambda message: None
+    global_arguments = flexmock(log_json=False)
     default_filter_flags = {
         'prefix': None,
         'match_archives': None,
         'sort_by': None,
         'first': None,
         'last': None,
     }
     altered_filter_flags = {**default_filter_flags, **{archive_filter_flag: 'foo'}}
 
     flexmock(module.feature).should_receive('available').with_args(
         module.feature.Feature.RLIST, '1.2.3'
     ).and_return(False)
     flexmock(module).should_receive('make_list_command').with_args(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=argparse.Namespace(
             archive='archive', paths=None, json=False, find_paths=None, **default_filter_flags
         ),
+        global_arguments=global_arguments,
         local_path='borg',
         remote_path=None,
     ).and_return(('borg', 'list', 'repo::archive'))
     flexmock(module).should_receive('make_find_paths').and_return(())
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
         ('borg', 'list', 'repo::archive'),
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     ).once()
 
     module.list_archive(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=argparse.Namespace(
             archive='archive', paths=None, json=False, find_paths=None, **altered_filter_flags
         ),
+        global_arguments=global_arguments,
     )
 
 
 @pytest.mark.parametrize(
-    'archive_filter_flag', ('prefix', 'match_archives', 'sort_by', 'first', 'last',),
+    'archive_filter_flag',
+    (
+        'prefix',
+        'match_archives',
+        'sort_by',
+        'first',
+        'last',
+    ),
 )
 def test_list_archive_with_find_paths_allows_archive_filter_flag_but_only_passes_it_to_rlist(
     archive_filter_flag,
 ):
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
     flexmock(module.logger).answer = lambda message: None
@@ -579,63 +646,69 @@
         'match_archives': None,
         'sort_by': None,
         'first': None,
         'last': None,
     }
     altered_filter_flags = {**default_filter_flags, **{archive_filter_flag: 'foo'}}
     glob_paths = ('**/*foo.txt*/**',)
+    global_arguments = flexmock(log_json=False)
     flexmock(module.feature).should_receive('available').and_return(True)
 
     flexmock(module.rlist).should_receive('make_rlist_command').with_args(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         rlist_arguments=argparse.Namespace(
             repository='repo', short=True, format=None, json=None, **altered_filter_flags
         ),
+        global_arguments=global_arguments,
         local_path='borg',
         remote_path=None,
     ).and_return(('borg', 'rlist', '--repo', 'repo'))
 
     flexmock(module).should_receive('execute_command_and_capture_output').with_args(
-        ('borg', 'rlist', '--repo', 'repo'), extra_environment=None,
+        ('borg', 'rlist', '--repo', 'repo'),
+        extra_environment=None,
+        borg_local_path='borg',
     ).and_return('archive1\narchive2').once()
 
     flexmock(module).should_receive('make_list_command').with_args(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=argparse.Namespace(
             repository='repo',
             archive='archive1',
             paths=None,
             short=True,
             format=None,
             json=None,
             find_paths=['foo.txt'],
             **default_filter_flags,
         ),
+        global_arguments=global_arguments,
         local_path='borg',
         remote_path=None,
     ).and_return(('borg', 'list', '--repo', 'repo', 'archive1'))
 
     flexmock(module).should_receive('make_list_command').with_args(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=argparse.Namespace(
             repository='repo',
             archive='archive2',
             paths=None,
             short=True,
             format=None,
             json=None,
             find_paths=['foo.txt'],
             **default_filter_flags,
         ),
+        global_arguments=global_arguments,
         local_path='borg',
         remote_path=None,
     ).and_return(('borg', 'list', '--repo', 'repo', 'archive2'))
 
     flexmock(module).should_receive('make_find_paths').and_return(glob_paths)
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
@@ -648,21 +721,22 @@
         ('borg', 'list', '--repo', 'repo', 'archive2') + glob_paths,
         output_log_level=module.borgmatic.logger.ANSWER,
         borg_local_path='borg',
         extra_environment=None,
     ).once()
 
     module.list_archive(
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='1.2.3',
         list_arguments=argparse.Namespace(
             repository='repo',
             archive=None,
             paths=None,
             short=True,
             format=None,
             json=None,
             find_paths=['foo.txt'],
             **altered_filter_flags,
         ),
+        global_arguments=global_arguments,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_mount.py` & `borgmatic-1.8.0/tests/unit/borg/test_mount.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,189 +6,207 @@
 
 from ..test_verbosity import insert_logging_mock
 
 
 def insert_execute_command_mock(command):
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        command, borg_local_path='borg', extra_environment=None,
+        command,
+        borg_local_path='borg',
+        extra_environment=None,
     ).once()
 
 
 def test_mount_archive_calls_borg_with_required_flags():
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
     insert_execute_command_mock(('borg', 'mount', 'repo', '/mnt'))
 
+    mount_arguments = flexmock(mount_point='/mnt', options=None, paths=None, foreground=False)
     module.mount_archive(
-        repository='repo',
+        repository_path='repo',
         archive=None,
-        mount_point='/mnt',
-        paths=None,
-        foreground=False,
-        options=None,
-        storage_config={},
+        mount_arguments=mount_arguments,
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_mount_archive_with_borg_features_calls_borg_with_repository_and_match_archives_flags():
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
     insert_execute_command_mock(
         ('borg', 'mount', '--repo', 'repo', '--match-archives', 'archive', '/mnt')
     )
 
+    mount_arguments = flexmock(mount_point='/mnt', options=None, paths=None, foreground=False)
     module.mount_archive(
-        repository='repo',
+        repository_path='repo',
         archive='archive',
-        mount_point='/mnt',
-        paths=None,
-        foreground=False,
-        options=None,
-        storage_config={},
+        mount_arguments=mount_arguments,
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_mount_archive_without_archive_calls_borg_with_repository_flags_only():
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
     insert_execute_command_mock(('borg', 'mount', 'repo::archive', '/mnt'))
 
+    mount_arguments = flexmock(mount_point='/mnt', options=None, paths=None, foreground=False)
     module.mount_archive(
-        repository='repo',
+        repository_path='repo',
         archive='archive',
-        mount_point='/mnt',
-        paths=None,
-        foreground=False,
-        options=None,
-        storage_config={},
+        mount_arguments=mount_arguments,
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_mount_archive_calls_borg_with_path_flags():
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
     insert_execute_command_mock(('borg', 'mount', 'repo::archive', '/mnt', 'path1', 'path2'))
 
+    mount_arguments = flexmock(
+        mount_point='/mnt', options=None, paths=['path1', 'path2'], foreground=False
+    )
     module.mount_archive(
-        repository='repo',
+        repository_path='repo',
         archive='archive',
-        mount_point='/mnt',
-        paths=['path1', 'path2'],
-        foreground=False,
-        options=None,
-        storage_config={},
+        mount_arguments=mount_arguments,
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_mount_archive_calls_borg_with_remote_path_flags():
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
     insert_execute_command_mock(
         ('borg', 'mount', '--remote-path', 'borg1', 'repo::archive', '/mnt')
     )
 
+    mount_arguments = flexmock(mount_point='/mnt', options=None, paths=None, foreground=False)
     module.mount_archive(
-        repository='repo',
+        repository_path='repo',
         archive='archive',
-        mount_point='/mnt',
-        paths=None,
-        foreground=False,
-        options=None,
-        storage_config={},
+        mount_arguments=mount_arguments,
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
         remote_path='borg1',
     )
 
 
 def test_mount_archive_calls_borg_with_umask_flags():
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
     insert_execute_command_mock(('borg', 'mount', '--umask', '0770', 'repo::archive', '/mnt'))
 
+    mount_arguments = flexmock(mount_point='/mnt', options=None, paths=None, foreground=False)
     module.mount_archive(
-        repository='repo',
+        repository_path='repo',
         archive='archive',
-        mount_point='/mnt',
-        paths=None,
-        foreground=False,
-        options=None,
-        storage_config={'umask': '0770'},
+        mount_arguments=mount_arguments,
+        config={'umask': '0770'},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+    )
+
+
+def test_mount_archive_calls_borg_with_log_json_flags():
+    flexmock(module.feature).should_receive('available').and_return(False)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(('borg', 'mount', '--log-json', 'repo::archive', '/mnt'))
+
+    mount_arguments = flexmock(mount_point='/mnt', options=None, paths=None, foreground=False)
+    module.mount_archive(
+        repository_path='repo',
+        archive='archive',
+        mount_arguments=mount_arguments,
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=True),
     )
 
 
 def test_mount_archive_calls_borg_with_lock_wait_flags():
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
     insert_execute_command_mock(('borg', 'mount', '--lock-wait', '5', 'repo::archive', '/mnt'))
 
+    mount_arguments = flexmock(mount_point='/mnt', options=None, paths=None, foreground=False)
     module.mount_archive(
-        repository='repo',
+        repository_path='repo',
         archive='archive',
-        mount_point='/mnt',
-        paths=None,
-        foreground=False,
-        options=None,
-        storage_config={'lock_wait': '5'},
+        mount_arguments=mount_arguments,
+        config={'lock_wait': '5'},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_mount_archive_with_log_info_calls_borg_with_info_parameter():
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
     insert_execute_command_mock(('borg', 'mount', '--info', 'repo::archive', '/mnt'))
     insert_logging_mock(logging.INFO)
 
+    mount_arguments = flexmock(mount_point='/mnt', options=None, paths=None, foreground=False)
     module.mount_archive(
-        repository='repo',
+        repository_path='repo',
         archive='archive',
-        mount_point='/mnt',
-        paths=None,
-        foreground=False,
-        options=None,
-        storage_config={},
+        mount_arguments=mount_arguments,
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_mount_archive_with_log_debug_calls_borg_with_debug_flags():
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
     insert_execute_command_mock(('borg', 'mount', '--debug', '--show-rc', 'repo::archive', '/mnt'))
     insert_logging_mock(logging.DEBUG)
 
+    mount_arguments = flexmock(mount_point='/mnt', options=None, paths=None, foreground=False)
     module.mount_archive(
-        repository='repo',
+        repository_path='repo',
         archive='archive',
-        mount_point='/mnt',
-        paths=None,
-        foreground=False,
-        options=None,
-        storage_config={},
+        mount_arguments=mount_arguments,
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_mount_archive_calls_borg_with_foreground_parameter():
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
@@ -197,36 +215,97 @@
     flexmock(module).should_receive('execute_command').with_args(
         ('borg', 'mount', '--foreground', 'repo::archive', '/mnt'),
         output_file=module.DO_NOT_CAPTURE,
         borg_local_path='borg',
         extra_environment=None,
     ).once()
 
+    mount_arguments = flexmock(mount_point='/mnt', options=None, paths=None, foreground=True)
     module.mount_archive(
-        repository='repo',
+        repository_path='repo',
         archive='archive',
-        mount_point='/mnt',
-        paths=None,
-        foreground=True,
-        options=None,
-        storage_config={},
+        mount_arguments=mount_arguments,
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
 def test_mount_archive_calls_borg_with_options_flags():
     flexmock(module.feature).should_receive('available').and_return(False)
     flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
         ('repo::archive',)
     )
     insert_execute_command_mock(('borg', 'mount', '-o', 'super_mount', 'repo::archive', '/mnt'))
 
+    mount_arguments = flexmock(
+        mount_point='/mnt', options='super_mount', paths=None, foreground=False
+    )
     module.mount_archive(
-        repository='repo',
+        repository_path='repo',
         archive='archive',
+        mount_arguments=mount_arguments,
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+    )
+
+
+def test_mount_archive_with_date_based_matching_calls_borg_with_date_based_flags():
+    flexmock(module.flags).should_receive('make_flags').and_return(())
+    flexmock(module.flags).should_receive('make_match_archives_flags').and_return(())
+    flexmock(module.flags).should_receive('make_flags_from_arguments').and_return(
+        (
+            '--newer',
+            '1d',
+            '--newest',
+            '1y',
+            '--older',
+            '1m',
+            '--oldest',
+            '1w',
+            '--match-archives',
+            None,
+        )
+    )
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo'))
+    flexmock(module.environment).should_receive('make_environment')
+    flexmock(module).should_receive('execute_command').with_args(
+        (
+            'borg',
+            'mount',
+            '--newer',
+            '1d',
+            '--newest',
+            '1y',
+            '--older',
+            '1m',
+            '--oldest',
+            '1w',
+            '--match-archives',
+            None,
+            '--repo',
+            'repo',
+            '/mnt',
+        ),
+        borg_local_path='borg',
+        extra_environment=None,
+    )
+
+    mount_arguments = flexmock(
         mount_point='/mnt',
+        options=None,
         paths=None,
         foreground=False,
-        options='super_mount',
-        storage_config={},
+        newer='1d',
+        newest='1y',
+        older='1m',
+        oldest='1w',
+    )
+    module.mount_archive(
+        repository_path='repo',
+        archive=None,
+        mount_arguments=mount_arguments,
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_prune.py` & `borgmatic-1.8.0/tests/unit/borg/test_export_tar.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,261 +1,326 @@
 import logging
-from collections import OrderedDict
 
 from flexmock import flexmock
 
-from borgmatic.borg import prune as module
+from borgmatic.borg import export_tar as module
 
 from ..test_verbosity import insert_logging_mock
 
 
-def insert_execute_command_mock(prune_command, output_log_level):
+def insert_execute_command_mock(
+    command, output_log_level=logging.INFO, borg_local_path='borg', capture=True
+):
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').with_args(
-        prune_command,
+        command,
+        output_file=None if capture else module.DO_NOT_CAPTURE,
         output_log_level=output_log_level,
-        borg_local_path=prune_command[0],
+        borg_local_path=borg_local_path,
         extra_environment=None,
     ).once()
 
 
-BASE_PRUNE_FLAGS = (('--keep-daily', '1'), ('--keep-weekly', '2'), ('--keep-monthly', '3'))
-
-
-def test_make_prune_flags_returns_flags_from_config_plus_default_prefix_glob():
-    retention_config = OrderedDict((('keep_daily', 1), ('keep_weekly', 2), ('keep_monthly', 3)))
-    flexmock(module.feature).should_receive('available').and_return(True)
-
-    result = module.make_prune_flags(retention_config, local_borg_version='1.2.3')
-
-    assert tuple(result) == BASE_PRUNE_FLAGS + (('--match-archives', 'sh:{hostname}-*'),)
-
-
-def test_make_prune_flags_accepts_prefix_with_placeholders():
-    retention_config = OrderedDict((('keep_daily', 1), ('prefix', 'Documents_{hostname}-{now}')))
-    flexmock(module.feature).should_receive('available').and_return(True)
-
-    result = module.make_prune_flags(retention_config, local_borg_version='1.2.3')
-
-    expected = (('--keep-daily', '1'), ('--match-archives', 'sh:Documents_{hostname}-{now}*'))
-
-    assert tuple(result) == expected
-
-
-def test_make_prune_flags_with_prefix_without_borg_features_uses_glob_archives():
-    retention_config = OrderedDict((('keep_daily', 1), ('prefix', 'Documents_{hostname}-{now}')))
-    flexmock(module.feature).should_receive('available').and_return(False)
-
-    result = module.make_prune_flags(retention_config, local_borg_version='1.2.3')
-
-    expected = (('--keep-daily', '1'), ('--glob-archives', 'Documents_{hostname}-{now}*'))
-
-    assert tuple(result) == expected
-
-
-def test_make_prune_flags_treats_empty_prefix_as_no_prefix():
-    retention_config = OrderedDict((('keep_daily', 1), ('prefix', '')))
-    flexmock(module.feature).should_receive('available').and_return(True)
-
-    result = module.make_prune_flags(retention_config, local_borg_version='1.2.3')
-
-    expected = (('--keep-daily', '1'),)
-
-    assert tuple(result) == expected
+def test_export_tar_archive_calls_borg_with_path_parameters():
+    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
+    flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(
+        ('borg', 'export-tar', 'repo::archive', 'test.tar', 'path1', 'path2')
+    )
 
+    module.export_tar_archive(
+        dry_run=False,
+        repository_path='repo',
+        archive='archive',
+        paths=['path1', 'path2'],
+        destination_path='test.tar',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+    )
 
-def test_make_prune_flags_treats_none_prefix_as_no_prefix():
-    retention_config = OrderedDict((('keep_daily', 1), ('prefix', None)))
-    flexmock(module.feature).should_receive('available').and_return(True)
 
-    result = module.make_prune_flags(retention_config, local_borg_version='1.2.3')
+def test_export_tar_archive_calls_borg_with_local_path_parameters():
+    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
+    flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(
+        ('borg1', 'export-tar', 'repo::archive', 'test.tar'), borg_local_path='borg1'
+    )
 
-    expected = (('--keep-daily', '1'),)
+    module.export_tar_archive(
+        dry_run=False,
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        local_path='borg1',
+    )
 
-    assert tuple(result) == expected
 
+def test_export_tar_archive_calls_borg_with_remote_path_parameters():
+    flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
+    flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(
+        ('borg', 'export-tar', '--remote-path', 'borg1', 'repo::archive', 'test.tar')
+    )
 
-PRUNE_COMMAND = ('borg', 'prune', '--keep-daily', '1', '--keep-weekly', '2', '--keep-monthly', '3')
+    module.export_tar_archive(
+        dry_run=False,
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={},
+        local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        remote_path='borg1',
+    )
 
 
-def test_prune_archives_calls_borg_with_parameters():
+def test_export_tar_archive_calls_borg_with_umask_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module).should_receive('make_prune_flags').and_return(BASE_PRUNE_FLAGS)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    insert_execute_command_mock(PRUNE_COMMAND + ('repo',), logging.INFO)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(
+        ('borg', 'export-tar', '--umask', '0770', 'repo::archive', 'test.tar')
+    )
 
-    module.prune_archives(
+    module.export_tar_archive(
         dry_run=False,
-        repository='repo',
-        storage_config={},
-        retention_config=flexmock(),
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={'umask': '0770'},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_prune_archives_with_log_info_calls_borg_with_info_parameter():
+def test_export_tar_archive_calls_borg_with_log_json_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module).should_receive('make_prune_flags').and_return(BASE_PRUNE_FLAGS)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    insert_execute_command_mock(PRUNE_COMMAND + ('--info', 'repo'), logging.INFO)
-    insert_logging_mock(logging.INFO)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(('borg', 'export-tar', '--log-json', 'repo::archive', 'test.tar'))
 
-    module.prune_archives(
-        repository='repo',
-        storage_config={},
+    module.export_tar_archive(
         dry_run=False,
-        retention_config=flexmock(),
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=True),
     )
 
 
-def test_prune_archives_with_log_debug_calls_borg_with_debug_parameter():
+def test_export_tar_archive_calls_borg_with_lock_wait_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module).should_receive('make_prune_flags').and_return(BASE_PRUNE_FLAGS)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    insert_execute_command_mock(PRUNE_COMMAND + ('--debug', '--show-rc', 'repo'), logging.INFO)
-    insert_logging_mock(logging.DEBUG)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(
+        ('borg', 'export-tar', '--lock-wait', '5', 'repo::archive', 'test.tar')
+    )
 
-    module.prune_archives(
-        repository='repo',
-        storage_config={},
+    module.export_tar_archive(
         dry_run=False,
-        retention_config=flexmock(),
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={'lock_wait': '5'},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_prune_archives_with_dry_run_calls_borg_with_dry_run_parameter():
+def test_export_tar_archive_with_log_info_calls_borg_with_info_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module).should_receive('make_prune_flags').and_return(BASE_PRUNE_FLAGS)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    insert_execute_command_mock(PRUNE_COMMAND + ('--dry-run', 'repo'), logging.INFO)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(('borg', 'export-tar', '--info', 'repo::archive', 'test.tar'))
+    insert_logging_mock(logging.INFO)
 
-    module.prune_archives(
-        repository='repo',
-        storage_config={},
-        dry_run=True,
-        retention_config=flexmock(),
+    module.export_tar_archive(
+        dry_run=False,
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_prune_archives_with_local_path_calls_borg_via_local_path():
+def test_export_tar_archive_with_log_debug_calls_borg_with_debug_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module).should_receive('make_prune_flags').and_return(BASE_PRUNE_FLAGS)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    insert_execute_command_mock(('borg1',) + PRUNE_COMMAND[1:] + ('repo',), logging.INFO)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(
+        ('borg', 'export-tar', '--debug', '--show-rc', 'repo::archive', 'test.tar')
+    )
+    insert_logging_mock(logging.DEBUG)
 
-    module.prune_archives(
+    module.export_tar_archive(
         dry_run=False,
-        repository='repo',
-        storage_config={},
-        retention_config=flexmock(),
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={},
         local_borg_version='1.2.3',
-        local_path='borg1',
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_prune_archives_with_remote_path_calls_borg_with_remote_path_parameters():
+def test_export_tar_archive_calls_borg_with_dry_run_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module).should_receive('make_prune_flags').and_return(BASE_PRUNE_FLAGS)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    insert_execute_command_mock(PRUNE_COMMAND + ('--remote-path', 'borg1', 'repo'), logging.INFO)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    flexmock(module).should_receive('execute_command').never()
 
-    module.prune_archives(
-        dry_run=False,
-        repository='repo',
-        storage_config={},
-        retention_config=flexmock(),
+    module.export_tar_archive(
+        dry_run=True,
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={},
         local_borg_version='1.2.3',
-        remote_path='borg1',
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_prune_archives_with_stats_calls_borg_with_stats_parameter_and_answer_output_log_level():
+def test_export_tar_archive_calls_borg_with_tar_filter_parameters():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module).should_receive('make_prune_flags').and_return(BASE_PRUNE_FLAGS)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    insert_execute_command_mock(PRUNE_COMMAND + ('--stats', 'repo'), module.borgmatic.logger.ANSWER)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(
+        ('borg', 'export-tar', '--tar-filter', 'bzip2', 'repo::archive', 'test.tar')
+    )
 
-    module.prune_archives(
+    module.export_tar_archive(
         dry_run=False,
-        repository='repo',
-        storage_config={},
-        retention_config=flexmock(),
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={},
         local_borg_version='1.2.3',
-        stats=True,
+        global_arguments=flexmock(log_json=False),
+        tar_filter='bzip2',
     )
 
 
-def test_prune_archives_with_files_calls_borg_with_list_parameter_and_answer_output_log_level():
+def test_export_tar_archive_calls_borg_with_list_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module).should_receive('make_prune_flags').and_return(BASE_PRUNE_FLAGS)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    insert_execute_command_mock(PRUNE_COMMAND + ('--list', 'repo'), module.borgmatic.logger.ANSWER)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(
+        ('borg', 'export-tar', '--list', 'repo::archive', 'test.tar'),
+        output_log_level=logging.ANSWER,
+    )
 
-    module.prune_archives(
+    module.export_tar_archive(
         dry_run=False,
-        repository='repo',
-        storage_config={},
-        retention_config=flexmock(),
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={},
         local_borg_version='1.2.3',
-        list_archives=True,
+        global_arguments=flexmock(log_json=False),
+        list_files=True,
     )
 
 
-def test_prune_archives_with_umask_calls_borg_with_umask_parameters():
+def test_export_tar_archive_calls_borg_with_strip_components_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    storage_config = {'umask': '077'}
-    flexmock(module).should_receive('make_prune_flags').and_return(BASE_PRUNE_FLAGS)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    insert_execute_command_mock(PRUNE_COMMAND + ('--umask', '077', 'repo'), logging.INFO)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(
+        ('borg', 'export-tar', '--strip-components', '5', 'repo::archive', 'test.tar')
+    )
 
-    module.prune_archives(
+    module.export_tar_archive(
         dry_run=False,
-        repository='repo',
-        storage_config=storage_config,
-        retention_config=flexmock(),
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
+        strip_components=5,
     )
 
 
-def test_prune_archives_with_lock_wait_calls_borg_with_lock_wait_parameters():
+def test_export_tar_archive_skips_abspath_for_remote_repository_parameter():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    storage_config = {'lock_wait': 5}
-    flexmock(module).should_receive('make_prune_flags').and_return(BASE_PRUNE_FLAGS)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    insert_execute_command_mock(PRUNE_COMMAND + ('--lock-wait', '5', 'repo'), logging.INFO)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('server:repo::archive',)
+    )
+    insert_execute_command_mock(('borg', 'export-tar', 'server:repo::archive', 'test.tar'))
 
-    module.prune_archives(
+    module.export_tar_archive(
         dry_run=False,
-        repository='repo',
-        storage_config=storage_config,
-        retention_config=flexmock(),
+        repository_path='server:repo',
+        archive='archive',
+        paths=None,
+        destination_path='test.tar',
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
 
 
-def test_prune_archives_with_extra_borg_options_calls_borg_with_extra_options():
+def test_export_tar_archive_calls_borg_with_stdout_destination_path():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
-    flexmock(module).should_receive('make_prune_flags').and_return(BASE_PRUNE_FLAGS)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('repo',))
-    insert_execute_command_mock(PRUNE_COMMAND + ('--extra', '--options', 'repo'), logging.INFO)
+    flexmock(module.flags).should_receive('make_repository_archive_flags').and_return(
+        ('repo::archive',)
+    )
+    insert_execute_command_mock(('borg', 'export-tar', 'repo::archive', '-'), capture=False)
 
-    module.prune_archives(
+    module.export_tar_archive(
         dry_run=False,
-        repository='repo',
-        storage_config={'extra_borg_options': {'prune': '--extra --options'}},
-        retention_config=flexmock(),
+        repository_path='repo',
+        archive='archive',
+        paths=None,
+        destination_path='-',
+        config={},
         local_borg_version='1.2.3',
+        global_arguments=flexmock(log_json=False),
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_rcreate.py` & `borgmatic-1.8.0/tests/unit/borg/test_rcreate.py`

 * *Files 21% similar despite different names*

```diff
@@ -32,238 +32,365 @@
     ).once()
 
 
 def test_create_repository_calls_borg_with_flags():
     insert_rinfo_command_not_found_mock()
     insert_rcreate_command_mock(RCREATE_COMMAND + ('--repo', 'repo'))
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
     )
 
 
 def test_create_repository_with_dry_run_skips_borg_call():
     insert_rinfo_command_not_found_mock()
     flexmock(module).should_receive('execute_command').never()
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=True,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
     )
 
 
 def test_create_repository_raises_for_borg_rcreate_error():
     insert_rinfo_command_not_found_mock()
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command').and_raise(
         module.subprocess.CalledProcessError(2, 'borg rcreate')
     )
 
     with pytest.raises(subprocess.CalledProcessError):
         module.create_repository(
             dry_run=False,
-            repository='repo',
-            storage_config={},
+            repository_path='repo',
+            config={},
             local_borg_version='2.3.4',
+            global_arguments=flexmock(log_json=False),
             encryption_mode='repokey',
         )
 
 
 def test_create_repository_skips_creation_when_repository_already_exists():
     insert_rinfo_command_found_mock()
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
     )
 
 
 def test_create_repository_raises_for_unknown_rinfo_command_error():
     flexmock(module.rinfo).should_receive('display_repository_info').and_raise(
         subprocess.CalledProcessError(RINFO_SOME_UNKNOWN_EXIT_CODE, [])
     )
 
     with pytest.raises(subprocess.CalledProcessError):
         module.create_repository(
             dry_run=False,
-            repository='repo',
-            storage_config={},
+            repository_path='repo',
+            config={},
             local_borg_version='2.3.4',
+            global_arguments=flexmock(log_json=False),
             encryption_mode='repokey',
         )
 
 
 def test_create_repository_with_source_repository_calls_borg_with_other_repo_flag():
     insert_rinfo_command_not_found_mock()
     insert_rcreate_command_mock(RCREATE_COMMAND + ('--other-repo', 'other.borg', '--repo', 'repo'))
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
         source_repository='other.borg',
     )
 
 
 def test_create_repository_with_copy_crypt_key_calls_borg_with_copy_crypt_key_flag():
     insert_rinfo_command_not_found_mock()
     insert_rcreate_command_mock(RCREATE_COMMAND + ('--copy-crypt-key', '--repo', 'repo'))
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
         copy_crypt_key=True,
     )
 
 
 def test_create_repository_with_append_only_calls_borg_with_append_only_flag():
     insert_rinfo_command_not_found_mock()
     insert_rcreate_command_mock(RCREATE_COMMAND + ('--append-only', '--repo', 'repo'))
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
         append_only=True,
     )
 
 
 def test_create_repository_with_storage_quota_calls_borg_with_storage_quota_flag():
     insert_rinfo_command_not_found_mock()
     insert_rcreate_command_mock(RCREATE_COMMAND + ('--storage-quota', '5G', '--repo', 'repo'))
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
         storage_quota='5G',
     )
 
 
 def test_create_repository_with_make_parent_dirs_calls_borg_with_make_parent_dirs_flag():
     insert_rinfo_command_not_found_mock()
     insert_rcreate_command_mock(RCREATE_COMMAND + ('--make-parent-dirs', '--repo', 'repo'))
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
         make_parent_dirs=True,
     )
 
 
 def test_create_repository_with_log_info_calls_borg_with_info_flag():
     insert_rinfo_command_not_found_mock()
     insert_rcreate_command_mock(RCREATE_COMMAND + ('--info', '--repo', 'repo'))
     insert_logging_mock(logging.INFO)
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
     )
 
 
 def test_create_repository_with_log_debug_calls_borg_with_debug_flag():
     insert_rinfo_command_not_found_mock()
     insert_rcreate_command_mock(RCREATE_COMMAND + ('--debug', '--repo', 'repo'))
     insert_logging_mock(logging.DEBUG)
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
+
+    module.create_repository(
+        dry_run=False,
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
+        encryption_mode='repokey',
+    )
+
+
+def test_create_repository_with_log_json_calls_borg_with_log_json_flag():
+    insert_rinfo_command_not_found_mock()
+    insert_rcreate_command_mock(RCREATE_COMMAND + ('--log-json', '--repo', 'repo'))
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
+
+    module.create_repository(
+        dry_run=False,
+        repository_path='repo',
+        config={},
+        local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=True),
+        encryption_mode='repokey',
+    )
+
+
+def test_create_repository_with_lock_wait_calls_borg_with_lock_wait_flag():
+    insert_rinfo_command_not_found_mock()
+    insert_rcreate_command_mock(RCREATE_COMMAND + ('--lock-wait', '5', '--repo', 'repo'))
+    flexmock(module.feature).should_receive('available').and_return(True)
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={'lock_wait': 5},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
     )
 
 
 def test_create_repository_with_local_path_calls_borg_via_local_path():
     insert_rinfo_command_not_found_mock()
     insert_rcreate_command_mock(('borg1',) + RCREATE_COMMAND[1:] + ('--repo', 'repo'))
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
         local_path='borg1',
     )
 
 
 def test_create_repository_with_remote_path_calls_borg_with_remote_path_flag():
     insert_rinfo_command_not_found_mock()
     insert_rcreate_command_mock(RCREATE_COMMAND + ('--remote-path', 'borg1', '--repo', 'repo'))
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={},
+        repository_path='repo',
+        config={},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
         remote_path='borg1',
     )
 
 
 def test_create_repository_with_extra_borg_options_calls_borg_with_extra_options():
     insert_rinfo_command_not_found_mock()
     insert_rcreate_command_mock(RCREATE_COMMAND + ('--extra', '--options', '--repo', 'repo'))
     flexmock(module.feature).should_receive('available').and_return(True)
-    flexmock(module.flags).should_receive('make_repository_flags').and_return(('--repo', 'repo',))
+    flexmock(module.flags).should_receive('make_repository_flags').and_return(
+        (
+            '--repo',
+            'repo',
+        )
+    )
 
     module.create_repository(
         dry_run=False,
-        repository='repo',
-        storage_config={'extra_borg_options': {'rcreate': '--extra --options'}},
+        repository_path='repo',
+        config={'extra_borg_options': {'rcreate': '--extra --options'}},
         local_borg_version='2.3.4',
+        global_arguments=flexmock(log_json=False),
         encryption_mode='repokey',
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_umount.py` & `borgmatic-1.8.0/tests/unit/borg/test_umount.py`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/tests/unit/borg/test_version.py` & `borgmatic-1.8.0/tests/unit/borg/test_version.py`

 * *Files 8% similar despite different names*

```diff
@@ -11,15 +11,17 @@
 
 
 def insert_execute_command_and_capture_output_mock(
     command, borg_local_path='borg', version_output=f'borg {VERSION}'
 ):
     flexmock(module.environment).should_receive('make_environment')
     flexmock(module).should_receive('execute_command_and_capture_output').with_args(
-        command, extra_environment=None,
+        command,
+        extra_environment=None,
+        borg_local_path=borg_local_path,
     ).once().and_return(version_output)
 
 
 def test_local_borg_version_calls_borg_with_required_parameters():
     insert_execute_command_and_capture_output_mock(('borg', '--version'))
     flexmock(module.environment).should_receive('make_environment')
```

### Comparing `borgmatic-1.7.9/tests/unit/commands/test_borgmatic.py` & `borgmatic-1.8.0/tests/unit/commands/test_borgmatic.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,59 +11,59 @@
 def test_run_configuration_runs_actions_for_each_repository():
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
     flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
     expected_results = [flexmock(), flexmock()]
     flexmock(module).should_receive('run_actions').and_return(expected_results[:1]).and_return(
         expected_results[1:]
     )
-    config = {'location': {'repositories': ['foo', 'bar']}}
+    config = {'repositories': [{'path': 'foo'}, {'path': 'bar'}]}
     arguments = {'global': flexmock(monitoring_verbosity=1)}
 
     results = list(module.run_configuration('test.yaml', config, arguments))
 
     assert results == expected_results
 
 
 def test_run_configuration_with_invalid_borg_version_errors():
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
     flexmock(module.borg_version).should_receive('local_borg_version').and_raise(ValueError)
     flexmock(module.command).should_receive('execute_hook').never()
     flexmock(module.dispatch).should_receive('call_hooks').never()
     flexmock(module).should_receive('run_actions').never()
-    config = {'location': {'repositories': ['foo']}}
+    config = {'repositories': ['foo']}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'prune': flexmock()}
 
     list(module.run_configuration('test.yaml', config, arguments))
 
 
 def test_run_configuration_logs_monitor_start_error():
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
     flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
     flexmock(module.dispatch).should_receive('call_hooks').and_raise(OSError).and_return(
         None
     ).and_return(None).and_return(None)
     expected_results = [flexmock()]
     flexmock(module).should_receive('log_error_records').and_return(expected_results)
     flexmock(module).should_receive('run_actions').never()
-    config = {'location': {'repositories': ['foo']}}
+    config = {'repositories': ['foo']}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
 
     results = list(module.run_configuration('test.yaml', config, arguments))
 
     assert results == expected_results
 
 
 def test_run_configuration_bails_for_monitor_start_soft_failure():
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
     flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
     error = subprocess.CalledProcessError(borgmatic.hooks.command.SOFT_FAIL_EXIT_CODE, 'try again')
     flexmock(module.dispatch).should_receive('call_hooks').and_raise(error)
     flexmock(module).should_receive('log_error_records').never()
     flexmock(module).should_receive('run_actions').never()
-    config = {'location': {'repositories': ['foo']}}
+    config = {'repositories': ['foo']}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
 
     results = list(module.run_configuration('test.yaml', config, arguments))
 
     assert results == []
 
 
@@ -71,15 +71,15 @@
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
     flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
     flexmock(module.command).should_receive('execute_hook')
     flexmock(module.dispatch).should_receive('call_hooks')
     expected_results = [flexmock()]
     flexmock(module).should_receive('log_error_records').and_return(expected_results)
     flexmock(module).should_receive('run_actions').and_raise(OSError)
-    config = {'location': {'repositories': ['foo']}}
+    config = {'repositories': [{'path': 'foo'}]}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False)}
 
     results = list(module.run_configuration('test.yaml', config, arguments))
 
     assert results == expected_results
 
 
@@ -87,15 +87,15 @@
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
     flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
     flexmock(module.dispatch).should_receive('call_hooks')
     error = subprocess.CalledProcessError(borgmatic.hooks.command.SOFT_FAIL_EXIT_CODE, 'try again')
     flexmock(module).should_receive('run_actions').and_raise(error)
     flexmock(module).should_receive('log_error_records').never()
     flexmock(module.command).should_receive('considered_soft_failure').and_return(True)
-    config = {'location': {'repositories': ['foo']}}
+    config = {'repositories': [{'path': 'foo'}]}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
 
     results = list(module.run_configuration('test.yaml', config, arguments))
 
     assert results == []
 
 
@@ -104,15 +104,15 @@
     flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
     flexmock(module.dispatch).should_receive('call_hooks').and_return(None).and_return(
         None
     ).and_raise(OSError)
     expected_results = [flexmock()]
     flexmock(module).should_receive('log_error_records').and_return(expected_results)
     flexmock(module).should_receive('run_actions').and_return([])
-    config = {'location': {'repositories': ['foo']}}
+    config = {'repositories': [{'path': 'foo'}]}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
 
     results = list(module.run_configuration('test.yaml', config, arguments))
 
     assert results == expected_results
 
 
@@ -122,15 +122,15 @@
     error = subprocess.CalledProcessError(borgmatic.hooks.command.SOFT_FAIL_EXIT_CODE, 'try again')
     flexmock(module.dispatch).should_receive('call_hooks').and_return(None).and_return(
         None
     ).and_raise(error)
     flexmock(module).should_receive('log_error_records').never()
     flexmock(module).should_receive('run_actions').and_return([])
     flexmock(module.command).should_receive('considered_soft_failure').and_return(True)
-    config = {'location': {'repositories': ['foo']}}
+    config = {'repositories': [{'path': 'foo'}]}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
 
     results = list(module.run_configuration('test.yaml', config, arguments))
 
     assert results == []
 
 
@@ -139,15 +139,15 @@
     flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
     flexmock(module.dispatch).should_receive('call_hooks').and_return(None).and_return(
         None
     ).and_return(None).and_raise(OSError)
     expected_results = [flexmock()]
     flexmock(module).should_receive('log_error_records').and_return(expected_results)
     flexmock(module).should_receive('run_actions').and_return([])
-    config = {'location': {'repositories': ['foo']}}
+    config = {'repositories': [{'path': 'foo'}]}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
 
     results = list(module.run_configuration('test.yaml', config, arguments))
 
     assert results == expected_results
 
 
@@ -157,32 +157,45 @@
     error = subprocess.CalledProcessError(borgmatic.hooks.command.SOFT_FAIL_EXIT_CODE, 'try again')
     flexmock(module.dispatch).should_receive('call_hooks').and_return(None).and_return(
         None
     ).and_raise(None).and_raise(error)
     flexmock(module).should_receive('log_error_records').never()
     flexmock(module).should_receive('run_actions').and_return([])
     flexmock(module.command).should_receive('considered_soft_failure').and_return(True)
-    config = {'location': {'repositories': ['foo']}}
+    config = {'repositories': [{'path': 'foo'}]}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
 
     results = list(module.run_configuration('test.yaml', config, arguments))
 
     assert results == []
 
 
+def test_run_configuration_does_not_call_monitoring_hooks_if_monitoring_hooks_are_disabled():
+    flexmock(module).should_receive('verbosity_to_log_level').and_return(module.DISABLED)
+    flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
+
+    flexmock(module.dispatch).should_receive('call_hooks').never()
+    flexmock(module).should_receive('run_actions').and_return([])
+
+    config = {'repositories': [{'path': 'foo'}]}
+    arguments = {'global': flexmock(monitoring_verbosity=-2, dry_run=False), 'create': flexmock()}
+    results = list(module.run_configuration('test.yaml', config, arguments))
+    assert results == []
+
+
 def test_run_configuration_logs_on_error_hook_error():
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
     flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
     flexmock(module.command).should_receive('execute_hook').and_raise(OSError)
     expected_results = [flexmock(), flexmock()]
     flexmock(module).should_receive('log_error_records').and_return(
         expected_results[:1]
     ).and_return(expected_results[1:])
     flexmock(module).should_receive('run_actions').and_raise(OSError)
-    config = {'location': {'repositories': ['foo']}}
+    config = {'repositories': [{'path': 'foo'}]}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
 
     results = list(module.run_configuration('test.yaml', config, arguments))
 
     assert results == expected_results
 
 
@@ -190,30 +203,30 @@
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
     flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
     error = subprocess.CalledProcessError(borgmatic.hooks.command.SOFT_FAIL_EXIT_CODE, 'try again')
     flexmock(module.command).should_receive('execute_hook').and_raise(error)
     expected_results = [flexmock()]
     flexmock(module).should_receive('log_error_records').and_return(expected_results)
     flexmock(module).should_receive('run_actions').and_raise(OSError)
-    config = {'location': {'repositories': ['foo']}}
+    config = {'repositories': [{'path': 'foo'}]}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
 
     results = list(module.run_configuration('test.yaml', config, arguments))
 
     assert results == expected_results
 
 
 def test_run_configuration_retries_soft_error():
     # Run action first fails, second passes
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
     flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
     flexmock(module.command).should_receive('execute_hook')
     flexmock(module).should_receive('run_actions').and_raise(OSError).and_return([])
     flexmock(module).should_receive('log_error_records').and_return([flexmock()]).once()
-    config = {'location': {'repositories': ['foo']}, 'storage': {'retries': 1}}
+    config = {'repositories': [{'path': 'foo'}], 'retries': 1}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
     results = list(module.run_configuration('test.yaml', config, arguments))
     assert results == []
 
 
 def test_run_configuration_retries_hard_error():
     # Run action fails twice
@@ -225,17 +238,18 @@
         'foo: Error running actions for repository',
         OSError,
         levelno=logging.WARNING,
         log_command_error_output=True,
     ).and_return([flexmock()])
     error_logs = [flexmock()]
     flexmock(module).should_receive('log_error_records').with_args(
-        'foo: Error running actions for repository', OSError,
+        'foo: Error running actions for repository',
+        OSError,
     ).and_return(error_logs)
-    config = {'location': {'repositories': ['foo']}, 'storage': {'retries': 1}}
+    config = {'repositories': [{'path': 'foo'}], 'retries': 1}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
     results = list(module.run_configuration('test.yaml', config, arguments))
     assert results == error_logs
 
 
 def test_run_configuration_repos_ordered():
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
@@ -245,21 +259,21 @@
     expected_results = [flexmock(), flexmock()]
     flexmock(module).should_receive('log_error_records').with_args(
         'foo: Error running actions for repository', OSError
     ).and_return(expected_results[:1]).ordered()
     flexmock(module).should_receive('log_error_records').with_args(
         'bar: Error running actions for repository', OSError
     ).and_return(expected_results[1:]).ordered()
-    config = {'location': {'repositories': ['foo', 'bar']}}
+    config = {'repositories': [{'path': 'foo'}, {'path': 'bar'}]}
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
     results = list(module.run_configuration('test.yaml', config, arguments))
     assert results == expected_results
 
 
-def test_run_configuration_retries_round_robbin():
+def test_run_configuration_retries_round_robin():
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
     flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
     flexmock(module.command).should_receive('execute_hook')
     flexmock(module).should_receive('run_actions').and_raise(OSError).times(4)
     flexmock(module).should_receive('log_error_records').with_args(
         'foo: Error running actions for repository',
         OSError,
@@ -276,15 +290,18 @@
     flexmock(module).should_receive('log_error_records').with_args(
         'foo: Error running actions for repository', OSError
     ).and_return(foo_error_logs).ordered()
     bar_error_logs = [flexmock()]
     flexmock(module).should_receive('log_error_records').with_args(
         'bar: Error running actions for repository', OSError
     ).and_return(bar_error_logs).ordered()
-    config = {'location': {'repositories': ['foo', 'bar']}, 'storage': {'retries': 1}}
+    config = {
+        'repositories': [{'path': 'foo'}, {'path': 'bar'}],
+        'retries': 1,
+    }
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
     results = list(module.run_configuration('test.yaml', config, arguments))
     assert results == foo_error_logs + bar_error_logs
 
 
 def test_run_configuration_retries_one_passes():
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
@@ -305,15 +322,18 @@
         levelno=logging.WARNING,
         log_command_error_output=True,
     ).and_return(flexmock()).ordered()
     error_logs = [flexmock()]
     flexmock(module).should_receive('log_error_records').with_args(
         'bar: Error running actions for repository', OSError
     ).and_return(error_logs).ordered()
-    config = {'location': {'repositories': ['foo', 'bar']}, 'storage': {'retries': 1}}
+    config = {
+        'repositories': [{'path': 'foo'}, {'path': 'bar'}],
+        'retries': 1,
+    }
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
     results = list(module.run_configuration('test.yaml', config, arguments))
     assert results == error_logs
 
 
 def test_run_configuration_retry_wait():
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
@@ -344,15 +364,19 @@
     ).and_return([flexmock()]).ordered()
 
     flexmock(time).should_receive('sleep').with_args(30).and_return().ordered()
     error_logs = [flexmock()]
     flexmock(module).should_receive('log_error_records').with_args(
         'foo: Error running actions for repository', OSError
     ).and_return(error_logs).ordered()
-    config = {'location': {'repositories': ['foo']}, 'storage': {'retries': 3, 'retry_wait': 10}}
+    config = {
+        'repositories': [{'path': 'foo'}],
+        'retries': 3,
+        'retry_wait': 10,
+    }
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
     results = list(module.run_configuration('test.yaml', config, arguments))
     assert results == error_logs
 
 
 def test_run_configuration_retries_timeout_multiple_repos():
     flexmock(module).should_receive('verbosity_to_log_level').and_return(logging.INFO)
@@ -380,431 +404,391 @@
     # Sleep before retrying bar (and failing)
     flexmock(time).should_receive('sleep').with_args(10).and_return().ordered()
     error_logs = [flexmock()]
     flexmock(module).should_receive('log_error_records').with_args(
         'bar: Error running actions for repository', OSError
     ).and_return(error_logs).ordered()
     config = {
-        'location': {'repositories': ['foo', 'bar']},
-        'storage': {'retries': 1, 'retry_wait': 10},
+        'repositories': [{'path': 'foo'}, {'path': 'bar'}],
+        'retries': 1,
+        'retry_wait': 10,
     }
     arguments = {'global': flexmock(monitoring_verbosity=1, dry_run=False), 'create': flexmock()}
     results = list(module.run_configuration('test.yaml', config, arguments))
     assert results == error_logs
 
 
 def test_run_actions_runs_rcreate():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(borgmatic.actions.rcreate).should_receive('run_rcreate').once()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'rcreate': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'rcreate': flexmock()},
+            config_filename=flexmock(),
+            config={'repositories': []},
+            local_path=flexmock(),
+            remote_path=flexmock(),
+            local_borg_version=flexmock(),
+            repository={'path': 'repo'},
+        )
+    )
+
+
+def test_run_actions_adds_log_file_to_hook_context():
+    flexmock(module).should_receive('add_custom_log_levels')
+    flexmock(module.command).should_receive('execute_hook')
+    expected = flexmock()
+    flexmock(borgmatic.actions.create).should_receive('run_create').with_args(
+        config_filename=object,
+        repository={'path': 'repo'},
+        config={'repositories': []},
+        hook_context={'repository': 'repo', 'repositories': '', 'log_file': 'foo'},
+        local_borg_version=object,
+        create_arguments=object,
+        global_arguments=object,
+        dry_run_label='',
+        local_path=object,
+        remote_path=object,
+    ).once().and_return(expected)
+
+    result = tuple(
+        module.run_actions(
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'create': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
+    assert result == (expected,)
 
 
 def test_run_actions_runs_transfer():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(borgmatic.actions.transfer).should_receive('run_transfer').once()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'transfer': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'transfer': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_run_actions_runs_create():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     expected = flexmock()
     flexmock(borgmatic.actions.create).should_receive('run_create').and_yield(expected).once()
 
     result = tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'create': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'create': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
     assert result == (expected,)
 
 
 def test_run_actions_runs_prune():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(borgmatic.actions.prune).should_receive('run_prune').once()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'prune': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'prune': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_run_actions_runs_compact():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(borgmatic.actions.compact).should_receive('run_compact').once()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'compact': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'compact': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_run_actions_runs_check_when_repository_enabled_for_checks():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(module.checks).should_receive('repository_enabled_for_checks').and_return(True)
     flexmock(borgmatic.actions.check).should_receive('run_check').once()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'check': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'check': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_run_actions_skips_check_when_repository_not_enabled_for_checks():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(module.checks).should_receive('repository_enabled_for_checks').and_return(False)
     flexmock(borgmatic.actions.check).should_receive('run_check').never()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'check': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'check': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_run_actions_runs_extract():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(borgmatic.actions.extract).should_receive('run_extract').once()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'extract': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'extract': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_run_actions_runs_export_tar():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(borgmatic.actions.export_tar).should_receive('run_export_tar').once()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'export-tar': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'export-tar': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_run_actions_runs_mount():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(borgmatic.actions.mount).should_receive('run_mount').once()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'mount': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'mount': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_run_actions_runs_restore():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(borgmatic.actions.restore).should_receive('run_restore').once()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'restore': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'restore': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_run_actions_runs_rlist():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     expected = flexmock()
     flexmock(borgmatic.actions.rlist).should_receive('run_rlist').and_yield(expected).once()
 
     result = tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'rlist': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'rlist': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
     assert result == (expected,)
 
 
 def test_run_actions_runs_list():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     expected = flexmock()
     flexmock(borgmatic.actions.list).should_receive('run_list').and_yield(expected).once()
 
     result = tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'list': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'list': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
     assert result == (expected,)
 
 
 def test_run_actions_runs_rinfo():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     expected = flexmock()
     flexmock(borgmatic.actions.rinfo).should_receive('run_rinfo').and_yield(expected).once()
 
     result = tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'rinfo': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'rinfo': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
     assert result == (expected,)
 
 
 def test_run_actions_runs_info():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     expected = flexmock()
     flexmock(borgmatic.actions.info).should_receive('run_info').and_yield(expected).once()
 
     result = tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'info': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'info': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
     assert result == (expected,)
 
 
 def test_run_actions_runs_break_lock():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(borgmatic.actions.break_lock).should_receive('run_break_lock').once()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'break-lock': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'break-lock': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_run_actions_runs_borg():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(borgmatic.actions.borg).should_receive('run_borg').once()
 
     tuple(
         module.run_actions(
-            arguments={'global': flexmock(dry_run=False), 'borg': flexmock()},
+            arguments={'global': flexmock(dry_run=False, log_file='foo'), 'borg': flexmock()},
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_run_actions_runs_multiple_actions_in_argument_order():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.command).should_receive('execute_hook')
     flexmock(borgmatic.actions.borg).should_receive('run_borg').once().ordered()
     flexmock(borgmatic.actions.restore).should_receive('run_restore').once().ordered()
 
     tuple(
         module.run_actions(
             arguments={
-                'global': flexmock(dry_run=False),
+                'global': flexmock(dry_run=False, log_file='foo'),
                 'borg': flexmock(),
                 'restore': flexmock(),
             },
             config_filename=flexmock(),
-            location={'repositories': []},
-            storage=flexmock(),
-            retention=flexmock(),
-            consistency=flexmock(),
-            hooks={},
+            config={'repositories': []},
             local_path=flexmock(),
             remote_path=flexmock(),
             local_borg_version=flexmock(),
-            repository_path='repo',
+            repository={'path': 'repo'},
         )
     )
 
 
 def test_load_configurations_collects_parsed_configurations_and_logs():
     configuration = flexmock()
     other_configuration = flexmock()
@@ -813,33 +797,33 @@
     flexmock(module.validate).should_receive('parse_configuration').and_return(
         configuration, test_expected_logs
     ).and_return(other_configuration, other_expected_logs)
 
     configs, logs = tuple(module.load_configurations(('test.yaml', 'other.yaml')))
 
     assert configs == {'test.yaml': configuration, 'other.yaml': other_configuration}
-    assert logs == test_expected_logs + other_expected_logs
+    assert set(logs) >= set(test_expected_logs + other_expected_logs)
 
 
 def test_load_configurations_logs_warning_for_permission_error():
     flexmock(module.validate).should_receive('parse_configuration').and_raise(PermissionError)
 
     configs, logs = tuple(module.load_configurations(('test.yaml',)))
 
     assert configs == {}
-    assert {log.levelno for log in logs} == {logging.WARNING}
+    assert max(log.levelno for log in logs) == logging.WARNING
 
 
 def test_load_configurations_logs_critical_for_parse_error():
     flexmock(module.validate).should_receive('parse_configuration').and_raise(ValueError)
 
     configs, logs = tuple(module.load_configurations(('test.yaml',)))
 
     assert configs == {}
-    assert {log.levelno for log in logs} == {logging.CRITICAL}
+    assert max(log.levelno for log in logs) == logging.CRITICAL
 
 
 def test_log_record_does_not_raise():
     module.log_record(levelno=1, foo='bar', baz='quux')
 
 
 def test_log_record_with_suppress_does_not_raise():
@@ -850,15 +834,27 @@
     flexmock(module).should_receive('log_record').replace_with(dict)
 
     logs = tuple(module.log_error_records('Error'))
 
     assert {log['levelno'] for log in logs} == {logging.CRITICAL}
 
 
-def test_log_error_records_generates_output_logs_for_called_process_error():
+def test_log_error_records_generates_output_logs_for_called_process_error_with_bytes_ouput():
+    flexmock(module).should_receive('log_record').replace_with(dict)
+    flexmock(module.logger).should_receive('getEffectiveLevel').and_return(logging.WARNING)
+
+    logs = tuple(
+        module.log_error_records('Error', subprocess.CalledProcessError(1, 'ls', b'error output'))
+    )
+
+    assert {log['levelno'] for log in logs} == {logging.CRITICAL}
+    assert any(log for log in logs if 'error output' in str(log))
+
+
+def test_log_error_records_generates_output_logs_for_called_process_error_with_string_ouput():
     flexmock(module).should_receive('log_record').replace_with(dict)
     flexmock(module.logger).should_receive('getEffectiveLevel').and_return(logging.WARNING)
 
     logs = tuple(
         module.log_error_records('Error', subprocess.CalledProcessError(1, 'ls', 'error output'))
     )
 
@@ -887,23 +883,153 @@
 
     logs = tuple(module.log_error_records('Error', KeyError()))
 
     assert logs == ()
 
 
 def test_get_local_path_uses_configuration_value():
-    assert module.get_local_path({'test.yaml': {'location': {'local_path': 'borg1'}}}) == 'borg1'
+    assert module.get_local_path({'test.yaml': {'local_path': 'borg1'}}) == 'borg1'
 
 
-def test_get_local_path_without_location_defaults_to_borg():
+def test_get_local_path_without_local_path_defaults_to_borg():
     assert module.get_local_path({'test.yaml': {}}) == 'borg'
 
 
-def test_get_local_path_without_local_path_defaults_to_borg():
-    assert module.get_local_path({'test.yaml': {'location': {}}}) == 'borg'
+def test_collect_highlander_action_summary_logs_info_for_success_with_bootstrap():
+    flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
+    flexmock(module.borgmatic.actions.config.bootstrap).should_receive('run_bootstrap')
+    arguments = {
+        'bootstrap': flexmock(repository='repo'),
+        'global': flexmock(dry_run=False),
+    }
+
+    logs = tuple(
+        module.collect_highlander_action_summary_logs(
+            {'test.yaml': {}}, arguments=arguments, configuration_parse_errors=False
+        )
+    )
+    assert {log.levelno for log in logs} == {logging.ANSWER}
+
+
+def test_collect_highlander_action_summary_logs_error_on_bootstrap_failure():
+    flexmock(module.borg_version).should_receive('local_borg_version').and_return(flexmock())
+    flexmock(module.borgmatic.actions.config.bootstrap).should_receive('run_bootstrap').and_raise(
+        ValueError
+    )
+    arguments = {
+        'bootstrap': flexmock(repository='repo'),
+        'global': flexmock(dry_run=False),
+    }
+
+    logs = tuple(
+        module.collect_highlander_action_summary_logs(
+            {'test.yaml': {}}, arguments=arguments, configuration_parse_errors=False
+        )
+    )
+
+    assert {log.levelno for log in logs} == {logging.CRITICAL}
+
+
+def test_collect_highlander_action_summary_logs_error_on_bootstrap_local_borg_version_failure():
+    flexmock(module.borg_version).should_receive('local_borg_version').and_raise(ValueError)
+    flexmock(module.borgmatic.actions.config.bootstrap).should_receive('run_bootstrap').never()
+    arguments = {
+        'bootstrap': flexmock(repository='repo'),
+        'global': flexmock(dry_run=False),
+    }
+
+    logs = tuple(
+        module.collect_highlander_action_summary_logs(
+            {'test.yaml': {}}, arguments=arguments, configuration_parse_errors=False
+        )
+    )
+
+    assert {log.levelno for log in logs} == {logging.CRITICAL}
+
+
+def test_collect_highlander_action_summary_logs_info_for_success_with_generate():
+    flexmock(module.borgmatic.actions.config.generate).should_receive('run_generate')
+    arguments = {
+        'generate': flexmock(destination='test.yaml'),
+        'global': flexmock(dry_run=False),
+    }
+
+    logs = tuple(
+        module.collect_highlander_action_summary_logs(
+            {'test.yaml': {}}, arguments=arguments, configuration_parse_errors=False
+        )
+    )
+    assert {log.levelno for log in logs} == {logging.ANSWER}
+
+
+def test_collect_highlander_action_summary_logs_error_on_generate_failure():
+    flexmock(module.borgmatic.actions.config.generate).should_receive('run_generate').and_raise(
+        ValueError
+    )
+    arguments = {
+        'generate': flexmock(destination='test.yaml'),
+        'global': flexmock(dry_run=False),
+    }
+
+    logs = tuple(
+        module.collect_highlander_action_summary_logs(
+            {'test.yaml': {}}, arguments=arguments, configuration_parse_errors=False
+        )
+    )
+
+    assert {log.levelno for log in logs} == {logging.CRITICAL}
+
+
+def test_collect_highlander_action_summary_logs_info_for_success_with_validate():
+    flexmock(module.borgmatic.actions.config.validate).should_receive('run_validate')
+    arguments = {
+        'validate': flexmock(),
+        'global': flexmock(dry_run=False),
+    }
+
+    logs = tuple(
+        module.collect_highlander_action_summary_logs(
+            {'test.yaml': {}}, arguments=arguments, configuration_parse_errors=False
+        )
+    )
+    assert {log.levelno for log in logs} == {logging.ANSWER}
+
+
+def test_collect_highlander_action_summary_logs_error_on_validate_parse_failure():
+    flexmock(module.borgmatic.actions.config.validate).should_receive('run_validate')
+    arguments = {
+        'validate': flexmock(),
+        'global': flexmock(dry_run=False),
+    }
+
+    logs = tuple(
+        module.collect_highlander_action_summary_logs(
+            {'test.yaml': {}}, arguments=arguments, configuration_parse_errors=True
+        )
+    )
+
+    assert {log.levelno for log in logs} == {logging.CRITICAL}
+
+
+def test_collect_highlander_action_summary_logs_error_on_run_validate_failure():
+    flexmock(module.borgmatic.actions.config.validate).should_receive('run_validate').and_raise(
+        ValueError
+    )
+    arguments = {
+        'validate': flexmock(),
+        'global': flexmock(dry_run=False),
+    }
+
+    logs = tuple(
+        module.collect_highlander_action_summary_logs(
+            {'test.yaml': {}}, arguments=arguments, configuration_parse_errors=False
+        )
+    )
+
+    assert {log.levelno for log in logs} == {logging.CRITICAL}
 
 
 def test_collect_configuration_run_summary_logs_info_for_success():
     flexmock(module.command).should_receive('execute_hook').never()
     flexmock(module.validate).should_receive('guard_configuration_contains_repository')
     flexmock(module).should_receive('run_configuration').and_return([])
     arguments = {}
```

### Comparing `borgmatic-1.7.9/tests/unit/config/test_checks.py` & `borgmatic-1.8.0/tests/unit/config/test_checks.py`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/tests/unit/config/test_collect.py` & `borgmatic-1.8.0/tests/unit/config/test_collect.py`

 * *Files 10% similar despite different names*

```diff
@@ -25,71 +25,65 @@
     flexmock(module.os, environ={'HOME': '/home/user'})
 
     config_paths = module.get_default_config_paths(expand_home=False)
 
     assert '$HOME/.config/borgmatic/config.yaml' in config_paths
 
 
-def test_collect_config_filenames_collects_given_files():
-    config_paths = ('config.yaml', 'other.yaml')
-    flexmock(module.os.path).should_receive('isdir').and_return(False)
-
-    config_filenames = tuple(module.collect_config_filenames(config_paths))
-
-    assert config_filenames == config_paths
-
-
 def test_collect_config_filenames_collects_yml_file_endings():
     config_paths = ('config.yaml', '/etc/borgmatic.d')
     mock_path = flexmock(module.os.path)
     mock_path.should_receive('exists').and_return(True)
     mock_path.should_receive('isdir').with_args('config.yaml').and_return(False)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d').and_return(True)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d/foo.yml').and_return(False)
+    mock_path.should_receive('abspath').replace_with(lambda path: module.os.path.join('/', path))
     flexmock(module.os).should_receive('access').and_return(True)
     flexmock(module.os).should_receive('listdir')
     flexmock(sys.modules['builtins']).should_receive('sorted').and_return(['foo.yml'])
 
     config_filenames = tuple(module.collect_config_filenames(config_paths))
 
-    assert config_filenames == ('config.yaml', '/etc/borgmatic.d/foo.yml')
+    assert config_filenames == ('/config.yaml', '/etc/borgmatic.d/foo.yml')
 
 
 def test_collect_config_filenames_collects_files_from_given_directories_and_ignores_sub_directories():
     config_paths = ('config.yaml', '/etc/borgmatic.d')
     mock_path = flexmock(module.os.path)
     mock_path.should_receive('exists').and_return(True)
     mock_path.should_receive('isdir').with_args('config.yaml').and_return(False)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d').and_return(True)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d/foo.yaml').and_return(False)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d/bar').and_return(True)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d/baz.yaml').and_return(False)
+    mock_path.should_receive('abspath').replace_with(lambda path: module.os.path.join('/', path))
     flexmock(module.os).should_receive('access').and_return(True)
     flexmock(module.os).should_receive('listdir')
     flexmock(sys.modules['builtins']).should_receive('sorted').and_return(
         ['foo.yaml', 'bar', 'baz.yaml']
     )
 
     config_filenames = tuple(module.collect_config_filenames(config_paths))
 
     assert config_filenames == (
-        'config.yaml',
+        '/config.yaml',
         '/etc/borgmatic.d/foo.yaml',
         '/etc/borgmatic.d/baz.yaml',
     )
 
 
 def test_collect_config_filenames_collects_files_from_given_directories_and_ignores_non_yaml_filenames():
     config_paths = ('/etc/borgmatic.d',)
     mock_path = flexmock(module.os.path)
     mock_path.should_receive('exists').and_return(True)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d').and_return(True)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d/foo.yaml').and_return(False)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d/bar.yaml~').and_return(False)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d/baz.txt').and_return(False)
+    mock_path.should_receive('abspath').replace_with(lambda path: module.os.path.join('/', path))
     flexmock(module.os).should_receive('access').and_return(True)
     flexmock(module.os).should_receive('listdir')
     flexmock(sys.modules['builtins']).should_receive('sorted').and_return(
         ['foo.yaml', 'bar.yaml~', 'baz.txt']
     )
 
     config_filenames = tuple(module.collect_config_filenames(config_paths))
@@ -99,66 +93,71 @@
 
 def test_collect_config_filenames_skips_permission_denied_directories():
     config_paths = ('config.yaml', '/etc/borgmatic.d')
     mock_path = flexmock(module.os.path)
     mock_path.should_receive('exists').and_return(True)
     mock_path.should_receive('isdir').with_args('config.yaml').and_return(False)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d').and_return(True)
+    mock_path.should_receive('abspath').replace_with(lambda path: module.os.path.join('/', path))
     flexmock(module.os).should_receive('access').and_return(False)
     flexmock(module.os).should_receive('listdir')
     flexmock(sys.modules['builtins']).should_receive('sorted').and_return(['config.yaml'])
 
     config_filenames = tuple(module.collect_config_filenames(config_paths))
 
-    assert config_filenames == ('config.yaml',)
+    assert config_filenames == ('/config.yaml',)
 
 
 def test_collect_config_filenames_skips_etc_borgmatic_config_dot_yaml_if_it_does_not_exist():
     config_paths = ('config.yaml', '/etc/borgmatic/config.yaml')
     mock_path = flexmock(module.os.path)
     mock_path.should_receive('exists').with_args('config.yaml').and_return(True)
     mock_path.should_receive('exists').with_args('/etc/borgmatic/config.yaml').and_return(False)
     mock_path.should_receive('isdir').with_args('config.yaml').and_return(False)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic/config.yaml').and_return(True)
+    mock_path.should_receive('abspath').replace_with(lambda path: module.os.path.join('/', path))
 
     config_filenames = tuple(module.collect_config_filenames(config_paths))
 
-    assert config_filenames == ('config.yaml',)
+    assert config_filenames == ('/config.yaml',)
 
 
 def test_collect_config_filenames_skips_etc_borgmatic_dot_d_if_it_does_not_exist():
     config_paths = ('config.yaml', '/etc/borgmatic.d')
     mock_path = flexmock(module.os.path)
     mock_path.should_receive('exists').with_args('config.yaml').and_return(True)
     mock_path.should_receive('exists').with_args('/etc/borgmatic.d').and_return(False)
     mock_path.should_receive('isdir').with_args('config.yaml').and_return(False)
     mock_path.should_receive('isdir').with_args('/etc/borgmatic.d').and_return(True)
+    mock_path.should_receive('abspath').replace_with(lambda path: module.os.path.join('/', path))
 
     config_filenames = tuple(module.collect_config_filenames(config_paths))
 
-    assert config_filenames == ('config.yaml',)
+    assert config_filenames == ('/config.yaml',)
 
 
 def test_collect_config_filenames_skips_non_canonical_etc_borgmatic_dot_d_if_it_does_not_exist():
     config_paths = ('config.yaml', '/etc/../etc/borgmatic.d')
     mock_path = flexmock(module.os.path)
     mock_path.should_receive('exists').with_args('config.yaml').and_return(True)
     mock_path.should_receive('exists').with_args('/etc/../etc/borgmatic.d').and_return(False)
     mock_path.should_receive('isdir').with_args('config.yaml').and_return(False)
     mock_path.should_receive('isdir').with_args('/etc/../etc/borgmatic.d').and_return(True)
+    mock_path.should_receive('abspath').replace_with(lambda path: module.os.path.join('/', path))
 
     config_filenames = tuple(module.collect_config_filenames(config_paths))
 
-    assert config_filenames == ('config.yaml',)
+    assert config_filenames == ('/config.yaml',)
 
 
 def test_collect_config_filenames_includes_other_directory_if_it_does_not_exist():
     config_paths = ('config.yaml', '/my/directory')
     mock_path = flexmock(module.os.path)
     mock_path.should_receive('exists').with_args('config.yaml').and_return(True)
     mock_path.should_receive('exists').with_args('/my/directory').and_return(False)
     mock_path.should_receive('isdir').with_args('config.yaml').and_return(False)
     mock_path.should_receive('isdir').with_args('/my/directory').and_return(True)
+    mock_path.should_receive('abspath').replace_with(lambda path: module.os.path.join('/', path))
 
     config_filenames = tuple(module.collect_config_filenames(config_paths))
 
-    assert config_filenames == config_paths
+    assert config_filenames == ('/config.yaml', '/my/directory')
```

### Comparing `borgmatic-1.7.9/tests/unit/config/test_environment.py` & `borgmatic-1.8.0/tests/unit/config/test_environment.py`

 * *Files 23% similar despite different names*

```diff
@@ -8,80 +8,80 @@
     config = {'key': 'Hello $MY_CUSTOM_VALUE'}
     module.resolve_env_variables(config)
     assert config == {'key': 'Hello $MY_CUSTOM_VALUE'}
 
 
 def test_env_braces(monkeypatch):
     monkeypatch.setenv('MY_CUSTOM_VALUE', 'foo')
-    config = {'key': 'Hello ${MY_CUSTOM_VALUE}'}
+    config = {'key': 'Hello ${MY_CUSTOM_VALUE}'}  # noqa: FS003
     module.resolve_env_variables(config)
     assert config == {'key': 'Hello foo'}
 
 
 def test_env_multi(monkeypatch):
     monkeypatch.setenv('MY_CUSTOM_VALUE', 'foo')
     monkeypatch.setenv('MY_CUSTOM_VALUE2', 'bar')
-    config = {'key': 'Hello ${MY_CUSTOM_VALUE}${MY_CUSTOM_VALUE2}'}
+    config = {'key': 'Hello ${MY_CUSTOM_VALUE}${MY_CUSTOM_VALUE2}'}  # noqa: FS003
     module.resolve_env_variables(config)
     assert config == {'key': 'Hello foobar'}
 
 
 def test_env_escape(monkeypatch):
     monkeypatch.setenv('MY_CUSTOM_VALUE', 'foo')
     monkeypatch.setenv('MY_CUSTOM_VALUE2', 'bar')
-    config = {'key': r'Hello ${MY_CUSTOM_VALUE} \${MY_CUSTOM_VALUE}'}
+    config = {'key': r'Hello ${MY_CUSTOM_VALUE} \${MY_CUSTOM_VALUE}'}  # noqa: FS003
     module.resolve_env_variables(config)
-    assert config == {'key': r'Hello foo ${MY_CUSTOM_VALUE}'}
+    assert config == {'key': r'Hello foo ${MY_CUSTOM_VALUE}'}  # noqa: FS003
 
 
 def test_env_default_value(monkeypatch):
     monkeypatch.delenv('MY_CUSTOM_VALUE', raising=False)
-    config = {'key': 'Hello ${MY_CUSTOM_VALUE:-bar}'}
+    config = {'key': 'Hello ${MY_CUSTOM_VALUE:-bar}'}  # noqa: FS003
     module.resolve_env_variables(config)
     assert config == {'key': 'Hello bar'}
 
 
 def test_env_unknown(monkeypatch):
     monkeypatch.delenv('MY_CUSTOM_VALUE', raising=False)
-    config = {'key': 'Hello ${MY_CUSTOM_VALUE}'}
+    config = {'key': 'Hello ${MY_CUSTOM_VALUE}'}  # noqa: FS003
     with pytest.raises(ValueError):
         module.resolve_env_variables(config)
 
 
 def test_env_full(monkeypatch):
     monkeypatch.setenv('MY_CUSTOM_VALUE', 'foo')
     monkeypatch.delenv('MY_CUSTOM_VALUE2', raising=False)
     config = {
         'key': 'Hello $MY_CUSTOM_VALUE is not resolved',
         'dict': {
             'key': 'value',
             'anotherdict': {
-                'key': 'My ${MY_CUSTOM_VALUE} here',
-                'other': '${MY_CUSTOM_VALUE}',
-                'escaped': r'\${MY_CUSTOM_VALUE}',
+                'key': 'My ${MY_CUSTOM_VALUE} here',  # noqa: FS003
+                'other': '${MY_CUSTOM_VALUE}',  # noqa: FS003
+                'escaped': r'\${MY_CUSTOM_VALUE}',  # noqa: FS003
                 'list': [
-                    '/home/${MY_CUSTOM_VALUE}/.local',
+                    '/home/${MY_CUSTOM_VALUE}/.local',  # noqa: FS003
                     '/var/log/',
-                    '/home/${MY_CUSTOM_VALUE2:-bar}/.config',
+                    '/home/${MY_CUSTOM_VALUE2:-bar}/.config',  # noqa: FS003
                 ],
             },
         },
         'list': [
-            '/home/${MY_CUSTOM_VALUE}/.local',
+            '/home/${MY_CUSTOM_VALUE}/.local',  # noqa: FS003
             '/var/log/',
-            '/home/${MY_CUSTOM_VALUE2-bar}/.config',
+            '/home/${MY_CUSTOM_VALUE2-bar}/.config',  # noqa: FS003
         ],
     }
     module.resolve_env_variables(config)
     assert config == {
         'key': 'Hello $MY_CUSTOM_VALUE is not resolved',
         'dict': {
             'key': 'value',
             'anotherdict': {
                 'key': 'My foo here',
                 'other': 'foo',
-                'escaped': '${MY_CUSTOM_VALUE}',
+                'escaped': '${MY_CUSTOM_VALUE}',  # noqa: FS003
                 'list': ['/home/foo/.local', '/var/log/', '/home/bar/.config'],
             },
         },
         'list': ['/home/foo/.local', '/var/log/', '/home/bar/.config'],
     }
```

### Comparing `borgmatic-1.7.9/tests/unit/config/test_generate.py` & `borgmatic-1.8.0/tests/unit/config/test_generate.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,53 +9,38 @@
 def test_schema_to_sample_configuration_generates_config_map_with_examples():
     flexmock(module.yaml.comments).should_receive('CommentedMap').replace_with(OrderedDict)
     flexmock(module).should_receive('add_comments_to_configuration_object')
     schema = {
         'type': 'object',
         'properties': OrderedDict(
             [
-                (
-                    'section1',
-                    {
-                        'type': 'object',
-                        'properties': {'field1': OrderedDict([('example', 'Example 1')])},
-                    },
-                ),
-                (
-                    'section2',
-                    {
-                        'type': 'object',
-                        'properties': OrderedDict(
-                            [
-                                ('field2', {'example': 'Example 2'}),
-                                ('field3', {'example': 'Example 3'}),
-                            ]
-                        ),
-                    },
-                ),
+                ('field1', {'example': 'Example 1'}),
+                ('field2', {'example': 'Example 2'}),
+                ('field3', {'example': 'Example 3'}),
             ]
         ),
     }
 
-    config = module._schema_to_sample_configuration(schema)
+    config = module.schema_to_sample_configuration(schema)
 
     assert config == OrderedDict(
         [
-            ('section1', OrderedDict([('field1', 'Example 1')])),
-            ('section2', OrderedDict([('field2', 'Example 2'), ('field3', 'Example 3')])),
+            ('field1', 'Example 1'),
+            ('field2', 'Example 2'),
+            ('field3', 'Example 3'),
         ]
     )
 
 
 def test_schema_to_sample_configuration_generates_config_sequence_of_strings_with_example():
     flexmock(module.yaml.comments).should_receive('CommentedSeq').replace_with(list)
     flexmock(module).should_receive('add_comments_to_configuration_sequence')
     schema = {'type': 'array', 'items': {'type': 'string'}, 'example': ['hi']}
 
-    config = module._schema_to_sample_configuration(schema)
+    config = module.schema_to_sample_configuration(schema)
 
     assert config == ['hi']
 
 
 def test_schema_to_sample_configuration_generates_config_sequence_of_maps_with_examples():
     flexmock(module.yaml.comments).should_receive('CommentedSeq').replace_with(list)
     flexmock(module).should_receive('add_comments_to_configuration_sequence')
@@ -66,24 +51,24 @@
             'type': 'object',
             'properties': OrderedDict(
                 [('field1', {'example': 'Example 1'}), ('field2', {'example': 'Example 2'})]
             ),
         },
     }
 
-    config = module._schema_to_sample_configuration(schema)
+    config = module.schema_to_sample_configuration(schema)
 
     assert config == [OrderedDict([('field1', 'Example 1'), ('field2', 'Example 2')])]
 
 
 def test_schema_to_sample_configuration_with_unsupported_schema_raises():
     schema = {'gobbledygook': [{'type': 'not-your'}]}
 
     with pytest.raises(ValueError):
-        module._schema_to_sample_configuration(schema)
+        module.schema_to_sample_configuration(schema)
 
 
 def test_merge_source_configuration_into_destination_inserts_map_fields():
     destination_config = {'foo': 'dest1', 'bar': 'dest2'}
     source_config = {'foo': 'source1', 'baz': 'source2'}
     flexmock(module).should_receive('remove_commented_out_sentinel')
     flexmock(module).should_receive('yaml.comments.CommentedSeq').replace_with(list)
```

### Comparing `borgmatic-1.7.9/tests/unit/config/test_override.py` & `borgmatic-1.8.0/tests/unit/config/test_override.py`

 * *Files 22% similar despite different names*

```diff
@@ -28,62 +28,84 @@
 
     assert config == {'key': 'value', 'other': 'other_value'}
 
 
 def test_set_values_with_multiple_keys_creates_hierarchy():
     config = {}
 
-    module.set_values(config, ('section', 'key'), 'value')
+    module.set_values(config, ('option', 'suboption'), 'value')
 
-    assert config == {'section': {'key': 'value'}}
+    assert config == {'option': {'suboption': 'value'}}
 
 
 def test_set_values_with_multiple_keys_updates_hierarchy():
-    config = {'section': {'other': 'other_value'}}
-    module.set_values(config, ('section', 'key'), 'value')
+    config = {'option': {'other': 'other_value'}}
+    module.set_values(config, ('option', 'key'), 'value')
 
-    assert config == {'section': {'key': 'value', 'other': 'other_value'}}
+    assert config == {'option': {'key': 'value', 'other': 'other_value'}}
+
+
+@pytest.mark.parametrize(
+    'key,expected_key',
+    (
+        (('foo', 'bar'), ('foo', 'bar')),
+        (('location', 'foo'), ('foo',)),
+        (('storage', 'foo'), ('foo',)),
+        (('retention', 'foo'), ('foo',)),
+        (('consistency', 'foo'), ('foo',)),
+        (('output', 'foo'), ('foo',)),
+        (('hooks', 'foo', 'bar'), ('foo', 'bar')),
+        (('foo', 'hooks'), ('foo', 'hooks')),
+    ),
+)
+def test_strip_section_names_passes_through_key_without_section_name(key, expected_key):
+    assert module.strip_section_names(key) == expected_key
 
 
 def test_parse_overrides_splits_keys_and_values():
+    flexmock(module).should_receive('strip_section_names').replace_with(lambda value: value)
     flexmock(module).should_receive('convert_value_type').replace_with(lambda value: value)
-    raw_overrides = ['section.my_option=value1', 'section.other_option=value2']
+    raw_overrides = ['option.my_option=value1', 'other_option=value2']
     expected_result = (
-        (('section', 'my_option'), 'value1'),
-        (('section', 'other_option'), 'value2'),
+        (('option', 'my_option'), 'value1'),
+        (('other_option'), 'value2'),
     )
 
     module.parse_overrides(raw_overrides) == expected_result
 
 
 def test_parse_overrides_allows_value_with_equal_sign():
+    flexmock(module).should_receive('strip_section_names').replace_with(lambda value: value)
     flexmock(module).should_receive('convert_value_type').replace_with(lambda value: value)
-    raw_overrides = ['section.option=this===value']
-    expected_result = ((('section', 'option'), 'this===value'),)
+    raw_overrides = ['option=this===value']
+    expected_result = ((('option',), 'this===value'),)
 
     module.parse_overrides(raw_overrides) == expected_result
 
 
 def test_parse_overrides_raises_on_missing_equal_sign():
+    flexmock(module).should_receive('strip_section_names').replace_with(lambda value: value)
     flexmock(module).should_receive('convert_value_type').replace_with(lambda value: value)
-    raw_overrides = ['section.option']
+    raw_overrides = ['option']
 
     with pytest.raises(ValueError):
         module.parse_overrides(raw_overrides)
 
 
 def test_parse_overrides_raises_on_invalid_override_value():
+    flexmock(module).should_receive('strip_section_names').replace_with(lambda value: value)
     flexmock(module).should_receive('convert_value_type').and_raise(ruamel.yaml.parser.ParserError)
-    raw_overrides = ['section.option=[in valid]']
+    raw_overrides = ['option=[in valid]']
 
     with pytest.raises(ValueError):
         module.parse_overrides(raw_overrides)
 
 
 def test_parse_overrides_allows_value_with_single_key():
+    flexmock(module).should_receive('strip_section_names').replace_with(lambda value: value)
     flexmock(module).should_receive('convert_value_type').replace_with(lambda value: value)
     raw_overrides = ['option=value']
     expected_result = ((('option',), 'value'),)
 
     module.parse_overrides(raw_overrides) == expected_result
```

### Comparing `borgmatic-1.7.9/tests/unit/hooks/test_command.py` & `borgmatic-1.8.0/tests/unit/hooks/test_command.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,35 +7,28 @@
 
 
 def test_interpolate_context_passes_through_command_without_variable():
     assert module.interpolate_context('test.yaml', 'pre-backup', 'ls', {'foo': 'bar'}) == 'ls'
 
 
 def test_interpolate_context_passes_through_command_with_unknown_variable():
-    assert (
-        module.interpolate_context('test.yaml', 'pre-backup', 'ls {baz}', {'foo': 'bar'})
-        == 'ls {baz}'
-    )
+    command = 'ls {baz}'  # noqa: FS003
+
+    assert module.interpolate_context('test.yaml', 'pre-backup', command, {'foo': 'bar'}) == command
 
 
 def test_interpolate_context_interpolates_variables():
+    command = 'ls {foo}{baz} {baz}'  # noqa: FS003
     context = {'foo': 'bar', 'baz': 'quux'}
 
     assert (
-        module.interpolate_context('test.yaml', 'pre-backup', 'ls {foo}{baz} {baz}', context)
-        == 'ls barquux quux'
+        module.interpolate_context('test.yaml', 'pre-backup', command, context) == 'ls barquux quux'
     )
 
 
-def test_interpolate_context_does_not_touch_unknown_variables():
-    context = {'foo': 'bar', 'baz': 'quux'}
-
-    assert module.interpolate_context('test.yaml', 'pre-backup', 'ls {wtf}', context) == 'ls {wtf}'
-
-
 def test_execute_hook_invokes_each_command():
     flexmock(module).should_receive('interpolate_context').replace_with(
         lambda config_file, hook_description, command, context: command
     )
     flexmock(module.execute).should_receive('execute_command').with_args(
         [':'], output_log_level=logging.WARNING, shell=True
     ).once()
```

### Comparing `borgmatic-1.7.9/tests/unit/hooks/test_cronhub.py` & `borgmatic-1.8.0/tests/unit/hooks/test_cronhub.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,14 +7,15 @@
     hook_config = {'ping_url': 'https://example.com/start/abcdef'}
     flexmock(module.requests).should_receive('get').with_args(
         'https://example.com/start/abcdef'
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -22,14 +23,15 @@
     hook_config = {'ping_url': 'https://example.com/ping/abcdef'}
     flexmock(module.requests).should_receive('get').with_args(
         'https://example.com/start/abcdef'
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -37,50 +39,62 @@
     hook_config = {'ping_url': 'https://example.com/start/abcdef'}
     flexmock(module.requests).should_receive('get').with_args(
         'https://example.com/finish/abcdef'
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         module.monitor.State.FINISH,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
 def test_ping_monitor_rewrites_ping_url_for_fail_state():
     hook_config = {'ping_url': 'https://example.com/start/abcdef'}
     flexmock(module.requests).should_receive('get').with_args(
         'https://example.com/fail/abcdef'
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
-        hook_config, 'config.yaml', module.monitor.State.FAIL, monitoring_log_level=1, dry_run=False
+        hook_config,
+        {},
+        'config.yaml',
+        module.monitor.State.FAIL,
+        monitoring_log_level=1,
+        dry_run=False,
     )
 
 
 def test_ping_monitor_dry_run_does_not_hit_ping_url():
     hook_config = {'ping_url': 'https://example.com'}
     flexmock(module.requests).should_receive('get').never()
 
     module.ping_monitor(
-        hook_config, 'config.yaml', module.monitor.State.START, monitoring_log_level=1, dry_run=True
+        hook_config,
+        {},
+        'config.yaml',
+        module.monitor.State.START,
+        monitoring_log_level=1,
+        dry_run=True,
     )
 
 
 def test_ping_monitor_with_connection_error_logs_warning():
     hook_config = {'ping_url': 'https://example.com/start/abcdef'}
     flexmock(module.requests).should_receive('get').and_raise(
         module.requests.exceptions.ConnectionError
     )
     flexmock(module.logger).should_receive('warning').once()
 
     module.ping_monitor(
         hook_config,
+        (),
         'config.yaml',
         module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -93,20 +107,27 @@
     flexmock(module.requests).should_receive('get').with_args(
         'https://example.com/start/abcdef'
     ).and_return(response)
     flexmock(module.logger).should_receive('warning').once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
-def test_ping_monitor_with_unsupported_monitoring_state():
+def test_ping_monitor_with_unsupported_monitoring_state_bails():
     hook_config = {'ping_url': 'https://example.com'}
     flexmock(module.requests).should_receive('get').never()
+
     module.ping_monitor(
-        hook_config, 'config.yaml', module.monitor.State.LOG, monitoring_log_level=1, dry_run=False,
+        hook_config,
+        {},
+        'config.yaml',
+        module.monitor.State.LOG,
+        monitoring_log_level=1,
+        dry_run=False,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/hooks/test_cronitor.py` & `borgmatic-1.8.0/tests/unit/hooks/test_cronitor.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,14 +7,15 @@
     hook_config = {'ping_url': 'https://example.com'}
     flexmock(module.requests).should_receive('get').with_args('https://example.com/run').and_return(
         flexmock(ok=True)
     )
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -22,50 +23,62 @@
     hook_config = {'ping_url': 'https://example.com'}
     flexmock(module.requests).should_receive('get').with_args(
         'https://example.com/complete'
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         module.monitor.State.FINISH,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
 def test_ping_monitor_hits_ping_url_for_fail_state():
     hook_config = {'ping_url': 'https://example.com'}
     flexmock(module.requests).should_receive('get').with_args(
         'https://example.com/fail'
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
-        hook_config, 'config.yaml', module.monitor.State.FAIL, monitoring_log_level=1, dry_run=False
+        hook_config,
+        {},
+        'config.yaml',
+        module.monitor.State.FAIL,
+        monitoring_log_level=1,
+        dry_run=False,
     )
 
 
 def test_ping_monitor_dry_run_does_not_hit_ping_url():
     hook_config = {'ping_url': 'https://example.com'}
     flexmock(module.requests).should_receive('get').never()
 
     module.ping_monitor(
-        hook_config, 'config.yaml', module.monitor.State.START, monitoring_log_level=1, dry_run=True
+        hook_config,
+        {},
+        'config.yaml',
+        module.monitor.State.START,
+        monitoring_log_level=1,
+        dry_run=True,
     )
 
 
 def test_ping_monitor_with_connection_error_logs_warning():
     hook_config = {'ping_url': 'https://example.com'}
     flexmock(module.requests).should_receive('get').and_raise(
         module.requests.exceptions.ConnectionError
     )
     flexmock(module.logger).should_receive('warning').once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -78,20 +91,27 @@
     flexmock(module.requests).should_receive('get').with_args('https://example.com/run').and_return(
         response
     )
     flexmock(module.logger).should_receive('warning').once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
-def test_ping_monitor_with_unsupported_monitoring_state():
+def test_ping_monitor_with_unsupported_monitoring_state_bails():
     hook_config = {'ping_url': 'https://example.com'}
     flexmock(module.requests).should_receive('get').never()
+
     module.ping_monitor(
-        hook_config, 'config.yaml', module.monitor.State.LOG, monitoring_log_level=1, dry_run=False,
+        hook_config,
+        {},
+        'config.yaml',
+        module.monitor.State.LOG,
+        monitoring_log_level=1,
+        dry_run=False,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/hooks/test_dispatch.py` & `borgmatic-1.8.0/tests/unit/hooks/test_dispatch.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,110 +2,116 @@
 
 import pytest
 from flexmock import flexmock
 
 from borgmatic.hooks import dispatch as module
 
 
-def hook_function(config, log_prefix, thing, value):
+def hook_function(hook_config, config, log_prefix, thing, value):
     '''
     This test function gets mocked out below.
     '''
     pass
 
 
 def test_call_hook_invokes_module_function_with_arguments_and_returns_value():
-    hooks = {'super_hook': flexmock(), 'other_hook': flexmock()}
+    config = {'super_hook': flexmock(), 'other_hook': flexmock()}
     expected_return_value = flexmock()
     test_module = sys.modules[__name__]
     flexmock(module).HOOK_NAME_TO_MODULE = {'super_hook': test_module}
     flexmock(test_module).should_receive('hook_function').with_args(
-        hooks['super_hook'], 'prefix', 55, value=66
+        config['super_hook'], config, 'prefix', 55, value=66
     ).and_return(expected_return_value).once()
 
-    return_value = module.call_hook('hook_function', hooks, 'prefix', 'super_hook', 55, value=66)
+    return_value = module.call_hook('hook_function', config, 'prefix', 'super_hook', 55, value=66)
 
     assert return_value == expected_return_value
 
 
 def test_call_hook_without_hook_config_invokes_module_function_with_arguments_and_returns_value():
-    hooks = {'other_hook': flexmock()}
+    config = {'other_hook': flexmock()}
     expected_return_value = flexmock()
     test_module = sys.modules[__name__]
     flexmock(module).HOOK_NAME_TO_MODULE = {'super_hook': test_module}
     flexmock(test_module).should_receive('hook_function').with_args(
-        {}, 'prefix', 55, value=66
+        {}, config, 'prefix', 55, value=66
     ).and_return(expected_return_value).once()
 
-    return_value = module.call_hook('hook_function', hooks, 'prefix', 'super_hook', 55, value=66)
+    return_value = module.call_hook('hook_function', config, 'prefix', 'super_hook', 55, value=66)
 
     assert return_value == expected_return_value
 
 
 def test_call_hook_without_corresponding_module_raises():
-    hooks = {'super_hook': flexmock(), 'other_hook': flexmock()}
+    config = {'super_hook': flexmock(), 'other_hook': flexmock()}
     test_module = sys.modules[__name__]
     flexmock(module).HOOK_NAME_TO_MODULE = {'other_hook': test_module}
     flexmock(test_module).should_receive('hook_function').never()
 
     with pytest.raises(ValueError):
-        module.call_hook('hook_function', hooks, 'prefix', 'super_hook', 55, value=66)
+        module.call_hook('hook_function', config, 'prefix', 'super_hook', 55, value=66)
 
 
 def test_call_hooks_calls_each_hook_and_collects_return_values():
-    hooks = {'super_hook': flexmock(), 'other_hook': flexmock()}
+    config = {'super_hook': flexmock(), 'other_hook': flexmock()}
     expected_return_values = {'super_hook': flexmock(), 'other_hook': flexmock()}
     flexmock(module).should_receive('call_hook').and_return(
         expected_return_values['super_hook']
     ).and_return(expected_return_values['other_hook'])
 
-    return_values = module.call_hooks('do_stuff', hooks, 'prefix', ('super_hook', 'other_hook'), 55)
+    return_values = module.call_hooks(
+        'do_stuff', config, 'prefix', ('super_hook', 'other_hook'), 55
+    )
 
     assert return_values == expected_return_values
 
 
 def test_call_hooks_calls_skips_return_values_for_missing_hooks():
-    hooks = {'super_hook': flexmock()}
+    config = {'super_hook': flexmock()}
     expected_return_values = {'super_hook': flexmock()}
     flexmock(module).should_receive('call_hook').and_return(expected_return_values['super_hook'])
 
-    return_values = module.call_hooks('do_stuff', hooks, 'prefix', ('super_hook', 'other_hook'), 55)
+    return_values = module.call_hooks(
+        'do_stuff', config, 'prefix', ('super_hook', 'other_hook'), 55
+    )
 
     assert return_values == expected_return_values
 
 
 def test_call_hooks_calls_skips_return_values_for_null_hooks():
-    hooks = {'super_hook': flexmock(), 'other_hook': None}
+    config = {'super_hook': flexmock(), 'other_hook': None}
     expected_return_values = {'super_hook': flexmock()}
     flexmock(module).should_receive('call_hook').and_return(expected_return_values['super_hook'])
 
-    return_values = module.call_hooks('do_stuff', hooks, 'prefix', ('super_hook', 'other_hook'), 55)
+    return_values = module.call_hooks(
+        'do_stuff', config, 'prefix', ('super_hook', 'other_hook'), 55
+    )
 
     assert return_values == expected_return_values
 
 
 def test_call_hooks_even_if_unconfigured_calls_each_hook_and_collects_return_values():
-    hooks = {'super_hook': flexmock(), 'other_hook': flexmock()}
+    config = {'super_hook': flexmock(), 'other_hook': flexmock()}
     expected_return_values = {'super_hook': flexmock(), 'other_hook': flexmock()}
     flexmock(module).should_receive('call_hook').and_return(
         expected_return_values['super_hook']
     ).and_return(expected_return_values['other_hook'])
 
     return_values = module.call_hooks_even_if_unconfigured(
-        'do_stuff', hooks, 'prefix', ('super_hook', 'other_hook'), 55
+        'do_stuff', config, 'prefix', ('super_hook', 'other_hook'), 55
     )
 
     assert return_values == expected_return_values
 
 
 def test_call_hooks_even_if_unconfigured_calls_each_hook_configured_or_not_and_collects_return_values():
-    hooks = {'other_hook': flexmock()}
+    config = {'other_hook': flexmock()}
     expected_return_values = {'super_hook': flexmock(), 'other_hook': flexmock()}
     flexmock(module).should_receive('call_hook').and_return(
         expected_return_values['super_hook']
     ).and_return(expected_return_values['other_hook'])
 
     return_values = module.call_hooks_even_if_unconfigured(
-        'do_stuff', hooks, 'prefix', ('super_hook', 'other_hook'), 55
+        'do_stuff', config, 'prefix', ('super_hook', 'other_hook'), 55
     )
 
     assert return_values == expected_return_values
```

### Comparing `borgmatic-1.7.9/tests/unit/hooks/test_dump.py` & `borgmatic-1.8.0/tests/unit/hooks/test_dump.py`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/tests/unit/hooks/test_healthchecks.py` & `borgmatic-1.8.0/tests/unit/hooks/test_healthchecks.py`

 * *Files 3% similar despite different names*

```diff
@@ -82,71 +82,72 @@
 
     mock_logger()
     flexmock(module).should_receive('Forgetful_buffering_handler').with_args(
         ping_body_limit - len(module.PAYLOAD_TRUNCATION_INDICATOR), monitoring_log_level
     ).once()
 
     module.initialize_monitor(
-        {'ping_body_limit': ping_body_limit}, 'test.yaml', monitoring_log_level, dry_run=False
+        {'ping_body_limit': ping_body_limit}, {}, 'test.yaml', monitoring_log_level, dry_run=False
     )
 
 
 def test_initialize_monitor_creates_log_handler_with_default_ping_body_limit():
     monitoring_log_level = 1
 
     mock_logger()
     flexmock(module).should_receive('Forgetful_buffering_handler').with_args(
         module.DEFAULT_PING_BODY_LIMIT_BYTES - len(module.PAYLOAD_TRUNCATION_INDICATOR),
         monitoring_log_level,
     ).once()
 
-    module.initialize_monitor({}, 'test.yaml', monitoring_log_level, dry_run=False)
+    module.initialize_monitor({}, {}, 'test.yaml', monitoring_log_level, dry_run=False)
 
 
 def test_initialize_monitor_creates_log_handler_with_zero_ping_body_limit():
     ping_body_limit = 0
     monitoring_log_level = 1
 
     mock_logger()
     flexmock(module).should_receive('Forgetful_buffering_handler').with_args(
         ping_body_limit, monitoring_log_level
     ).once()
 
     module.initialize_monitor(
-        {'ping_body_limit': ping_body_limit}, 'test.yaml', monitoring_log_level, dry_run=False
+        {'ping_body_limit': ping_body_limit}, {}, 'test.yaml', monitoring_log_level, dry_run=False
     )
 
 
 def test_initialize_monitor_creates_log_handler_when_send_logs_true():
     mock_logger()
     flexmock(module).should_receive('Forgetful_buffering_handler').once()
 
     module.initialize_monitor(
-        {'send_logs': True}, 'test.yaml', monitoring_log_level=1, dry_run=False
+        {'send_logs': True}, {}, 'test.yaml', monitoring_log_level=1, dry_run=False
     )
 
 
 def test_initialize_monitor_bails_when_send_logs_false():
     mock_logger()
     flexmock(module).should_receive('Forgetful_buffering_handler').never()
 
     module.initialize_monitor(
-        {'send_logs': False}, 'test.yaml', monitoring_log_level=1, dry_run=False
+        {'send_logs': False}, {}, 'test.yaml', monitoring_log_level=1, dry_run=False
     )
 
 
 def test_ping_monitor_hits_ping_url_for_start_state():
     flexmock(module).should_receive('Forgetful_buffering_handler')
     hook_config = {'ping_url': 'https://example.com'}
     flexmock(module.requests).should_receive('post').with_args(
         'https://example.com/start', data=''.encode('utf-8'), verify=True
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -156,14 +157,15 @@
     flexmock(module).should_receive('format_buffered_logs_for_payload').and_return(payload)
     flexmock(module.requests).should_receive('post').with_args(
         'https://example.com', data=payload.encode('utf-8'), verify=True
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.FINISH,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -173,14 +175,15 @@
     flexmock(module).should_receive('format_buffered_logs_for_payload').and_return(payload)
     flexmock(module.requests).should_receive('post').with_args(
         'https://example.com/fail', data=payload.encode('utf'), verify=True
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -190,33 +193,35 @@
     flexmock(module).should_receive('format_buffered_logs_for_payload').and_return(payload)
     flexmock(module.requests).should_receive('post').with_args(
         'https://example.com/log', data=payload.encode('utf'), verify=True
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.LOG,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
 def test_ping_monitor_with_ping_uuid_hits_corresponding_url():
     hook_config = {'ping_url': 'abcd-efgh-ijkl-mnop'}
     payload = 'data'
     flexmock(module).should_receive('format_buffered_logs_for_payload').and_return(payload)
     flexmock(module.requests).should_receive('post').with_args(
-        'https://hc-ping.com/{}'.format(hook_config['ping_url']),
+        f"https://hc-ping.com/{hook_config['ping_url']}",
         data=payload.encode('utf-8'),
         verify=True,
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.FINISH,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -226,14 +231,15 @@
     flexmock(module).should_receive('format_buffered_logs_for_payload').and_return(payload)
     flexmock(module.requests).should_receive('post').with_args(
         'https://example.com', data=payload.encode('utf-8'), verify=False
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.FINISH,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -243,42 +249,45 @@
     flexmock(module).should_receive('format_buffered_logs_for_payload').and_return(payload)
     flexmock(module.requests).should_receive('post').with_args(
         'https://example.com', data=payload.encode('utf-8'), verify=True
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.FINISH,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
 def test_ping_monitor_dry_run_does_not_hit_ping_url():
     flexmock(module).should_receive('Forgetful_buffering_handler')
     hook_config = {'ping_url': 'https://example.com'}
     flexmock(module.requests).should_receive('post').never()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=True,
     )
 
 
 def test_ping_monitor_does_not_hit_ping_url_when_states_not_matching():
     flexmock(module).should_receive('Forgetful_buffering_handler')
     hook_config = {'ping_url': 'https://example.com', 'states': ['finish']}
     flexmock(module.requests).should_receive('post').never()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=True,
     )
 
 
@@ -287,14 +296,15 @@
     hook_config = {'ping_url': 'https://example.com', 'states': ['start', 'finish']}
     flexmock(module.requests).should_receive('post').with_args(
         'https://example.com/start', data=''.encode('utf-8'), verify=True
     ).and_return(flexmock(ok=True))
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -304,14 +314,15 @@
     flexmock(module.requests).should_receive('post').with_args(
         'https://example.com/start', data=''.encode('utf-8'), verify=True
     ).and_raise(module.requests.exceptions.ConnectionError)
     flexmock(module.logger).should_receive('warning').once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -325,12 +336,13 @@
     flexmock(module.requests).should_receive('post').with_args(
         'https://example.com/start', data=''.encode('utf-8'), verify=True
     ).and_return(response)
     flexmock(module.logger).should_receive('warning').once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         state=module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/hooks/test_mysql.py` & `borgmatic-1.8.0/tests/unit/hooks/test_mysql.py`

 * *Files 24% similar despite different names*

```diff
@@ -59,15 +59,15 @@
             dump_path=object,
             database_names=(name,),
             extra_environment=object,
             dry_run=object,
             dry_run_label=object,
         ).and_return(process).once()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False) == processes
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False) == processes
 
 
 def test_dump_databases_dumps_with_password():
     database = {'name': 'foo', 'username': 'root', 'password': 'trustsome1'}
     process = flexmock()
     flexmock(module).should_receive('make_dump_path').and_return('')
     flexmock(module).should_receive('database_names_to_dump').and_return(('foo',)).and_return(
@@ -80,15 +80,15 @@
         dump_path=object,
         database_names=('foo',),
         extra_environment={'MYSQL_PWD': 'trustsome1'},
         dry_run=object,
         dry_run_label=object,
     ).and_return(process).once()
 
-    assert module.dump_databases([database], 'test.yaml', {}, dry_run=False) == [process]
+    assert module.dump_databases([database], {}, 'test.yaml', dry_run=False) == [process]
 
 
 def test_dump_databases_dumps_all_databases_at_once():
     databases = [{'name': 'all'}]
     process = flexmock()
     flexmock(module).should_receive('make_dump_path').and_return('')
     flexmock(module).should_receive('database_names_to_dump').and_return(('foo', 'bar'))
@@ -98,15 +98,15 @@
         dump_path=object,
         database_names=('foo', 'bar'),
         extra_environment=object,
         dry_run=object,
         dry_run_label=object,
     ).and_return(process).once()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False) == [process]
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False) == [process]
 
 
 def test_dump_databases_dumps_all_databases_separately_when_format_configured():
     databases = [{'name': 'all', 'format': 'sql'}]
     processes = [flexmock(), flexmock()]
     flexmock(module).should_receive('make_dump_path').and_return('')
     flexmock(module).should_receive('database_names_to_dump').and_return(('foo', 'bar'))
@@ -118,15 +118,15 @@
             dump_path=object,
             database_names=(name,),
             extra_environment=object,
             dry_run=object,
             dry_run_label=object,
         ).and_return(process).once()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False) == processes
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False) == processes
 
 
 def test_database_names_to_dump_runs_mysql_with_list_options():
     database = {'name': 'all', 'list_options': '--defaults-extra-file=my.cnf'}
     flexmock(module).should_receive('execute_command_and_capture_output').with_args(
         (
             'mysql',
@@ -145,16 +145,22 @@
 def test_execute_dump_command_runs_mysqldump():
     process = flexmock()
     flexmock(module.dump).should_receive('make_database_dump_filename').and_return('dump')
     flexmock(module.os.path).should_receive('exists').and_return(False)
     flexmock(module.dump).should_receive('create_named_pipe_for_dump')
 
     flexmock(module).should_receive('execute_command').with_args(
-        ('mysqldump', '--add-drop-database', '--databases', 'foo', '>', 'dump',),
-        shell=True,
+        (
+            'mysqldump',
+            '--add-drop-database',
+            '--databases',
+            'foo',
+            '--result-file',
+            'dump',
+        ),
         extra_environment=None,
         run_to_completion=False,
     ).and_return(process).once()
 
     assert (
         module.execute_dump_command(
             database={'name': 'foo'},
@@ -172,16 +178,21 @@
 def test_execute_dump_command_runs_mysqldump_without_add_drop_database():
     process = flexmock()
     flexmock(module.dump).should_receive('make_database_dump_filename').and_return('dump')
     flexmock(module.os.path).should_receive('exists').and_return(False)
     flexmock(module.dump).should_receive('create_named_pipe_for_dump')
 
     flexmock(module).should_receive('execute_command').with_args(
-        ('mysqldump', '--databases', 'foo', '>', 'dump',),
-        shell=True,
+        (
+            'mysqldump',
+            '--databases',
+            'foo',
+            '--result-file',
+            'dump',
+        ),
         extra_environment=None,
         run_to_completion=False,
     ).and_return(process).once()
 
     assert (
         module.execute_dump_command(
             database={'name': 'foo', 'add_drop_database': False},
@@ -210,18 +221,17 @@
             'database.example.org',
             '--port',
             '5433',
             '--protocol',
             'tcp',
             '--databases',
             'foo',
-            '>',
+            '--result-file',
             'dump',
         ),
-        shell=True,
         extra_environment=None,
         run_to_completion=False,
     ).and_return(process).once()
 
     assert (
         module.execute_dump_command(
             database={'name': 'foo', 'hostname': 'database.example.org', 'port': 5433},
@@ -239,16 +249,24 @@
 def test_execute_dump_command_runs_mysqldump_with_username_and_password():
     process = flexmock()
     flexmock(module.dump).should_receive('make_database_dump_filename').and_return('dump')
     flexmock(module.os.path).should_receive('exists').and_return(False)
     flexmock(module.dump).should_receive('create_named_pipe_for_dump')
 
     flexmock(module).should_receive('execute_command').with_args(
-        ('mysqldump', '--add-drop-database', '--user', 'root', '--databases', 'foo', '>', 'dump',),
-        shell=True,
+        (
+            'mysqldump',
+            '--add-drop-database',
+            '--user',
+            'root',
+            '--databases',
+            'foo',
+            '--result-file',
+            'dump',
+        ),
         extra_environment={'MYSQL_PWD': 'trustsome1'},
         run_to_completion=False,
     ).and_return(process).once()
 
     assert (
         module.execute_dump_command(
             database={'name': 'foo', 'username': 'root', 'password': 'trustsome1'},
@@ -266,16 +284,23 @@
 def test_execute_dump_command_runs_mysqldump_with_options():
     process = flexmock()
     flexmock(module.dump).should_receive('make_database_dump_filename').and_return('dump')
     flexmock(module.os.path).should_receive('exists').and_return(False)
     flexmock(module.dump).should_receive('create_named_pipe_for_dump')
 
     flexmock(module).should_receive('execute_command').with_args(
-        ('mysqldump', '--stuff=such', '--add-drop-database', '--databases', 'foo', '>', 'dump',),
-        shell=True,
+        (
+            'mysqldump',
+            '--stuff=such',
+            '--add-drop-database',
+            '--databases',
+            'foo',
+            '--result-file',
+            'dump',
+        ),
         extra_environment=None,
         run_to_completion=False,
     ).and_return(process).once()
 
     assert (
         module.execute_dump_command(
             database={'name': 'foo', 'options': '--stuff=such'},
@@ -336,76 +361,109 @@
     flexmock(module).should_receive('make_dump_path').and_return('')
     flexmock(module.dump).should_receive('make_database_dump_filename').and_return(
         'databases/localhost/all'
     )
     flexmock(module).should_receive('database_names_to_dump').and_return(())
 
     with pytest.raises(ValueError):
-        assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False)
+        assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False)
 
 
 def test_dump_databases_does_not_error_for_missing_all_databases_with_dry_run():
     databases = [{'name': 'all'}]
     flexmock(module).should_receive('make_dump_path').and_return('')
     flexmock(module.dump).should_receive('make_database_dump_filename').and_return(
         'databases/localhost/all'
     )
     flexmock(module).should_receive('database_names_to_dump').and_return(())
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=True) == []
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=True) == []
 
 
 def test_restore_database_dump_runs_mysql_to_restore():
-    database_config = [{'name': 'foo'}]
+    databases_config = [{'name': 'foo'}, {'name': 'bar'}]
     extract_process = flexmock(stdout=flexmock())
 
     flexmock(module).should_receive('execute_command_with_processes').with_args(
         ('mysql', '--batch'),
         processes=[extract_process],
         output_log_level=logging.DEBUG,
         input_file=extract_process.stdout,
         extra_environment=None,
     ).once()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=False, extract_process=extract_process
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
 
 
-def test_restore_database_dump_errors_on_multiple_database_config():
-    database_config = [{'name': 'foo'}, {'name': 'bar'}]
+def test_restore_database_dump_errors_when_database_missing_from_configuration():
+    databases_config = [{'name': 'foo'}, {'name': 'bar'}]
+    extract_process = flexmock(stdout=flexmock())
 
     flexmock(module).should_receive('execute_command_with_processes').never()
-    flexmock(module).should_receive('execute_command').never()
 
     with pytest.raises(ValueError):
         module.restore_database_dump(
-            database_config, 'test.yaml', {}, dry_run=False, extract_process=flexmock()
+            databases_config,
+            {},
+            'test.yaml',
+            database_name='other',
+            dry_run=False,
+            extract_process=extract_process,
+            connection_params={
+                'hostname': None,
+                'port': None,
+                'username': None,
+                'password': None,
+            },
         )
 
 
 def test_restore_database_dump_runs_mysql_with_options():
-    database_config = [{'name': 'foo', 'restore_options': '--harder'}]
+    databases_config = [{'name': 'foo', 'restore_options': '--harder'}]
     extract_process = flexmock(stdout=flexmock())
 
     flexmock(module).should_receive('execute_command_with_processes').with_args(
         ('mysql', '--batch', '--harder'),
         processes=[extract_process],
         output_log_level=logging.DEBUG,
         input_file=extract_process.stdout,
         extra_environment=None,
     ).once()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=False, extract_process=extract_process
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
 
 
 def test_restore_database_dump_runs_mysql_with_hostname_and_port():
-    database_config = [{'name': 'foo', 'hostname': 'database.example.org', 'port': 5433}]
+    databases_config = [{'name': 'foo', 'hostname': 'database.example.org', 'port': 5433}]
     extract_process = flexmock(stdout=flexmock())
 
     flexmock(module).should_receive('execute_command_with_processes').with_args(
         (
             'mysql',
             '--batch',
             '--host',
@@ -418,36 +476,169 @@
         processes=[extract_process],
         output_log_level=logging.DEBUG,
         input_file=extract_process.stdout,
         extra_environment=None,
     ).once()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=False, extract_process=extract_process
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
 
 
 def test_restore_database_dump_runs_mysql_with_username_and_password():
-    database_config = [{'name': 'foo', 'username': 'root', 'password': 'trustsome1'}]
+    databases_config = [{'name': 'foo', 'username': 'root', 'password': 'trustsome1'}]
     extract_process = flexmock(stdout=flexmock())
 
     flexmock(module).should_receive('execute_command_with_processes').with_args(
         ('mysql', '--batch', '--user', 'root'),
         processes=[extract_process],
         output_log_level=logging.DEBUG,
         input_file=extract_process.stdout,
         extra_environment={'MYSQL_PWD': 'trustsome1'},
     ).once()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=False, extract_process=extract_process
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
+    )
+
+
+def test_restore_database_dump_with_connection_params_uses_connection_params_for_restore():
+    databases_config = [
+        {
+            'name': 'foo',
+            'username': 'root',
+            'password': 'trustsome1',
+            'restore_hostname': 'restorehost',
+            'restore_port': 'restoreport',
+            'restore_username': 'restoreusername',
+            'restore_password': 'restorepassword',
+        }
+    ]
+    extract_process = flexmock(stdout=flexmock())
+
+    flexmock(module).should_receive('execute_command_with_processes').with_args(
+        (
+            'mysql',
+            '--batch',
+            '--host',
+            'clihost',
+            '--port',
+            'cliport',
+            '--protocol',
+            'tcp',
+            '--user',
+            'cliusername',
+        ),
+        processes=[extract_process],
+        output_log_level=logging.DEBUG,
+        input_file=extract_process.stdout,
+        extra_environment={'MYSQL_PWD': 'clipassword'},
+    ).once()
+
+    module.restore_database_dump(
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': 'clihost',
+            'port': 'cliport',
+            'username': 'cliusername',
+            'password': 'clipassword',
+        },
+    )
+
+
+def test_restore_database_dump_without_connection_params_uses_restore_params_in_config_for_restore():
+    databases_config = [
+        {
+            'name': 'foo',
+            'username': 'root',
+            'password': 'trustsome1',
+            'hostname': 'dbhost',
+            'port': 'dbport',
+            'restore_username': 'restoreuser',
+            'restore_password': 'restorepass',
+            'restore_hostname': 'restorehost',
+            'restore_port': 'restoreport',
+        }
+    ]
+    extract_process = flexmock(stdout=flexmock())
+
+    flexmock(module).should_receive('execute_command_with_processes').with_args(
+        (
+            'mysql',
+            '--batch',
+            '--host',
+            'restorehost',
+            '--port',
+            'restoreport',
+            '--protocol',
+            'tcp',
+            '--user',
+            'restoreuser',
+        ),
+        processes=[extract_process],
+        output_log_level=logging.DEBUG,
+        input_file=extract_process.stdout,
+        extra_environment={'MYSQL_PWD': 'restorepass'},
+    ).once()
+
+    module.restore_database_dump(
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
 
 
 def test_restore_database_dump_with_dry_run_skips_restore():
-    database_config = [{'name': 'foo'}]
+    databases_config = [{'name': 'foo'}]
 
     flexmock(module).should_receive('execute_command_with_processes').never()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=True, extract_process=flexmock()
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=True,
+        extract_process=flexmock(),
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/hooks/test_ntfy.py` & `borgmatic-1.8.0/tests/unit/hooks/test_ntfy.py`

 * *Files 4% similar despite different names*

```diff
@@ -40,14 +40,15 @@
         f'{default_base_url}/{topic}',
         headers=return_default_message_headers(borgmatic.hooks.monitor.State.FAIL),
         auth=None,
     ).and_return(flexmock(ok=True)).once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -61,14 +62,15 @@
         f'{default_base_url}/{topic}',
         headers=return_default_message_headers(borgmatic.hooks.monitor.State.FAIL),
         auth=module.requests.auth.HTTPBasicAuth('testuser', 'fakepassword'),
     ).and_return(flexmock(ok=True)).once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -79,14 +81,15 @@
         headers=return_default_message_headers(borgmatic.hooks.monitor.State.FAIL),
         auth=None,
     ).and_return(flexmock(ok=True)).once()
     flexmock(module.logger).should_receive('warning').once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -97,40 +100,43 @@
         headers=return_default_message_headers(borgmatic.hooks.monitor.State.FAIL),
         auth=None,
     ).and_return(flexmock(ok=True)).once()
     flexmock(module.logger).should_receive('warning').once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
 def test_ping_monitor_minimal_config_does_not_hit_hosted_ntfy_on_start():
     hook_config = {'topic': topic}
     flexmock(module.requests).should_receive('post').never()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
 def test_ping_monitor_minimal_config_does_not_hit_hosted_ntfy_on_finish():
     hook_config = {'topic': topic}
     flexmock(module.requests).should_receive('post').never()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.FINISH,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -140,27 +146,29 @@
         f'{custom_base_url}/{topic}',
         headers=return_default_message_headers(borgmatic.hooks.monitor.State.FAIL),
         auth=None,
     ).and_return(flexmock(ok=True)).once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
 def test_ping_monitor_minimal_config_does_not_hit_hosted_ntfy_on_fail_dry_run():
     hook_config = {'topic': topic}
     flexmock(module.requests).should_receive('post').never()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=True,
     )
 
 
@@ -168,14 +176,15 @@
     hook_config = {'topic': topic, 'fail': custom_message_config}
     flexmock(module.requests).should_receive('post').with_args(
         f'{default_base_url}/{topic}', headers=custom_message_headers, auth=None
     ).and_return(flexmock(ok=True)).once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -185,14 +194,15 @@
         f'{default_base_url}/{topic}',
         headers=return_default_message_headers(borgmatic.hooks.monitor.State.START),
         auth=None,
     ).and_return(flexmock(ok=True)).once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -203,14 +213,15 @@
         headers=return_default_message_headers(borgmatic.hooks.monitor.State.FAIL),
         auth=None,
     ).and_raise(module.requests.exceptions.ConnectionError)
     flexmock(module.logger).should_receive('warning').once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -225,12 +236,13 @@
         headers=return_default_message_headers(borgmatic.hooks.monitor.State.FAIL),
         auth=None,
     ).and_return(response)
     flexmock(module.logger).should_receive('warning').once()
 
     module.ping_monitor(
         hook_config,
+        {},
         'config.yaml',
         borgmatic.hooks.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/hooks/test_pagerduty.py` & `borgmatic-1.8.0/tests/unit/hooks/test_pagerduty.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,50 +4,54 @@
 
 
 def test_ping_monitor_ignores_start_state():
     flexmock(module.requests).should_receive('post').never()
 
     module.ping_monitor(
         {'integration_key': 'abc123'},
+        {},
         'config.yaml',
         module.monitor.State.START,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
 def test_ping_monitor_ignores_finish_state():
     flexmock(module.requests).should_receive('post').never()
 
     module.ping_monitor(
         {'integration_key': 'abc123'},
+        {},
         'config.yaml',
         module.monitor.State.FINISH,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
 def test_ping_monitor_calls_api_for_fail_state():
     flexmock(module.requests).should_receive('post').and_return(flexmock(ok=True))
 
     module.ping_monitor(
         {'integration_key': 'abc123'},
+        {},
         'config.yaml',
         module.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
 def test_ping_monitor_dry_run_does_not_call_api():
     flexmock(module.requests).should_receive('post').never()
 
     module.ping_monitor(
         {'integration_key': 'abc123'},
+        {},
         'config.yaml',
         module.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=True,
     )
 
 
@@ -55,14 +59,15 @@
     flexmock(module.requests).should_receive('post').and_raise(
         module.requests.exceptions.ConnectionError
     )
     flexmock(module.logger).should_receive('warning').once()
 
     module.ping_monitor(
         {'integration_key': 'abc123'},
+        {},
         'config.yaml',
         module.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
 
 
@@ -72,12 +77,13 @@
         module.requests.exceptions.RequestException
     )
     flexmock(module.requests).should_receive('post').and_return(response)
     flexmock(module.logger).should_receive('warning')
 
     module.ping_monitor(
         {'integration_key': 'abc123'},
+        {},
         'config.yaml',
         module.monitor.State.FAIL,
         monitoring_log_level=1,
         dry_run=False,
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/hooks/test_postgresql.py` & `borgmatic-1.8.0/tests/unit/hooks/test_postgresql.py`

 * *Files 26% similar despite different names*

```diff
@@ -2,14 +2,58 @@
 
 import pytest
 from flexmock import flexmock
 
 from borgmatic.hooks import postgresql as module
 
 
+def test_make_extra_environment_maps_options_to_environment():
+    database = {
+        'name': 'foo',
+        'password': 'pass',
+        'ssl_mode': 'require',
+        'ssl_cert': 'cert.crt',
+        'ssl_key': 'key.key',
+        'ssl_root_cert': 'root.crt',
+        'ssl_crl': 'crl.crl',
+    }
+    expected = {
+        'PGPASSWORD': 'pass',
+        'PGSSLMODE': 'require',
+        'PGSSLCERT': 'cert.crt',
+        'PGSSLKEY': 'key.key',
+        'PGSSLROOTCERT': 'root.crt',
+        'PGSSLCRL': 'crl.crl',
+    }
+
+    extra_env = module.make_extra_environment(database)
+
+    assert extra_env == expected
+
+
+def test_make_extra_environment_with_cli_password_sets_correct_password():
+    database = {'name': 'foo', 'restore_password': 'trustsome1', 'password': 'anotherpassword'}
+
+    extra = module.make_extra_environment(
+        database, restore_connection_params={'password': 'clipassword'}
+    )
+
+    assert extra['PGPASSWORD'] == 'clipassword'
+
+
+def test_make_extra_environment_without_cli_password_or_configured_password_does_not_set_password():
+    database = {'name': 'foo'}
+
+    extra = module.make_extra_environment(
+        database, restore_connection_params={'username': 'someone'}
+    )
+
+    assert 'PGPASSWORD' not in extra
+
+
 def test_database_names_to_dump_passes_through_individual_database_name():
     database = {'name': 'foo'}
 
     assert module.database_names_to_dump(database, flexmock(), flexmock(), dry_run=False) == (
         'foo',
     )
 
@@ -52,14 +96,15 @@
 def test_database_names_to_dump_with_all_and_format_lists_databases_with_hostname_and_port():
     database = {'name': 'all', 'format': 'custom', 'hostname': 'localhost', 'port': 1234}
     flexmock(module).should_receive('execute_command_and_capture_output').with_args(
         (
             'psql',
             '--list',
             '--no-password',
+            '--no-psqlrc',
             '--csv',
             '--tuples-only',
             '--host',
             'localhost',
             '--port',
             '1234',
         ),
@@ -71,28 +116,37 @@
         'bar',
     )
 
 
 def test_database_names_to_dump_with_all_and_format_lists_databases_with_username():
     database = {'name': 'all', 'format': 'custom', 'username': 'postgres'}
     flexmock(module).should_receive('execute_command_and_capture_output').with_args(
-        ('psql', '--list', '--no-password', '--csv', '--tuples-only', '--username', 'postgres'),
+        (
+            'psql',
+            '--list',
+            '--no-password',
+            '--no-psqlrc',
+            '--csv',
+            '--tuples-only',
+            '--username',
+            'postgres',
+        ),
         extra_environment=object,
     ).and_return('foo,test,\nbar,test,"stuff and such"')
 
     assert module.database_names_to_dump(database, flexmock(), flexmock(), dry_run=False) == (
         'foo',
         'bar',
     )
 
 
 def test_database_names_to_dump_with_all_and_format_lists_databases_with_options():
     database = {'name': 'all', 'format': 'custom', 'list_options': '--harder'}
     flexmock(module).should_receive('execute_command_and_capture_output').with_args(
-        ('psql', '--list', '--no-password', '--csv', '--tuples-only', '--harder'),
+        ('psql', '--list', '--no-password', '--no-psqlrc', '--csv', '--tuples-only', '--harder'),
         extra_environment=object,
     ).and_return('foo,test,\nbar,test,"stuff and such"')
 
     assert module.database_names_to_dump(database, flexmock(), flexmock(), dry_run=False) == (
         'foo',
         'bar',
     )
@@ -105,14 +159,36 @@
     )
 
     assert module.database_names_to_dump(database, flexmock(), flexmock(), dry_run=False) == (
         'foo',
     )
 
 
+def test_database_names_to_dump_with_all_and_psql_command_uses_custom_command():
+    database = {'name': 'all', 'format': 'custom', 'psql_command': 'docker exec mycontainer psql'}
+    flexmock(module).should_receive('execute_command_and_capture_output').with_args(
+        (
+            'docker',
+            'exec',
+            'mycontainer',
+            'psql',
+            '--list',
+            '--no-password',
+            '--no-psqlrc',
+            '--csv',
+            '--tuples-only',
+        ),
+        extra_environment=object,
+    ).and_return('foo,text').once()
+
+    assert module.database_names_to_dump(database, flexmock(), flexmock(), dry_run=False) == (
+        'foo',
+    )
+
+
 def test_dump_databases_runs_pg_dump_for_each_database():
     databases = [{'name': 'foo'}, {'name': 'bar'}]
     processes = [flexmock(), flexmock()]
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path').and_return('')
     flexmock(module).should_receive('database_names_to_dump').and_return(('foo',)).and_return(
         ('bar',)
@@ -130,41 +206,41 @@
                 '--no-password',
                 '--clean',
                 '--if-exists',
                 '--format',
                 'custom',
                 name,
                 '>',
-                'databases/localhost/{}'.format(name),
+                f'databases/localhost/{name}',
             ),
             shell=True,
             extra_environment={'PGSSLMODE': 'disable'},
             run_to_completion=False,
         ).and_return(process).once()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False) == processes
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False) == processes
 
 
 def test_dump_databases_raises_when_no_database_names_to_dump():
     databases = [{'name': 'foo'}, {'name': 'bar'}]
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path').and_return('')
     flexmock(module).should_receive('database_names_to_dump').and_return(())
 
     with pytest.raises(ValueError):
-        module.dump_databases(databases, 'test.yaml', {}, dry_run=False)
+        module.dump_databases(databases, {}, 'test.yaml', dry_run=False)
 
 
 def test_dump_databases_does_not_raise_when_no_database_names_to_dump():
     databases = [{'name': 'foo'}, {'name': 'bar'}]
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path').and_return('')
     flexmock(module).should_receive('database_names_to_dump').and_return(())
 
-    module.dump_databases(databases, 'test.yaml', {}, dry_run=True) == []
+    module.dump_databases(databases, {}, 'test.yaml', dry_run=True) == []
 
 
 def test_dump_databases_with_duplicate_dump_skips_pg_dump():
     databases = [{'name': 'foo'}, {'name': 'bar'}]
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path').and_return('')
     flexmock(module).should_receive('database_names_to_dump').and_return(('foo',)).and_return(
@@ -173,15 +249,15 @@
     flexmock(module.dump).should_receive('make_database_dump_filename').and_return(
         'databases/localhost/foo'
     ).and_return('databases/localhost/bar')
     flexmock(module.os.path).should_receive('exists').and_return(True)
     flexmock(module.dump).should_receive('create_named_pipe_for_dump').never()
     flexmock(module).should_receive('execute_command').never()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False) == []
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False) == []
 
 
 def test_dump_databases_with_dry_run_skips_pg_dump():
     databases = [{'name': 'foo'}, {'name': 'bar'}]
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path').and_return('')
     flexmock(module).should_receive('database_names_to_dump').and_return(('foo',)).and_return(
@@ -190,15 +266,15 @@
     flexmock(module.dump).should_receive('make_database_dump_filename').and_return(
         'databases/localhost/foo'
     ).and_return('databases/localhost/bar')
     flexmock(module.os.path).should_receive('exists').and_return(False)
     flexmock(module.dump).should_receive('create_named_pipe_for_dump').never()
     flexmock(module).should_receive('execute_command').never()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=True) == []
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=True) == []
 
 
 def test_dump_databases_runs_pg_dump_with_hostname_and_port():
     databases = [{'name': 'foo', 'hostname': 'database.example.org', 'port': 5433}]
     process = flexmock()
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path').and_return('')
@@ -226,15 +302,15 @@
             'databases/database.example.org/foo',
         ),
         shell=True,
         extra_environment={'PGSSLMODE': 'disable'},
         run_to_completion=False,
     ).and_return(process).once()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False) == [process]
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False) == [process]
 
 
 def test_dump_databases_runs_pg_dump_with_username_and_password():
     databases = [{'name': 'foo', 'username': 'postgres', 'password': 'trustsome1'}]
     process = flexmock()
     flexmock(module).should_receive('make_extra_environment').and_return(
         {'PGPASSWORD': 'trustsome1', 'PGSSLMODE': 'disable'}
@@ -262,38 +338,15 @@
             'databases/localhost/foo',
         ),
         shell=True,
         extra_environment={'PGPASSWORD': 'trustsome1', 'PGSSLMODE': 'disable'},
         run_to_completion=False,
     ).and_return(process).once()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False) == [process]
-
-
-def test_make_extra_environment_maps_options_to_environment():
-    database = {
-        'name': 'foo',
-        'password': 'pass',
-        'ssl_mode': 'require',
-        'ssl_cert': 'cert.crt',
-        'ssl_key': 'key.key',
-        'ssl_root_cert': 'root.crt',
-        'ssl_crl': 'crl.crl',
-    }
-    expected = {
-        'PGPASSWORD': 'pass',
-        'PGSSLMODE': 'require',
-        'PGSSLCERT': 'cert.crt',
-        'PGSSLKEY': 'key.key',
-        'PGSSLROOTCERT': 'root.crt',
-        'PGSSLCRL': 'crl.crl',
-    }
-
-    extra_env = module.make_extra_environment(database)
-    assert extra_env == expected
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False) == [process]
 
 
 def test_dump_databases_runs_pg_dump_with_directory_format():
     databases = [{'name': 'foo', 'format': 'directory'}]
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path').and_return('')
     flexmock(module).should_receive('database_names_to_dump').and_return(('foo',))
@@ -316,15 +369,15 @@
             'databases/localhost/foo',
             'foo',
         ),
         shell=True,
         extra_environment={'PGSSLMODE': 'disable'},
     ).and_return(flexmock()).once()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False) == []
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False) == []
 
 
 def test_dump_databases_runs_pg_dump_with_options():
     databases = [{'name': 'foo', 'options': '--stuff=such'}]
     process = flexmock()
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path').and_return('')
@@ -349,15 +402,15 @@
             'databases/localhost/foo',
         ),
         shell=True,
         extra_environment={'PGSSLMODE': 'disable'},
         run_to_completion=False,
     ).and_return(process).once()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False) == [process]
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False) == [process]
 
 
 def test_dump_databases_runs_pg_dumpall_for_all_databases():
     databases = [{'name': 'all'}]
     process = flexmock()
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path').and_return('')
@@ -371,15 +424,15 @@
     flexmock(module).should_receive('execute_command').with_args(
         ('pg_dumpall', '--no-password', '--clean', '--if-exists', '>', 'databases/localhost/all'),
         shell=True,
         extra_environment={'PGSSLMODE': 'disable'},
         run_to_completion=False,
     ).and_return(process).once()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False) == [process]
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False) == [process]
 
 
 def test_dump_databases_runs_non_default_pg_dump():
     databases = [{'name': 'foo', 'pg_dump_command': 'special_pg_dump'}]
     process = flexmock()
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path').and_return('')
@@ -403,19 +456,19 @@
             'databases/localhost/foo',
         ),
         shell=True,
         extra_environment={'PGSSLMODE': 'disable'},
         run_to_completion=False,
     ).and_return(process).once()
 
-    assert module.dump_databases(databases, 'test.yaml', {}, dry_run=False) == [process]
+    assert module.dump_databases(databases, {}, 'test.yaml', dry_run=False) == [process]
 
 
 def test_restore_database_dump_runs_pg_restore():
-    database_config = [{'name': 'foo'}]
+    databases_config = [{'name': 'foo', 'schemas': None}, {'name': 'bar'}]
     extract_process = flexmock(stdout=flexmock())
 
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path')
     flexmock(module.dump).should_receive('make_database_dump_filename')
     flexmock(module).should_receive('execute_command_with_processes').with_args(
         (
@@ -429,40 +482,71 @@
         ),
         processes=[extract_process],
         output_log_level=logging.DEBUG,
         input_file=extract_process.stdout,
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
     flexmock(module).should_receive('execute_command').with_args(
-        ('psql', '--no-password', '--quiet', '--dbname', 'foo', '--command', 'ANALYZE'),
+        (
+            'psql',
+            '--no-password',
+            '--no-psqlrc',
+            '--quiet',
+            '--dbname',
+            'foo',
+            '--command',
+            'ANALYZE',
+        ),
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=False, extract_process=extract_process
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
 
 
-def test_restore_database_dump_errors_on_multiple_database_config():
-    database_config = [{'name': 'foo'}, {'name': 'bar'}]
+def test_restore_database_dump_errors_when_database_missing_from_configuration():
+    databases_config = [{'name': 'foo', 'schemas': None}, {'name': 'bar'}]
+    extract_process = flexmock(stdout=flexmock())
 
-    flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
-    flexmock(module).should_receive('make_dump_path')
-    flexmock(module.dump).should_receive('make_database_dump_filename')
     flexmock(module).should_receive('execute_command_with_processes').never()
     flexmock(module).should_receive('execute_command').never()
 
     with pytest.raises(ValueError):
         module.restore_database_dump(
-            database_config, 'test.yaml', {}, dry_run=False, extract_process=flexmock()
+            databases_config,
+            {},
+            'test.yaml',
+            database_name='other',
+            dry_run=False,
+            extract_process=extract_process,
+            connection_params={
+                'hostname': None,
+                'port': None,
+                'username': None,
+                'password': None,
+            },
         )
 
 
 def test_restore_database_dump_runs_pg_restore_with_hostname_and_port():
-    database_config = [{'name': 'foo', 'hostname': 'database.example.org', 'port': 5433}]
+    databases_config = [
+        {'name': 'foo', 'hostname': 'database.example.org', 'port': 5433, 'schemas': None}
+    ]
     extract_process = flexmock(stdout=flexmock())
 
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path')
     flexmock(module.dump).should_receive('make_database_dump_filename')
     flexmock(module).should_receive('execute_command_with_processes').with_args(
         (
@@ -483,34 +567,48 @@
         input_file=extract_process.stdout,
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
     flexmock(module).should_receive('execute_command').with_args(
         (
             'psql',
             '--no-password',
+            '--no-psqlrc',
             '--quiet',
             '--host',
             'database.example.org',
             '--port',
             '5433',
             '--dbname',
             'foo',
             '--command',
             'ANALYZE',
         ),
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=False, extract_process=extract_process
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
 
 
 def test_restore_database_dump_runs_pg_restore_with_username_and_password():
-    database_config = [{'name': 'foo', 'username': 'postgres', 'password': 'trustsome1'}]
+    databases_config = [
+        {'name': 'foo', 'username': 'postgres', 'password': 'trustsome1', 'schemas': None}
+    ]
     extract_process = flexmock(stdout=flexmock())
 
     flexmock(module).should_receive('make_extra_environment').and_return(
         {'PGPASSWORD': 'trustsome1', 'PGSSLMODE': 'disable'}
     )
     flexmock(module).should_receive('make_dump_path')
     flexmock(module.dump).should_receive('make_database_dump_filename')
@@ -531,33 +629,208 @@
         input_file=extract_process.stdout,
         extra_environment={'PGPASSWORD': 'trustsome1', 'PGSSLMODE': 'disable'},
     ).once()
     flexmock(module).should_receive('execute_command').with_args(
         (
             'psql',
             '--no-password',
+            '--no-psqlrc',
             '--quiet',
             '--username',
             'postgres',
             '--dbname',
             'foo',
             '--command',
             'ANALYZE',
         ),
         extra_environment={'PGPASSWORD': 'trustsome1', 'PGSSLMODE': 'disable'},
     ).once()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=False, extract_process=extract_process
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
+    )
+
+
+def test_restore_database_dump_with_connection_params_uses_connection_params_for_restore():
+    databases_config = [
+        {
+            'name': 'foo',
+            'hostname': 'database.example.org',
+            'port': 5433,
+            'username': 'postgres',
+            'password': 'trustsome1',
+            'restore_hostname': 'restorehost',
+            'restore_port': 'restoreport',
+            'restore_username': 'restoreusername',
+            'restore_password': 'restorepassword',
+            'schemas': None,
+        }
+    ]
+    extract_process = flexmock(stdout=flexmock())
+
+    flexmock(module).should_receive('make_extra_environment').and_return(
+        {'PGPASSWORD': 'clipassword', 'PGSSLMODE': 'disable'}
+    )
+    flexmock(module).should_receive('make_dump_path')
+    flexmock(module.dump).should_receive('make_database_dump_filename')
+    flexmock(module).should_receive('execute_command_with_processes').with_args(
+        (
+            'pg_restore',
+            '--no-password',
+            '--if-exists',
+            '--exit-on-error',
+            '--clean',
+            '--dbname',
+            'foo',
+            '--host',
+            'clihost',
+            '--port',
+            'cliport',
+            '--username',
+            'cliusername',
+        ),
+        processes=[extract_process],
+        output_log_level=logging.DEBUG,
+        input_file=extract_process.stdout,
+        extra_environment={'PGPASSWORD': 'clipassword', 'PGSSLMODE': 'disable'},
+    ).once()
+    flexmock(module).should_receive('execute_command').with_args(
+        (
+            'psql',
+            '--no-password',
+            '--no-psqlrc',
+            '--quiet',
+            '--host',
+            'clihost',
+            '--port',
+            'cliport',
+            '--username',
+            'cliusername',
+            '--dbname',
+            'foo',
+            '--command',
+            'ANALYZE',
+        ),
+        extra_environment={'PGPASSWORD': 'clipassword', 'PGSSLMODE': 'disable'},
+    ).once()
+
+    module.restore_database_dump(
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': 'clihost',
+            'port': 'cliport',
+            'username': 'cliusername',
+            'password': 'clipassword',
+        },
+    )
+
+
+def test_restore_database_dump_without_connection_params_uses_restore_params_in_config_for_restore():
+    databases_config = [
+        {
+            'name': 'foo',
+            'hostname': 'database.example.org',
+            'port': 5433,
+            'username': 'postgres',
+            'password': 'trustsome1',
+            'schemas': None,
+            'restore_hostname': 'restorehost',
+            'restore_port': 'restoreport',
+            'restore_username': 'restoreusername',
+            'restore_password': 'restorepassword',
+        }
+    ]
+    extract_process = flexmock(stdout=flexmock())
+
+    flexmock(module).should_receive('make_extra_environment').and_return(
+        {'PGPASSWORD': 'restorepassword', 'PGSSLMODE': 'disable'}
+    )
+    flexmock(module).should_receive('make_dump_path')
+    flexmock(module.dump).should_receive('make_database_dump_filename')
+    flexmock(module).should_receive('execute_command_with_processes').with_args(
+        (
+            'pg_restore',
+            '--no-password',
+            '--if-exists',
+            '--exit-on-error',
+            '--clean',
+            '--dbname',
+            'foo',
+            '--host',
+            'restorehost',
+            '--port',
+            'restoreport',
+            '--username',
+            'restoreusername',
+        ),
+        processes=[extract_process],
+        output_log_level=logging.DEBUG,
+        input_file=extract_process.stdout,
+        extra_environment={'PGPASSWORD': 'restorepassword', 'PGSSLMODE': 'disable'},
+    ).once()
+    flexmock(module).should_receive('execute_command').with_args(
+        (
+            'psql',
+            '--no-password',
+            '--no-psqlrc',
+            '--quiet',
+            '--host',
+            'restorehost',
+            '--port',
+            'restoreport',
+            '--username',
+            'restoreusername',
+            '--dbname',
+            'foo',
+            '--command',
+            'ANALYZE',
+        ),
+        extra_environment={'PGPASSWORD': 'restorepassword', 'PGSSLMODE': 'disable'},
+    ).once()
+
+    module.restore_database_dump(
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
 
 
 def test_restore_database_dump_runs_pg_restore_with_options():
-    database_config = [
-        {'name': 'foo', 'restore_options': '--harder', 'analyze_options': '--smarter'}
+    databases_config = [
+        {
+            'name': 'foo',
+            'restore_options': '--harder',
+            'analyze_options': '--smarter',
+            'schemas': None,
+        }
     ]
     extract_process = flexmock(stdout=flexmock())
 
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path')
     flexmock(module.dump).should_receive('make_database_dump_filename')
     flexmock(module).should_receive('execute_command_with_processes').with_args(
@@ -576,102 +849,215 @@
         input_file=extract_process.stdout,
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
     flexmock(module).should_receive('execute_command').with_args(
         (
             'psql',
             '--no-password',
+            '--no-psqlrc',
             '--quiet',
             '--dbname',
             'foo',
             '--smarter',
             '--command',
             'ANALYZE',
         ),
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=False, extract_process=extract_process
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
 
 
 def test_restore_database_dump_runs_psql_for_all_database_dump():
-    database_config = [{'name': 'all'}]
+    databases_config = [{'name': 'all', 'schemas': None}]
     extract_process = flexmock(stdout=flexmock())
 
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path')
     flexmock(module.dump).should_receive('make_database_dump_filename')
     flexmock(module).should_receive('execute_command_with_processes').with_args(
-        ('psql', '--no-password'),
+        (
+            'psql',
+            '--no-password',
+            '--no-psqlrc',
+        ),
         processes=[extract_process],
         output_log_level=logging.DEBUG,
         input_file=extract_process.stdout,
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
     flexmock(module).should_receive('execute_command').with_args(
-        ('psql', '--no-password', '--quiet', '--command', 'ANALYZE'),
+        ('psql', '--no-password', '--no-psqlrc', '--quiet', '--command', 'ANALYZE'),
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=False, extract_process=extract_process
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='all',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
+    )
+
+
+def test_restore_database_dump_runs_psql_for_plain_database_dump():
+    databases_config = [{'name': 'foo', 'format': 'plain', 'schemas': None}]
+    extract_process = flexmock(stdout=flexmock())
+
+    flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
+    flexmock(module).should_receive('make_dump_path')
+    flexmock(module.dump).should_receive('make_database_dump_filename')
+    flexmock(module).should_receive('execute_command_with_processes').with_args(
+        ('psql', '--no-password', '--no-psqlrc', '--dbname', 'foo'),
+        processes=[extract_process],
+        output_log_level=logging.DEBUG,
+        input_file=extract_process.stdout,
+        extra_environment={'PGSSLMODE': 'disable'},
+    ).once()
+    flexmock(module).should_receive('execute_command').with_args(
+        (
+            'psql',
+            '--no-password',
+            '--no-psqlrc',
+            '--quiet',
+            '--dbname',
+            'foo',
+            '--command',
+            'ANALYZE',
+        ),
+        extra_environment={'PGSSLMODE': 'disable'},
+    ).once()
+
+    module.restore_database_dump(
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
 
 
 def test_restore_database_dump_runs_non_default_pg_restore_and_psql():
-    database_config = [
-        {'name': 'foo', 'pg_restore_command': 'special_pg_restore', 'psql_command': 'special_psql'}
+    databases_config = [
+        {
+            'name': 'foo',
+            'pg_restore_command': 'docker exec mycontainer pg_restore',
+            'psql_command': 'docker exec mycontainer psql',
+            'schemas': None,
+        }
     ]
     extract_process = flexmock(stdout=flexmock())
 
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path')
     flexmock(module.dump).should_receive('make_database_dump_filename')
     flexmock(module).should_receive('execute_command_with_processes').with_args(
         (
-            'special_pg_restore',
+            'docker',
+            'exec',
+            'mycontainer',
+            'pg_restore',
             '--no-password',
             '--if-exists',
             '--exit-on-error',
             '--clean',
             '--dbname',
             'foo',
         ),
         processes=[extract_process],
         output_log_level=logging.DEBUG,
         input_file=extract_process.stdout,
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
     flexmock(module).should_receive('execute_command').with_args(
-        ('special_psql', '--no-password', '--quiet', '--dbname', 'foo', '--command', 'ANALYZE'),
+        (
+            'docker',
+            'exec',
+            'mycontainer',
+            'psql',
+            '--no-password',
+            '--no-psqlrc',
+            '--quiet',
+            '--dbname',
+            'foo',
+            '--command',
+            'ANALYZE',
+        ),
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=False, extract_process=extract_process
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=extract_process,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
 
 
 def test_restore_database_dump_with_dry_run_skips_restore():
-    database_config = [{'name': 'foo'}]
+    databases_config = [{'name': 'foo', 'schemas': None}]
 
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path')
     flexmock(module.dump).should_receive('make_database_dump_filename')
     flexmock(module).should_receive('execute_command_with_processes').never()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=True, extract_process=flexmock()
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=True,
+        extract_process=flexmock(),
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
 
 
 def test_restore_database_dump_without_extract_process_restores_from_disk():
-    database_config = [{'name': 'foo'}]
+    databases_config = [{'name': 'foo', 'schemas': None}]
 
     flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
     flexmock(module).should_receive('make_dump_path')
     flexmock(module.dump).should_receive('make_database_dump_filename').and_return('/dump/path')
     flexmock(module).should_receive('execute_command_with_processes').with_args(
         (
             'pg_restore',
@@ -685,14 +1071,90 @@
         ),
         processes=[],
         output_log_level=logging.DEBUG,
         input_file=None,
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
     flexmock(module).should_receive('execute_command').with_args(
-        ('psql', '--no-password', '--quiet', '--dbname', 'foo', '--command', 'ANALYZE'),
+        (
+            'psql',
+            '--no-password',
+            '--no-psqlrc',
+            '--quiet',
+            '--dbname',
+            'foo',
+            '--command',
+            'ANALYZE',
+        ),
+        extra_environment={'PGSSLMODE': 'disable'},
+    ).once()
+
+    module.restore_database_dump(
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=None,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
+    )
+
+
+def test_restore_database_dump_with_schemas_restores_schemas():
+    databases_config = [{'name': 'foo', 'schemas': ['bar', 'baz']}]
+
+    flexmock(module).should_receive('make_extra_environment').and_return({'PGSSLMODE': 'disable'})
+    flexmock(module).should_receive('make_dump_path')
+    flexmock(module.dump).should_receive('make_database_dump_filename').and_return('/dump/path')
+    flexmock(module).should_receive('execute_command_with_processes').with_args(
+        (
+            'pg_restore',
+            '--no-password',
+            '--if-exists',
+            '--exit-on-error',
+            '--clean',
+            '--dbname',
+            'foo',
+            '/dump/path',
+            '--schema',
+            'bar',
+            '--schema',
+            'baz',
+        ),
+        processes=[],
+        output_log_level=logging.DEBUG,
+        input_file=None,
+        extra_environment={'PGSSLMODE': 'disable'},
+    ).once()
+    flexmock(module).should_receive('execute_command').with_args(
+        (
+            'psql',
+            '--no-password',
+            '--no-psqlrc',
+            '--quiet',
+            '--dbname',
+            'foo',
+            '--command',
+            'ANALYZE',
+        ),
         extra_environment={'PGSSLMODE': 'disable'},
     ).once()
 
     module.restore_database_dump(
-        database_config, 'test.yaml', {}, dry_run=False, extract_process=None
+        databases_config,
+        {},
+        'test.yaml',
+        database_name='foo',
+        dry_run=False,
+        extract_process=None,
+        connection_params={
+            'hostname': None,
+            'port': None,
+            'username': None,
+            'password': None,
+        },
     )
```

### Comparing `borgmatic-1.7.9/tests/unit/test_execute.py` & `borgmatic-1.8.0/tests/unit/test_execute.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,40 +3,40 @@
 import pytest
 from flexmock import flexmock
 
 from borgmatic import execute as module
 
 
 @pytest.mark.parametrize(
-    'process,exit_code,borg_local_path,expected_result',
+    'command,exit_code,borg_local_path,expected_result',
     (
-        (flexmock(args=['grep']), 2, None, True),
-        (flexmock(args=['grep']), 2, 'borg', True),
-        (flexmock(args=['borg']), 2, 'borg', True),
-        (flexmock(args=['borg1']), 2, 'borg1', True),
-        (flexmock(args=['grep']), 1, None, True),
-        (flexmock(args=['grep']), 1, 'borg', True),
-        (flexmock(args=['borg']), 1, 'borg', False),
-        (flexmock(args=['borg1']), 1, 'borg1', False),
-        (flexmock(args=['grep']), 0, None, False),
-        (flexmock(args=['grep']), 0, 'borg', False),
-        (flexmock(args=['borg']), 0, 'borg', False),
-        (flexmock(args=['borg1']), 0, 'borg1', False),
+        (['grep'], 2, None, True),
+        (['grep'], 2, 'borg', True),
+        (['borg'], 2, 'borg', True),
+        (['borg1'], 2, 'borg1', True),
+        (['grep'], 1, None, True),
+        (['grep'], 1, 'borg', True),
+        (['borg'], 1, 'borg', False),
+        (['borg1'], 1, 'borg1', False),
+        (['grep'], 0, None, False),
+        (['grep'], 0, 'borg', False),
+        (['borg'], 0, 'borg', False),
+        (['borg1'], 0, 'borg1', False),
         # -9 exit code occurs when child process get SIGKILLed.
-        (flexmock(args=['grep']), -9, None, True),
-        (flexmock(args=['grep']), -9, 'borg', True),
-        (flexmock(args=['borg']), -9, 'borg', True),
-        (flexmock(args=['borg1']), -9, 'borg1', True),
-        (flexmock(args=['borg']), None, None, False),
+        (['grep'], -9, None, True),
+        (['grep'], -9, 'borg', True),
+        (['borg'], -9, 'borg', True),
+        (['borg1'], -9, 'borg1', True),
+        (['borg'], None, None, False),
     ),
 )
 def test_exit_code_indicates_error_respects_exit_code_and_borg_local_path(
-    process, exit_code, borg_local_path, expected_result
+    command, exit_code, borg_local_path, expected_result
 ):
-    assert module.exit_code_indicates_error(process, exit_code, borg_local_path) is expected_result
+    assert module.exit_code_indicates_error(command, exit_code, borg_local_path) is expected_result
 
 
 def test_command_for_process_converts_sequence_command_to_string():
     process = flexmock(args=['foo', 'bar', 'baz'])
 
     assert module.command_for_process(process) == 'foo bar baz'
 
@@ -61,14 +61,49 @@
 
     assert (
         module.output_buffer_for_process(process, exclude_stdouts=[flexmock(), flexmock()])
         == stdout
     )
 
 
+def test_append_last_lines_under_max_line_count_appends():
+    last_lines = ['last']
+    flexmock(module.logger).should_receive('log').once()
+
+    module.append_last_lines(
+        last_lines, captured_output=flexmock(), line='line', output_log_level=flexmock()
+    )
+
+    assert last_lines == ['last', 'line']
+
+
+def test_append_last_lines_over_max_line_count_trims_and_appends():
+    original_last_lines = [str(number) for number in range(0, module.ERROR_OUTPUT_MAX_LINE_COUNT)]
+    last_lines = list(original_last_lines)
+    flexmock(module.logger).should_receive('log').once()
+
+    module.append_last_lines(
+        last_lines, captured_output=flexmock(), line='line', output_log_level=flexmock()
+    )
+
+    assert last_lines == original_last_lines[1:] + ['line']
+
+
+def test_append_last_lines_with_output_log_level_none_appends_captured_output():
+    last_lines = ['last']
+    captured_output = ['captured']
+    flexmock(module.logger).should_receive('log').never()
+
+    module.append_last_lines(
+        last_lines, captured_output=captured_output, line='line', output_log_level=None
+    )
+
+    assert captured_output == ['captured', 'line']
+
+
 def test_execute_command_calls_full_command():
     full_command = ['foo', 'bar']
     flexmock(module.os, environ={'a': 'b'})
     flexmock(module.subprocess).should_receive('Popen').with_args(
         full_command,
         stdin=None,
         stdout=module.subprocess.PIPE,
@@ -235,14 +270,42 @@
     ).and_return(flexmock(decode=lambda: expected_output)).once()
 
     output = module.execute_command_and_capture_output(full_command, capture_stderr=True)
 
     assert output == expected_output
 
 
+def test_execute_command_and_capture_output_returns_output_when_process_error_is_not_considered_an_error():
+    full_command = ['foo', 'bar']
+    expected_output = '[]'
+    err_output = b'[]'
+    flexmock(module.os, environ={'a': 'b'})
+    flexmock(module.subprocess).should_receive('check_output').with_args(
+        full_command, stderr=None, shell=False, env=None, cwd=None
+    ).and_raise(subprocess.CalledProcessError(1, full_command, err_output)).once()
+    flexmock(module).should_receive('exit_code_indicates_error').and_return(False).once()
+
+    output = module.execute_command_and_capture_output(full_command)
+
+    assert output == expected_output
+
+
+def test_execute_command_and_capture_output_raises_when_command_errors():
+    full_command = ['foo', 'bar']
+    expected_output = '[]'
+    flexmock(module.os, environ={'a': 'b'})
+    flexmock(module.subprocess).should_receive('check_output').with_args(
+        full_command, stderr=None, shell=False, env=None, cwd=None
+    ).and_raise(subprocess.CalledProcessError(2, full_command, expected_output)).once()
+    flexmock(module).should_receive('exit_code_indicates_error').and_return(True).once()
+
+    with pytest.raises(subprocess.CalledProcessError):
+        module.execute_command_and_capture_output(full_command)
+
+
 def test_execute_command_and_capture_output_returns_output_with_shell():
     full_command = ['foo', 'bar']
     expected_output = '[]'
     flexmock(module.os, environ={'a': 'b'})
     flexmock(module.subprocess).should_receive('check_output').with_args(
         'foo bar', stderr=None, shell=True, env=None, cwd=None
     ).and_return(flexmock(decode=lambda: expected_output)).once()
@@ -253,15 +316,19 @@
 
 
 def test_execute_command_and_capture_output_returns_output_with_extra_environment():
     full_command = ['foo', 'bar']
     expected_output = '[]'
     flexmock(module.os, environ={'a': 'b'})
     flexmock(module.subprocess).should_receive('check_output').with_args(
-        full_command, stderr=None, shell=False, env={'a': 'b', 'c': 'd'}, cwd=None,
+        full_command,
+        stderr=None,
+        shell=False,
+        env={'a': 'b', 'c': 'd'},
+        cwd=None,
     ).and_return(flexmock(decode=lambda: expected_output)).once()
 
     output = module.execute_command_and_capture_output(
         full_command, shell=False, extra_environment={'c': 'd'}
     )
 
     assert output == expected_output
```

### Comparing `borgmatic-1.7.9/tests/unit/test_logger.py` & `borgmatic-1.8.0/tests/unit/test_logger.py`

 * *Files 11% similar despite different names*

```diff
@@ -281,39 +281,106 @@
     )
     flexmock(module.os.path).should_receive('exists').with_args('/dev/log').and_return(True)
     flexmock(module.logging.handlers).should_receive('SysLogHandler').never()
 
     module.configure_logging(console_log_level=logging.INFO)
 
 
-def test_configure_logging_to_logfile_instead_of_syslog():
+def test_configure_logging_skips_syslog_if_syslog_logging_is_disabled():
+    flexmock(module).should_receive('add_custom_log_levels')
+    flexmock(module.logging).DISABLED = module.DISABLED
+    flexmock(module).should_receive('Multi_stream_handler').and_return(
+        flexmock(setFormatter=lambda formatter: None, setLevel=lambda level: None)
+    )
+    flexmock(module).should_receive('Console_color_formatter')
+    flexmock(module).should_receive('interactive_console').never()
+    flexmock(module.logging).should_receive('basicConfig').with_args(
+        level=logging.INFO, handlers=tuple
+    )
+    flexmock(module.os.path).should_receive('exists').with_args('/dev/log').and_return(True)
+    flexmock(module.logging.handlers).should_receive('SysLogHandler').never()
+
+    module.configure_logging(console_log_level=logging.INFO, syslog_log_level=logging.DISABLED)
+
+
+def test_configure_logging_skips_log_file_if_log_file_logging_is_disabled():
+    flexmock(module).should_receive('add_custom_log_levels')
+    flexmock(module.logging).DISABLED = module.DISABLED
+    flexmock(module).should_receive('Multi_stream_handler').and_return(
+        flexmock(setFormatter=lambda formatter: None, setLevel=lambda level: None)
+    )
+
+    # syslog skipped in non-interactive console if --log-file argument provided
+    flexmock(module).should_receive('interactive_console').and_return(False)
+    flexmock(module.logging).should_receive('basicConfig').with_args(
+        level=logging.INFO, handlers=tuple
+    )
+    flexmock(module.os.path).should_receive('exists').never()
+    flexmock(module.logging.handlers).should_receive('SysLogHandler').never()
+    flexmock(module.logging.handlers).should_receive('WatchedFileHandler').never()
+
+    module.configure_logging(
+        console_log_level=logging.INFO, log_file_log_level=logging.DISABLED, log_file='/tmp/logfile'
+    )
+
+
+def test_configure_logging_to_log_file_instead_of_syslog():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.ANSWER
     flexmock(module).should_receive('Multi_stream_handler').and_return(
         flexmock(setFormatter=lambda formatter: None, setLevel=lambda level: None)
     )
 
     # syslog skipped in non-interactive console if --log-file argument provided
     flexmock(module).should_receive('interactive_console').and_return(False)
     flexmock(module.logging).should_receive('basicConfig').with_args(
         level=logging.DEBUG, handlers=tuple
     )
-    flexmock(module.os.path).should_receive('exists').with_args('/dev/log').and_return(True)
+    flexmock(module.os.path).should_receive('exists').never()
     flexmock(module.logging.handlers).should_receive('SysLogHandler').never()
     file_handler = logging.handlers.WatchedFileHandler('/tmp/logfile')
     flexmock(module.logging.handlers).should_receive('WatchedFileHandler').with_args(
         '/tmp/logfile'
     ).and_return(file_handler).once()
 
     module.configure_logging(
         console_log_level=logging.INFO, log_file_log_level=logging.DEBUG, log_file='/tmp/logfile'
     )
 
 
-def test_configure_logging_skips_logfile_if_argument_is_none():
+def test_configure_logging_to_log_file_formats_with_custom_log_format():
+    flexmock(module).should_receive('add_custom_log_levels')
+    flexmock(module.logging).ANSWER = module.ANSWER
+    flexmock(module.logging).should_receive('Formatter').with_args(
+        '{message}', style='{'  # noqa: FS003
+    ).once()
+    flexmock(module).should_receive('Multi_stream_handler').and_return(
+        flexmock(setFormatter=lambda formatter: None, setLevel=lambda level: None)
+    )
+
+    flexmock(module).should_receive('interactive_console').and_return(False)
+    flexmock(module.logging).should_receive('basicConfig').with_args(
+        level=logging.DEBUG, handlers=tuple
+    )
+    flexmock(module.os.path).should_receive('exists').with_args('/dev/log').and_return(True)
+    flexmock(module.logging.handlers).should_receive('SysLogHandler').never()
+    file_handler = logging.handlers.WatchedFileHandler('/tmp/logfile')
+    flexmock(module.logging.handlers).should_receive('WatchedFileHandler').with_args(
+        '/tmp/logfile'
+    ).and_return(file_handler).once()
+
+    module.configure_logging(
+        console_log_level=logging.INFO,
+        log_file_log_level=logging.DEBUG,
+        log_file='/tmp/logfile',
+        log_file_format='{message}',  # noqa: FS003
+    )
+
+
+def test_configure_logging_skips_log_file_if_argument_is_none():
     flexmock(module).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.ANSWER
     flexmock(module).should_receive('Multi_stream_handler').and_return(
         flexmock(setFormatter=lambda formatter: None, setLevel=lambda level: None)
     )
 
     # No WatchedFileHandler added if argument --log-file is None
```

### Comparing `borgmatic-1.7.9/tests/unit/test_signals.py` & `borgmatic-1.8.0/tests/unit/test_signals.py`

 * *Files identical despite different names*

### Comparing `borgmatic-1.7.9/tests/unit/test_verbosity.py` & `borgmatic-1.8.0/tests/unit/test_verbosity.py`

 * *Files 14% similar despite different names*

```diff
@@ -13,19 +13,21 @@
     logging.should_receive('isEnabledFor').replace_with(lambda level: level >= log_level)
     logging.should_receive('getEffectiveLevel').replace_with(lambda: log_level)
 
 
 def test_verbosity_to_log_level_maps_known_verbosity_to_log_level():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
+    flexmock(module.logging).DISABLED = module.borgmatic.logger.DISABLED
 
     assert module.verbosity_to_log_level(module.VERBOSITY_ERROR) == logging.ERROR
     assert module.verbosity_to_log_level(module.VERBOSITY_ANSWER) == module.borgmatic.logger.ANSWER
     assert module.verbosity_to_log_level(module.VERBOSITY_SOME) == logging.INFO
     assert module.verbosity_to_log_level(module.VERBOSITY_LOTS) == logging.DEBUG
+    assert module.verbosity_to_log_level(module.VERBOSITY_DISABLED) == logging.DISABLED
 
 
 def test_verbosity_to_log_level_maps_unknown_verbosity_to_warning_level():
     flexmock(module.borgmatic.logger).should_receive('add_custom_log_levels')
     flexmock(module.logging).ANSWER = module.borgmatic.logger.ANSWER
 
     assert module.verbosity_to_log_level('my pants') == logging.WARNING
```

### Comparing `borgmatic-1.7.9/tox.ini` & `borgmatic-1.8.0/tox.ini`

 * *Files 24% similar despite different names*

```diff
@@ -12,26 +12,34 @@
     sh
 passenv = COVERAGE_FILE
 commands =
     pytest {posargs}
     py38,py39,py310,py311: black --check .
     isort --check-only --settings-path setup.cfg .
     flake8 borgmatic tests
+    codespell
 
 [testenv:black]
 commands =
     black {posargs} .
 
 [testenv:test]
 commands =
     pytest {posargs}
 
 [testenv:end-to-end]
+usedevelop = False
 deps = -rtest_requirements.txt
+       .
 passenv = COVERAGE_FILE
 commands =
     pytest {posargs} --no-cov tests/end-to-end
 
 [testenv:isort]
 deps = {[testenv]deps}
 commands =
     isort --settings-path setup.cfg .
+
+[testenv:codespell]
+deps = {[testenv]deps}
+commands =
+    codespell --write-changes
```

